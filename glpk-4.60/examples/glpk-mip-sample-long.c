#include <stdlib.h>
#include <stdio.h>
//#include <glpk.h>

/* glpk.h (GLPK API) */

/***********************************************************************
*  This code is part of GLPK (GNU Linear Programming Kit).
*
*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
*  2009, 2010, 2011, 2013, 2014, 2015, 2016 Andrew Makhorin, Department
*  for Applied Informatics, Moscow Aviation Institute, Moscow, Russia.
*  All rights reserved. E-mail: <mao@gnu.org>.
*
*  GLPK is free software: you can redistribute it and/or modify it
*  under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  GLPK is distributed in the hope that it will be useful, but WITHOUT
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
*  License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/

#include <stdarg.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/* library version numbers: */
#define GLP_MAJOR_VERSION  4
#define GLP_MINOR_VERSION  60

//typedef struct glp_prob glp_prob;
/* LP/MIP problem object */

/* optimization direction flag: */
#define GLP_MIN            1  /* minimization */
#define GLP_MAX            2  /* maximization */

/* kind of structural variable: */
#define GLP_CV             1  /* continuous variable */
#define GLP_IV             2  /* integer variable */
#define GLP_BV             3  /* binary variable */

/* type of auxiliary/structural variable: */
#define GLP_FR             1  /* free (unbounded) variable */
#define GLP_LO             2  /* variable with lower bound */
#define GLP_UP             3  /* variable with upper bound */
#define GLP_DB             4  /* double-bounded variable */
#define GLP_FX             5  /* fixed variable */

/* status of auxiliary/structural variable: */
#define GLP_BS             1  /* basic variable */
#define GLP_NL             2  /* non-basic variable on lower bound */
#define GLP_NU             3  /* non-basic variable on upper bound */
#define GLP_NF             4  /* non-basic free (unbounded) variable */
#define GLP_NS             5  /* non-basic fixed variable */

/* scaling options: */
#define GLP_SF_GM       0x01  /* perform geometric mean scaling */
#define GLP_SF_EQ       0x10  /* perform equilibration scaling */
#define GLP_SF_2N       0x20  /* round scale factors to power of two */
#define GLP_SF_SKIP     0x40  /* skip if problem is well scaled */
#define GLP_SF_AUTO     0x80  /* choose scaling options automatically */

/* solution indicator: */
#define GLP_SOL            1  /* basic solution */
#define GLP_IPT            2  /* interior-point solution */
#define GLP_MIP            3  /* mixed integer solution */

/* solution status: */
#define GLP_UNDEF          1  /* solution is undefined */
#define GLP_FEAS           2  /* solution is feasible */
#define GLP_INFEAS         3  /* solution is infeasible */
#define GLP_NOFEAS         4  /* no feasible solution exists */
#define GLP_OPT            5  /* solution is optimal */
#define GLP_UNBND          6  /* solution is unbounded */

typedef struct
{     /* basis factorization control parameters */
      int msg_lev;            /* (not used) */
      int type;               /* factorization type: */
#if 1 /* 05/III-2014 */
#define GLP_BF_LUF      0x00  /* plain LU-factorization */
#define GLP_BF_BTF      0x10  /* block triangular LU-factorization */
#endif
#define GLP_BF_FT       0x01  /* Forrest-Tomlin (LUF only) */
#define GLP_BF_BG       0x02  /* Schur compl. + Bartels-Golub */
#define GLP_BF_GR       0x03  /* Schur compl. + Givens rotation */
      int lu_size;            /* (not used) */
      double piv_tol;         /* sgf_piv_tol */
      int piv_lim;            /* sgf_piv_lim */
      int suhl;               /* sgf_suhl */
      double eps_tol;         /* sgf_eps_tol */
      double max_gro;         /* (not used) */
      int nfs_max;            /* fhvint.nfs_max */
      double upd_tol;         /* (not used) */
      int nrs_max;            /* scfint.nn_max */
      int rs_size;            /* (not used) */
      double foo_bar[38];     /* (reserved) */
} glp_bfcp;

typedef struct
{     /* simplex method control parameters */
      int msg_lev;            /* message level: */
#define GLP_MSG_OFF        0  /* no output */
#define GLP_MSG_ERR        1  /* warning and error messages only */
#define GLP_MSG_ON         2  /* normal output */
#define GLP_MSG_ALL        3  /* full output */
#define GLP_MSG_DBG        4  /* debug output */
      int meth;               /* simplex method option: */
#define GLP_PRIMAL         1  /* use primal simplex */
#define GLP_DUALP          2  /* use dual; if it fails, use primal */
#define GLP_DUAL           3  /* use dual simplex */
      int pricing;            /* pricing technique: */
#define GLP_PT_STD      0x11  /* standard (Dantzig's rule) */
#define GLP_PT_PSE      0x22  /* projected steepest edge */
      int r_test;             /* ratio test technique: */
#define GLP_RT_STD      0x11  /* standard (textbook) */
#define GLP_RT_HAR      0x22  /* Harris' two-pass ratio test */
#if 1 /* 16/III-2016 */
#define GLP_RT_FLIP     0x33  /* long-step (flip-flop) ratio test */
#endif
      double tol_bnd;         /* spx.tol_bnd */
      double tol_dj;          /* spx.tol_dj */
      double tol_piv;         /* spx.tol_piv */
      double obj_ll;          /* spx.obj_ll */
      double obj_ul;          /* spx.obj_ul */
      int it_lim;             /* spx.it_lim */
      int tm_lim;             /* spx.tm_lim (milliseconds) */
      int out_frq;            /* spx.out_frq */
      int out_dly;            /* spx.out_dly (milliseconds) */
      int presolve;           /* enable/disable using LP presolver */
      double foo_bar[36];     /* (reserved) */
} glp_smcp;

typedef struct
{     /* interior-point solver control parameters */
      int msg_lev;            /* message level (see glp_smcp) */
      int ord_alg;            /* ordering algorithm: */
#define GLP_ORD_NONE       0  /* natural (original) ordering */
#define GLP_ORD_QMD        1  /* quotient minimum degree (QMD) */
#define GLP_ORD_AMD        2  /* approx. minimum degree (AMD) */
#define GLP_ORD_SYMAMD     3  /* approx. minimum degree (SYMAMD) */
      double foo_bar[48];     /* (reserved) */
} glp_iptcp;

typedef struct glp_tree glp_tree;
/* branch-and-bound tree */

typedef struct
{     /* integer optimizer control parameters */
      int msg_lev;            /* message level (see glp_smcp) */
      int br_tech;            /* branching technique: */
#define GLP_BR_FFV         1  /* first fractional variable */
#define GLP_BR_LFV         2  /* last fractional variable */
#define GLP_BR_MFV         3  /* most fractional variable */
#define GLP_BR_DTH         4  /* heuristic by Driebeck and Tomlin */
#define GLP_BR_PCH         5  /* hybrid pseudocost heuristic */
      int bt_tech;            /* backtracking technique: */
#define GLP_BT_DFS         1  /* depth first search */
#define GLP_BT_BFS         2  /* breadth first search */
#define GLP_BT_BLB         3  /* best local bound */
#define GLP_BT_BPH         4  /* best projection heuristic */
      double tol_int;         /* mip.tol_int */
      double tol_obj;         /* mip.tol_obj */
      int tm_lim;             /* mip.tm_lim (milliseconds) */
      int out_frq;            /* mip.out_frq (milliseconds) */
      int out_dly;            /* mip.out_dly (milliseconds) */
      void (*cb_func)(glp_tree *T, void *info);
                              /* mip.cb_func */
      void *cb_info;          /* mip.cb_info */
      int cb_size;            /* mip.cb_size */
      int pp_tech;            /* preprocessing technique: */
#define GLP_PP_NONE        0  /* disable preprocessing */
#define GLP_PP_ROOT        1  /* preprocessing only on root level */
#define GLP_PP_ALL         2  /* preprocessing on all levels */
      double mip_gap;         /* relative MIP gap tolerance */
      int mir_cuts;           /* MIR cuts       (GLP_ON/GLP_OFF) */
      int gmi_cuts;           /* Gomory's cuts  (GLP_ON/GLP_OFF) */
      int cov_cuts;           /* cover cuts     (GLP_ON/GLP_OFF) */
      int clq_cuts;           /* clique cuts    (GLP_ON/GLP_OFF) */
      int presolve;           /* enable/disable using MIP presolver */
      int binarize;           /* try to binarize integer variables */
      int fp_heur;            /* feasibility pump heuristic */
      int ps_heur;            /* proximity search heuristic */
      int ps_tm_lim;          /* proxy time limit, milliseconds */
      int sr_heur;            /* simple rounding heuristic */
#if 1 /* 24/X-2015; not documented--should not be used */
      int use_sol;            /* use existing solution */
      const char *save_sol;   /* filename to save every new solution */
      int alien;              /* use alien solver */
#endif
#if 1 /* 16/III-2016; not documented--should not be used */
      int flip;               /* use long-step dual simplex */
#endif
      double foo_bar[23];     /* (reserved) */
} glp_iocp;

typedef struct
{     /* additional row attributes */
      int level;
      /* subproblem level at which the row was added */
      int origin;
      /* row origin flag: */
#define GLP_RF_REG         0  /* regular constraint */
#define GLP_RF_LAZY        1  /* "lazy" constraint */
#define GLP_RF_CUT         2  /* cutting plane constraint */
      int klass;
      /* row class descriptor: */
#define GLP_RF_GMI         1  /* Gomory's mixed integer cut */
#define GLP_RF_MIR         2  /* mixed integer rounding cut */
#define GLP_RF_COV         3  /* mixed cover cut */
#define GLP_RF_CLQ         4  /* clique cut */
      double foo_bar[7];
      /* (reserved) */
} glp_attr;

/* enable/disable flag: */
#define GLP_ON             1  /* enable something */
#define GLP_OFF            0  /* disable something */

/* reason codes: */
#define GLP_IROWGEN     0x01  /* request for row generation */
#define GLP_IBINGO      0x02  /* better integer solution found */
#define GLP_IHEUR       0x03  /* request for heuristic solution */
#define GLP_ICUTGEN     0x04  /* request for cut generation */
#define GLP_IBRANCH     0x05  /* request for branching */
#define GLP_ISELECT     0x06  /* request for subproblem selection */
#define GLP_IPREPRO     0x07  /* request for preprocessing */

/* branch selection indicator: */
#define GLP_NO_BRNCH       0  /* select no branch */
#define GLP_DN_BRNCH       1  /* select down-branch */
#define GLP_UP_BRNCH       2  /* select up-branch */

/* return codes: */
#define GLP_EBADB       0x01  /* invalid basis */
#define GLP_ESING       0x02  /* singular matrix */
#define GLP_ECOND       0x03  /* ill-conditioned matrix */
#define GLP_EBOUND      0x04  /* invalid bounds */
#define GLP_EFAIL       0x05  /* solver failed */
#define GLP_EOBJLL      0x06  /* objective lower limit reached */
#define GLP_EOBJUL      0x07  /* objective upper limit reached */
#define GLP_EITLIM      0x08  /* iteration limit exceeded */
#define GLP_ETMLIM      0x09  /* time limit exceeded */
#define GLP_ENOPFS      0x0A  /* no primal feasible solution */
#define GLP_ENODFS      0x0B  /* no dual feasible solution */
#define GLP_EROOT       0x0C  /* root LP optimum not provided */
#define GLP_ESTOP       0x0D  /* search terminated by application */
#define GLP_EMIPGAP     0x0E  /* relative mip gap tolerance reached */
#define GLP_ENOFEAS     0x0F  /* no primal/dual feasible solution */
#define GLP_ENOCVG      0x10  /* no convergence */
#define GLP_EINSTAB     0x11  /* numerical instability */
#define GLP_EDATA       0x12  /* invalid data */
#define GLP_ERANGE      0x13  /* result out of range */

/* condition indicator: */
#define GLP_KKT_PE         1  /* primal equalities */
#define GLP_KKT_PB         2  /* primal bounds */
#define GLP_KKT_DE         3  /* dual equalities */
#define GLP_KKT_DB         4  /* dual bounds */
#define GLP_KKT_CS         5  /* complementary slackness */

/* MPS file format: */
#define GLP_MPS_DECK       1  /* fixed (ancient) */
#define GLP_MPS_FILE       2  /* free (modern) */

typedef struct
{     /* MPS format control parameters */
      int blank;
      /* character code to replace blanks in symbolic names */
      char *obj_name;
      /* objective row name */
      double tol_mps;
      /* zero tolerance for MPS data */
      double foo_bar[17];
      /* (reserved for use in the future) */
} glp_mpscp;

typedef struct
{     /* CPLEX LP format control parameters */
      double foo_bar[20];
      /* (reserved for use in the future) */
} glp_cpxcp;

typedef struct glp_tran glp_tran;
/* MathProg translator workspace */















#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <setjmp.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

typedef struct ENV ENV;
typedef struct MBD MBD;

#define SIZE_T_MAX (~(size_t)0)
/* largest value of size_t type */

#define TBUF_SIZE 4096
/* terminal output buffer size, in bytes */

#define EBUF_SIZE 1024
/* error message buffer size, in bytes */

/* enable/disable flag: */
#define GLP_ON  1
#define GLP_OFF 0

struct ENV
{     /* GLPK environment block */
      char version[7+1];
      /* version string returned by the routine glp_version */
      ENV *self;
      /* pointer to this block to check its validity */
      /*--------------------------------------------------------------*/
      /* terminal output */
      char *term_buf; /* char term_buf[TBUF_SIZE]; */
      /* terminal output buffer */
      int term_out;
      /* flag to enable/disable terminal output */
      int (*term_hook)(void *info, const char *s);
      /* user-defined routine to intercept terminal output */
      void *term_info;
      /* transit pointer (cookie) passed to the routine term_hook */
      FILE *tee_file;
      /* output stream used to copy terminal output */
      /*--------------------------------------------------------------*/
      /* error handling */
#if 1 /* 07/XI-2015 */
      int err_st;
      /* error state flag; set on entry to glp_error */
#endif
      const char *err_file;
      /* value of the __FILE__ macro passed to glp_error */
      int err_line;
      /* value of the __LINE__ macro passed to glp_error */
      void (*err_hook)(void *info);
      /* user-defined routine to intercept abnormal termination */
      void *err_info;
      /* transit pointer (cookie) passed to the routine err_hook */
      char *err_buf; /* char err_buf[EBUF_SIZE]; */
      /* buffer to store error messages (used by I/O routines) */
      /*--------------------------------------------------------------*/
      /* dynamic memory allocation */
      size_t mem_limit;
      /* maximal amount of memory, in bytes, available for dynamic
       * allocation */
      MBD *mem_ptr;
      /* pointer to the linked list of allocated memory blocks */
      int mem_count;
      /* total number of currently allocated memory blocks */
      int mem_cpeak;
      /* peak value of mem_count */
      size_t mem_total;
      /* total amount of currently allocated memory, in bytes; it is
       * the sum of the size field over all memory block descriptors */
      size_t mem_tpeak;
      /* peak value of mem_total */
#if 1 /* 23/XI-2015 */
      /*--------------------------------------------------------------*/
      /* bignum module working area */
      void *gmp_pool; /* DMP *gmp_pool; */
      /* working memory pool */
      int gmp_size;
      /* size of working array */
      unsigned short *gmp_work; /* ushort gmp_work[gmp_size]; */
      /* working array */
#endif
      /*--------------------------------------------------------------*/
      /* dynamic linking support (optional) */
      void *h_odbc;
      /* handle to ODBC shared library */
      void *h_mysql;
      /* handle to MySQL shared library */
};

struct MBD
{     /* memory block descriptor */
      size_t size;
      /* size of block, in bytes, including descriptor */
      MBD *self;
      /* pointer to this descriptor to check its validity */
      MBD *prev;
      /* pointer to previous memory block descriptor */
      MBD *next;
      /* pointer to next memory block descriptor */
};

#define get_env_ptr _glp_get_env_ptr
ENV *get_env_ptr(void);
/* retrieve pointer to environment block */

#define tls_set_ptr _glp_tls_set_ptr
void tls_set_ptr(void *ptr);
/* store global pointer in TLS */

#define tls_get_ptr _glp_tls_get_ptr
void *tls_get_ptr(void);
/* retrieve global pointer from TLS */

#define xputs glp_puts
void glp_puts(const char *s);
/* write string on terminal */

#define xprintf glp_printf
void glp_printf(const char *fmt, ...);
/* write formatted output on terminal */

#define xvprintf glp_vprintf
void glp_vprintf(const char *fmt, va_list arg);
/* write formatted output on terminal */

int glp_term_out(int flag);
/* enable/disable terminal output */

void glp_term_hook(int (*func)(void *info, const char *s), void *info);
/* install hook to intercept terminal output */

int glp_open_tee(const char *fname);
/* start copying terminal output to text file */

int glp_close_tee(void);
/* stop copying terminal output to text file */

#ifndef GLP_ERRFUNC_DEFINED
#define GLP_ERRFUNC_DEFINED
typedef void (*glp_errfunc)(const char *fmt, ...);
#endif

#define xerror glp_error_(__FILE__, __LINE__)
glp_errfunc glp_error_(const char *file, int line);
/* display fatal error message and terminate execution */

#define xassert(expr) \
      ((void)((expr) || (glp_assert_(#expr, __FILE__, __LINE__), 1)))
void glp_assert_(const char *expr, const char *file, int line);
/* check for logical condition */

void glp_error_hook(void (*func)(void *info), void *info);
/* install hook to intercept abnormal termination */

#define put_err_msg _glp_put_err_msg
void put_err_msg(const char *msg);
/* provide error message string */

#define get_err_msg _glp_get_err_msg
const char *get_err_msg(void);
/* obtain error message string */

#define xmalloc(size) glp_alloc(1, size)
/* allocate memory block (obsolete) */

#define xcalloc(n, size) glp_alloc(n, size)
/* allocate memory block (obsolete) */

#define xalloc(n, size) glp_alloc(n, size)
#define talloc(n, type) ((type *)glp_alloc(n, sizeof(type)))
void *glp_alloc(int n, int size);
/* allocate memory block */

#define xrealloc(ptr, n, size) glp_realloc(ptr, n, size)
#define trealloc(ptr, n, type) ((type *)glp_realloc(ptr, n, \
      sizeof(type)))
void *glp_realloc(void *ptr, int n, int size);
/* reallocate memory block */

#define xfree(ptr) glp_free(ptr)
#define tfree(ptr) glp_free(ptr)
void glp_free(void *ptr);
/* free memory block */

void glp_mem_limit(int limit);
/* set memory usage limit */

void glp_mem_usage(int *count, int *cpeak, size_t *total,
      size_t *tpeak);
/* get memory usage information */

typedef struct glp_file glp_file;
/* sequential stream descriptor */

#define glp_open _glp_open
glp_file *glp_open(const char *name, const char *mode);
/* open stream */

#define glp_eof _glp_eof
int glp_eof(glp_file *f);
/* test end-of-file indicator */

#define glp_ioerr _glp_ioerr
int glp_ioerr(glp_file *f);
/* test I/O error indicator */

#define glp_read _glp_read
int glp_read(glp_file *f, void *buf, int nnn);
/* read data from stream */

#define glp_getc _glp_getc
int glp_getc(glp_file *f);
/* read character from stream */

#define glp_write _glp_write
int glp_write(glp_file *f, const void *buf, int nnn);
/* write data to stream */

#define glp_format _glp_format
int glp_format(glp_file *f, const char *fmt, ...);
/* write formatted data to stream */

#define glp_close _glp_close
int glp_close(glp_file *f);
/* close stream */

#define xtime glp_time
double glp_time(void);
/* determine current universal time */

#define xdifftime glp_difftime
double glp_difftime(double t1, double t0);
/* compute difference between two time values */

#define xdlopen _glp_dlopen
void *xdlopen(const char *module);
/* open dynamically linked library */

#define xdlsym _glp_dlsym
void *xdlsym(void *h, const char *symbol);
/* obtain address of symbol from dynamically linked library */

#define xdlclose _glp_dlclose
void xdlclose(void *h);
/* close dynamically linked library */


int glp_init_env(void)
{     ENV *env;
      int ok;
      /* check if the programming model is supported */
      ok = (CHAR_BIT == 8 && sizeof(char) == 1 &&
         sizeof(short) == 2 && sizeof(int) == 4 &&
         (sizeof(void *) == 4 || sizeof(void *) == 8));
      if (!ok)
         return 3;
      /* check if the environment is already initialized */
      if (tls_get_ptr() != NULL)
         return 1;
      /* allocate and initialize the environment block */
      env = malloc(sizeof(ENV));
      if (env == NULL)
         return 2;
      memset(env, 0, sizeof(ENV));
      sprintf(env->version, "%d.%d",
         GLP_MAJOR_VERSION, GLP_MINOR_VERSION);
      env->self = env;
      env->term_buf = malloc(TBUF_SIZE);
      if (env->term_buf == NULL)
      {  free(env);
         return 2;
      }
      env->term_out = GLP_ON;
      env->term_hook = NULL;
      env->term_info = NULL;
      env->tee_file = NULL;
#if 1 /* 23/XI-2015 */
      env->err_st = 0;
#endif
      env->err_file = NULL;
      env->err_line = 0;
      env->err_hook = NULL;
      env->err_info = NULL;
      env->err_buf = malloc(EBUF_SIZE);
      if (env->err_buf == NULL)
      {  free(env->term_buf);
         free(env);
         return 2;
      }
      env->err_buf[0] = '\0';
      env->mem_limit = SIZE_T_MAX;
      env->mem_ptr = NULL;
      env->mem_count = env->mem_cpeak = 0;
      env->mem_total = env->mem_tpeak = 0;
#if 1 /* 23/XI-2015 */
      env->gmp_pool = NULL;
      env->gmp_size = 0;
      env->gmp_work = NULL;
#endif
      env->h_odbc = env->h_mysql = NULL;
      /* save pointer to the environment block */
      tls_set_ptr(env);
      /* initialization successful */
      return 0;
}

ENV *get_env_ptr(void)
{     ENV *env = tls_get_ptr();
      /* check if the environment has been initialized */
      if (env == NULL)
      {  /* not initialized yet; perform initialization */
         if (glp_init_env() != 0)
         {  /* initialization failed; display an error message */
            fprintf(stderr, "GLPK initialization failed\n");
            fflush(stderr);
            /* and abnormally terminate the program */
            abort();
         }
         /* initialization successful; retrieve the pointer */
         env = tls_get_ptr();
      }
      /* check if the environment block is valid */
      if (env->self != env)
      {  fprintf(stderr, "Invalid GLPK environment\n");
         fflush(stderr);
         abort();
      }
      return env;
}

const char *glp_version(void)
{     ENV *env = get_env_ptr();
      return env->version;
}

int glp_free_env(void)
{     ENV *env = tls_get_ptr();
      MBD *desc;
      /* check if the environment is active */
      if (env == NULL)
         return 1;
      /* check if the environment block is valid */
      if (env->self != env)
      {  fprintf(stderr, "Invalid GLPK environment\n");
         fflush(stderr);
         abort();
      }
      /* close handles to shared libraries */
      if (env->h_odbc != NULL)
         xdlclose(env->h_odbc);
      if (env->h_mysql != NULL)
         xdlclose(env->h_mysql);
      /* free memory blocks which are still allocated */
      while (env->mem_ptr != NULL)
      {  desc = env->mem_ptr;
         env->mem_ptr = desc->next;
         free(desc);
      }
      /* close text file used for copying terminal output */
      if (env->tee_file != NULL)
         fclose(env->tee_file);
      /* invalidate the environment block */
      env->self = NULL;
      /* free memory allocated to the environment block */
      free(env->term_buf);
      free(env->err_buf);
      free(env);
      /* reset a pointer to the environment block */
      tls_set_ptr(NULL);
      /* termination successful */
      return 0;
}


#define ALIGN 16
/* some processors need data to be properly aligned, so this macro
 * defines the alignment boundary, in bytes, provided by glpk memory
 * allocation routines; looks like 16-byte alignment boundary is
 * sufficient for all 32- and 64-bit platforms (8-byte boundary is not
 * sufficient for some 64-bit platforms because of jmp_buf) */

#define MBD_SIZE (((sizeof(MBD) + (ALIGN - 1)) / ALIGN) * ALIGN)
/* size of memory block descriptor, in bytes, rounded up to multiple
 * of the alignment boundary */

/***********************************************************************
*  dma - dynamic memory allocation (basic routine)
*
*  This routine performs dynamic memory allocation. It is similar to
*  the standard realloc function, however, it provides every allocated
*  memory block with a descriptor, which is used for sanity checks on
*  reallocating/freeing previously allocated memory blocks as well as
*  for book-keeping the memory usage statistics. */

static void *dma(const char *func, void *ptr, size_t size)
{     ENV *env = get_env_ptr();
      MBD *mbd;
      if (ptr == NULL)
      {  /* new memory block will be allocated */
         mbd = NULL;
      }
      else
      {  /* allocated memory block will be reallocated or freed */
         /* get pointer to the block descriptor */
         mbd = (MBD *)((char *)ptr - MBD_SIZE);
         /* make sure that the block descriptor is valid */
         if (mbd->self != mbd)
            xerror("%s: ptr = %p; invalid pointer\n", func, ptr);
         /* remove the block from the linked list */
         mbd->self = NULL;
         if (mbd->prev == NULL)
            env->mem_ptr = mbd->next;
         else
            mbd->prev->next = mbd->next;
         if (mbd->next == NULL)
            ;
         else
            mbd->next->prev = mbd->prev;
         /* decrease usage counts */
         if (!(env->mem_count >= 1 && env->mem_total >= mbd->size))
            xerror("%s: memory allocation error\n", func);
         env->mem_count--;
         env->mem_total -= mbd->size;
         if (size == 0)
         {  /* free the memory block */
            free(mbd);
            return NULL;
         }
      }
      /* allocate/reallocate memory block */
      if (size > SIZE_T_MAX - MBD_SIZE)
         xerror("%s: block too large\n", func);
      size += MBD_SIZE;
      if (size > env->mem_limit - env->mem_total)
         xerror("%s: memory allocation limit exceeded\n", func);
      if (env->mem_count == INT_MAX)
         xerror("%s: too many memory blocks allocated\n", func);
      mbd = (mbd == NULL ? malloc(size) : realloc(mbd, size));
      if (mbd == NULL)
         xerror("%s: no memory available\n", func);
      /* setup the block descriptor */
      mbd->size = size;
      mbd->self = mbd;
      mbd->prev = NULL;
      mbd->next = env->mem_ptr;
      /* add the block to the beginning of the linked list */
      if (mbd->next != NULL)
         mbd->next->prev = mbd;
      env->mem_ptr = mbd;
      /* increase usage counts */
      env->mem_count++;
      if (env->mem_cpeak < env->mem_count)
         env->mem_cpeak = env->mem_count;
      env->mem_total += size;
      if (env->mem_tpeak < env->mem_total)
         env->mem_tpeak = env->mem_total;
      return (char *)mbd + MBD_SIZE;
}

/***********************************************************************
*  NAME
*
*  glp_alloc - allocate memory block
*
*  SYNOPSIS
*
*  void *glp_alloc(int n, int size);
*
*  DESCRIPTION
*
*  The routine glp_alloc allocates a memory block of n * size bytes
*  long.
*
*  Note that being allocated the memory block contains arbitrary data
*  (not binary zeros!).
*
*  RETURNS
*
*  The routine glp_alloc returns a pointer to the block allocated.
*  To free this block the routine glp_free (not free!) must be used. */

void *glp_alloc(int n, int size)
{     if (n < 1)
         xerror("glp_alloc: n = %d; invalid parameter\n", n);
      if (size < 1)
         xerror("glp_alloc: size = %d; invalid parameter\n", size);
      if ((size_t)n > SIZE_T_MAX / (size_t)size)
         xerror("glp_alloc: n = %d, size = %d; block too large\n",
            n, size);
      return dma("glp_alloc", NULL, (size_t)n * (size_t)size);
}

/**********************************************************************/

void *glp_realloc(void *ptr, int n, int size)
{     /* reallocate memory block */
      if (ptr == NULL)
         xerror("glp_realloc: ptr = %p; invalid pointer\n", ptr);
      if (n < 1)
         xerror("glp_realloc: n = %d; invalid parameter\n", n);
      if (size < 1)
         xerror("glp_realloc: size = %d; invalid parameter\n", size);
      if ((size_t)n > SIZE_T_MAX / (size_t)size)
         xerror("glp_realloc: n = %d, size = %d; block too large\n",
            n, size);
      return dma("glp_realloc", ptr, (size_t)n * (size_t)size);
}

/***********************************************************************
*  NAME
*
*  glp_free - free (deallocate) memory block
*
*  SYNOPSIS
*
*  void glp_free(void *ptr);
*
*  DESCRIPTION
*
*  The routine glp_free frees (deallocates) a memory block pointed to
*  by ptr, which was previuosly allocated by the routine glp_alloc or
*  reallocated by the routine glp_realloc. */

void glp_free(void *ptr)
{     if (ptr == NULL)
         xerror("glp_free: ptr = %p; invalid pointer\n", ptr);
      dma("glp_free", ptr, 0);
      return;
}

/***********************************************************************
*  NAME
*
*  glp_mem_limit - set memory usage limit
*
*  SYNOPSIS
*
*  void glp_mem_limit(int limit);
*
*  DESCRIPTION
*
*  The routine glp_mem_limit limits the amount of memory available for
*  dynamic allocation (in GLPK routines) to limit megabytes. */

void glp_mem_limit(int limit)
{     ENV *env = get_env_ptr();
      if (limit < 1)
         xerror("glp_mem_limit: limit = %d; invalid parameter\n",
            limit);
      if ((size_t)limit <= (SIZE_T_MAX >> 20))
         env->mem_limit = (size_t)limit << 20;
      else
         env->mem_limit = SIZE_T_MAX;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_mem_usage - get memory usage information
*
*  SYNOPSIS
*
*  void glp_mem_usage(int *count, int *cpeak, size_t *total,
*     size_t *tpeak);
*
*  DESCRIPTION
*
*  The routine glp_mem_usage reports some information about utilization
*  of the memory by GLPK routines. Information is stored to locations
*  specified by corresponding parameters (see below). Any parameter can
*  be specified as NULL, in which case its value is not stored.
*
*  *count is the number of the memory blocks currently allocated by the
*  routines glp_malloc and glp_calloc (one call to glp_malloc or
*  glp_calloc results in allocating one memory block).
*
*  *cpeak is the peak value of *count reached since the initialization
*  of the GLPK library environment.
*
*  *total is the total amount, in bytes, of the memory blocks currently
*  allocated by the routines glp_malloc and glp_calloc.
*
*  *tpeak is the peak value of *total reached since the initialization
*  of the GLPK library envirionment. */

void glp_mem_usage(int *count, int *cpeak, size_t *total,
      size_t *tpeak)
{     ENV *env = get_env_ptr();
      if (count != NULL)
         *count = env->mem_count;
      if (cpeak != NULL)
         *cpeak = env->mem_cpeak;
      if (total != NULL)
         *total = env->mem_total;
      if (tpeak != NULL)
         *tpeak = env->mem_tpeak;
      return;
}



/* GNU version ********************************************************/

#if defined(HAVE_LTDL)

#include <ltdl.h>

void *xdlopen(const char *module)
{     /* open dynamically linked library */
      void *h = NULL;
      if (lt_dlinit() != 0)
      {  put_err_msg(lt_dlerror());
         goto done;
      }
      h = lt_dlopen(module);
      if (h == NULL)
      {  put_err_msg(lt_dlerror());
         if (lt_dlexit() != 0)
            xerror("xdlopen: %s\n", lt_dlerror());
      }
done: return h;
}

void *xdlsym(void *h, const char *symbol)
{     /* obtain address of symbol from dynamically linked library */
      void *ptr;
      xassert(h != NULL);
      ptr = lt_dlsym(h, symbol);
      if (ptr == NULL)
         xerror("xdlsym: %s: %s\n", symbol, lt_dlerror());
      return ptr;
}

void xdlclose(void *h)
{     /* close dynamically linked library */
      xassert(h != NULL);
      if (lt_dlclose(h) != 0)
         xerror("xdlclose: %s\n", lt_dlerror());
      if (lt_dlexit() != 0)
         xerror("xdlclose: %s\n", lt_dlerror());
      return;
}

/* POSIX version ******************************************************/

#elif defined(HAVE_DLFCN)

#include <dlfcn.h>

void *xdlopen(const char *module)
{     /* open dynamically linked library */
      void *h;
      h = dlopen(module, RTLD_NOW);
      if (h == NULL)
         put_err_msg(dlerror());
      return h;
}

void *xdlsym(void *h, const char *symbol)
{     /* obtain address of symbol from dynamically linked library */
      void *ptr;
      xassert(h != NULL);
      ptr = dlsym(h, symbol);
      if (ptr == NULL)
         xerror("xdlsym: %s: %s\n", symbol, dlerror());
      return ptr;
}

void xdlclose(void *h)
{     /* close dynamically linked library */
      xassert(h != NULL);
      if (dlclose(h) != 0)
         xerror("xdlclose: %s\n", dlerror());
      return;
}

/* MS Windows version *************************************************/

#elif defined(__WOE__)

#include <windows.h>

void *xdlopen(const char *module)
{     /* open dynamically linked library */
      void *h;
      h = LoadLibrary(module);
      if (h == NULL)
      {  char msg[20];
         sprintf(msg, "Error %d", GetLastError());
         put_err_msg(msg);
      }
      return h;
}

void *xdlsym(void *h, const char *symbol)
{     /* obtain address of symbol from dynamically linked library */
      void *ptr;
      xassert(h != NULL);
      ptr = GetProcAddress(h, symbol);
      if (ptr == NULL)
         xerror("xdlsym: %s: Error %d\n", symbol, GetLastError());
      return ptr;
}

void xdlclose(void *h)
{     /* close dynamically linked library */
      xassert(h != NULL);
      if (!FreeLibrary(h))
         xerror("xdlclose: Error %d\n", GetLastError());
      return;
}

/* NULL version *******************************************************/

#else

void *xdlopen(const char *module)
{     /* open dynamically linked library */
      xassert(module == module);
      put_err_msg("Shared libraries not supported");
      return NULL;
}

void *xdlsym(void *h, const char *symbol)
{     /* obtain address of symbol from dynamically linked library */
      xassert(h != h);
      xassert(symbol != symbol);
      return NULL;
}

void xdlclose(void *h)
{     /* close dynamically linked library */
      xassert(h != h);
      return;
}

#endif



static void errfunc(const char *fmt, ...)
{     ENV *env = get_env_ptr();
      va_list arg;
#if 1 /* 07/XI-2015 */
      env->err_st = 1;
#endif
      env->term_out = GLP_ON;
      va_start(arg, fmt);
      xvprintf(fmt, arg);
      va_end(arg);
      xprintf("Error detected in file %s at line %d\n",
         env->err_file, env->err_line);
      if (env->err_hook != NULL)
         env->err_hook(env->err_info);
      abort();
      exit(EXIT_FAILURE);
      /* no return */
}

glp_errfunc glp_error_(const char *file, int line)
{     ENV *env = get_env_ptr();
      env->err_file = file;
      env->err_line = line;
      return errfunc;
}

#if 1 /* 07/XI-2015 */
/***********************************************************************
*  NAME
*
*  glp_at_error - check for error state
*
*  SYNOPSIS
*
*  int glp_at_error(void);
*
*  DESCRIPTION
*
*  The routine glp_at_error checks if the GLPK environment is at error
*  state, i.e. if the call to the routine is (indirectly) made from the
*  glp_error routine via an user-defined hook routine.
*
*  RETURNS
*
*  If the GLPK environment is at error state, the routine glp_at_error
*  returns non-zero, otherwise zero. */

int glp_at_error(void)
{     ENV *env = get_env_ptr();
      return env->err_st;
}
#endif

/***********************************************************************
*  NAME
*
*  glp_assert - check for logical condition
*
*  SYNOPSIS
*
*  void glp_assert(int expr);
*
*  DESCRIPTION
*
*  The routine glp_assert (implemented as a macro) checks for a logical
*  condition specified by the parameter expr. If the condition is false
*  (i.e. the value of expr is zero), the routine writes a message on
*  the terminal and abnormally terminates the program. */

void glp_assert_(const char *expr, const char *file, int line)
{     glp_error_(file, line)("Assertion failed: %s\n", expr);
      /* no return */
}

/***********************************************************************
*  NAME
*
*  glp_error_hook - install hook to intercept abnormal termination
*
*  SYNOPSIS
*
*  void glp_error_hook(void (*func)(void *info), void *info);
*
*  DESCRIPTION
*
*  The routine glp_error_hook installs a user-defined hook routine to
*  intercept abnormal termination.
*
*  The parameter func specifies the user-defined hook routine. It is
*  called from the routine glp_error before the latter calls the abort
*  function to abnormally terminate the application program because of
*  fatal error. The parameter info is a transit pointer, specified in
*  the corresponding call to the routine glp_error_hook; it may be used
*  to pass some information to the hook routine.
*
*  To uninstall the hook routine the parameters func and info should be
*  both specified as NULL. */

void glp_error_hook(void (*func)(void *info), void *info)
{     ENV *env = get_env_ptr();
      if (func == NULL)
      {  env->err_hook = NULL;
         env->err_info = NULL;
      }
      else
      {  env->err_hook = func;
         env->err_info = info;
      }
      return;
}

/***********************************************************************
*  NAME
*
*  put_err_msg - provide error message string
*
*  SYNOPSIS
*
*  #include "env.h"
*  void put_err_msg(const char *msg);
*
*  DESCRIPTION
*
*  The routine put_err_msg stores an error message string pointed to by
*  msg to the environment block. */

void put_err_msg(const char *msg)
{     ENV *env = get_env_ptr();
      int len;
      len = strlen(msg);
      if (len >= EBUF_SIZE)
         len = EBUF_SIZE - 1;
      memcpy(env->err_buf, msg, len);
      if (len > 0 && env->err_buf[len-1] == '\n')
         len--;
      env->err_buf[len] = '\0';
      return;
}

/***********************************************************************
*  NAME
*
*  get_err_msg - obtain error message string
*
*  SYNOPSIS
*
*  #include "env.h"
*  const char *get_err_msg(void);
*
*  RETURNS
*
*  The routine get_err_msg returns a pointer to an error message string
*  previously stored by the routine put_err_msg. */

const char *get_err_msg(void)
{     ENV *env = get_env_ptr();
      return env->err_buf;
}




#include <assert.h>

/***********************************************************************
*  NAME
*
*  glp_puts - write string on terminal
*
*  SYNOPSIS
*
*  void glp_puts(const char *s);
*
*  The routine glp_puts writes the string s on the terminal. */

void glp_puts(const char *s)
{     ENV *env = get_env_ptr();
      /* if terminal output is disabled, do nothing */
      if (!env->term_out)
         goto skip;
      /* pass the string to the hook routine, if defined */
      if (env->term_hook != NULL)
      {  if (env->term_hook(env->term_info, s) != 0)
            goto skip;
      }
      /* write the string on the terminal */
      fputs(s, stdout);
      fflush(stdout);
      /* write the string on the tee file, if required */
      if (env->tee_file != NULL)
      {  fputs(s, env->tee_file);
         fflush(env->tee_file);
      }
skip: return;
}

/***********************************************************************
*  NAME
*
*  glp_printf - write formatted output on terminal
*
*  SYNOPSIS
*
*  void glp_printf(const char *fmt, ...);
*
*  DESCRIPTION
*
*  The routine glp_printf uses the format control string fmt to format
*  its parameters and writes the formatted output on the terminal. */

void glp_printf(const char *fmt, ...)
{     ENV *env = get_env_ptr();
      va_list arg;
      /* if terminal output is disabled, do nothing */
      if (!env->term_out)
         goto skip;
      /* format the output */
      va_start(arg, fmt);
      vsprintf(env->term_buf, fmt, arg);
      /* (do not use xassert) */
      assert(strlen(env->term_buf) < TBUF_SIZE);
      va_end(arg);
      /* write the formatted output on the terminal */
      glp_puts(env->term_buf);
skip: return;
}

/***********************************************************************
*  NAME
*
*  glp_vprintf - write formatted output on terminal
*
*  SYNOPSIS
*
*  void glp_vprintf(const char *fmt, va_list arg);
*
*  DESCRIPTION
*
*  The routine glp_vprintf uses the format control string fmt to format
*  its parameters specified by the list arg and writes the formatted
*  output on the terminal. */

void glp_vprintf(const char *fmt, va_list arg)
{     ENV *env = get_env_ptr();
      /* if terminal output is disabled, do nothing */
      if (!env->term_out)
         goto skip;
      /* format the output */
      vsprintf(env->term_buf, fmt, arg);
      /* (do not use xassert) */
      assert(strlen(env->term_buf) < TBUF_SIZE);
      /* write the formatted output on the terminal */
      glp_puts(env->term_buf);
skip: return;
}

/***********************************************************************
*  NAME
*
*  glp_term_out - enable/disable terminal output
*
*  SYNOPSIS
*
*  int glp_term_out(int flag);
*
*  DESCRIPTION
*
*  Depending on the parameter flag the routine glp_term_out enables or
*  disables terminal output performed by glpk routines:
*
*  GLP_ON  - enable terminal output;
*  GLP_OFF - disable terminal output.
*
*  RETURNS
*
*  The routine glp_term_out returns the previous value of the terminal
*  output flag. */

int glp_term_out(int flag)
{     ENV *env = get_env_ptr();
      int old = env->term_out;
      if (!(flag == GLP_ON || flag == GLP_OFF))
         xerror("glp_term_out: flag = %d; invalid parameter\n", flag);
      env->term_out = flag;
      return old;
}

/***********************************************************************
*  NAME
*
*  glp_term_hook - install hook to intercept terminal output
*
*  SYNOPSIS
*
*  void glp_term_hook(int (*func)(void *info, const char *s),
*     void *info);
*
*  DESCRIPTION
*
*  The routine glp_term_hook installs a user-defined hook routine to
*  intercept all terminal output performed by glpk routines.
*
*  This feature can be used to redirect the terminal output to other
*  destination, for example to a file or a text window.
*
*  The parameter func specifies the user-defined hook routine. It is
*  called from an internal printing routine, which passes to it two
*  parameters: info and s. The parameter info is a transit pointer,
*  specified in the corresponding call to the routine glp_term_hook;
*  it may be used to pass some information to the hook routine. The
*  parameter s is a pointer to the null terminated character string,
*  which is intended to be written to the terminal. If the hook routine
*  returns zero, the printing routine writes the string s to the
*  terminal in a usual way; otherwise, if the hook routine returns
*  non-zero, no terminal output is performed.
*
*  To uninstall the hook routine the parameters func and info should be
*  specified as NULL. */

void glp_term_hook(int (*func)(void *info, const char *s), void *info)
{     ENV *env = get_env_ptr();
      if (func == NULL)
      {  env->term_hook = NULL;
         env->term_info = NULL;
      }
      else
      {  env->term_hook = func;
         env->term_info = info;
      }
      return;
}

/***********************************************************************
*  NAME
*
*  glp_open_tee - start copying terminal output to text file
*
*  SYNOPSIS
*
*  int glp_open_tee(const char *name);
*
*  DESCRIPTION
*
*  The routine glp_open_tee starts copying all the terminal output to
*  an output text file, whose name is specified by the character string
*  name.
*
*  RETURNS
*
*  0 - operation successful
*  1 - copying terminal output is already active
*  2 - unable to create output file */

int glp_open_tee(const char *name)
{     ENV *env = get_env_ptr();
      if (env->tee_file != NULL)
      {  /* copying terminal output is already active */
         return 1;
      }
      env->tee_file = fopen(name, "w");
      if (env->tee_file == NULL)
      {  /* unable to create output file */
         return 2;
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  glp_close_tee - stop copying terminal output to text file
*
*  SYNOPSIS
*
*  int glp_close_tee(void);
*
*  DESCRIPTION
*
*  The routine glp_close_tee stops copying the terminal output to the
*  output text file previously open by the routine glp_open_tee closing
*  that file.
*
*  RETURNS
*
*  0 - operation successful
*  1 - copying terminal output was not started */

int glp_close_tee(void)
{     ENV *env = get_env_ptr();
      if (env->tee_file == NULL)
      {  /* copying terminal output was not started */
         return 1;
      }
      fclose(env->tee_file);
      env->tee_file = NULL;
      return 0;
}

#if 0

#include "zlib.h"

struct glp_file
{     /* sequential stream descriptor */
      char *base;
      /* pointer to buffer */
      int size;
      /* size of buffer, in bytes */
      char *ptr;
      /* pointer to next byte in buffer */
      int cnt;
      /* count of bytes in buffer */
      int flag;
      /* stream flags: */
#define IONULL 0x01 /* null file */
#define IOSTD  0x02 /* standard stream */
#define IOGZIP 0x04 /* gzipped file */
#define IOWRT  0x08 /* output stream */
#define IOEOF  0x10 /* end of file */
#define IOERR  0x20 /* input/output error */
      void *file;
      /* pointer to underlying control object */
};

/***********************************************************************
*  NAME
*
*  glp_open - open stream
*
*  SYNOPSIS
*
*  glp_file *glp_open(const char *name, const char *mode);
*
*  DESCRIPTION
*
*  The routine glp_open opens a file whose name is a string pointed to
*  by name and associates a stream with it.
*
*  The following special filenames are recognized by the routine (this
*  feature is platform independent):
*
*  "/dev/null"    empty (null) file;
*  "/dev/stdin"   standard input stream;
*  "/dev/stdout"  standard output stream;
*  "/dev/stderr"  standard error stream.
*
*  If the specified filename is ended with ".gz", it is assumed that
*  the file is in gzipped format. In this case the file is compressed
*  or decompressed by the I/O routines "on the fly".
*
*  The parameter mode points to a string, which indicates the open mode
*  and should be one of the following:
*
*  "r"   open text file for reading;
*  "w"   truncate to zero length or create text file for writing;
*  "a"   append, open or create text file for writing at end-of-file;
*  "rb"  open binary file for reading;
*  "wb"  truncate to zero length or create binary file for writing;
*  "ab"  append, open or create binary file for writing at end-of-file.
*
*  RETURNS
*
*  The routine glp_open returns a pointer to the object controlling the
*  stream. If the operation fails, the routine returns NULL. */

glp_file *glp_open(const char *name, const char *mode)
{     glp_file *f;
      int flag;
      void *file;
      if (strcmp(mode, "r") == 0 || strcmp(mode, "rb") == 0)
         flag = 0;
      else if (strcmp(mode, "w") == 0 || strcmp(mode, "wb") == 0)
         flag = IOWRT;
#if 1 /* 08/V-2014 */
      else if (strcmp(mode, "a") == 0 || strcmp(mode, "ab") == 0)
         flag = IOWRT;
#endif
      else
         xerror("glp_open: invalid mode string\n");
      if (strcmp(name, "/dev/null") == 0)
      {  flag |= IONULL;
         file = NULL;
      }
      else if (strcmp(name, "/dev/stdin") == 0)
      {  flag |= IOSTD;
         file = stdin;
      }
      else if (strcmp(name, "/dev/stdout") == 0)
      {  flag |= IOSTD;
         file = stdout;
      }
      else if (strcmp(name, "/dev/stderr") == 0)
      {  flag |= IOSTD;
         file = stderr;
      }
      else
      {  char *ext = strrchr(name, '.');
         if (ext == NULL || strcmp(ext, ".gz") != 0)
         {  file = fopen(name, mode);
            if (file == NULL)
            {  put_err_msg(strerror(errno));
               return NULL;
            }
         }
         else
         {  flag |= IOGZIP;
            if (strcmp(mode, "r") == 0)
               mode = "rb";
            else if (strcmp(mode, "w") == 0)
               mode = "wb";
#if 1 /* 08/V-2014; this mode seems not to work */
            else if (strcmp(mode, "a") == 0)
               mode = "ab";
#endif
            file = gzopen(name, mode);
            if (file == NULL)
            {  put_err_msg(strerror(errno));
               return NULL;
            }
         }
      }
      f = talloc(1, glp_file);
      f->base = talloc(BUFSIZ, char);
      f->size = BUFSIZ;
      f->ptr = f->base;
      f->cnt = 0;
      f->flag = flag;
      f->file = file;
      return f;
}

/***********************************************************************
*  NAME
*
*  glp_eof - test end-of-file indicator
*
*  SYNOPSIS
*
*  int glp_eof(glp_file *f);
*
*  DESCRIPTION
*
*  The routine glp_eof tests the end-of-file indicator for the stream
*  pointed to by f.
*
*  RETURNS
*
*  The routine glp_eof returns non-zero if and only if the end-of-file
*  indicator is set for the specified stream. */

int glp_eof(glp_file *f)
{     return
         f->flag & IOEOF;
}

/***********************************************************************
*  NAME
*
*  glp_ioerr - test I/O error indicator
*
*  SYNOPSIS
*
*  int glp_ioerr(glp_file *f);
*
*  DESCRIPTION
*
*  The routine glp_ioerr tests the I/O error indicator for the stream
*  pointed to by f.
*
*  RETURNS
*
*  The routine glp_ioerr returns non-zero if and only if the I/O error
*  indicator is set for the specified stream. */

int glp_ioerr(glp_file *f)
{     return
         f->flag & IOERR;
}

/***********************************************************************
*  NAME
*
*  glp_read - read data from stream
*
*  SYNOPSIS
*
*  int glp_read(glp_file *f, void *buf, int nnn);
*
*  DESCRIPTION
*
*  The routine glp_read reads, into the buffer pointed to by buf, up to
*  nnn bytes, from the stream pointed to by f.
*
*  RETURNS
*
*  The routine glp_read returns the number of bytes successfully read
*  (which may be less than nnn). If an end-of-file is encountered, the
*  end-of-file indicator for the stream is set and glp_read returns
*  zero. If a read error occurs, the error indicator for the stream is
*  set and glp_read returns a negative value. */

int glp_read(glp_file *f, void *buf, int nnn)
{     int nrd, cnt;
      if (f->flag & IOWRT)
         xerror("glp_read: attempt to read from output stream\n");
      if (nnn < 1)
         xerror("glp_read: nnn = %d; invalid parameter\n", nnn);
      for (nrd = 0; nrd < nnn; nrd += cnt)
      {  if (f->cnt == 0)
         {  /* buffer is empty; fill it */
            if (f->flag & IONULL)
               cnt = 0;
            else if (!(f->flag & IOGZIP))
            {  cnt = fread(f->base, 1, f->size, (FILE *)(f->file));
               if (ferror((FILE *)(f->file)))
               {  f->flag |= IOERR;
                  put_err_msg(strerror(errno));
                  return EOF;
               }
            }
            else
            {  int errnum;
               const char *msg;
               cnt = gzread((gzFile)(f->file), f->base, f->size);
               if (cnt < 0)
               {  f->flag |= IOERR;
                  msg = gzerror((gzFile)(f->file), &errnum);
                  if (errnum == Z_ERRNO)
                     put_err_msg(strerror(errno));
                  else
                     put_err_msg(msg);
                  return EOF;
               }
            }
            if (cnt == 0)
            {  if (nrd == 0)
                  f->flag |= IOEOF;
               break;
            }
            f->ptr = f->base;
            f->cnt = cnt;
         }
         cnt = nnn - nrd;
         if (cnt > f->cnt)
            cnt = f->cnt;
         memcpy((char *)buf + nrd, f->ptr, cnt);
         f->ptr += cnt;
         f->cnt -= cnt;
      }
      return nrd;
}

/***********************************************************************
*  NAME
*
*  glp_getc - read character from stream
*
*  SYNOPSIS
*
*  int glp_getc(glp_file *f);
*
*  DESCRIPTION
*
*  The routine glp_getc obtains a next character as an unsigned char
*  converted to an int from the input stream pointed to by f.
*
*  RETURNS
*
*  The routine glp_getc returns the next character obtained. However,
*  if an end-of-file is encountered or a read error occurs, the routine
*  returns EOF. (An end-of-file and a read error can be distinguished
*  by use of the routines glp_eof and glp_ioerr.) */

int glp_getc(glp_file *f)
{     unsigned char buf[1];
      if (f->flag & IOWRT)
         xerror("glp_getc: attempt to read from output stream\n");
      if (glp_read(f, buf, 1) != 1)
         return EOF;
      return buf[0];
}

/***********************************************************************
*  do_flush - flush output stream
*
*  This routine causes buffered data for the specified output stream to
*  be written to the associated file.
*
*  If the operation was successful, the routine returns zero, otherwise
*  non-zero. */

static int do_flush(glp_file *f)
{     xassert(f->flag & IOWRT);
      if (f->cnt > 0)
      {  if (f->flag & IONULL)
            ;
         else if (!(f->flag & IOGZIP))
         {  if ((int)fwrite(f->base, 1, f->cnt, (FILE *)(f->file))
               != f->cnt)
            {  f->flag |= IOERR;
               put_err_msg(strerror(errno));
               return EOF;
            }
         }
         else
         {  int errnum;
            const char *msg;
            if (gzwrite((gzFile)(f->file), f->base, f->cnt) != f->cnt)
            {  f->flag |= IOERR;
               msg = gzerror((gzFile)(f->file), &errnum);
               if (errnum == Z_ERRNO)
                  put_err_msg(strerror(errno));
               else
                  put_err_msg(msg);
               return EOF;
            }
         }
      }
      f->ptr = f->base;
      f->cnt = 0;
      return 0;
}

/***********************************************************************
*  NAME
*
*  glp_write - write data to stream
*
*  SYNOPSIS
*
*  int glp_write(glp_file *f, const void *buf, int nnn);
*
*  DESCRIPTION
*
*  The routine glp_write writes, from the buffer pointed to by buf, up
*  to nnn bytes, to the stream pointed to by f.
*
*  RETURNS
*
*  The routine glp_write returns the number of bytes successfully
*  written (which is equal to nnn). If a write error occurs, the error
*  indicator for the stream is set and glp_write returns a negative
*  value. */

int glp_write(glp_file *f, const void *buf, int nnn)
{     int nwr, cnt;
      if (!(f->flag & IOWRT))
         xerror("glp_write: attempt to write to input stream\n");
      if (nnn < 1)
         xerror("glp_write: nnn = %d; invalid parameter\n", nnn);
      for (nwr = 0; nwr < nnn; nwr += cnt)
      {  cnt = nnn - nwr;
         if (cnt > f->size - f->cnt)
            cnt = f->size - f->cnt;
         memcpy(f->ptr, (const char *)buf + nwr, cnt);
         f->ptr += cnt;
         f->cnt += cnt;
         if (f->cnt == f->size)
         {  /* buffer is full; flush it */
            if (do_flush(f) != 0)
               return EOF;
         }
      }
      return nwr;
}

/***********************************************************************
*  NAME
*
*  glp_format - write formatted data to stream
*
*  SYNOPSIS
*
*  int glp_format(glp_file *f, const char *fmt, ...);
*
*  DESCRIPTION
*
*  The routine glp_format writes formatted data to the stream pointed
*  to by f. The format control string pointed to by fmt specifies how
*  subsequent arguments are converted for output.
*
*  RETURNS
*
*  The routine glp_format returns the number of characters written, or
*  a negative value if an output error occurs. */

int glp_format(glp_file *f, const char *fmt, ...)
{     ENV *env = get_env_ptr();
      va_list arg;
      int nnn;
      if (!(f->flag & IOWRT))
         xerror("glp_format: attempt to write to input stream\n");
      va_start(arg, fmt);
      nnn = vsprintf(env->term_buf, fmt, arg);
      xassert(0 <= nnn && nnn < TBUF_SIZE);
      va_end(arg);
      return nnn == 0 ? 0 : glp_write(f, env->term_buf, nnn);
}

/***********************************************************************
*  NAME
*
*  glp_close - close stream
*
*  SYNOPSIS
*
*  int glp_close(glp_file *f);
*
*  DESCRIPTION
*
*  The routine glp_close closes the stream pointed to by f.
*
*  RETURNS
*
*  If the operation was successful, the routine returns zero, otherwise
*  non-zero. */

int glp_close(glp_file *f)
{     int ret = 0;
      if (f->flag & IOWRT)
      {  if (do_flush(f) != 0)
            ret = EOF;
      }
      if (f->flag & (IONULL | IOSTD))
         ;
      else if (!(f->flag & IOGZIP))
      {  if (fclose((FILE *)(f->file)) != 0)
         {  if (ret == 0)
            {  put_err_msg(strerror(errno));
               ret = EOF;
            }
         }
      }
      else
      {  int errnum;
         errnum = gzclose((gzFile)(f->file));
         if (errnum == Z_OK)
            ;
         else if (errnum == Z_ERRNO)
         {  if (ret == 0)
            {  put_err_msg(strerror(errno));
               ret = EOF;
            }
         }
#if 1 /* FIXME */
         else
         {  if (ret == 0)
            {  ENV *env = get_env_ptr();
               sprintf(env->term_buf, "gzclose returned %d", errnum);
               put_err_msg(env->term_buf);
               ret = EOF;
            }
         }
#endif
      }
      tfree(f->base);
      tfree(f);
      return ret;
}
#endif


#define jday _glp_jday
int jday(int d, int m, int y);
/* convert calendar date to Julian day number */

#define jdate _glp_jdate
int jdate(int j, int *d, int *m, int *y);
/* convert Julian day number to calendar date */


/***********************************************************************
*  NAME
*
*  jday - convert calendar date to Julian day number
*
*  SYNOPSIS
*
*  #include "jd.h"
*  int jday(int d, int m, int y);
*
*  DESCRIPTION
*
*  The routine jday converts a calendar date, Gregorian calendar, to
*  corresponding Julian day number j.
*
*  From the given day d, month m, and year y, the Julian day number j
*  is computed without using tables.
*
*  The routine is valid for 1 <= y <= 4000.
*
*  RETURNS
*
*  The routine jday returns the Julian day number, or negative value if
*  the specified date is incorrect.
*
*  REFERENCES
*
*  R. G. Tantzen, Algorithm 199: conversions between calendar date and
*  Julian day number, Communications of the ACM, vol. 6, no. 8, p. 444,
*  Aug. 1963. */

int jday(int d, int m, int y)
{     int c, ya, j, dd;
      if (!(1 <= d && d <= 31 &&
            1 <= m && m <= 12 &&
            1 <= y && y <= 4000))
         return -1;
      if (m >= 3)
         m -= 3;
      else
         m += 9, y--;
      c = y / 100;
      ya = y - 100 * c;
      j = (146097 * c) / 4 + (1461 * ya) / 4 + (153 * m + 2) / 5 + d +
         1721119;
      jdate(j, &dd, NULL, NULL);
      if (d != dd)
         return -1;
      return j;
}

/***********************************************************************
*  NAME
*
*  jdate - convert Julian day number to calendar date
*
*  SYNOPSIS
*
*  #include "jd.h"
*  int jdate(int j, int *d, int *m, int *y);
*
*  DESCRIPTION
*
*  The routine jdate converts a Julian day number j to corresponding
*  calendar date, Gregorian calendar.
*
*  The day d, month m, and year y are computed without using tables and
*  stored in corresponding locations.
*
*  The routine is valid for 1721426 <= j <= 3182395.
*
*  RETURNS
*
*  If the conversion is successful, the routine returns zero, otherwise
*  non-zero.
*
*  REFERENCES
*
*  R. G. Tantzen, Algorithm 199: conversions between calendar date and
*  Julian day number, Communications of the ACM, vol. 6, no. 8, p. 444,
*  Aug. 1963. */

int jdate(int j, int *d_, int *m_, int *y_)
{     int d, m, y;
      if (!(1721426 <= j && j <= 3182395))
         return 1;
      j -= 1721119;
      y = (4 * j - 1) / 146097;
      j = (4 * j - 1) % 146097;
      d = j / 4;
      j = (4 * d + 3) / 1461;
      d = (4 * d + 3) % 1461;
      d = (d + 4) / 4;
      m = (5 * d - 3) / 153;
      d = (5 * d - 3) % 153;
      d = (d + 5) / 5;
      y = 100 * y + j;
      if (m <= 9)
         m += 3;
      else m -= 9,
         y++;
      if (d_ != NULL) *d_ = d;
      if (m_ != NULL) *m_ = m;
      if (y_ != NULL) *y_ = y;
      return 0;
}

#ifdef GLP_TEST
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

int main(void)
{     int jbeg, jend, j, d, m, y;
      jbeg = jday(1, 1, 1);
      jend = jday(31, 12, 4000);
      for (j = jbeg; j <= jend; j++)
      {  assert(jdate(j, &d, &m, &y) == 0);
         assert(jday(d, m, y) == j);
      }
      printf("Routines jday and jdate work correctly.\n");
      return 0;
}
#endif


/***********************************************************************
*  NAME
*
*  glp_time - determine current universal time
*
*  SYNOPSIS
*
*  double glp_time(void);
*
*  RETURNS
*
*  The routine glp_time returns the current universal time (UTC), in
*  milliseconds, elapsed since 00:00:00 GMT January 1, 1970. */

#define EPOCH 2440588 /* jday(1, 1, 1970) */

/* POSIX version ******************************************************/

#if defined(HAVE_SYS_TIME_H) && defined(HAVE_GETTIMEOFDAY)

#include <sys/time.h>
#include <time.h>

double glp_time(void)
{     struct timeval tv;
      struct tm *tm;
      int j;
      double t;
      gettimeofday(&tv, NULL);
      tm = gmtime(&tv.tv_sec);
      j = jday(tm->tm_mday, tm->tm_mon + 1, 1900 + tm->tm_year);
      xassert(j >= 0);
      t = ((((double)(j - EPOCH) * 24.0 + (double)tm->tm_hour) * 60.0 +
         (double)tm->tm_min) * 60.0 + (double)tm->tm_sec) * 1000.0 +
         (double)(tv.tv_usec / 1000);
      return t;
}

/* MS Windows version *************************************************/

#elif defined(__WOE__)

#include <windows.h>

double glp_time(void)
{     SYSTEMTIME st;
      int j;
      double t;
      GetSystemTime(&st);
      j = jday(st.wDay, st.wMonth, st.wYear);
      xassert(j >= 0);
      t = ((((double)(j - EPOCH) * 24.0 + (double)st.wHour) * 60.0 +
         (double)st.wMinute) * 60.0 + (double)st.wSecond) * 1000.0 +
         (double)st.wMilliseconds;
      return t;
}

/* portable ANSI C version ********************************************/

#else

#include <time.h>

double glp_time(void)
{     time_t timer;
      struct tm *tm;
      int j;
      double t;
      timer = time(NULL);
      tm = gmtime(&timer);
      j = jday(tm->tm_mday, tm->tm_mon + 1, 1900 + tm->tm_year);
      xassert(j >= 0);
      t = ((((double)(j - EPOCH) * 24.0 + (double)tm->tm_hour) * 60.0 +
         (double)tm->tm_min) * 60.0 + (double)tm->tm_sec) * 1000.0;
      return t;
}

#endif

/***********************************************************************
*  NAME
*
*  glp_difftime - compute difference between two time values
*
*  SYNOPSIS
*
*  double glp_difftime(double t1, double t0);
*
*  RETURNS
*
*  The routine glp_difftime returns the difference between two time
*  values t1 and t0, expressed in seconds. */

double glp_difftime(double t1, double t0)
{     return
         (t1 - t0) / 1000.0;
}

/**********************************************************************/

#ifdef GLP_TEST
#include <assert.h>

int main(void)
{     int ttt, ss, mm, hh, day, month, year;
      double t;
      t = glp_time();
      xprintf("t = %.f\n", t);
      assert(floor(t) == t);
      ttt = (int)fmod(t, 1000.0);
      t = (t - (double)ttt) / 1000.0;
      assert(floor(t) == t);
      ss = (int)fmod(t, 60.0);
      t = (t - (double)ss) / 60.0;
      assert(floor(t) == t);
      mm = (int)fmod(t, 60.0);
      t = (t - (double)mm) / 60.0;
      assert(floor(t) == t);
      hh = (int)fmod(t, 24.0);
      t = (t - (double)hh) / 24.0;
      assert(floor(t) == t);
      assert(jdate((int)t + EPOCH, &day, &month, &year) == 0);
      printf("%04d-%02d-%02d %02d:%02d:%02d.%03d\n",
         year, month, day, hh, mm, ss, ttt);
      return 0;
}
#endif



static void *tls = NULL;
/* NOTE: in a re-entrant version of the package this variable should be
 * placed in the Thread Local Storage (TLS) */

/***********************************************************************
*  NAME
*
*  tls_set_ptr - store global pointer in TLS
*
*  SYNOPSIS
*
*  #include "env.h"
*  void tls_set_ptr(void *ptr);
*
*  DESCRIPTION
*
*  The routine tls_set_ptr stores a pointer specified by the parameter
*  ptr in the Thread Local Storage (TLS). */

void tls_set_ptr(void *ptr)
{     tls = ptr;
      return;
}

/***********************************************************************
*  NAME
*
*  tls_get_ptr - retrieve global pointer from TLS
*
*  SYNOPSIS
*
*  #include "env.h"
*  void *tls_get_ptr(void);
*
*  RETURNS
*
*  The routine tls_get_ptr returns a pointer previously stored by the
*  routine tls_set_ptr. If the latter has not been called yet, NULL is
*  returned. */

void *tls_get_ptr(void)
{     void *ptr;
      ptr = tls;
      return ptr;
}



























typedef struct AVL AVL;
typedef struct AVLNODE AVLNODE;

#define avl_create_tree _glp_avl_create_tree
AVL *avl_create_tree(int (*fcmp)(void *info, const void *key1,
      const void *key2), void *info);
/* create AVL tree */

#define avl_strcmp _glp_avl_strcmp
int avl_strcmp(void *info, const void *key1, const void *key2);
/* compare character string keys */

#define avl_insert_node _glp_avl_insert_node
AVLNODE *avl_insert_node(AVL *tree, const void *key);
/* insert new node into AVL tree */

#define avl_set_node_type _glp_avl_set_node_type
void avl_set_node_type(AVLNODE *node, int type);
/* assign the type field of specified node */

#define avl_set_node_link _glp_avl_set_node_link
void avl_set_node_link(AVLNODE *node, void *link);
/* assign the link field of specified node */

#define avl_find_node _glp_avl_find_node
AVLNODE *avl_find_node(AVL *tree, const void *key);
/* find node in AVL tree */

#define avl_get_node_type _glp_avl_get_node_type
int avl_get_node_type(AVLNODE *node);
/* retrieve the type field of specified node */

#define avl_get_node_link _glp_avl_get_node_link
void *avl_get_node_link(AVLNODE *node);
/* retrieve the link field of specified node */

#define avl_delete_node _glp_avl_delete_node
void avl_delete_node(AVL *tree, AVLNODE *node);
/* delete specified node from AVL tree */

#define avl_delete_tree _glp_avl_delete_tree
void avl_delete_tree(AVL *tree);
/* delete AVL tree */

typedef struct DMP DMP;

#define dmp_debug _glp_dmp_debug
extern int dmp_debug;
/* debug mode flag */

#define dmp_create_pool _glp_dmp_create_pool
DMP *dmp_create_pool(void);
/* create dynamic memory pool */

#define dmp_talloc(pool, type) \
      ((type *)dmp_get_atom(pool, sizeof(type)))

#define dmp_get_atom _glp_dmp_get_atom
void *dmp_get_atom(DMP *pool, int size);
/* get free atom from dynamic memory pool */

#define dmp_tfree(pool, atom) \
      dmp_free_atom(pool, atom, sizeof(*(atom)))

#define dmp_free_atom _glp_dmp_free_atom
void dmp_free_atom(DMP *pool, void *atom, int size);
/* return atom to dynamic memory pool */

#define dmp_in_use _glp_dmp_in_use
size_t dmp_in_use(DMP *pool);
/* determine how many atoms are still in use */

#define dmp_delete_pool _glp_dmp_delete_pool
void dmp_delete_pool(DMP *pool);
/* delete dynamic memory pool */

struct DMP
{     /* dynamic memory pool */
      void *avail[32];
      /* avail[k], 0 <= k <= 31, is a pointer to first available (free)
       * atom of (k+1)*8 bytes long; at the beginning of each free atom
       * there is a pointer to another free atom of the same size */
      void *block;
      /* pointer to most recently allocated memory block; at the
       * beginning of each allocated memory block there is a pointer to
       * previously allocated memory block */
      int used;
      /* number of bytes used in most recently allocated memory block */
      size_t count;
      /* number of atoms which are currently in use */
};

#define DMP_BLK_SIZE 8000
/* size of memory blocks, in bytes, allocated for memory pools */

struct prefix
{     /* atom prefix (for debugging only) */
      DMP *pool;
      /* dynamic memory pool */
      int size;
      /* original atom size, in bytes */
};

#define prefix_size ((sizeof(struct prefix) + 7) & ~7)
/* size of atom prefix rounded up to multiple of 8 bytes */

int dmp_debug;
/* debug mode flag */


DMP *dmp_create_pool(void)
{     DMP *pool;
      int k;
      xassert(sizeof(void *) <= 8);
      if (dmp_debug)
         xprintf("dmp_create_pool: warning: debug mode is on\n");
      pool = talloc(1, DMP);
      for (k = 0; k <= 31; k++)
         pool->avail[k] = NULL;
      pool->block = NULL;
      pool->used = DMP_BLK_SIZE;
      pool->count = 0;
      return pool;
}

void *dmp_get_atom(DMP *pool, int size)
{     void *atom;
      int k, need;
      xassert(1 <= size && size <= 256);
      /* round up atom size to multiple of 8 bytes */
      need = (size + 7) & ~7;
      /* determine number of corresponding list of free atoms */
      k = (need >> 3) - 1;
      /* obtain free atom */
      if (pool->avail[k] == NULL)
      {  /* corresponding list of free atoms is empty */
         /* if debug mode is on, add atom prefix size */
         if (dmp_debug)
            need += prefix_size;
         if (pool->used + need > DMP_BLK_SIZE)
         {  /* allocate new memory block */
            void *block = talloc(DMP_BLK_SIZE, char);
            *(void **)block = pool->block;
            pool->block = block;
            pool->used = 8; /* sufficient to store pointer */
         }
         /* allocate new atom in current memory block */
         atom = (char *)pool->block + pool->used;
         pool->used += need;
      }
      else
      {  /* obtain atom from corresponding list of free atoms */
         atom  = pool->avail[k];
         pool->avail[k] = *(void **)atom;
      }
      /* if debug mode is on, fill atom prefix */
      if (dmp_debug)
      {  ((struct prefix *)atom)->pool = pool;
         ((struct prefix *)atom)->size = size;
         atom = (char *)atom + prefix_size;
      }
      /* increase number of allocated atoms */
      pool->count++;
      return atom;
}

void dmp_free_atom(DMP *pool, void *atom, int size)
{     int k;
      xassert(1 <= size && size <= 256);
      /* determine number of corresponding list of free atoms */
      k = ((size + 7) >> 3) - 1;
      /* if debug mode is on, check atom prefix */
      if (dmp_debug)
      {  atom = (char *)atom - prefix_size;
         xassert(((struct prefix *)atom)->pool == pool);
         xassert(((struct prefix *)atom)->size == size);
      }
      /* return atom to corresponding list of free atoms */
      *(void **)atom = pool->avail[k];
      pool->avail[k] = atom;
      /* decrease number of allocated atoms */
      xassert(pool->count > 0);
      pool->count--;
      return;
}


size_t dmp_in_use(DMP *pool)
{     return
         pool->count;
}


void dmp_delete_pool(DMP *pool)
{     while (pool->block != NULL)
      {  void *block = pool->block;
         pool->block = *(void **)block;
         tfree(block);
      }
      tfree(pool);
      return;
}

struct AVL
{     /* AVL tree (Adelson-Velsky & Landis binary search tree) */
      DMP *pool;
      /* memory pool for allocating nodes */
      AVLNODE *root;
      /* pointer to the root node */
      int (*fcmp)(void *info, const void *key1, const void *key2);
      /* application-defined key comparison routine */
      void *info;
      /* transit pointer passed to the routine fcmp */
      int size;
      /* the tree size (the total number of nodes) */
      int height;
      /* the tree height */
};

struct AVLNODE
{     /* node of AVL tree */
      const void *key;
      /* pointer to the node key (data structure for representing keys
         is supplied by the application) */
      int rank;
      /* node rank = relative position of the node in its own subtree =
         the number of nodes in the left subtree plus one */
      int type;
      /* reserved for the application specific information */
      void *link;
      /* reserved for the application specific information */
      AVLNODE *up;
      /* pointer to the parent node */
      short int flag;
      /* node flag:
         0 - this node is the left child of its parent (or this node is
             the root of the tree and has no parent)
         1 - this node is the right child of its parent */
      short int bal;
      /* node balance = the difference between heights of the right and
         left subtrees:
         -1 - the left subtree is higher than the right one;
          0 - the left and right subtrees have the same height;
         +1 - the left subtree is lower than the right one */
      AVLNODE *left;
      /* pointer to the root of the left subtree */
      AVLNODE *right;
      /* pointer to the root of the right subtree */
};

AVL *avl_create_tree(int (*fcmp)(void *info, const void *key1,
      const void *key2), void *info)
{     /* create AVL tree */
      AVL *tree;
      tree = xmalloc(sizeof(AVL));
      tree->pool = dmp_create_pool();
      tree->root = NULL;
      tree->fcmp = fcmp;
      tree->info = info;
      tree->size = 0;
      tree->height = 0;
      return tree;
}

int avl_strcmp(void *info, const void *key1, const void *key2)
{     /* compare character string keys */
      xassert(info == info);
      return strcmp(key1, key2);
}

static AVLNODE *rotate_subtree(AVL *tree, AVLNODE *node);

AVLNODE *avl_insert_node(AVL *tree, const void *key)
{     /* insert new node into AVL tree */
      AVLNODE *p, *q, *r;
      short int flag;
      /* find an appropriate point for insertion */
      p = NULL; q = tree->root;
      while (q != NULL)
      {  p = q;
         if (tree->fcmp(tree->info, key, p->key) <= 0)
         {  flag = 0;
            q = p->left;
            p->rank++;
         }
         else
         {  flag = 1;
            q = p->right;
         }
      }
      /* create new node and insert it into the tree */
      r = dmp_get_atom(tree->pool, sizeof(AVLNODE));
      r->key = key; r->type = 0; r->link = NULL;
      r->rank = 1; r->up = p;
      r->flag = (short int)(p == NULL ? 0 : flag);
      r->bal = 0; r->left = NULL; r->right = NULL;
      tree->size++;
      if (p == NULL)
         tree->root = r;
      else
         if (flag == 0) p->left = r; else p->right = r;
      /* go upstairs to the root and correct all subtrees affected by
         insertion */
      while (p != NULL)
      {  if (flag == 0)
         {  /* the height of the left subtree of [p] is increased */
            if (p->bal > 0)
            {  p->bal = 0;
               break;
            }
            if (p->bal < 0)
            {  rotate_subtree(tree, p);
               break;
            }
            p->bal = -1; flag = p->flag; p = p->up;
         }
         else
         {  /* the height of the right subtree of [p] is increased */
            if (p->bal < 0)
            {  p->bal = 0;
               break;
            }
            if (p->bal > 0)
            {  rotate_subtree(tree, p);
               break;
            }
            p->bal = +1; flag = p->flag; p = p->up;
         }
      }
      /* if the root has been reached, the height of the entire tree is
         increased */
      if (p == NULL) tree->height++;
      return r;
}

void avl_set_node_type(AVLNODE *node, int type)
{     /* assign the type field of specified node */
      node->type = type;
      return;
}

void avl_set_node_link(AVLNODE *node, void *link)
{     /* assign the link field of specified node */
      node->link = link;
      return;
}

AVLNODE *avl_find_node(AVL *tree, const void *key)
{     /* find node in AVL tree */
      AVLNODE *p;
      int c;
      p = tree->root;
      while (p != NULL)
      {  c = tree->fcmp(tree->info, key, p->key);
         if (c == 0) break;
         p = (c < 0 ? p->left : p->right);
      }
      return p;
}

int avl_get_node_type(AVLNODE *node)
{     /* retrieve the type field of specified node */
      return node->type;
}

void *avl_get_node_link(AVLNODE *node)
{     /* retrieve the link field of specified node */
      return node->link;
}

static AVLNODE *find_next_node(AVL *tree, AVLNODE *node)
{     /* find next node in AVL tree */
      AVLNODE *p, *q;
      if (tree->root == NULL) return NULL;
      p = node;
      q = (p == NULL ? tree->root : p->right);
      if (q == NULL)
      {  /* go upstairs from the left subtree */
         for (;;)
         {  q = p->up;
            if (q == NULL) break;
            if (p->flag == 0) break;
            p = q;
         }
      }
      else
      {  /* go downstairs into the right subtree */
         for (;;)
         {  p = q->left;
            if (p == NULL) break;
            q = p;
         }
      }
      return q;
}

void avl_delete_node(AVL *tree, AVLNODE *node)
{     /* delete specified node from AVL tree */
      AVLNODE *f, *p, *q, *r, *s, *x, *y;
      short int flag;
      p = node;
      /* if both subtrees of the specified node are non-empty, the node
         should be interchanged with the next one, at least one subtree
         of which is always empty */
      if (p->left == NULL || p->right == NULL) goto skip;
      f = p->up; q = p->left;
      r = find_next_node(tree, p); s = r->right;
      if (p->right == r)
      {  if (f == NULL)
            tree->root = r;
         else
            if (p->flag == 0) f->left = r; else f->right = r;
         r->rank = p->rank; r->up = f;
         r->flag = p->flag; r->bal = p->bal;
         r->left = q; r->right = p;
         q->up = r;
         p->rank = 1; p->up = r; p->flag = 1;
         p->bal = (short int)(s == NULL ? 0 : +1);
         p->left = NULL; p->right = s;
         if (s != NULL) s->up = p;
      }
      else
      {  x = p->right; y = r->up;
         if (f == NULL)
            tree->root = r;
         else
            if (p->flag == 0) f->left = r; else f->right = r;
         r->rank = p->rank; r->up = f;
         r->flag = p->flag; r->bal = p->bal;
         r->left = q; r->right = x;
         q->up = r; x->up = r; y->left = p;
         p->rank = 1; p->up = y; p->flag = 0;
         p->bal = (short int)(s == NULL ? 0 : +1);
         p->left = NULL; p->right = s;
         if (s != NULL) s->up = p;
      }
skip: /* now the specified node [p] has at least one empty subtree;
         go upstairs to the root and adjust the rank field of all nodes
         affected by deletion */
      q = p; f = q->up;
      while (f != NULL)
      {  if (q->flag == 0) f->rank--;
         q = f; f = q->up;
      }
      /* delete the specified node from the tree */
      f = p->up; flag = p->flag;
      q = p->left != NULL ? p->left : p->right;
      if (f == NULL)
         tree->root = q;
      else
         if (flag == 0) f->left = q; else f->right = q;
      if (q != NULL) q->up = f, q->flag = flag;
      tree->size--;
      /* go upstairs to the root and correct all subtrees affected by
         deletion */
      while (f != NULL)
      {  if (flag == 0)
         {  /* the height of the left subtree of [f] is decreased */
            if (f->bal == 0)
            {  f->bal = +1;
               break;
            }
            if (f->bal < 0)
               f->bal = 0;
            else
            {  f = rotate_subtree(tree, f);
               if (f->bal < 0) break;
            }
            flag = f->flag; f = f->up;
         }
         else
         {  /* the height of the right subtree of [f] is decreased */
            if (f->bal == 0)
            {  f->bal = -1;
               break;
            }
            if (f->bal > 0)
               f->bal = 0;
            else
            {  f = rotate_subtree(tree, f);
               if (f->bal > 0) break;
            }
            flag = f->flag; f = f->up;
         }
      }
      /* if the root has been reached, the height of the entire tree is
         decreased */
      if (f == NULL) tree->height--;
      /* returns the deleted node to the memory pool */
      dmp_free_atom(tree->pool, p, sizeof(AVLNODE));
      return;
}

static AVLNODE *rotate_subtree(AVL *tree, AVLNODE *node)
{     /* restore balance of AVL subtree */
      AVLNODE *f, *p, *q, *r, *x, *y;
      xassert(node != NULL);
      p = node;
      if (p->bal < 0)
      {  /* perform negative (left) rotation */
         f = p->up; q = p->left; r = q->right;
         if (q->bal <= 0)
         {  /* perform single negative rotation */
            if (f == NULL)
               tree->root = q;
            else
               if (p->flag == 0) f->left = q; else f->right = q;
            p->rank -= q->rank;
            q->up = f; q->flag = p->flag; q->bal++; q->right = p;
            p->up = q; p->flag = 1;
            p->bal = (short int)(-q->bal); p->left = r;
            if (r != NULL) r->up = p, r->flag = 0;
            node = q;
         }
         else
         {  /* perform double negative rotation */
            x = r->left; y = r->right;
            if (f == NULL)
               tree->root = r;
            else
               if (p->flag == 0) f->left = r; else f->right = r;
            p->rank -= (q->rank + r->rank);
            r->rank += q->rank;
            p->bal = (short int)(r->bal >= 0 ? 0 : +1);
            q->bal = (short int)(r->bal <= 0 ? 0 : -1);
            r->up = f; r->flag = p->flag; r->bal = 0;
            r->left = q; r->right = p;
            p->up = r; p->flag = 1; p->left = y;
            q->up = r; q->flag = 0; q->right = x;
            if (x != NULL) x->up = q, x->flag = 1;
            if (y != NULL) y->up = p, y->flag = 0;
            node = r;
         }
      }
      else
      {  /* perform positive (right) rotation */
         f = p->up; q = p->right; r = q->left;
         if (q->bal >= 0)
         {  /* perform single positive rotation */
            if (f == NULL)
               tree->root = q;
            else
               if (p->flag == 0) f->left = q; else f->right = q;
            q->rank += p->rank;
            q->up = f; q->flag = p->flag; q->bal--; q->left = p;
            p->up = q; p->flag = 0;
            p->bal = (short int)(-q->bal); p->right = r;
            if (r != NULL) r->up = p, r->flag = 1;
            node = q;
         }
         else
         {  /* perform double positive rotation */
            x = r->left; y = r->right;
            if (f == NULL)
               tree->root = r;
            else
               if (p->flag == 0) f->left = r; else f->right = r;
            q->rank -= r->rank;
            r->rank += p->rank;
            p->bal = (short int)(r->bal <= 0 ? 0 : -1);
            q->bal = (short int)(r->bal >= 0 ? 0 : +1);
            r->up = f; r->flag = p->flag; r->bal = 0;
            r->left = p; r->right = q;
            p->up = r; p->flag = 0; p->right = x;
            q->up = r; q->flag = 1; q->left = y;
            if (x != NULL) x->up = p, x->flag = 1;
            if (y != NULL) y->up = q, y->flag = 0;
            node = r;
         }
      }
      return node;
}

void avl_delete_tree(AVL *tree)
{     /* delete AVL tree */
      dmp_delete_pool(tree->pool);
      xfree(tree);
      return;
}


typedef struct FVS FVS;

struct FVS
{     /* sparse vector in full vector storage format */
      int n;
      /* vector dimension (total number of elements) */
      int nnz;
      /* number of non-zero elements, 0 <= nnz <= n */
      int *ind; /* int ind[1+n]; */
      /* ind[0] is not used;
       * ind[k] = j, 1 <= k <= nnz, means that vec[j] != 0
       * non-zero indices in the array ind are stored in arbitrary
       * order; if vec[j] = 0, its index j should NOT be presented in
       * the array ind */
      double *vec; /* double vec[1+n]; */
      /* vec[0] is not used;
       * vec[j], 1 <= j <= n, is a numeric value of j-th element */
};

#define fvs_alloc_vec _glp_fvs_alloc_vec
void fvs_alloc_vec(FVS *x, int n);
/* allocate sparse vector */

#define fvs_check_vec _glp_fvs_check_vec
void fvs_check_vec(const FVS *x);
/* check sparse vector */

#define fvs_gather_vec _glp_fvs_gather_vec
void fvs_gather_vec(FVS *x, double eps);
/* gather sparse vector */

#define fvs_clear_vec _glp_fvs_clear_vec
void fvs_clear_vec(FVS *x);
/* clear sparse vector */

#define fvs_copy_vec _glp_fvs_copy_vec
void fvs_copy_vec(FVS *x, const FVS *y);
/* copy sparse vector */

#define fvs_adjust_vec _glp_fvs_adjust_vec
void fvs_adjust_vec(FVS *x, double eps);
/* replace tiny vector elements by exact zeros */

#define fvs_free_vec _glp_fvs_free_vec
void fvs_free_vec(FVS *x);
/* deallocate sparse vector */

void fvs_alloc_vec(FVS *x, int n)
{     /* allocate sparse vector */
      int j;
      xassert(n >= 0);
      x->n = n;
      x->nnz = 0;
      x->ind = talloc(1+n, int);
      x->vec = talloc(1+n, double);
      for (j = 1; j <= n; j++)
         x->vec[j] = 0.0;
      return;
}

void fvs_check_vec(const FVS *x)
{     /* check sparse vector */
      /* NOTE: for testing/debugging only */
      int n = x->n;
      int nnz = x->nnz;
      int *ind = x->ind;
      double *vec = x->vec;
      char *map;
      int j, k;
      xassert(n >= 0);
      xassert(0 <= nnz && nnz <= n);
      map = talloc(1+n, char);
      for (j = 1; j <= n; j++)
         map[j] = (vec[j] != 0.0);
      for (k = 1; k <= nnz; k++)
      {  j = ind[k];
         xassert(1 <= j && j <= n);
         xassert(map[j]);
         map[j] = 0;
      }
      for (j = 1; j <= n; j++)
         xassert(!map[j]);
      tfree(map);
      return;
}

void fvs_gather_vec(FVS *x, double eps)
{     /* gather sparse vector */
      int n = x->n;
      int *ind = x->ind;
      double *vec = x->vec;
      int j, nnz = 0;
      for (j = n; j >= 1; j--)
      {  if (-eps < vec[j] && vec[j] < +eps)
            vec[j] = 0.0;
         else
            ind[++nnz] = j;
      }
      x->nnz = nnz;
      return;
}

void fvs_clear_vec(FVS *x)
{     /* clear sparse vector */
      int *ind = x->ind;
      double *vec = x->vec;
      int k;
      for (k = x->nnz; k >= 1; k--)
         vec[ind[k]] = 0.0;
      x->nnz = 0;
      return;
}

void fvs_copy_vec(FVS *x, const FVS *y)
{     /* copy sparse vector */
      int *x_ind = x->ind;
      double *x_vec = x->vec;
      int *y_ind = y->ind;
      double *y_vec = y->vec;
      int j, k;
      xassert(x != y);
      xassert(x->n == y->n);
      fvs_clear_vec(x);
      for (k = x->nnz = y->nnz; k >= 1; k--)
      {  j = x_ind[k] = y_ind[k];
         x_vec[j] = y_vec[j];
      }
      return;
}

void fvs_adjust_vec(FVS *x, double eps)
{     /* replace tiny vector elements by exact zeros */
      int nnz = x->nnz;
      int *ind = x->ind;
      double *vec = x->vec;
      int j, k, cnt = 0;
      for (k = 1; k <= nnz; k++)
      {  j = ind[k];
         if (-eps < vec[j] && vec[j] < +eps)
            vec[j] = 0.0;
         else
            ind[++cnt] = j;
      }
      x->nnz = cnt;
      return;
}

void fvs_free_vec(FVS *x)
{     /* deallocate sparse vector */
      tfree(x->ind);
      tfree(x->vec);
      x->n = x->nnz = -1;
      x->ind = NULL;
      x->vec = NULL;
      return;
}



typedef struct SVA SVA;

struct SVA
{     /* sparse vector area */
      int n_max;
      /* maximal value of n (enlarged automatically) */
      int n;
      /* number of currently allocated vectors, 0 <= n <= n_max */
      int *ptr; /* int ptr[1+n_max]; */
      /* ptr[0] is not used;
       * ptr[k], 1 <= i <= n, is pointer to first location of k-th
       * vector in the arrays ind and val */
      int *len; /* int len[1+n_max]; */
      /* len[0] is not used;
       * len[k], 1 <= k <= n, is length of k-th vector, len[k] >= 0 */
      int *cap; /* int cap[1+n_max]; */
      /* cap[0] is not used;
       * cap[k], 1 <= k <= n, is capacity of k-th vector (the number
       * of adjacent locations allocated to it), cap[k] >= len[k] */
      /* NOTE: if cap[k] = 0, then ptr[k] = 0 and len[k] = 0 */
      int size;
      /* total number of locations in SVA */
      int m_ptr, r_ptr;
      /* partitioning pointers that define the left, middle, and right
       * parts of SVA (see above); 1 <= m_ptr <= r_ptr <= size+1 */
      int head;
      /* number of first (leftmost) vector in the linked list */
      int tail;
      /* number of last (rightmost) vector in the linked list */
      int *prev; /* int prev[1+n_max]; */
      /* prev[0] is not used;
       * prev[k] is number of vector which precedes k-th vector in the
       * linked list;
       * prev[k] < 0 means that k-th vector is not in the list */
      int *next; /* int next[1+n_max]; */
      /* next[0] is not used;
       * next[k] is number of vector which succedes k-th vector in the
       * linked list;
       * next[k] < 0 means that k-th vector is not in the list */
      /* NOTE: only vectors having non-zero capacity and stored in the
       *       left part of SVA are included in this linked list */
      int *ind; /* int ind[1+size]; */
      /* ind[0] is not used;
       * ind[p], 1 <= p <= size, is index field of location p */
      double *val; /* double val[1+size]; */
      /* val[0] is not used;
       * val[p], 1 <= p <= size, is value field of location p */
#if 1
      int talky;
      /* option to enable talky mode */
#endif
};

#define sva_create_area _glp_sva_create_area
SVA *sva_create_area(int n_max, int size);
/* create sparse vector area (SVA) */

#define sva_alloc_vecs _glp_sva_alloc_vecs
int sva_alloc_vecs(SVA *sva, int nnn);
/* allocate new vectors in SVA */

#define sva_resize_area _glp_sva_resize_area
void sva_resize_area(SVA *sva, int delta);
/* change size of SVA storage */

#define sva_defrag_area _glp_sva_defrag_area
void sva_defrag_area(SVA *sva);
/* defragment left part of SVA */

#define sva_more_space _glp_sva_more_space
void sva_more_space(SVA *sva, int m_size);
/* increase size of middle (free) part of SVA */

#define sva_enlarge_cap _glp_sva_enlarge_cap
void sva_enlarge_cap(SVA *sva, int k, int new_cap, int skip);
/* enlarge capacity of specified vector */

#define sva_reserve_cap _glp_sva_reserve_cap
void sva_reserve_cap(SVA *sva, int k, int new_cap);
/* reserve locations for specified vector */

#define sva_make_static _glp_sva_make_static
void sva_make_static(SVA *sva, int k);
/* relocate specified vector to right part of SVA */

#define sva_check_area _glp_sva_check_area
void sva_check_area(SVA *sva);
/* check sparse vector area (SVA) */

#define sva_delete_area _glp_sva_delete_area
void sva_delete_area(SVA *sva);
/* delete sparse vector area (SVA) */


/***********************************************************************
*  sva_create_area - create sparse vector area (SVA)
*
*  This routine creates the sparse vector area (SVA), which initially
*  is empty.
*
*  The parameter n_max specifies the initial number of vectors that can
*  be allocated in the SVA, n_max > 0.
*
*  The parameter size specifies the initial number of free locations in
*  the SVA, size > 0.
*
*  On exit the routine returns a pointer to the SVA created. */

SVA *sva_create_area(int n_max, int size)
{     SVA *sva;
      xassert(0 < n_max && n_max < INT_MAX);
      xassert(0 < size && size < INT_MAX);
      sva = talloc(1, SVA);
      sva->n_max = n_max;
      sva->n = 0;
      sva->ptr = talloc(1+n_max, int);
      sva->len = talloc(1+n_max, int);
      sva->cap = talloc(1+n_max, int);
      sva->size = size;
      sva->m_ptr = 1;
      sva->r_ptr = size+1;
      sva->head = sva->tail = 0;
      sva->prev = talloc(1+n_max, int);
      sva->next = talloc(1+n_max, int);
      sva->ind = talloc(1+size, int);
      sva->val = talloc(1+size, double);
      sva->talky = 0;
      return sva;
}

/***********************************************************************
*  sva_alloc_vecs - allocate new vectors in SVA
*
*  This routine allocates nnn new empty vectors, nnn > 0, in the sparse
*  vector area (SVA).
*
*  The new vectors are assigned reference numbers k, k+1, ..., k+nnn-1,
*  where k is a reference number assigned to the very first new vector,
*  which is returned by the routine on exit. */

int sva_alloc_vecs(SVA *sva, int nnn)
{     int n = sva->n;
      int n_max = sva->n_max;
      int *ptr = sva->ptr;
      int *len = sva->len;
      int *cap = sva->cap;
      int *prev = sva->prev;
      int *next = sva->next;
      int k, new_n;
#if 1
      if (sva->talky)
         xprintf("sva_alloc_vecs: nnn = %d\n", nnn);
#endif
      xassert(nnn > 0);
      /* determine new number of vectors in SVA */
      new_n = n + nnn;
      xassert(new_n > n);
      if (n_max < new_n)
      {  /* enlarge the SVA arrays */
         while (n_max < new_n)
         {  n_max += n_max;
            xassert(n_max > 0);
         }
         sva->n_max = n_max;
         sva->ptr = ptr = trealloc(ptr, 1+n_max, int);
         sva->len = len = trealloc(len, 1+n_max, int);
         sva->cap = cap = trealloc(cap, 1+n_max, int);
         sva->prev = prev = trealloc(prev, 1+n_max, int);
         sva->next = next = trealloc(next, 1+n_max, int);
      }
      /* initialize new vectors */
      sva->n = new_n;
      for (k = n+1; k <= new_n; k++)
      {  ptr[k] = len[k] = cap[k] = 0;
         prev[k] = next[k] = -1;
      }
#if 1
      if (sva->talky)
         xprintf("now sva->n_max = %d, sva->n = %d\n",
            sva->n_max, sva->n);
#endif
      /* return reference number of very first new vector */
      return n+1;
}

/***********************************************************************
*  sva_resize_area - change size of SVA storage
*
*  This routine increases or decrases the size of the SVA storage by
*  reallocating it.
*
*  The parameter delta specifies the number of location by which the
*  current size of the SVA storage should be increased (if delta > 0)
*  or decreased (if delta < 0). Note that if delta is negative, it
*  should not be less than the current size of the middle part.
*
*  As a result of this operation the size of the middle part of SVA is
*  increased/decreased by delta locations.
*
*  NOTE: This operation changes ptr[k] for all vectors stored in the
*        right part of SVA. */

void sva_resize_area(SVA *sva, int delta)
{     int n = sva->n;
      int *ptr = sva->ptr;
      int size = sva->size;
      int m_ptr = sva->m_ptr;
      int r_ptr = sva->r_ptr;
      int k, r_size;
#if 1
      if (sva->talky)
         xprintf("sva_resize_area: delta = %d\n", delta);
#endif
      xassert(delta != 0);
      /* determine size of the right part, in locations */
      r_size = size - r_ptr + 1;
      /* relocate the right part in case of negative delta */
      if (delta < 0)
      {  xassert(delta >= m_ptr - r_ptr);
         sva->r_ptr += delta;
         memmove(&sva->ind[sva->r_ptr], &sva->ind[r_ptr],
            r_size * sizeof(int));
         memmove(&sva->val[sva->r_ptr], &sva->val[r_ptr],
            r_size * sizeof(double));
      }
      /* reallocate the storage arrays */
      xassert(delta < INT_MAX - sva->size);
      sva->size += delta;
      sva->ind = trealloc(sva->ind, 1+sva->size, int);
      sva->val = trealloc(sva->val, 1+sva->size, double);
      /* relocate the right part in case of positive delta */
      if (delta > 0)
      {  sva->r_ptr += delta;
         memmove(&sva->ind[sva->r_ptr], &sva->ind[r_ptr],
            r_size * sizeof(int));
         memmove(&sva->val[sva->r_ptr], &sva->val[r_ptr],
            r_size * sizeof(double));
      }
      /* update pointers to vectors stored in the right part */
      for (k = 1; k <= n; k++)
      {  if (ptr[k] >= r_ptr)
            ptr[k] += delta;
      }
#if 1
      if (sva->talky)
         xprintf("now sva->size = %d\n", sva->size);
#endif
      return;
}

/***********************************************************************
*  sva_defrag_area - defragment left part of SVA
*
*  This routine performs "garbage" collection to defragment the left
*  part of SVA.
*
*  NOTE: This operation may change ptr[k] and cap[k] for all vectors
*        stored in the left part of SVA. */

void sva_defrag_area(SVA *sva)
{     int *ptr = sva->ptr;
      int *len = sva->len;
      int *cap = sva->cap;
      int *prev = sva->prev;
      int *next = sva->next;
      int *ind = sva->ind;
      double *val = sva->val;
      int k, next_k, ptr_k, len_k, m_ptr, head, tail;
#if 1
      if (sva->talky)
      {  xprintf("sva_defrag_area:\n");
         xprintf("before defragmenting = %d %d %d\n", sva->m_ptr - 1,
            sva->r_ptr - sva->m_ptr, sva->size + 1 - sva->r_ptr);
      }
#endif
      m_ptr = 1;
      head = tail = 0;
      /* walk through the linked list of vectors stored in the left
       * part of SVA */
      for (k = sva->head; k != 0; k = next_k)
      {  /* save number of next vector in the list */
         next_k = next[k];
         /* determine length of k-th vector */
         len_k = len[k];
         if (len_k == 0)
         {  /* k-th vector is empty; remove it from the left part */
            ptr[k] = cap[k] = 0;
            prev[k] = next[k] = -1;
         }
         else
         {  /* determine pointer to first location of k-th vector */
            ptr_k = ptr[k];
            xassert(m_ptr <= ptr_k);
            /* relocate k-th vector to the beginning of the left part,
             * if necessary */
            if (m_ptr < ptr_k)
            {  memmove(&ind[m_ptr], &ind[ptr_k],
                  len_k * sizeof(int));
               memmove(&val[m_ptr], &val[ptr_k],
                  len_k * sizeof(double));
               ptr[k] = m_ptr;
            }
            /* remove unused locations from k-th vector */
            cap[k] = len_k;
            /* the left part of SVA has been enlarged */
            m_ptr += len_k;
            /* add k-th vector to the end of the new linked list */
            prev[k] = tail;
            next[k] = 0;
            if (head == 0)
               head = k;
            else
               next[tail] = k;
            tail = k;
         }
      }
      /* set new pointer to the middle part of SVA */
      xassert(m_ptr <= sva->r_ptr);
      sva->m_ptr = m_ptr;
      /* set new head and tail of the linked list */
      sva->head = head;
      sva->tail = tail;
#if 1
      if (sva->talky)
         xprintf("after defragmenting = %d %d %d\n", sva->m_ptr - 1,
            sva->r_ptr - sva->m_ptr, sva->size + 1 - sva->r_ptr);
#endif
      return;
}

/***********************************************************************
*  sva_more_space - increase size of middle (free) part of SVA
*
*  This routine increases the size of the middle (free) part of the
*  sparse vector area (SVA).
*
*  The parameter m_size specifies the minimal size, in locations, of
*  the middle part to be provided. This new size should be greater than
*  the current size of the middle part.
*
*  First, the routine defragments the left part of SVA. Then, if the
*  size of the left part has not sufficiently increased, the routine
*  increases the total size of the SVA storage by reallocating it. */

void sva_more_space(SVA *sva, int m_size)
{     int size, delta;
#if 1
      if (sva->talky)
         xprintf("sva_more_space: m_size = %d\n", m_size);
#endif
      xassert(m_size > sva->r_ptr - sva->m_ptr);
      /* defragment the left part */
      sva_defrag_area(sva);
      /* set, heuristically, the minimal size of the middle part to be
       * not less than the size of the defragmented left part */
      if (m_size < sva->m_ptr - 1)
         m_size = sva->m_ptr - 1;
      /* if there is still not enough room, increase the total size of
       * the SVA storage */
      if (sva->r_ptr - sva->m_ptr < m_size)
      {  size = sva->size; /* new sva size */
         for (;;)
         {  delta = size - sva->size;
            if (sva->r_ptr - sva->m_ptr + delta >= m_size)
               break;
            size += size;
            xassert(size > 0);
         }
         sva_resize_area(sva, delta);
         xassert(sva->r_ptr - sva->m_ptr >= m_size);
      }
      return;
}

/***********************************************************************
*  sva_enlarge_cap - enlarge capacity of specified vector
*
*  This routine enlarges the current capacity of the specified vector
*  by relocating its content.
*
*  The parameter k specifies the reference number of the vector whose
*  capacity should be enlarged, 1 <= k <= n. This vector should either
*  have zero capacity or be stored in the left (dynamic) part of SVA.
*
*  The parameter new_cap specifies the new capacity of the vector,
*  in locations. This new capacity should be greater than the current
*  capacity of the vector.
*
*  The parameter skip is a flag. If this flag is set, the routine does
*  *not* copy numerical values of elements of the vector on relocating
*  its content, i.e. only element indices are copied.
*
*  NOTE: On entry to the routine the middle part of SVA should have at
*        least new_cap free locations. */

void sva_enlarge_cap(SVA *sva, int k, int new_cap, int skip)
{     int *ptr = sva->ptr;
      int *len = sva->len;
      int *cap = sva->cap;
      int *prev = sva->prev;
      int *next = sva->next;
      int *ind = sva->ind;
      double *val = sva->val;
      xassert(1 <= k && k <= sva->n);
      xassert(new_cap > cap[k]);
      /* there should be at least new_cap free locations */
      xassert(sva->r_ptr - sva->m_ptr >= new_cap);
      /* relocate the vector */
      if (cap[k] == 0)
      {  /* the vector is empty */
         xassert(ptr[k] == 0);
         xassert(len[k] == 0);
      }
      else
      {  /* the vector has non-zero capacity */
         xassert(ptr[k] + len[k] <= sva->m_ptr);
         /* copy the current vector content to the beginning of the
          * middle part */
         if (len[k] > 0)
         {  memcpy(&ind[sva->m_ptr], &ind[ptr[k]],
               len[k] * sizeof(int));
            if (!skip)
               memcpy(&val[sva->m_ptr], &val[ptr[k]],
                  len[k] * sizeof(double));
         }
         /* remove the vector from the linked list */
         if (prev[k] == 0)
            sva->head = next[k];
         else
         {  /* preceding vector exists; increase its capacity */
            cap[prev[k]] += cap[k];
            next[prev[k]] = next[k];
         }
         if (next[k] == 0)
            sva->tail = prev[k];
         else
            prev[next[k]] = prev[k];
      }
      /* set new pointer and capacity of the vector */
      ptr[k] = sva->m_ptr;
      cap[k] = new_cap;
      /* add the vector to the end of the linked list */
      prev[k] = sva->tail;
      next[k] = 0;
      if (sva->head == 0)
         sva->head = k;
      else
         next[sva->tail] = k;
      sva->tail = k;
      /* new_cap free locations have been consumed */
      sva->m_ptr += new_cap;
      xassert(sva->m_ptr <= sva->r_ptr);
      return;
}

/***********************************************************************
*  sva_reserve_cap - reserve locations for specified vector
*
*  This routine reserves locations for the specified vector in the
*  right (static) part of SVA.
*
*  The parameter k specifies the reference number of the vector (this
*  vector should have zero capacity), 1 <= k <= n.
*
*  The parameter new_cap specifies a non-zero capacity of the vector,
*  in locations.
*
*  NOTE: On entry to the routine the middle part of SVA should have at
*        least new_cap free locations. */

void sva_reserve_cap(SVA *sva, int k, int new_cap)
{     int *ptr = sva->ptr;
      int *len = sva->len;
      int *cap = sva->cap;
      xassert(1 <= k && k <= sva->n);
      xassert(new_cap > 0);
      xassert(ptr[k] == 0 && len[k] == 0 && cap[k] == 0);
      /* there should be at least new_cap free locations */
      xassert(sva->r_ptr - sva->m_ptr >= new_cap);
      /* set the pointer and capacity of the vector */
      ptr[k] = sva->r_ptr - new_cap;
      cap[k] = new_cap;
      /* new_cap free locations have been consumed */
      sva->r_ptr -= new_cap;
      return;
}

/***********************************************************************
*  sva_make_static - relocate specified vector to right part of SVA
*
*  Assuming that the specified vector is stored in the left (dynamic)
*  part of SVA, this routine makes the vector static by relocating its
*  content to the right (static) part of SVA. However, if the specified
*  vector has zero capacity, the routine does nothing.
*
*  The parameter k specifies the reference number of the vector to be
*  relocated, 1 <= k <= n.
*
*  NOTE: On entry to the routine the middle part of SVA should have at
*        least len[k] free locations, where len[k] is the length of the
*        vector to be relocated. */

void sva_make_static(SVA *sva, int k)
{     int *ptr = sva->ptr;
      int *len = sva->len;
      int *cap = sva->cap;
      int *prev = sva->prev;
      int *next = sva->next;
      int *ind = sva->ind;
      double *val = sva->val;
      int ptr_k, len_k;
      xassert(1 <= k && k <= sva->n);
      /* if the vector has zero capacity, do nothing */
      if (cap[k] == 0)
      {  xassert(ptr[k] == 0);
         xassert(len[k] == 0);
         goto done;
      }
      /* there should be at least len[k] free locations */
      len_k = len[k];
      xassert(sva->r_ptr - sva->m_ptr >= len_k);
      /* remove the vector from the linked list */
      if (prev[k] == 0)
         sva->head = next[k];
      else
      {  /* preceding vector exists; increase its capacity */
         cap[prev[k]] += cap[k];
         next[prev[k]] = next[k];
      }
      if (next[k] == 0)
         sva->tail = prev[k];
      else
         prev[next[k]] = prev[k];
      /* if the vector has zero length, make it empty */
      if (len_k == 0)
      {  ptr[k] = cap[k] = 0;
         goto done;
      }
      /* copy the vector content to the beginning of the right part */
      ptr_k = sva->r_ptr - len_k;
      memcpy(&ind[ptr_k], &ind[ptr[k]], len_k * sizeof(int));
      memcpy(&val[ptr_k], &val[ptr[k]], len_k * sizeof(double));
      /* set new pointer and capacity of the vector */
      ptr[k] = ptr_k;
      cap[k] = len_k;
      /* len[k] free locations have been consumed */
      sva->r_ptr -= len_k;
done: return;
}

/***********************************************************************
*  sva_check_area - check sparse vector area (SVA)
*
*  This routine checks the SVA data structures for correctness.
*
*  NOTE: For testing/debugging only. */

void sva_check_area(SVA *sva)
{     int n_max = sva->n_max;
      int n = sva->n;
      int *ptr = sva->ptr;
      int *len = sva->len;
      int *cap = sva->cap;
      int size = sva->size;
      int m_ptr = sva->m_ptr;
      int r_ptr = sva->r_ptr;
      int head = sva->head;
      int tail = sva->tail;
      int *prev = sva->prev;
      int *next = sva->next;
      int k;
#if 0 /* 16/II-2004; SVA may be empty */
      xassert(1 <= n && n <= n_max);
#else
      xassert(0 <= n && n <= n_max);
#endif
      xassert(1 <= m_ptr && m_ptr <= r_ptr && r_ptr <= size+1);
      /* all vectors included the linked list should have non-zero
       * capacity and be stored in the left part */
      for (k = head; k != 0; k = next[k])
      {  xassert(1 <= k && k <= n);
         xassert(cap[k] > 0);
         xassert(0 <= len[k] && len[k] <= cap[k]);
         if (prev[k] == 0)
            xassert(k == head);
         else
         {  xassert(1 <= prev[k] && prev[k] <= n);
            xassert(next[prev[k]] == k);
         }
         if (next[k] == 0)
         {  xassert(k == tail);
            xassert(ptr[k] + cap[k] <= m_ptr);
         }
         else
         {  xassert(1 <= next[k] && next[k] <= n);
            xassert(prev[next[k]] == k);
            xassert(ptr[k] + cap[k] <= ptr[next[k]]);
         }
         cap[k] = -cap[k];
      }
      /* all other vectors should either have zero capacity or be
       * stored in the right part */
      for (k = 1; k <= n; k++)
      {  if (cap[k] < 0)
         {  /* k-th vector is stored in the left part */
            cap[k] = -cap[k];
         }
         else if (cap[k] == 0)
         {  /* k-th vector has zero capacity */
            xassert(ptr[k] == 0);
            xassert(len[k] == 0);
         }
         else /* cap[k] > 0 */
         {  /* k-th vector is stored in the right part */
            xassert(0 <= len[k] && len[k] <= cap[k]);
            xassert(r_ptr <= ptr[k] && ptr[k] + cap[k] <= size+1);
         }
      }
      return;
}

/***********************************************************************
*  sva_delete_area - delete sparse vector area (SVA)
*
*  This routine deletes the sparse vector area (SVA) freeing all the
*  memory allocated to it. */

void sva_delete_area(SVA *sva)
{     tfree(sva->ptr);
      tfree(sva->len);
      tfree(sva->cap);
      tfree(sva->prev);
      tfree(sva->next);
      tfree(sva->ind);
      tfree(sva->val);
      tfree(sva);
      return;
}
























typedef struct LUF LUF;

struct LUF
{     /* sparse LU-factorization */
      int n;
      /* order of matrices A, F, V, P, Q */
      SVA *sva;
      /* associated sparse vector area (SVA) used to store rows and
       * columns of matrices F and V; note that different objects may
       * share the same SVA */
      /*--------------------------------------------------------------*/
      /* matrix F in row-wise format */
      /* during the factorization process this object is not used */
      int fr_ref;
      /* reference number of sparse vector in SVA, which is the first
       * row of matrix F */
#if 0 + 0
      int *fr_ptr = &sva->ptr[fr_ref-1];
      /* fr_ptr[0] is not used;
       * fr_ptr[i], 1 <= i <= n, is pointer to i-th row in SVA */
      int *fr_len = &sva->len[fr_ref-1];
      /* fr_len[0] is not used;
       * fr_len[i], 1 <= i <= n, is length of i-th row */
#endif
      /*--------------------------------------------------------------*/
      /* matrix F in column-wise format */
      /* during the factorization process this object is constructed
         by columns */
      int fc_ref;
      /* reference number of sparse vector in SVA, which is the first
       * column of matrix F */
#if 0 + 0
      int *fc_ptr = &sva->ptr[fc_ref-1];
      /* fc_ptr[0] is not used;
       * fc_ptr[j], 1 <= j <= n, is pointer to j-th column in SVA */
      int *fc_len = &sva->len[fc_ref-1];
      /* fc_len[0] is not used;
       * fc_len[j], 1 <= j <= n, is length of j-th column */
#endif
      /*--------------------------------------------------------------*/
      /* matrix V in row-wise format */
      int vr_ref;
      /* reference number of sparse vector in SVA, which is the first
       * row of matrix V */
#if 0 + 0
      int *vr_ptr = &sva->ptr[vr_ref-1];
      /* vr_ptr[0] is not used;
       * vr_ptr[i], 1 <= i <= n, is pointer to i-th row in SVA */
      int *vr_len = &sva->len[vr_ref-1];
      /* vr_len[0] is not used;
       * vr_len[i], 1 <= i <= n, is length of i-th row */
      int *vr_cap = &sva->cap[vr_ref-1];
      /* vr_cap[0] is not used;
       * vr_cap[i], 1 <= i <= n, is capacity of i-th row */
#endif
      double *vr_piv; /* double vr_piv[1+n]; */
      /* vr_piv[0] is not used;
       * vr_piv[i], 1 <= i <= n, is pivot element of i-th row */
      /*--------------------------------------------------------------*/
      /* matrix V in column-wise format */
      /* during the factorization process this object contains only the
       * patterns (row indices) of columns of the active submatrix */
      int vc_ref;
      /* reference number of sparse vector in SVA, which is the first
       * column of matrix V */
#if 0 + 0
      int *vc_ptr = &sva->ptr[vc_ref-1];
      /* vc_ptr[0] is not used;
       * vc_ptr[j], 1 <= j <= n, is pointer to j-th column in SVA */
      int *vc_len = &sva->len[vc_ref-1];
      /* vc_len[0] is not used;
       * vc_len[j], 1 <= j <= n, is length of j-th column */
      int *vc_cap = &sva->cap[vc_ref-1];
      /* vc_cap[0] is not used;
       * vc_cap[j], 1 <= j <= n, is capacity of j-th column */
#endif
      /*--------------------------------------------------------------*/
      /* matrix P */
      int *pp_ind; /* int pp_ind[1+n]; */
      /* pp_ind[i] = j means that P[i,j] = 1 */
      int *pp_inv; /* int pp_inv[1+n]; */
      /* pp_inv[j] = i means that P[i,j] = 1 */
      /* if i-th row or column of matrix F is i'-th row or column of
       * matrix L, or if i-th row of matrix V is i'-th row of matrix U,
       * then pp_ind[i] = i' and pp_inv[i'] = i */
      /*--------------------------------------------------------------*/
      /* matrix Q */
      int *qq_ind; /* int qq_ind[1+n]; */
      /* qq_ind[i] = j means that Q[i,j] = 1 */
      int *qq_inv; /* int qq_inv[1+n]; */
      /* qq_inv[j] = i means that Q[i,j] = 1 */
      /* if j-th column of matrix V is j'-th column of matrix U, then
       * qq_ind[j'] = j and qq_inv[j] = j' */
};

#define luf_swap_u_rows(i1, i2) \
      do \
      {  int j1, j2; \
         j1 = pp_inv[i1], j2 = pp_inv[i2]; \
         pp_ind[j1] = i2, pp_inv[i2] = j1; \
         pp_ind[j2] = i1, pp_inv[i1] = j2; \
      } while (0)
/* swap rows i1 and i2 of matrix U = P'* V * Q' */

#define luf_swap_u_cols(j1, j2) \
      do \
      {  int i1, i2; \
         i1 = qq_ind[j1], i2 = qq_ind[j2]; \
         qq_ind[j1] = i2, qq_inv[i2] = j1; \
         qq_ind[j2] = i1, qq_inv[i1] = j2; \
      } while (0)
/* swap columns j1 and j2 of matrix U = P'* V * Q' */

#define luf_store_v_cols _glp_luf_store_v_cols
int luf_store_v_cols(LUF *luf, int (*col)(void *info, int j, int ind[],
      double val[]), void *info, int ind[], double val[]);
/* store matrix V = A in column-wise format */

#define luf_check_all _glp_luf_check_all
void luf_check_all(LUF *luf, int k);
/* check LU-factorization before k-th elimination step */

#define luf_build_v_rows _glp_luf_build_v_rows
void luf_build_v_rows(LUF *luf, int len[/*1+n*/]);
/* build matrix V in row-wise format */

#define luf_build_f_rows _glp_luf_build_f_rows
void luf_build_f_rows(LUF *luf, int len[/*1+n*/]);
/* build matrix F in row-wise format */

#define luf_build_v_cols _glp_luf_build_v_cols
void luf_build_v_cols(LUF *luf, int updat, int len[/*1+n*/]);
/* build matrix V in column-wise format */

#define luf_check_f_rc _glp_luf_check_f_rc
void luf_check_f_rc(LUF *luf);
/* check rows and columns of matrix F */

#define luf_check_v_rc _glp_luf_check_v_rc
void luf_check_v_rc(LUF *luf);
/* check rows and columns of matrix V */

#define luf_f_solve _glp_luf_f_solve
void luf_f_solve(LUF *luf, double x[/*1+n*/]);
/* solve system F * x = b */

#define luf_ft_solve _glp_luf_ft_solve
void luf_ft_solve(LUF *luf, double x[/*1+n*/]);
/* solve system F' * x = b */

#define luf_v_solve _glp_luf_v_solve
void luf_v_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/]);
/* solve system V * x = b */

#define luf_vt_solve _glp_luf_vt_solve
void luf_vt_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/]);
/* solve system V' * x = b */

#define luf_vt_solve1 _glp_luf_vt_solve1
void luf_vt_solve1(LUF *luf, double e[/*1+n*/], double y[/*1+n*/]);
/* solve system V' * y = e' to cause growth in y */

#define luf_estimate_norm _glp_luf_estimate_norm
double luf_estimate_norm(LUF *luf, double w1[/*1+n*/], double
      w2[/*1+n*/]);
/* estimate 1-norm of inv(A) */


int luf_store_v_cols(LUF *luf, int (*col)(void *info, int j, int ind[],
      double val[]), void *info, int ind[], double val[])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int *vc_cap = &sva->cap[vc_ref-1];
      int j, len, ptr, nnz;
      nnz = 0;
      for (j = 1; j <= n; j++)
      {  /* get j-th column */
         len = col(info, j, ind, val);
         xassert(0 <= len && len <= n);
         /* enlarge j-th column capacity */
         if (vc_cap[j] < len)
         {  if (sva->r_ptr - sva->m_ptr < len)
            {  sva_more_space(sva, len);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_enlarge_cap(sva, vc_ref-1+j, len, 0);
         }
         /* store j-th column */
         ptr = vc_ptr[j];
         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));
         memcpy(&sv_val[ptr], &val[1], len * sizeof(double));
         vc_len[j] = len;
         nnz += len;
      }
      return nnz;
}


void luf_check_all(LUF *luf, int k)
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int fr_ref = luf->fr_ref;
      int *fr_len = &sva->len[fr_ref-1];
      int fc_ref = luf->fc_ref;
      int *fc_ptr = &sva->ptr[fc_ref-1];
      int *fc_len = &sva->len[fc_ref-1];
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int *pp_ind = luf->pp_ind;
      int *pp_inv = luf->pp_inv;
      int *qq_ind = luf->qq_ind;
      int *qq_inv = luf->qq_inv;
      int i, ii, i_ptr, i_end, j, jj, j_ptr, j_end;
      xassert(n > 0);
      xassert(1 <= k && k <= n+1);
      /* check permutation matrix P */
      for (i = 1; i <= n; i++)
      {  ii = pp_ind[i];
         xassert(1 <= ii && ii <= n);
         xassert(pp_inv[ii] == i);
      }
      /* check permutation matrix Q */
      for (j = 1; j <= n; j++)
      {  jj = qq_inv[j];
         xassert(1 <= jj && jj <= n);
         xassert(qq_ind[jj] == j);
      }
      /* check row-wise representation of matrix F */
      for (i = 1; i <= n; i++)
         xassert(fr_len[i] == 0);
      /* check column-wise representation of matrix F */
      for (j = 1; j <= n; j++)
      {  /* j-th column of F = jj-th column of L */
         jj = pp_ind[j];
         if (jj < k)
         {  j_ptr = fc_ptr[j];
            j_end = j_ptr + fc_len[j];
            for (; j_ptr < j_end; j_ptr++)
            {  i = sv_ind[j_ptr];
               xassert(1 <= i && i <= n);
               ii = pp_ind[i]; /* f[i,j] = l[ii,jj] */
               xassert(ii > jj);
               xassert(sv_val[j_ptr] != 0.0);
            }
         }
         else /* jj >= k */
            xassert(fc_len[j] == 0);
      }
      /* check row-wise representation of matrix V */
      for (i = 1; i <= n; i++)
      {  /* i-th row of V = ii-th row of U */
         ii = pp_ind[i];
         i_ptr = vr_ptr[i];
         i_end = i_ptr + vr_len[i];
         for (; i_ptr < i_end; i_ptr++)
         {  j = sv_ind[i_ptr];
            xassert(1 <= j && j <= n);
            jj = qq_inv[j]; /* v[i,j] = u[ii,jj] */
            if (ii < k)
               xassert(jj > ii);
            else /* ii >= k */
            {  xassert(jj >= k);
               /* find v[i,j] in j-th column */
               j_ptr = vc_ptr[j];
               j_end = j_ptr + vc_len[j];
               for (; sv_ind[j_ptr] != i; j_ptr++)
                  /* nop */;
               xassert(j_ptr < j_end);
            }
            xassert(sv_val[i_ptr] != 0.0);
         }
      }
      /* check column-wise representation of matrix V */
      for (j = 1; j <= n; j++)
      {  /* j-th column of V = jj-th column of U */
         jj = qq_inv[j];
         if (jj < k)
            xassert(vc_len[j] == 0);
         else /* jj >= k */
         {  j_ptr = vc_ptr[j];
            j_end = j_ptr + vc_len[j];
            for (; j_ptr < j_end; j_ptr++)
            {  i = sv_ind[j_ptr];
               ii = pp_ind[i]; /* v[i,j] = u[ii,jj] */
               xassert(ii >= k);
               /* find v[i,j] in i-th row */
               i_ptr = vr_ptr[i];
               i_end = i_ptr + vr_len[i];
               for (; sv_ind[i_ptr] != j; i_ptr++)
                  /* nop */;
               xassert(i_ptr < i_end);
            }
         }
      }
      return;
}


void luf_build_v_rows(LUF *luf, int len[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int i, j, end, nnz, ptr, ptr1;
      /* calculate the number of non-zeros in each row of matrix V and
       * the total number of non-zeros */
      nnz = 0;
      for (i = 1; i <= n; i++)
         len[i] = 0;
      for (j = 1; j <= n; j++)
      {  nnz += vc_len[j];
         for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)
            len[sv_ind[ptr]]++;
      }
      /* we need at least nnz free locations in SVA */
      if (sva->r_ptr - sva->m_ptr < nnz)
      {  sva_more_space(sva, nnz);
         sv_ind = sva->ind;
         sv_val = sva->val;
      }
      /* reserve locations for rows of matrix V */
      for (i = 1; i <= n; i++)
      {  if (len[i] > 0)
            sva_enlarge_cap(sva, vr_ref-1+i, len[i], 0);
         vr_len[i] = len[i];
      }
      /* walk thru column of matrix V and build its rows */
      for (j = 1; j <= n; j++)
      {  for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)
         {  i = sv_ind[ptr];
            sv_ind[ptr1 = vr_ptr[i] + (--len[i])] = j;
            sv_val[ptr1] = sv_val[ptr];
         }
      }
      return;
}


void luf_build_f_rows(LUF *luf, int len[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int fr_ref = luf->fr_ref;
      int *fr_ptr = &sva->ptr[fr_ref-1];
      int *fr_len = &sva->len[fr_ref-1];
      int fc_ref = luf->fc_ref;
      int *fc_ptr = &sva->ptr[fc_ref-1];
      int *fc_len = &sva->len[fc_ref-1];
      int i, j, end, nnz, ptr, ptr1;
      /* calculate the number of non-zeros in each row of matrix F and
       * the total number of non-zeros (except diagonal elements) */
      nnz = 0;
      for (i = 1; i <= n; i++)
         len[i] = 0;
      for (j = 1; j <= n; j++)
      {  nnz += fc_len[j];
         for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)
            len[sv_ind[ptr]]++;
      }
      /* we need at least nnz free locations in SVA */
      if (sva->r_ptr - sva->m_ptr < nnz)
      {  sva_more_space(sva, nnz);
         sv_ind = sva->ind;
         sv_val = sva->val;
      }
      /* reserve locations for rows of matrix F */
      for (i = 1; i <= n; i++)
      {  if (len[i] > 0)
            sva_reserve_cap(sva, fr_ref-1+i, len[i]);
         fr_len[i] = len[i];
      }
      /* walk through columns of matrix F and build its rows */
      for (j = 1; j <= n; j++)
      {  for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)
         {  i = sv_ind[ptr];
            sv_ind[ptr1 = fr_ptr[i] + (--len[i])] = j;
            sv_val[ptr1] = sv_val[ptr];
         }
      }
      return;
}

void luf_build_v_cols(LUF *luf, int updat, int len[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int i, j, end, nnz, ptr, ptr1;
      /* calculate the number of non-zeros in each column of matrix V
       * and the total number of non-zeros (except pivot elements) */
      nnz = 0;
      for (j = 1; j <= n; j++)
         len[j] = 0;
      for (i = 1; i <= n; i++)
      {  nnz += vr_len[i];
         for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)
            len[sv_ind[ptr]]++;
      }
      /* we need at least nnz free locations in SVA */
      if (sva->r_ptr - sva->m_ptr < nnz)
      {  sva_more_space(sva, nnz);
         sv_ind = sva->ind;
         sv_val = sva->val;
      }
      /* reserve locations for columns of matrix V */
      for (j = 1; j <= n; j++)
      {  if (len[j] > 0)
         {  if (updat)
               sva_enlarge_cap(sva, vc_ref-1+j, len[j], 0);
            else
               sva_reserve_cap(sva, vc_ref-1+j, len[j]);
         }
         vc_len[j] = len[j];
      }
      /* walk through rows of matrix V and build its columns */
      for (i = 1; i <= n; i++)
      {  for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)
         {  j = sv_ind[ptr];
            sv_ind[ptr1 = vc_ptr[j] + (--len[j])] = i;
            sv_val[ptr1] = sv_val[ptr];
         }
      }
      return;
}


void luf_check_f_rc(LUF *luf)
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int fr_ref = luf->fr_ref;
      int *fr_ptr = &sva->ptr[fr_ref-1];
      int *fr_len = &sva->len[fr_ref-1];
      int fc_ref = luf->fc_ref;
      int *fc_ptr = &sva->ptr[fc_ref-1];
      int *fc_len = &sva->len[fc_ref-1];
      int i, i_end, i_ptr, j, j_end, j_ptr;
      /* walk thru rows of matrix F */
      for (i = 1; i <= n; i++)
      {  for (i_end = (i_ptr = fr_ptr[i]) + fr_len[i];
            i_ptr < i_end; i_ptr++)
         {  j = sv_ind[i_ptr];
            /* find element f[i,j] in j-th column of matrix F */
            for (j_end = (j_ptr = fc_ptr[j]) + fc_len[j];
               sv_ind[j_ptr] != i; j_ptr++)
               /* nop */;
            xassert(j_ptr < j_end);
            xassert(sv_val[i_ptr] == sv_val[j_ptr]);
            /* mark element f[i,j] */
            sv_ind[j_ptr] = -i;
         }
      }
      /* walk thru column of matix F and check that all elements has
         been marked */
      for (j = 1; j <= n; j++)
      {  for (j_end = (j_ptr = fc_ptr[j]) + fc_len[j];
            j_ptr < j_end; j_ptr++)
         {  xassert((i = sv_ind[j_ptr]) < 0);
            /* unmark element f[i,j] */
            sv_ind[j_ptr] = -i;
         }
      }
      return;
}


void luf_check_v_rc(LUF *luf)
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int i, i_end, i_ptr, j, j_end, j_ptr;
      /* walk thru rows of matrix V */
      for (i = 1; i <= n; i++)
      {  for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
            i_ptr < i_end; i_ptr++)
         {  j = sv_ind[i_ptr];
            /* find element v[i,j] in j-th column of matrix V */
            for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
               sv_ind[j_ptr] != i; j_ptr++)
               /* nop */;
            xassert(j_ptr < j_end);
            xassert(sv_val[i_ptr] == sv_val[j_ptr]);
            /* mark element v[i,j] */
            sv_ind[j_ptr] = -i;
         }
      }
      /* walk thru column of matix V and check that all elements has
         been marked */
      for (j = 1; j <= n; j++)
      {  for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
            j_ptr < j_end; j_ptr++)
         {  xassert((i = sv_ind[j_ptr]) < 0);
            /* unmark element v[i,j] */
            sv_ind[j_ptr] = -i;
         }
      }
      return;
}


void luf_f_solve(LUF *luf, double x[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int fc_ref = luf->fc_ref;
      int *fc_ptr = &sva->ptr[fc_ref-1];
      int *fc_len = &sva->len[fc_ref-1];
      int *pp_inv = luf->pp_inv;
      int j, k, ptr, end;
      double x_j;
      for (k = 1; k <= n; k++)
      {  /* k-th column of L = j-th column of F */
         j = pp_inv[k];
         /* x[j] is already computed */
         /* walk thru j-th column of matrix F and substitute x[j] into
          * other equations */
         if ((x_j = x[j]) != 0.0)
         {  for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)
               x[sv_ind[ptr]] -= sv_val[ptr] * x_j;
         }
      }
      return;
}


void luf_ft_solve(LUF *luf, double x[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int fr_ref = luf->fr_ref;
      int *fr_ptr = &sva->ptr[fr_ref-1];
      int *fr_len = &sva->len[fr_ref-1];
      int *pp_inv = luf->pp_inv;
      int i, k, ptr, end;
      double x_i;
      for (k = n; k >= 1; k--)
      {  /* k-th column of L' = i-th row of F */
         i = pp_inv[k];
         /* x[i] is already computed */
         /* walk thru i-th row of matrix F and substitute x[i] into
          * other equations */
         if ((x_i = x[i]) != 0.0)
         {  for (end = (ptr = fr_ptr[i]) + fr_len[i]; ptr < end; ptr++)
               x[sv_ind[ptr]] -= sv_val[ptr] * x_i;
         }
      }
      return;
}

void luf_v_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      double *vr_piv = luf->vr_piv;
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int *pp_inv = luf->pp_inv;
      int *qq_ind = luf->qq_ind;
      int i, j, k, ptr, end;
      double x_j;
      for (k = n; k >= 1; k--)
      {  /* k-th row of U = i-th row of V */
         /* k-th column of U = j-th column of V */
         i = pp_inv[k];
         j = qq_ind[k];
         /* compute x[j] = b[i] / u[k,k], where u[k,k] = v[i,j];
          * walk through j-th column of matrix V and substitute x[j]
          * into other equations */
         if ((x_j = x[j] = b[i] / vr_piv[i]) != 0.0)
         {  for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)
               b[sv_ind[ptr]] -= sv_val[ptr] * x_j;
         }
      }
      return;
}

void luf_vt_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      double *vr_piv = luf->vr_piv;
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int *pp_inv = luf->pp_inv;
      int *qq_ind = luf->qq_ind;
      int i, j, k, ptr, end;
      double x_i;
      for (k = 1; k <= n; k++)
      {  /* k-th row of U' = j-th column of V */
         /* k-th column of U' = i-th row of V */
         i = pp_inv[k];
         j = qq_ind[k];
         /* compute x[i] = b[j] / u'[k,k], where u'[k,k] = v[i,j];
          * walk through i-th row of matrix V and substitute x[i] into
          * other equations */
         if ((x_i = x[i] = b[j] / vr_piv[i]) != 0.0)
         {  for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)
               b[sv_ind[ptr]] -= sv_val[ptr] * x_i;
         }
      }
      return;
}

void luf_vt_solve1(LUF *luf, double e[/*1+n*/], double y[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      double *vr_piv = luf->vr_piv;
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int *pp_inv = luf->pp_inv;
      int *qq_ind = luf->qq_ind;
      int i, j, k, ptr, end;
      double e_j, y_i;
      for (k = 1; k <= n; k++)
      {  /* k-th row of U' = j-th column of V */
         /* k-th column of U' = i-th row of V */
         i = pp_inv[k];
         j = qq_ind[k];
         /* determine e'[j] = e[j] + delta e[j] */
         e_j = (e[j] >= 0.0 ? e[j] + 1.0 : e[j] - 1.0);
         /* compute y[i] = e'[j] / u'[k,k], where u'[k,k] = v[i,j] */
         y_i = y[i] = e_j / vr_piv[i];
         /* walk through i-th row of matrix V and substitute y[i] into
          * other equations */
         for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)
            e[sv_ind[ptr]] -= sv_val[ptr] * y_i;
      }
      return;
}

double luf_estimate_norm(LUF *luf, double w1[/*1+n*/], double
      w2[/*1+n*/])
{     int n = luf->n;
      double *e = w1;
      double *y = w2;
      double *z = w1;
      int i;
      double y_norm, z_norm;
      /* y = inv(A') * e = inv(F') * inv(V') * e */
      /* compute y' = inv(V') * e to cause growth in y' */
      for (i = 1; i <= n; i++)
         e[i] = 0.0;
      luf_vt_solve1(luf, e, y);
      /* compute y = inv(F') * y' */
      luf_ft_solve(luf, y);
      /* compute 1-norm of y = sum |y[i]| */
      y_norm = 0.0;
      for (i = 1; i <= n; i++)
         y_norm += (y[i] >= 0.0 ? +y[i] : -y[i]);
      /* z = inv(A) * y = inv(V) * inv(F) * y */
      /* compute z' = inv(F) * y */
      luf_f_solve(luf, y);
      /* compute z = inv(V) * z' */
      luf_v_solve(luf, y, z);
      /* compute 1-norm of z = sum |z[i]| */
      z_norm = 0.0;
      for (i = 1; i <= n; i++)
         z_norm += (z[i] >= 0.0 ? +z[i] : -z[i]);
      /* estimate 1-norm of inv(A) = (1-norm of z) / (1-norm of y) */
      return z_norm / y_norm;
}



typedef struct SGF SGF;

struct SGF
{     /* sparse Gaussian factorizer workspace */
      LUF *luf;
      /* LU-factorization being computed */
      /*--------------------------------------------------------------*/
      /* to efficiently choose pivot elements according to Markowitz
       * strategy, the search technique proposed by Iain Duff is used;
       * it is based on using two families of sets {R[0], ..., R[n]}
       * and {C[0], ..., C[n]}, where R[k] and C[k], 0 <= k <= n, are,
       * respectively, sets of rows and columns of the active submatrix
       * of matrix V having k non-zeros (i.e. whose length is k); each
       * set R[k] and C[k] is implemented as a doubly linked list */
      int *rs_head; /* int rs_head[1+n]; */
      /* rs_head[k], 0 <= k <= n, is the number of first row, which
       * has k non-zeros in the active submatrix */
      int *rs_prev; /* int rs_prev[1+n]; */
      /* rs_prev[0] is not used;
       * rs_prev[i], 1 <= i <= n, is the number of previous row, which
       * has the same number of non-zeros as i-th row;
       * rs_prev[i] < 0 means that i-th row is inactive */
      int *rs_next; /* int rs_next[1+n]; */
      /* rs_next[0] is not used;
       * rs_next[i], 1 <= i <= n, is the number of next row, which has
       * the same number of non-zeros as i-th row;
       * rs_next[i] < 0 means that i-th row is inactive */
      int *cs_head; /* int cs_head[1+n]; */
      /* cs_head[k], 0 <= k <= n, is the number of first column, which
       * has k non-zeros in the active submatrix */
      int *cs_prev; /* int cs_prev[1+n]; */
      /* cs_prev[0] is not used;
       * cs_prev[j], 1 <= j <= n, is the number of previous column,
       * which has the same number of non-zeros as j-th column;
       * cs_prev[j] < 0 means that j-th column is inactive */
      int *cs_next; /* int cs_next[1+n]; */
      /* cs_next[0] is not used;
       * cs_next[j], 1 <= j <= n, is the number of next column, which
       * has the same number of non-zeros as j-th column;
       * cs_next[j] < 0 means that j-th column is inactive */
      /* NOTE: cs_prev[j] = cs_next[j] = j means that j-th column was
       *       temporarily removed from corresponding set C[k] by the
       *       pivoting routine according to Uwe Suhl's heuristic */
      /*--------------------------------------------------------------*/
      /* working arrays */
      double *vr_max; /* int vr_max[1+n]; */
      /* vr_max[0] is not used;
       * vr_max[i], 1 <= i <= n, is used only if i-th row of matrix V
       * is active (i.e. belongs to the active submatrix), and is the
       * largest magnitude of elements in that row; if vr_max[i] < 0,
       * the largest magnitude is unknown yet */
      char *flag; /* char flag[1+n]; */
      /* boolean working array */
      double *work; /* double work[1+n]; */
      /* floating-point working array */
      /*--------------------------------------------------------------*/
      /* control parameters */
      int updat;
      /* if this flag is set, the matrix V is assumed to be updatable;
       * in this case factorized (non-active) part of V is stored in
       * the left part of SVA rather than in its right part */
      double piv_tol;
      /* threshold pivoting tolerance, 0 < piv_tol < 1; element v[i,j]
       * of the active submatrix fits to be pivot if it satisfies to
       * the stability criterion |v[i,j]| >= piv_tol * max |v[i,*]|,
       * i.e. if it is not very small in the magnitude among other
       * elements in the same row; decreasing this parameter gives
       * better sparsity at the expense of numerical accuracy and vice
       * versa */
      int piv_lim;
      /* maximal allowable number of pivot candidates to be considered;
       * if piv_lim pivot candidates have been considered, the pivoting
       * routine terminates the search with the best candidate found */
      int suhl;
      /* if this flag is set, the pivoting routine applies a heuristic
       * proposed by Uwe Suhl: if a column of the active submatrix has
       * no eligible pivot candidates (i.e. all its elements do not
       * satisfy to the stability criterion), the routine excludes it
       * from futher consideration until it becomes column singleton;
       * in many cases this allows reducing the time needed to choose
       * the pivot */
      double eps_tol;
      /* epsilon tolerance; each element of the active submatrix, whose
       * magnitude is less than eps_tol, is replaced by exact zero */
#if 0 /* FIXME */
      double den_lim;
      /* density limit; if the density of the active submatrix reaches
       * this limit, the factorization routine switches from sparse to
       * dense mode */
#endif
};

#define sgf_activate_row(i) \
      do \
      {  int len = vr_len[i]; \
         rs_prev[i] = 0; \
         rs_next[i] = rs_head[len]; \
         if (rs_next[i] != 0) \
            rs_prev[rs_next[i]] = i; \
         rs_head[len] = i; \
      } while (0)
/* include i-th row of matrix V in active set R[len] */

#define sgf_deactivate_row(i) \
      do \
      {  if (rs_prev[i] == 0) \
            rs_head[vr_len[i]] = rs_next[i]; \
         else \
            rs_next[rs_prev[i]] = rs_next[i]; \
         if (rs_next[i] == 0) \
            ; \
         else \
            rs_prev[rs_next[i]] = rs_prev[i]; \
         rs_prev[i] = rs_next[i] = -1; \
      } while (0)
/* remove i-th row of matrix V from active set R[len] */

#define sgf_activate_col(j) \
      do \
      {  int len = vc_len[j]; \
         cs_prev[j] = 0; \
         cs_next[j] = cs_head[len]; \
         if (cs_next[j] != 0) \
            cs_prev[cs_next[j]] = j; \
         cs_head[len] = j; \
      } while (0)
/* include j-th column of matrix V in active set C[len] */

#define sgf_deactivate_col(j) \
      do \
      {  if (cs_prev[j] == 0) \
            cs_head[vc_len[j]] = cs_next[j]; \
         else \
            cs_next[cs_prev[j]] = cs_next[j]; \
         if (cs_next[j] == 0) \
            ; \
         else \
            cs_prev[cs_next[j]] = cs_prev[j]; \
         cs_prev[j] = cs_next[j] = -1; \
      } while (0)
/* remove j-th column of matrix V from active set C[len] */

#define sgf_reduce_nuc _glp_sgf_reduce_nuc
int sgf_reduce_nuc(LUF *luf, int *k1, int *k2, int cnt[/*1+n*/],
      int list[/*1+n*/]);
/* initial reordering to minimize nucleus size */

#define sgf_singl_phase _glp_sgf_singl_phase
int sgf_singl_phase(LUF *luf, int k1, int k2, int updat,
      int ind[/*1+n*/], double val[/*1+n*/]);
/* compute LU-factorization (singleton phase) */

#define sgf_choose_pivot _glp_sgf_choose_pivot
int sgf_choose_pivot(SGF *sgf, int *p, int *q);
/* choose pivot element v[p,q] */

#define sgf_eliminate _glp_sgf_eliminate
int sgf_eliminate(SGF *sgf, int p, int q);
/* perform gaussian elimination */

#define sgf_dense_lu _glp_sgf_dense_lu
int sgf_dense_lu(int n, double a[], int r[], int c[], double eps);
/* compute dense LU-factorization with full pivoting */

#define sgf_dense_phase _glp_sgf_dense_phase
int sgf_dense_phase(LUF *luf, int k, int updat);
/* compute LU-factorization (dense phase) */

#define sgf_factorize _glp_sgf_factorize
int sgf_factorize(SGF *sgf, int singl);
/* compute LU-factorization (main routine) */


int sgf_reduce_nuc(LUF *luf, int *k1_, int *k2_, int cnt[/*1+n*/],
      int list[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int *pp_ind = luf->pp_ind;
      int *pp_inv = luf->pp_inv;
      int *qq_ind = luf->qq_ind;
      int *qq_inv = luf->qq_inv;
      int i, ii, j, jj, k1, k2, ns, ptr, end;
      /* initial nucleus is U = V = A */
      k1 = 1, k2 = n;
      /*--------------------------------------------------------------*/
      /* process column singletons                                    */
      /*--------------------------------------------------------------*/
      /* determine initial counts of columns of V and initialize list
       * of active column singletons */
      ns = 0; /* number of active column singletons */
      for (j = 1; j <= n; j++)
      {  if ((cnt[j] = vc_len[j]) == 1)
            list[++ns] = j;
      }
      /* process active column singletons */
      while (ns > 0)
      {  /* column singleton is in j-th column of V */
         j = list[ns--];
#if 1 /* 21/II-2016 */
         if (cnt[j] == 0)
         {  /* j-th column in the current nucleus is actually empty */
            /* this happened because on a previous step in the nucleus
             * there were two or more identical column singletons (that
             * means structural singularity), so removing one of them
             * from the nucleus made other columns empty */
            return 1;
         }
#endif
         /* find i-th row of V containing column singleton */
         ptr = vc_ptr[j];
         end = ptr + vc_len[j];
         for (; pp_ind[i = sv_ind[ptr]] < k1; ptr++)
            /* nop */;
         xassert(ptr < end);
         /* permute rows and columns of U to move column singleton to
          * position u[k1,k1] */
         ii = pp_ind[i];
         luf_swap_u_rows(k1, ii);
         jj = qq_inv[j];
         luf_swap_u_cols(k1, jj);
         /* nucleus size decreased */
         k1++;
         /* walk thru i-th row of V and decrease column counts; this
          * may cause new column singletons to appear */
         ptr = vr_ptr[i];
         end = ptr + vr_len[i];
         for (; ptr < end; ptr++)
         {  if (--(cnt[j = sv_ind[ptr]]) == 1)
               list[++ns] = j;
         }
      }
      /* nucleus begins at k1-th row/column of U */
      if (k1 > n)
      {  /* U is upper triangular; no nucleus exist */
         goto done;
      }
      /*--------------------------------------------------------------*/
      /* process row singletons                                       */
      /*--------------------------------------------------------------*/
      /* determine initial counts of rows of V and initialize list of
       * active row singletons */
      ns = 0; /* number of active row singletons */
      for (i = 1; i <= n; i++)
      {  if (pp_ind[i] < k1)
         {  /* corresponding row of U is above its k1-th row; set its
             * count to zero to prevent including it in active list */
            cnt[i] = 0;
         }
         else if ((cnt[i] = vr_len[i]) == 1)
            list[++ns] = i;
      }
      /* process active row singletons */
      while (ns > 0)
      {  /* row singleton is in i-th row of V */
         i = list[ns--];
#if 1 /* 21/II-2016 */
         if (cnt[i] == 0)
         {  /* i-th row in the current nucleus is actually empty */
            /* (see comments above for similar case of empty column) */
            return 2;
         }
#endif
         /* find j-th column of V containing row singleton */
         ptr = vr_ptr[i];
         end = ptr + vr_len[i];
         for (; qq_inv[j = sv_ind[ptr]] > k2; ptr++)
            /* nop */;
         xassert(ptr < end);
         /* permute rows and columns of U to move row singleton to
          * position u[k2,k2] */
         ii = pp_ind[i];
         luf_swap_u_rows(k2, ii);
         jj = qq_inv[j];
         luf_swap_u_cols(k2, jj);
         /* nucleus size decreased */
         k2--;
         /* walk thru j-th column of V and decrease row counts; this
          * may cause new row singletons to appear */
         ptr = vc_ptr[j];
         end = ptr + vc_len[j];
         for (; ptr < end; ptr++)
         {  if (--(cnt[i = sv_ind[ptr]]) == 1)
               list[++ns] = i;
         }
      }
      /* nucleus ends at k2-th row/column of U */
      xassert(k1 < k2);
done: *k1_ = k1, *k2_ = k2;
      return 0;
}

int sgf_singl_phase(LUF *luf, int k1, int k2, int updat,
      int ind[/*1+n*/], double val[/*1+n*/])
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int fc_ref = luf->fc_ref;
      int *fc_ptr = &sva->ptr[fc_ref-1];
      int *fc_len = &sva->len[fc_ref-1];
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      double *vr_piv = luf->vr_piv;
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int *pp_ind = luf->pp_ind;
      int *pp_inv = luf->pp_inv;
      int *qq_ind = luf->qq_ind;
      int *qq_inv = luf->qq_inv;
      int i, j, k, ptr, ptr1, end, len;
      double piv;
      /* (see routine sgf_reduce_nuc) */
      xassert((1 <= k1 && k1 < k2 && k2 <= n)
         || (k1 == n+1 && k2 == n));
      /* perform symmetric permutations of rows/columns of U */
      for (k = k1; k <= k2; k++)
         pp_ind[pp_inv[k]] = qq_inv[qq_ind[k]] = k - k2 + n;
      for (k = k2+1; k <= n; k++)
         pp_ind[pp_inv[k]] = qq_inv[qq_ind[k]] = n - k + k1;
      for (k = 1; k <= n; k++)
         pp_inv[pp_ind[k]] = qq_ind[qq_inv[k]] = k;
      /* determine k2' */
      k2 = n - k2 + k1;
      /* process rows and columns of V corresponding to rows and
       * columns 1, ..., k1-1 of U */
      for (k = 1; k < k1; k++)
      {  /* k-th row of U = i-th row of V */
         i = pp_inv[k];
         /* find pivot u[k,k] = v[i,j] in i-th row of V */
         ptr = vr_ptr[i];
         end = ptr + vr_len[i];
         for (; qq_inv[sv_ind[ptr]] != k; ptr++)
            /* nop */;
         xassert(ptr < end);
         /* store pivot */
         vr_piv[i] = sv_val[ptr];
         /* and remove it from i-th row of V */
         sv_ind[ptr] = sv_ind[end-1];
         sv_val[ptr] = sv_val[end-1];
         vr_len[i]--;
         /* clear column of V corresponding to k-th column of U */
         vc_len[qq_ind[k]] = 0;
      }
      /* clear rows of V corresponding to rows k1, ..., k2'-1 of U */
      for (k = k1; k < k2; k++)
         vr_len[pp_inv[k]] = 0;
      /* process rows and columns of V corresponding to rows and
       * columns k2', ..., n of U */
      for (k = k2; k <= n; k++)
      {  /* k-th row of U = i-th row of V */
         i = pp_inv[k];
         /* remove elements from i-th row of V that correspond to
          * elements u[k,k1], ..., u[k,k2'-1] */
         ptr = ptr1 = vr_ptr[i];
         end = ptr + vr_len[i];
         for (; ptr < end; ptr++)
         {  if (qq_inv[sv_ind[ptr]] >= k2)
            {  sv_ind[ptr1] = sv_ind[ptr];
               sv_val[ptr1] = sv_val[ptr];
               ptr1++;
            }
         }
         vr_len[i] = ptr1 - vr_ptr[i];
         /* k-th column of U = j-th column of V */
         j = qq_ind[k];
         /* remove elements from j-th column of V that correspond to
          * elements u[1,k], ..., u[k1-1,k] */
         ptr = ptr1 = vc_ptr[j];
         end = ptr + vc_len[j];
         for (; ptr < end; ptr++)
         {  if (pp_ind[sv_ind[ptr]] >= k2)
               /* element value is not needed in this case */
               sv_ind[ptr1++] = sv_ind[ptr];
         }
         vc_len[j] = ptr1 - vc_ptr[j];
      }
      /* process columns of V corresponding to columns k1, ..., k2'-1
       * of U, build columns of F */
      for (k = k1; k < k2; k++)
      {  /* k-th column of U = j-th column of V */
         j = qq_ind[k];
         /* remove elements from j-th column of V that correspond to
          * pivot (diagonal) element u[k,k] and subdiagonal elements
          * u[k+1,k], ..., u[n,k]; subdiagonal elements are stored for
          * further addition to matrix F */
         len = 0;
         piv = 0.0;
         ptr = vc_ptr[j];
         end = ptr + vc_len[j];
         for (; ptr < end; ptr++)
         {  i = sv_ind[ptr]; /* v[i,j] */
            if (pp_ind[i] == k)
            {  /* store pivot v[i,j] = u[k,k] */
               piv = vr_piv[i] = sv_val[ptr];
            }
            else if (pp_ind[i] > k)
            {  /* store subdiagonal element v[i,j] = u[i',k] */
               len++;
               ind[len] = i;
               val[len] = sv_val[ptr];
            }
         }
         /* clear j-th column of V = k-th column of U */
         vc_len[j] = 0;
         /* build k-th column of L = j-th column of F */
         j = pp_inv[k];
         xassert(piv != 0.0);
         if (len > 0)
         {  if (sva->r_ptr - sva->m_ptr < len)
            {  sva_more_space(sva, len);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_reserve_cap(sva, fc_ref-1+j, len);
            for (ptr = fc_ptr[j], ptr1 = 1; ptr1 <= len; ptr++, ptr1++)
            {  sv_ind[ptr] = ind[ptr1];
               sv_val[ptr] = val[ptr1] / piv;
            }
            fc_len[j] = len;
         }
      }
      /* if it is not planned to update matrix V, relocate all its
       * non-active rows corresponding to rows 1, ..., k2'-1 of U to
       * the right (static) part of SVA */
      if (!updat)
      {  for (k = 1; k < k2; k++)
         {  i = pp_inv[k];
            len = vr_len[i];
            if (sva->r_ptr - sva->m_ptr < len)
            {  sva_more_space(sva, len);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_make_static(sva, vr_ref-1+i);
         }
      }
      /* elimination steps 1, ..., k2'-1 have been performed */
      return k2;
}

int sgf_choose_pivot(SGF *sgf, int *p_, int *q_)
{     LUF *luf = sgf->luf;
      int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int *rs_head = sgf->rs_head;
      int *rs_next = sgf->rs_next;
      int *cs_head = sgf->cs_head;
      int *cs_prev = sgf->cs_prev;
      int *cs_next = sgf->cs_next;
      double *vr_max = sgf->vr_max;
      double piv_tol = sgf->piv_tol;
      int piv_lim = sgf->piv_lim;
      int suhl = sgf->suhl;
      int i, i_ptr, i_end, j, j_ptr, j_end, len, min_i, min_j, min_len,
         ncand, next_j, p, q;
      double best, big, cost, temp;
      /* no pivot candidate has been chosen so far */
      p = q = 0, best = DBL_MAX, ncand = 0;
      /* if the active submatrix contains a column having the only
       * non-zero element (column singleton), choose it as the pivot */
      j = cs_head[1];
      if (j != 0)
      {  xassert(vc_len[j] == 1);
         p = sv_ind[vc_ptr[j]], q = j;
         goto done;
      }
      /* if the active submatrix contains a row having the only
       * non-zero element (row singleton), choose it as the pivot */
      i = rs_head[1];
      if (i != 0)
      {  xassert(vr_len[i] == 1);
         p = i, q = sv_ind[vr_ptr[i]];
         goto done;
      }
      /* the active submatrix contains no singletons; walk thru its
       * other non-empty rows and columns */
      for (len = 2; len <= n; len++)
      {  /* consider active columns containing len non-zeros */
         for (j = cs_head[len]; j != 0; j = next_j)
         {  /* save the number of next column of the same length */
            next_j = cs_next[j];
            /* find an element in j-th column, which is placed in the
             * row with minimal number of non-zeros and satisfies to
             * the stability condition (such element may not exist) */
            min_i = min_j = 0, min_len = INT_MAX;
            for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
               j_ptr < j_end; j_ptr++)
            {  /* get row index of v[i,j] */
               i = sv_ind[j_ptr];
               /* if i-th row is not shorter, skip v[i,j] */
               if (vr_len[i] >= min_len)
                  continue;
               /* big := max|v[i,*]| */
               if ((big = vr_max[i]) < 0.0)
               {  /* largest magnitude is unknown; compute it */
                  for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
                     i_ptr < i_end; i_ptr++)
                  {  if ((temp = sv_val[i_ptr]) < 0.0)
                        temp = -temp;
                     if (big < temp)
                        big = temp;
                  }
                  xassert(big > 0.0);
                  vr_max[i] = big;
               }
               /* find v[i,j] in i-th row */
               for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
                  sv_ind[i_ptr] != j; i_ptr++)
                  /* nop */;
               xassert(i_ptr < i_end);
               /* if |v[i,j]| < piv_tol * max|v[i,*]|, skip v[i,j] */
               if ((temp = sv_val[i_ptr]) < 0.0)
                  temp = -temp;
               if (temp < piv_tol * big)
                  continue;
               /* v[i,j] is a better candidate */
               min_i = i, min_j = j, min_len = vr_len[i];
               /* if Markowitz cost of v[i,j] is not greater than
                * (len-1)**2, v[i,j] can be chosen as the pivot right
                * now; this heuristic reduces the search and works well
                * in many cases */
               if (min_len <= len)
               {  p = min_i, q = min_j;
                  goto done;
               }
            }
            /* j-th column has been scanned */
            if (min_i != 0)
            {  /* element v[min_i,min_j] is a next pivot candidate */
               ncand++;
               /* compute its Markowitz cost */
               cost = (double)(min_len - 1) * (double)(len - 1);
               /* if this element is better, choose it as the pivot */
               if (cost < best)
                  p = min_i, q = min_j, best = cost;
               /* if piv_lim candidates were considered, terminate
                * the search, because it is doubtful that a much better
                * candidate will be found */
               if (ncand == piv_lim)
                  goto done;
            }
            else if (suhl)
            {  /* j-th column has no eligible elements that satisfy to
                * the stability criterion; Uwe Suhl suggests to exclude
                * such column from further considerations until it
                * becomes a column singleton; in hard cases this may
                * significantly reduce the time needed to choose the
                * pivot element */
               sgf_deactivate_col(j);
               cs_prev[j] = cs_next[j] = j;
            }
         }
         /* consider active rows containing len non-zeros */
         for (i = rs_head[len]; i != 0; i = rs_next[i])
         {  /* big := max|v[i,*]| */
            if ((big = vr_max[i]) < 0.0)
            {  /* largest magnitude is unknown; compute it */
               for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
                  i_ptr < i_end; i_ptr++)
               {  if ((temp = sv_val[i_ptr]) < 0.0)
                     temp = -temp;
                  if (big < temp)
                     big = temp;
               }
               xassert(big > 0.0);
               vr_max[i] = big;
            }
            /* find an element in i-th row, which is placed in the
             * column with minimal number of non-zeros and satisfies to
             * the stability condition (such element always exists) */
            min_i = min_j = 0, min_len = INT_MAX;
            for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
               i_ptr < i_end; i_ptr++)
            {  /* get column index of v[i,j] */
               j = sv_ind[i_ptr];
               /* if j-th column is not shorter, skip v[i,j] */
               if (vc_len[j] >= min_len)
                  continue;
               /* if |v[i,j]| < piv_tol * max|v[i,*]|, skip v[i,j] */
               if ((temp = sv_val[i_ptr]) < 0.0)
                  temp = -temp;
               if (temp < piv_tol * big)
                  continue;
               /* v[i,j] is a better candidate */
               min_i = i, min_j = j, min_len = vc_len[j];
               /* if Markowitz cost of v[i,j] is not greater than
                * (len-1)**2, v[i,j] can be chosen as the pivot right
                * now; this heuristic reduces the search and works well
                * in many cases */
               if (min_len <= len)
               {  p = min_i, q = min_j;
                  goto done;
               }
            }
            /* i-th row has been scanned */
            if (min_i != 0)
            {  /* element v[min_i,min_j] is a next pivot candidate */
               ncand++;
               /* compute its Markowitz cost */
               cost = (double)(len - 1) * (double)(min_len - 1);
               /* if this element is better, choose it as the pivot */
               if (cost < best)
                  p = min_i, q = min_j, best = cost;
               /* if piv_lim candidates were considered, terminate
                * the search, because it is doubtful that a much better
                * candidate will be found */
               if (ncand == piv_lim)
                  goto done;
            }
            else
            {  /* this can never be */
               xassert(min_i != min_i);
            }
         }
      }
done: /* report the pivot to the factorization routine */
      *p_ = p, *q_ = q;
      return (p == 0);
}


int sgf_eliminate(SGF *sgf, int p, int q)
{     LUF *luf = sgf->luf;
      int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int fc_ref = luf->fc_ref;
      int *fc_ptr = &sva->ptr[fc_ref-1];
      int *fc_len = &sva->len[fc_ref-1];
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int *vr_cap = &sva->cap[vr_ref-1];
      double *vr_piv = luf->vr_piv;
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int *vc_cap = &sva->cap[vc_ref-1];
      int *rs_head = sgf->rs_head;
      int *rs_prev = sgf->rs_prev;
      int *rs_next = sgf->rs_next;
      int *cs_head = sgf->cs_head;
      int *cs_prev = sgf->cs_prev;
      int *cs_next = sgf->cs_next;
      double *vr_max = sgf->vr_max;
      char *flag = sgf->flag;
      double *work = sgf->work;
      double eps_tol = sgf->eps_tol;
      int nnz_diff = 0;
      int fill, i, i_ptr, i_end, j, j_ptr, j_end, ptr, len, loc, loc1;
      double vpq, fip, vij;
      xassert(1 <= p && p <= n);
      xassert(1 <= q && q <= n);
      /* remove p-th row from the active set; this row will never
       * return there */
      sgf_deactivate_row(p);
      /* process p-th (pivot) row */
      ptr = 0;
      for (i_end = (i_ptr = vr_ptr[p]) + vr_len[p];
         i_ptr < i_end; i_ptr++)
      {  /* get column index of v[p,j] */
         j = sv_ind[i_ptr];
         if (j == q)
         {  /* save pointer to pivot v[p,q] */
            ptr = i_ptr;
         }
         else
         {  /* store v[p,j], j != q, to working array */
            flag[j] = 1;
            work[j] = sv_val[i_ptr];
         }
         /* remove j-th column from the active set; q-th column will
          * never return there while other columns will return to the
          * active set with new length */
         if (cs_next[j] == j)
         {  /* j-th column was marked by the pivoting routine according
             * to Uwe Suhl's suggestion and is already inactive */
            xassert(cs_prev[j] == j);
         }
         else
            sgf_deactivate_col(j);
         nnz_diff -= vc_len[j];
         /* find and remove v[p,j] from j-th column */
         for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
            sv_ind[j_ptr] != p; j_ptr++)
            /* nop */;
         xassert(j_ptr < j_end);
         sv_ind[j_ptr] = sv_ind[j_end-1];
         vc_len[j]--;
      }
      /* save pivot v[p,q] and remove it from p-th row */
      xassert(ptr > 0);
      vpq = vr_piv[p] = sv_val[ptr];
      sv_ind[ptr] = sv_ind[i_end-1];
      sv_val[ptr] = sv_val[i_end-1];
      vr_len[p]--;
      /* if it is not planned to update matrix V, relocate p-th row to
       * the right (static) part of SVA */
      if (!sgf->updat)
      {  len = vr_len[p];
         if (sva->r_ptr - sva->m_ptr < len)
         {  sva_more_space(sva, len);
            sv_ind = sva->ind;
            sv_val = sva->val;
         }
         sva_make_static(sva, vr_ref-1+p);
      }
      /* copy the pattern (row indices) of q-th column of the active
       * submatrix (from which v[p,q] has been just removed) to p-th
       * column of matrix F (without unity diagonal element) */
      len = vc_len[q];
      if (len > 0)
      {  if (sva->r_ptr - sva->m_ptr < len)
         {  sva_more_space(sva, len);
            sv_ind = sva->ind;
            sv_val = sva->val;
         }
         sva_reserve_cap(sva, fc_ref-1+p, len);
         memcpy(&sv_ind[fc_ptr[p]], &sv_ind[vc_ptr[q]],
            len * sizeof(int));
         fc_len[p] = len;
      }
      /* make q-th column of the active submatrix empty */
      vc_len[q] = 0;
      /* transform non-pivot rows of the active submatrix */
      for (loc = fc_len[p]-1; loc >= 0; loc--)
      {  /* get row index of v[i,q] = row index of f[i,p] */
         i = sv_ind[fc_ptr[p] + loc];
         xassert(i != p); /* v[p,q] was removed */
         /* remove i-th row from the active set; this row will return
          * there with new length */
         sgf_deactivate_row(i);
         /* find v[i,q] in i-th row */
         for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
            sv_ind[i_ptr] != q; i_ptr++)
            /* nop */;
         xassert(i_ptr < i_end);
         /* compute gaussian multiplier f[i,p] = v[i,q] / v[p,q] */
         fip = sv_val[fc_ptr[p] + loc] = sv_val[i_ptr] / vpq;
         /* remove v[i,q] from i-th row */
         sv_ind[i_ptr] = sv_ind[i_end-1];
         sv_val[i_ptr] = sv_val[i_end-1];
         vr_len[i]--;
         /* perform elementary gaussian transformation:
          * (i-th row) := (i-th row) - f[i,p] * (p-th row)
          * note that p-th row of V, which is in the working array,
          * doesn't contain pivot v[p,q], and i-th row of V doesn't
          * contain v[i,q] to be eliminated */
         /* walk thru i-th row and transform existing elements */
         fill = vr_len[p];
         for (i_end = (i_ptr = ptr = vr_ptr[i]) + vr_len[i];
            i_ptr < i_end; i_ptr++)
         {  /* get column index and value of v[i,j] */
            j = sv_ind[i_ptr];
            vij = sv_val[i_ptr];
            if (flag[j])
            {  /* v[p,j] != 0 */
               flag[j] = 0, fill--;
               /* v[i,j] := v[i,j] - f[i,p] * v[p,j] */
               vij -= fip * work[j];
               if (-eps_tol < vij && vij < +eps_tol)
               {  /* new v[i,j] is close to zero; remove it from the
                   * active submatrix, i.e. replace it by exact zero */
                  /* find and remove v[i,j] from j-th column */
                  for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
                     sv_ind[j_ptr] != i; j_ptr++)
                     /* nop */;
                  xassert(j_ptr < j_end);
                  sv_ind[j_ptr] = sv_ind[j_end-1];
                  vc_len[j]--;
                  continue;
               }
            }
            /* keep new v[i,j] in i-th row */
            sv_ind[ptr] = j;
            sv_val[ptr] = vij;
            ptr++;
         }
         /* (new length of i-th row may decrease because of numerical
          * cancellation) */
         vr_len[i] = len = ptr - vr_ptr[i];
         /* now flag[*] is the pattern of the set v[p,*] \ v[i,*], and
          * fill is the number of non-zeros in this set */
         if (fill == 0)
         {  /* no fill-in occurs */
            /* walk thru p-th row and restore the column flags */
            for (i_end = (i_ptr = vr_ptr[p]) + vr_len[p];
               i_ptr < i_end; i_ptr++)
               flag[sv_ind[i_ptr]] = 1; /* v[p,j] != 0 */
            goto skip;
         }
         /* up to fill new non-zero elements may appear in i-th row due
          * to fill-in; reserve locations for these elements (note that
          * actual length of i-th row is currently stored in len) */
         if (vr_cap[i] < len + fill)
         {  if (sva->r_ptr - sva->m_ptr < len + fill)
            {  sva_more_space(sva, len + fill);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_enlarge_cap(sva, vr_ref-1+i, len + fill, 0);
         }
         vr_len[i] += fill;
         /* walk thru p-th row and add new elements to i-th row */
         for (loc1 = vr_len[p]-1; loc1 >= 0; loc1--)
         {  /* get column index of v[p,j] */
            j = sv_ind[vr_ptr[p] + loc1];
            if (!flag[j])
            {  /* restore j-th column flag */
               flag[j] = 1;
               /* v[i,j] was computed earlier on transforming existing
                * elements of i-th row */
               continue;
            }
            /* v[i,j] := 0 - f[i,p] * v[p,j] */
            vij = - fip * work[j];
            if (-eps_tol < vij && vij < +eps_tol)
            {  /* new v[i,j] is close to zero; do not add it to the
                * active submatrix, i.e. replace it by exact zero */
               continue;
            }
            /* add new v[i,j] to i-th row */
            sv_ind[ptr = vr_ptr[i] + (len++)] = j;
            sv_val[ptr] = vij;
            /* add new v[i,j] to j-th column */
            if (vc_cap[j] == vc_len[j])
            {  /* we reserve extra locations in j-th column to reduce
                * further relocations of that column */
#if 1 /* FIXME */
               /* use control parameter to specify the number of extra
                * locations reserved */
               int need = vc_len[j] + 10;
#endif
               if (sva->r_ptr - sva->m_ptr < need)
               {  sva_more_space(sva, need);
                  sv_ind = sva->ind;
                  sv_val = sva->val;
               }
               sva_enlarge_cap(sva, vc_ref-1+j, need, 1);
            }
            sv_ind[vc_ptr[j] + (vc_len[j]++)] = i;
         }
         /* set final length of i-th row just transformed */
         xassert(len <= vr_len[i]);
         vr_len[i] = len;
skip:    /* return i-th row to the active set with new length */
         sgf_activate_row(i);
         /* since i-th row has been changed, largest magnitude of its
          * elements becomes unknown */
         vr_max[i] = -1.0;
      }
      /* walk thru p-th (pivot) row */
      for (i_end = (i_ptr = vr_ptr[p]) + vr_len[p];
         i_ptr < i_end; i_ptr++)
      {  /* get column index of v[p,j] */
         j = sv_ind[i_ptr];
         xassert(j != q); /* v[p,q] was removed */
         /* return j-th column to the active set with new length */
         if (cs_next[j] == j && vc_len[j] != 1)
         {  /* j-th column was marked by the pivoting routine and it is
             * still not a column singleton, so leave it incative */
            xassert(cs_prev[j] == j);
         }
         else
            sgf_activate_col(j);
         nnz_diff += vc_len[j];
         /* restore zero content of the working arrays */
         flag[j] = 0;
         work[j] = 0.0;
      }
      /* return the difference between the numbers of non-zeros in the
       * active submatrix on entry and on exit, resp. */
      return nnz_diff;
}

int sgf_dense_lu(int n, double a_[], int r[], int c[], double eps)
{     /* non-optimized version */
      int i, j, k, p, q, ref;
      double akk, big, temp;
#     define a(i,j) a_[(i)*n+(j)]
      /* initially U = A, L = P = Q = I */
      /* main elimination loop */
      for (k = 0; k < n; k++)
      {  /* choose pivot u[p,q], k <= p, q <= n */
         p = q = -1, big = eps;
         for (i = k; i < n; i++)
         {  for (j = k; j < n; j++)
            {  /* temp = |u[i,j]| */
               if ((temp = a(i,j)) < 0.0)
                  temp = -temp;
               if (big < temp)
                  p = i, q = j, big = temp;
            }
         }
         if (p < 0)
         {  /* k-th elimination step failed */
            return k+1;
         }
         /* permute rows k and p */
         if (k != p)
         {  for (j = 0; j < n; j++)
               temp = a(k,j), a(k,j) = a(p,j), a(p,j) = temp;
            ref = r[k], r[k] = r[p], r[p] = ref;
         }
         /* permute columns k and q */
         if (k != q)
         {  for (i = 0; i < n; i++)
               temp = a(i,k), a(i,k) = a(i,q), a(i,q) = temp;
            ref = c[k], c[k] = c[q], c[q] = ref;
         }
         /* now pivot is in position u[k,k] */
         akk = a(k,k);
         /* eliminate subdiagonal elements u[k+1,k], ..., u[n,k] */
         for (i = k+1; i < n; i++)
         {  if (a(i,k) != 0.0)
            {  /* gaussian multiplier l[i,k] := u[i,k] / u[k,k] */
               temp = (a(i,k) /= akk);
               /* (i-th row) := (i-th row) - l[i,k] * (k-th row) */
               for (j = k+1; j < n; j++)
                  a(i,j) -= temp * a(k,j);
            }
         }
      }
#     undef a
      return 0;
}


int sgf_dense_phase(LUF *luf, int k, int updat)
{     int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int fc_ref = luf->fc_ref;
      int *fc_ptr = &sva->ptr[fc_ref-1];
      int *fc_len = &sva->len[fc_ref-1];
      int *fc_cap = &sva->cap[fc_ref-1];
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int *vr_cap = &sva->cap[vr_ref-1];
      double *vr_piv = luf->vr_piv;
      int vc_ref = luf->vc_ref;
      int *vc_len = &sva->len[vc_ref-1];
      int *pp_inv = luf->pp_inv;
      int *pp_ind = luf->pp_ind;
      int *qq_ind = luf->qq_ind;
      int *qq_inv = luf->qq_inv;
      int a_end, a_ptr, end, i, ia, ii, j, ja, jj, ka, len, na, ne,
         need, ptr;
      double *a_;
      xassert(1 <= k && k <= n);
      /* active columns of V are not longer needed; make them empty */
      for (jj = k; jj <= n; jj++)
      {  /* jj is number of active column of U = P'* V * Q' */
         vc_len[qq_ind[jj]] = 0;
      }
      /* determine order of active submatrix A~ of matrix U */
      na = n - k + 1;
      xassert(1 <= na && na <= n);
      /* determine number of elements in dense triangular factor (L~ or
       * U~), except diagonal elements */
      ne = na * (na - 1) / 2;
      /* we allocate active submatrix A~ in free (middle) part of SVA;
       * to avoid defragmentation that could destroy A~ we also should
       * reserve ne locations to build rows of V from rows of U~ and ne
       * locations to build columns of F from columns of L~ */
      need = na * na + ne + ne;
      if (sva->r_ptr - sva->m_ptr < need)
      {  sva_more_space(sva, need);
         sv_ind = sva->ind;
         sv_val = sva->val;
      }
      /* free (middle) part of SVA is structured as follows:
       * end of left (dynamic) part
       * ne free locations for new rows of V
       * na free locations for active submatrix A~
       * unused locations, if any
       * ne free locations for new columns of F
       * beginning of right (static) part */
      a_ptr = sva->m_ptr + ne;
      a_end = a_ptr + na * na;
      /* copy active submatrix A~ from matrix V to working array in
       * dense row-wise format */
      a_ = &sva->val[a_ptr];
#     define a(ia, ja) a_[((ia) - 1) * na + ((ja) - 1)]
      for (ia = 1; ia <= na; ia++)
      {  /* clear ia-th row of A~ */
         for (ja = 1; ja <= na; ja++)
            a(ia, ja) = 0.0;
         /* ia-th row of A~ = (k-1+ia)-th row of U = i-th row of V */
         i = pp_inv[k-1+ia];
         ptr = vr_ptr[i];
         end = ptr + vr_len[i];
         for (; ptr < end; ptr++)
            a(ia, qq_inv[sv_ind[ptr]]-k+1) = sv_val[ptr];
         /* i-th row of V is no longer needed; make it empty */
         vr_len[i] = 0;
      }
      /* compute dense factorization A~ = P~* L~* U~* Q~ */
#if 1 /* FIXME: epsilon tolerance */
      ka = sgf_dense_lu(na, &a(1, 1), &pp_inv[k], &qq_ind[k], 1e-20);
#endif
      /* rows of U with numbers pp_inv[k, k+1, ..., n] were permuted
       * due to row permutations of A~; update matrix P using P~ */
      for (ii = k; ii <= n; ii++)
         pp_ind[pp_inv[ii]] = ii;
      /* columns of U with numbers qq_ind[k, k+1, ..., n] were permuted
       * due to column permutations of A~; update matrix Q using Q~ */
      for (jj = k; jj <= n; jj++)
         qq_inv[qq_ind[jj]] = jj;
      /* check if dense factorization is complete */
      if (ka != 0)
      {  /* A~ is singular to working precision */
         /* information on linearly dependent rows/columns is provided
          * by matrices P and Q */
         xassert(1 <= ka && ka <= na);
         return k - 1 + ka;
      }
      /* build new rows of V from rows of U~ */
      for (ia = 1; ia <= na; ia++)
      {  /* ia-th row of U~ = (k-1+ia)-th row of U = i-th row of V */
         i = pp_inv[k-1+ia];
         xassert(vr_len[i] == 0);
         /* store diagonal element u~[ia,ia] */
         vr_piv[i] = a(ia, ia);
         /* determine number of non-zero non-diagonal elements in ia-th
          * row of U~ */
         len = 0;
         for (ja = ia+1; ja <= na; ja++)
         {  if (a(ia, ja) != 0.0)
               len++;
         }
         /* reserve len locations for i-th row of matrix V in left
          * (dynamic) part of SVA */
         if (vr_cap[i] < len)
         {  /* there should be enough room in free part of SVA */
            xassert(sva->r_ptr - sva->m_ptr >= len);
            sva_enlarge_cap(sva, vr_ref-1+i, len, 0);
            /* left part of SVA should not overlap matrix A~ */
            xassert(sva->m_ptr <= a_ptr);
         }
         /* copy non-zero non-diaginal elements of ia-th row of U~ to
          * i-th row of V */
         ptr = vr_ptr[i];
         for (ja = ia+1; ja <= na; ja++)
         {  if (a(ia, ja) != 0.0)
            {  sv_ind[ptr] = qq_ind[k-1+ja];
               sv_val[ptr] = a(ia, ja);
               ptr++;
            }
         }
         xassert(ptr - vr_ptr[i] == len);
         vr_len[i] = len;
      }
      /* build new columns of F from columns of L~ */
      for (ja = 1; ja <= na; ja++)
      {  /* ja-th column of L~ = (k-1+ja)-th column of L = j-th column
          * of F */
         j = pp_inv[k-1+ja];
         xassert(fc_len[j] == 0);
         xassert(fc_cap[j] == 0);
         /* determine number of non-zero non-diagonal elements in ja-th
          * column of L~ */
         len = 0;
         for (ia = ja+1; ia <= na; ia++)
         {  if (a(ia, ja) != 0.0)
               len++;
         }
         /* reserve len locations for j-th column of matrix F in right
          * (static) part of SVA */
         /* there should be enough room in free part of SVA */
         xassert(sva->r_ptr - sva->m_ptr >= len);
         if (len > 0)
            sva_reserve_cap(sva, fc_ref-1+j, len);
         /* right part of SVA should not overlap matrix A~ */
         xassert(a_end <= sva->r_ptr);
         /* copy non-zero non-diagonal elements of ja-th column of L~
          * to j-th column of F */
         ptr = fc_ptr[j];
         for (ia = ja+1; ia <= na; ia++)
         {  if (a(ia, ja) != 0.0)
            {  sv_ind[ptr] = pp_inv[k-1+ia];
               sv_val[ptr] = a(ia, ja);
               ptr++;
            }
         }
         xassert(ptr - fc_ptr[j] == len);
         fc_len[j] = len;
      }
      /* factors L~ and U~ are no longer needed */
#     undef a
      /* if it is not planned to update matrix V, relocate all its new
       * rows to the right (static) part of SVA */
      if (!updat)
      {  for (ia = 1; ia <= na; ia++)
         {  i = pp_inv[k-1+ia];
            len = vr_len[i];
            if (sva->r_ptr - sva->m_ptr < len)
            {  sva_more_space(sva, len);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_make_static(sva, vr_ref-1+i);
         }
      }
      return 0;
}


#if 1 /* 21/II-2016 */
/* If the matrix A is structurally singular, the routine returns -1.
*  NOTE: This case can be detected only if the singl flag is set. */
#endif

int sgf_factorize(SGF *sgf, int singl)
{     LUF *luf = sgf->luf;
      int n = luf->n;
      SVA *sva = luf->sva;
      int vr_ref = luf->vr_ref;
      int *vr_len = &sva->len[vr_ref-1];
      double *vr_piv = luf->vr_piv;
      int vc_ref = luf->vc_ref;
      int *vc_len = &sva->len[vc_ref-1];
      int *pp_ind = luf->pp_ind;
      int *pp_inv = luf->pp_inv;
      int *qq_ind = luf->qq_ind;
      int *qq_inv = luf->qq_inv;
      int *rs_head = sgf->rs_head;
      int *rs_prev = sgf->rs_prev;
      int *rs_next = sgf->rs_next;
      int *cs_head = sgf->cs_head;
      int *cs_prev = sgf->cs_prev;
      int *cs_next = sgf->cs_next;
      double *vr_max = sgf->vr_max;
      char *flag = sgf->flag;
      double *work = sgf->work;
      int i, j, k, k1, k2, p, q, nnz;
      /* build matrix V = A in row-wise format */
      luf_build_v_rows(luf, rs_prev);
      /* P := Q := I, so V = U = A, F = L = I */
      for (k = 1; k <= n; k++)
      {  vr_piv[k] = 0.0;
         pp_ind[k] = pp_inv[k] = qq_ind[k] = qq_inv[k] = k;
      }
#ifdef GLP_DEBUG
      sva_check_area(sva);
      luf_check_all(luf, 1);
#endif
      /* perform singleton phase, if required */
      if (!singl)
      {  /* assume that nucleus is entire matrix U */
         k2 = 1;
      }
      else
      {  /* minimize nucleus size */
#if 0 /* 21/II-2016 */
         sgf_reduce_nuc(luf, &k1, &k2, rs_prev, rs_next);
#else
         if (sgf_reduce_nuc(luf, &k1, &k2, rs_prev, rs_next))
            return -1;
#endif
#ifdef GLP_DEBUG
         xprintf("n = %d; k1 = %d; k2 = %d\n", n, k1, k2);
#endif
         /* perform singleton phase */
         k2 = sgf_singl_phase(luf, k1, k2, sgf->updat, rs_prev, work);
      }
#ifdef GLP_DEBUG
      sva_check_area(sva);
      luf_check_all(luf, k2);
#endif
      /* initialize working arrays */
      rs_head[0] = cs_head[0] = 0;
      for (k = 1; k <= n; k++)
      {  rs_head[k] = cs_head[k] = 0;
         vr_max[k] = -1.0;
         flag[k] = 0;
         work[k] = 0.0;
      }
      /* build lists of active rows and columns of matrix V; determine
       * number of non-zeros in initial active submatrix */
      nnz = 0;
      for (k = k2; k <= n; k++)
      {  i = pp_inv[k];
         sgf_activate_row(i);
         nnz += vr_len[i];
         j = qq_ind[k];
         sgf_activate_col(j);
      }
      /* main factorization loop */
      for (k = k2; k <= n; k++)
      {  int na;
         double den;
         /* calculate density of active submatrix */
         na = n - k + 1; /* order of active submatrix */
#if 0 /* 21/VIII-2014 */
         den = (double)nnz / (double)(na * na);
#else
         den = (double)nnz / ((double)(na) * (double)(na));
#endif
         /* if active submatrix is relatively dense, switch to dense
          * phase */
#if 1 /* FIXME */
         if (na >= 5 && den >= 0.71)
         {
#ifdef GLP_DEBUG
            xprintf("na = %d; nnz = %d; den = %g\n", na, nnz, den);
#endif
            break;
         }
#endif
         /* choose pivot v[p,q] */
         if (sgf_choose_pivot(sgf, &p, &q) != 0)
            return k; /* failure */
         /* u[i,j] = v[p,q], k <= i, j <= n */
         i = pp_ind[p];
         xassert(k <= i && i <= n);
         j = qq_inv[q];
         xassert(k <= j && j <= n);
         /* move u[i,j] to position u[k,k] by implicit permutations of
          * rows and columns of matrix U */
         luf_swap_u_rows(k, i);
         luf_swap_u_cols(k, j);
         /* perform gaussian elimination */
         nnz += sgf_eliminate(sgf, p, q);
      }
#if 1 /* FIXME */
      if (k <= n)
      {  /* continue computing factorization in dense mode */
#ifdef GLP_DEBUG
         sva_check_area(sva);
         luf_check_all(luf, k);
#endif
         k = sgf_dense_phase(luf, k, sgf->updat);
         if (k != 0)
            return k; /* failure */
      }
#endif
#ifdef GLP_DEBUG
      sva_check_area(sva);
      luf_check_all(luf, n+1);
#endif
      /* defragment SVA; currently all columns of V are empty, so they
       * will have zero capacity as required by luf_build_v_cols */
      sva_defrag_area(sva);
      /* build matrix F in row-wise format */
      luf_build_f_rows(luf, rs_head);
      /* build matrix V in column-wise format */
      luf_build_v_cols(luf, sgf->updat, rs_head);
      return 0;
}


typedef struct LUFINT LUFINT;

struct LUFINT
{     /* interface to LU-factorization */
      int n_max;
      /* maximal value of n (increased automatically) */
      int valid;
      /* factorization is valid only if this flag is set */
      SVA *sva;
      /* sparse vector area (SVA) */
      LUF *luf;
      /* sparse LU-factorization */
      SGF *sgf;
      /* sparse Gaussian factorizer workspace */
      /*--------------------------------------------------------------*/
      /* control parameters */
      int sva_n_max, sva_size;
      /* parameters passed to sva_create_area */
      int delta_n0, delta_n;
      /* if n_max = 0, set n_max = n + delta_n0
       * if n_max < n, set n_max = n + delta_n */
      int sgf_updat;
      double sgf_piv_tol;
      int sgf_piv_lim;
      int sgf_suhl;
      double sgf_eps_tol;
      /* factorizer control parameters */
};

#define lufint_create _glp_lufint_create
LUFINT *lufint_create(void);
/* create interface to LU-factorization */

#define lufint_factorize _glp_lufint_factorize
int lufint_factorize(LUFINT *fi, int n, int (*col)(void *info, int j,
      int ind[], double val[]), void *info);
/* compute LU-factorization of specified matrix A */

#define lufint_delete _glp_lufint_delete
void lufint_delete(LUFINT *fi);
/* delete interface to LU-factorization */


typedef struct FHV FHV;

struct FHV
{     /* FHV-factorization */
      LUF *luf;
      /* LU-factorization (contains matrices F, V, P, Q) */
      /*--------------------------------------------------------------*/
      /* matrix H in the form of eta file */
      int nfs_max;
      /* maximal number of row-like factors (this limits the number of
       * updates of the factorization) */
      int nfs;
      /* current number of row-like factors, 0 <= nfs <= nfs_max */
      int *hh_ind; /* int hh_ind[1+nfs_max]; */
      /* hh_ind[0] is not used;
       * hh_ind[k], 1 <= k <= nfs, is number of non-trivial row of
       * factor H[k] */
      int hh_ref;
      /* reference number of sparse vector in SVA, which is non-trivial
       * row of factor H[1] */
#if 0 + 0
      int *hh_ptr = &sva->ptr[hh_ref-1];
      /* hh_ptr[0] is not used;
       * hh_ptr[k], 1 <= k <= nfs, is pointer to non-trivial row of
       * factor H[k] */
      int *hh_len = &sva->len[hh_ref-1];
      /* hh_len[0] is not used;
       * hh_len[k], 1 <= k <= nfs, is number of non-zero elements in
       * non-trivial row of factor H[k] */
#endif
      /*--------------------------------------------------------------*/
      /* matrix P0 */
      int *p0_ind; /* int p0_ind[1+n]; */
      /* p0_ind[i] = j means that P0[i,j] = 1 */
      int *p0_inv; /* int p0_inv[1+n]; */
      /* p0_inv[j] = i means that P0[i,j] = 1 */
};

#define fhv_ft_update _glp_fhv_ft_update
int fhv_ft_update(FHV *fhv, int q, int aq_len, const int aq_ind[],
      const double aq_val[], int ind[/*1+n*/], double val[/*1+n*/],
      double work[/*1+n*/]);
/* update FHV-factorization (Forrest-Tomlin) */

#define fhv_h_solve _glp_fhv_h_solve
void fhv_h_solve(FHV *fhv, double x[/*1+n*/]);
/* solve system H * x = b */

#define fhv_ht_solve _glp_fhv_ht_solve
void fhv_ht_solve(FHV *fhv, double x[/*1+n*/]);
/* solve system H' * x = b */


/***********************************************************************
*  fhv_ft_update - update FHV-factorization (Forrest-Tomlin)
*
*  This routine updates FHV-factorization of the original matrix A
*  after replacing its j-th column by a new one. The routine is based
*  on the method proposed by Forrest and Tomlin [1].
*
*  The parameter q specifies the number of column of A, which has been
*  replaced, 1 <= q <= n, where n is the order of A.
*
*  Row indices and numerical values of non-zero elements of the new
*  j-th column of A should be placed in locations aq_ind[1], ...,
*  aq_ind[aq_len] and aq_val[1], ..., aq_val[aq_len], respectively,
*  where aq_len is the number of non-zeros. Neither zero nor duplicate
*  elements are allowed.
*
*  The working arrays ind, val, and work should have at least 1+n
*  elements (0-th elements are not used).
*
*  RETURNS
*
*  0  The factorization has been successfully updated.
*
*  1  New matrix U = P'* V * Q' is upper triangular with zero diagonal
*     element u[s,s]. (Elimination was not performed.)
*
*  2  New matrix U = P'* V * Q' is upper triangular, and its diagonal
*     element u[s,s] or u[t,t] is too small in magnitude. (Elimination
*     was not performed.)
*
*  3  The same as 2, but after performing elimination.
*
*  4  The factorization has not been updated, because maximal number of
*     updates has been reached.
*
*  5  Accuracy test failed for the updated factorization.
*
*  BACKGROUND
*
*  The routine is based on the updating method proposed by Forrest and
*  Tomlin [1].
*
*  Let q-th column of the original matrix A have been replaced by new
*  column A[q]. Then, to keep the equality A = F * H * V, q-th column
*  of matrix V should be replaced by column V[q] = inv(F * H) * A[q].
*  From the standpoint of matrix U = P'* V * Q' such replacement is
*  equivalent to replacement of s-th column of matrix U, where s is
*  determined from q by permutation matrix Q. Thus, matrix U loses its
*  upper triangular form and becomes the following:
*
*        1   s       t   n
*     1  x x * x x x x x x
*        . x * x x x x x x
*     s  . . * x x x x x x
*        . . * x x x x x x
*        . . * . x x x x x
*        . . * . . x x x x
*     t  . . * . . . x x x
*        . . . . . . . x x
*     n  . . . . . . . . x
*
*  where t is largest row index of a non-zero element in s-th column.
*
*  The routine makes matrix U upper triangular as follows. First, it
*  moves rows and columns s+1, ..., t by one position to the left and
*  upwards, resp., and moves s-th row and s-th column to position t.
*  Due to such symmetric permutations matrix U becomes the following
*  (note that all diagonal elements remain on the diagonal, and element
*  u[s,s] becomes u[t,t]):
*
*        1   s       t   n
*     1  x x x x x x * x x
*        . x x x x x * x x
*     s  . . x x x x * x x
*        . . . x x x * x x
*        . . . . x x * x x
*        . . . . . x * x x
*     t  . . x x x x * x x
*        . . . . . . . x x
*     n  . . . . . . . . x
*
*  Then the routine performs gaussian elimination to eliminate
*  subdiagonal elements u[t,s], ..., u[t,t-1] using diagonal elements
*  u[s,s], ..., u[t-1,t-1] as pivots. During the elimination process
*  the routine permutes neither rows nor columns, so only t-th row is
*  changed. Should note that actually all operations are performed on
*  matrix V = P * U * Q, since matrix U is not stored.
*
*  To keep the equality A = F * H * V, the routine appends new row-like
*  factor H[k] to matrix H, and every time it applies elementary
*  gaussian transformation to eliminate u[t,j'] = v[p,j] using pivot
*  u[j',j'] = v[i,j], it also adds new element f[p,j] = v[p,j] / v[i,j]
*  (gaussian multiplier) to factor H[k], which initially is a unity
*  matrix. At the end of elimination process the row-like factor H[k]
*  may look as follows:
*
*        1               n          1   s       t   n
*     1  1 . . . . . . . .       1  1 . . . . . . . .
*        . 1 . . . . . . .          . 1 . . . . . . .
*        . . 1 . . . . . .       s  . . 1 . . . . . .
*     p  . x x 1 . x . x .          . . . 1 . . . . .
*        . . . . 1 . . . .          . . . . 1 . . . .
*        . . . . . 1 . . .          . . . . . 1 . . .
*        . . . . . . 1 . .       t  . . x x x x 1 . .
*        . . . . . . . 1 .          . . . . . . . 1 .
*     n  . . . . . . . . 1       n  . . . . . . . . 1
*
*              H[k]                 inv(P) * H[k] * P
*
*  If, however, s = t, no elimination is needed, in which case no new
*  row-like factor is created.
*
*  REFERENCES
*
*  1. J.J.H.Forrest and J.A.Tomlin, "Updated triangular factors of the
*     basis to maintain sparsity in the product form simplex method,"
*     Math. Prog. 2 (1972), pp. 263-78. */

int fhv_ft_update(FHV *fhv, int q, int aq_len, const int aq_ind[],
      const double aq_val[], int ind[/*1+n*/], double val[/*1+n*/],
      double work[/*1+n*/])
{     LUF *luf = fhv->luf;
      int n = luf->n;
      SVA *sva = luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int vr_ref = luf->vr_ref;
      int *vr_ptr = &sva->ptr[vr_ref-1];
      int *vr_len = &sva->len[vr_ref-1];
      int *vr_cap = &sva->cap[vr_ref-1];
      double *vr_piv = luf->vr_piv;
      int vc_ref = luf->vc_ref;
      int *vc_ptr = &sva->ptr[vc_ref-1];
      int *vc_len = &sva->len[vc_ref-1];
      int *vc_cap = &sva->cap[vc_ref-1];
      int *pp_ind = luf->pp_ind;
      int *pp_inv = luf->pp_inv;
      int *qq_ind = luf->qq_ind;
      int *qq_inv = luf->qq_inv;
      int *hh_ind = fhv->hh_ind;
      int hh_ref = fhv->hh_ref;
      int *hh_ptr = &sva->ptr[hh_ref-1];
      int *hh_len = &sva->len[hh_ref-1];
#if 1 /* FIXME */
      const double eps_tol = DBL_EPSILON;
      const double vpq_tol = 1e-5;
      const double err_tol = 1e-10;
#endif
      int end, i, i_end, i_ptr, j, j_end, j_ptr, k, len, nnz, p, p_end,
         p_ptr, ptr, q_end, q_ptr, s, t;
      double f, vpq, temp;
      /*--------------------------------------------------------------*/
      /* replace current q-th column of matrix V by new one           */
      /*--------------------------------------------------------------*/
      xassert(1 <= q && q <= n);
      /* convert new q-th column of matrix A to dense format */
      for (i = 1; i <= n; i++)
         val[i] = 0.0;
      xassert(0 <= aq_len && aq_len <= n);
      for (k = 1; k <= aq_len; k++)
      {  i = aq_ind[k];
         xassert(1 <= i && i <= n);
         xassert(val[i] == 0.0);
         xassert(aq_val[k] != 0.0);
         val[i] = aq_val[k];
      }
      /* compute new q-th column of matrix V:
       * new V[q] = inv(F * H) * (new A[q]) */
      luf->pp_ind = fhv->p0_ind;
      luf->pp_inv = fhv->p0_inv;
      luf_f_solve(luf, val);
      luf->pp_ind = pp_ind;
      luf->pp_inv = pp_inv;
      fhv_h_solve(fhv, val);
      /* q-th column of V = s-th column of U */
      s = qq_inv[q];
      /* determine row number of element v[p,q] that corresponds to
       * diagonal element u[s,s] */
      p = pp_inv[s];
      /* convert new q-th column of V to sparse format;
       * element v[p,q] = u[s,s] is not included in the element list
       * and stored separately */
      vpq = 0.0;
      len = 0;
      for (i = 1; i <= n; i++)
      {  temp = val[i];
#if 1 /* FIXME */
         if (-eps_tol < temp && temp < +eps_tol)
#endif
            /* nop */;
         else if (i == p)
            vpq = temp;
         else
         {  ind[++len] = i;
            val[len] = temp;
         }
      }
      /* clear q-th column of matrix V */
      for (q_end = (q_ptr = vc_ptr[q]) + vc_len[q];
         q_ptr < q_end; q_ptr++)
      {  /* get row index of v[i,q] */
         i = sv_ind[q_ptr];
         /* find and remove v[i,q] from i-th row */
         for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
            sv_ind[i_ptr] != q; i_ptr++)
            /* nop */;
         xassert(i_ptr < i_end);
         sv_ind[i_ptr] = sv_ind[i_end-1];
         sv_val[i_ptr] = sv_val[i_end-1];
         vr_len[i]--;
      }
      /* now q-th column of matrix V is empty */
      vc_len[q] = 0;
      /* put new q-th column of V (except element v[p,q] = u[s,s]) in
       * column-wise format */
      if (len > 0)
      {  if (vc_cap[q] < len)
         {  if (sva->r_ptr - sva->m_ptr < len)
            {  sva_more_space(sva, len);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_enlarge_cap(sva, vc_ref-1+q, len, 0);
         }
         ptr = vc_ptr[q];
         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));
         memcpy(&sv_val[ptr], &val[1], len * sizeof(double));
         vc_len[q] = len;
      }
      /* put new q-th column of V (except element v[p,q] = u[s,s]) in
       * row-wise format, and determine largest row number t such that
       * u[s,t] != 0 */
      t = (vpq == 0.0 ? 0 : s);
      for (k = 1; k <= len; k++)
      {  /* get row index of v[i,q] */
         i = ind[k];
         /* put v[i,q] to i-th row */
         if (vr_cap[i] == vr_len[i])
         {  /* reserve extra locations in i-th row to reduce further
             * relocations of that row */
#if 1 /* FIXME */
            int need = vr_len[i] + 5;
#endif
            if (sva->r_ptr - sva->m_ptr < need)
            {  sva_more_space(sva, need);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_enlarge_cap(sva, vr_ref-1+i, need, 0);
         }
         sv_ind[ptr = vr_ptr[i] + (vr_len[i]++)] = q;
         sv_val[ptr] = val[k];
         /* v[i,q] is non-zero; increase t */
         if (t < pp_ind[i])
            t = pp_ind[i];
      }
      /*--------------------------------------------------------------*/
      /* check if matrix U is already upper triangular                */
      /*--------------------------------------------------------------*/
      /* check if there is a spike in s-th column of matrix U, which
       * is q-th column of matrix V */
      if (s >= t)
      {  /* no spike; matrix U is already upper triangular */
         /* store its diagonal element u[s,s] = v[p,q] */
         vr_piv[p] = vpq;
         if (s > t)
         {  /* matrix U is structurally singular, because its diagonal
             * element u[s,s] = v[p,q] is exact zero */
            xassert(vpq == 0.0);
            return 1;
         }
#if 1 /* FIXME */
         else if (-vpq_tol < vpq && vpq < +vpq_tol)
#endif
         {  /* matrix U is not well conditioned, because its diagonal
             * element u[s,s] = v[p,q] is too small in magnitude */
            return 2;
         }
         else
         {  /* normal case */
            return 0;
         }
      }
      /*--------------------------------------------------------------*/
      /* perform implicit symmetric permutations of rows and columns  */
      /* of matrix U                                                  */
      /*--------------------------------------------------------------*/
      /* currently v[p,q] = u[s,s] */
      xassert(p == pp_inv[s] && q == qq_ind[s]);
      for (k = s; k < t; k++)
      {  pp_ind[pp_inv[k] = pp_inv[k+1]] = k;
         qq_inv[qq_ind[k] = qq_ind[k+1]] = k;
      }
      /* now v[p,q] = u[t,t] */
      pp_ind[pp_inv[t] = p] = qq_inv[qq_ind[t] = q] = t;
      /*--------------------------------------------------------------*/
      /* check if matrix U is already upper triangular                */
      /*--------------------------------------------------------------*/
      /* check if there is a spike in t-th row of matrix U, which is
       * p-th row of matrix V */
      for (p_end = (p_ptr = vr_ptr[p]) + vr_len[p];
         p_ptr < p_end; p_ptr++)
      {  if (qq_inv[sv_ind[p_ptr]] < t)
            break; /* spike detected */
      }
      if (p_ptr == p_end)
      {  /* no spike; matrix U is already upper triangular */
         /* store its diagonal element u[t,t] = v[p,q] */
         vr_piv[p] = vpq;
#if 1 /* FIXME */
         if (-vpq_tol < vpq && vpq < +vpq_tol)
#endif
         {  /* matrix U is not well conditioned, because its diagonal
             * element u[t,t] = v[p,q] is too small in magnitude */
            return 2;
         }
         else
         {  /* normal case */
            return 0;
         }
      }
      /*--------------------------------------------------------------*/
      /* copy p-th row of matrix V, which is t-th row of matrix U, to */
      /* working array                                                */
      /*--------------------------------------------------------------*/
      /* copy p-th row of matrix V, including element v[p,q] = u[t,t],
       * to the working array in dense format and remove these elements
       * from matrix V; since no pivoting is used, only this row will
       * change during elimination */
      for (j = 1; j <= n; j++)
         work[j] = 0.0;
      work[q] = vpq;
      for (p_end = (p_ptr = vr_ptr[p]) + vr_len[p];
         p_ptr < p_end; p_ptr++)
      {  /* get column index of v[p,j] and store this element to the
          * working array */
         work[j = sv_ind[p_ptr]] = sv_val[p_ptr];
         /* find and remove v[p,j] from j-th column */
         for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
            sv_ind[j_ptr] != p; j_ptr++)
            /* nop */;
         xassert(j_ptr < j_end);
         sv_ind[j_ptr] = sv_ind[j_end-1];
         sv_val[j_ptr] = sv_val[j_end-1];
         vc_len[j]--;
      }
      /* now p-th row of matrix V is temporarily empty */
      vr_len[p] = 0;
      /*--------------------------------------------------------------*/
      /* perform gaussian elimination                                 */
      /*--------------------------------------------------------------*/
      /* transform p-th row of matrix V stored in working array, which
       * is t-th row of matrix U, to eliminate subdiagonal elements
       * u[t,s], ..., u[t,t-1]; corresponding gaussian multipliers will
       * form non-trivial row of new row-like factor */
      nnz = 0; /* number of non-zero gaussian multipliers */
      for (k = s; k < t; k++)
      {  /* diagonal element u[k,k] = v[i,j] is used as pivot */
         i = pp_inv[k], j = qq_ind[k];
         /* take subdiagonal element u[t,k] = v[p,j] */
         temp = work[j];
#if 1 /* FIXME */
         if (-eps_tol < temp && temp < +eps_tol)
            continue;
#endif
         /* compute and save gaussian multiplier:
          * f := u[t,k] / u[k,k] = v[p,j] / v[i,j] */
         ind[++nnz] = i;
         val[nnz] = f = work[j] / vr_piv[i];
         /* gaussian transformation to eliminate u[t,k] = v[p,j]:
          * (p-th row of V) := (p-th row of V) - f * (i-th row of V) */
         for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
            i_ptr < i_end; i_ptr++)
            work[sv_ind[i_ptr]] -= f * sv_val[i_ptr];
      }
      /* now matrix U is again upper triangular */
#if 1 /* FIXME */
      if (-vpq_tol < work[q] && work[q] < +vpq_tol)
#endif
      {  /* however, its new diagonal element u[t,t] = v[p,q] is too
          * small in magnitude */
         return 3;
      }
      /*--------------------------------------------------------------*/
      /* create new row-like factor H[k] and add to eta file H        */
      /*--------------------------------------------------------------*/
      /* (nnz = 0 means that all subdiagonal elements were too small
       * in magnitude) */
      if (nnz > 0)
      {  if (fhv->nfs == fhv->nfs_max)
         {  /* maximal number of row-like factors has been reached */
            return 4;
         }
         k = ++(fhv->nfs);
         hh_ind[k] = p;
         /* store non-trivial row of H[k] in right (dynamic) part of
          * SVA (diagonal unity element is not stored) */
         if (sva->r_ptr - sva->m_ptr < nnz)
         {  sva_more_space(sva, nnz);
            sv_ind = sva->ind;
            sv_val = sva->val;
         }
         sva_reserve_cap(sva, fhv->hh_ref-1+k, nnz);
         ptr = hh_ptr[k];
         memcpy(&sv_ind[ptr], &ind[1], nnz * sizeof(int));
         memcpy(&sv_val[ptr], &val[1], nnz * sizeof(double));
         hh_len[k] = nnz;
      }
      /*--------------------------------------------------------------*/
      /* copy transformed p-th row of matrix V, which is t-th row of  */
      /* matrix U, from working array back to matrix V                */
      /*--------------------------------------------------------------*/
      /* copy elements of transformed p-th row of matrix V, which are
       * non-diagonal elements u[t,t+1], ..., u[t,n] of matrix U, from
       * working array to corresponding columns of matrix V (note that
       * diagonal element u[t,t] = v[p,q] not copied); also transform
       * p-th row of matrix V to sparse format */
      len = 0;
      for (k = t+1; k <= n; k++)
      {  /* j-th column of V = k-th column of U */
         j = qq_ind[k];
         /* take non-diagonal element v[p,j] = u[t,k] */
         temp = work[j];
#if 1 /* FIXME */
         if (-eps_tol < temp && temp < +eps_tol)
            continue;
#endif
         /* add v[p,j] to j-th column of matrix V */
         if (vc_cap[j] == vc_len[j])
         {  /* reserve extra locations in j-th column to reduce further
             * relocations of that column */
#if 1 /* FIXME */
            int need = vc_len[j] + 5;
#endif
            if (sva->r_ptr - sva->m_ptr < need)
            {  sva_more_space(sva, need);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_enlarge_cap(sva, vc_ref-1+j, need, 0);
         }
         sv_ind[ptr = vc_ptr[j] + (vc_len[j]++)] = p;
         sv_val[ptr] = temp;
         /* store element v[p,j] = u[t,k] to working sparse vector */
         ind[++len] = j;
         val[len] = temp;
      }
      /* copy elements from working sparse vector to p-th row of matrix
       * V (this row is currently empty) */
      if (vr_cap[p] < len)
      {  if (sva->r_ptr - sva->m_ptr < len)
         {  sva_more_space(sva, len);
            sv_ind = sva->ind;
            sv_val = sva->val;
         }
         sva_enlarge_cap(sva, vr_ref-1+p, len, 0);
      }
      ptr = vr_ptr[p];
      memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));
      memcpy(&sv_val[ptr], &val[1], len * sizeof(double));
      vr_len[p] = len;
      /* store new diagonal element u[t,t] = v[p,q] */
      vr_piv[p] = work[q];
      /*--------------------------------------------------------------*/
      /* perform accuracy test (only if new H[k] was added)           */
      /*--------------------------------------------------------------*/
      if (nnz > 0)
      {  /* copy p-th (non-trivial) row of row-like factor H[k] (except
          * unity diagonal element) to working array in dense format */
         for (j = 1; j <= n; j++)
            work[j] = 0.0;
         k = fhv->nfs;
         for (end = (ptr = hh_ptr[k]) + hh_len[k]; ptr < end; ptr++)
            work[sv_ind[ptr]] = sv_val[ptr];
         /* compute inner product of p-th (non-trivial) row of matrix
          * H[k] and q-th column of matrix V */
         temp = vr_piv[p]; /* 1 * v[p,q] */
         ptr = vc_ptr[q];
         end = ptr + vc_len[q];
         for (; ptr < end; ptr++)
            temp += work[sv_ind[ptr]] * sv_val[ptr];
         /* inner product should be equal to element v[p,q] *before*
          * matrix V was transformed */
         /* compute relative error */
         temp = fabs(vpq - temp) / (1.0 + fabs(vpq));
#if 1 /* FIXME */
         if (temp > err_tol)
#endif
         {  /* relative error is too large */
            return 5;
         }
      }
      /* factorization has been successfully updated */
      return 0;
}

/***********************************************************************
*  fhv_h_solve - solve system H * x = b
*
*  This routine solves the system H * x = b, where the matrix H is the
*  middle factor of the sparse updatable FHV-factorization.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix H. On exit this array will contain elements of the solution
*  vector x in the same locations. */

void fhv_h_solve(FHV *fhv, double x[/*1+n*/])
{     SVA *sva = fhv->luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int nfs = fhv->nfs;
      int *hh_ind = fhv->hh_ind;
      int hh_ref = fhv->hh_ref;
      int *hh_ptr = &sva->ptr[hh_ref-1];
      int *hh_len = &sva->len[hh_ref-1];
      int i, k, end, ptr;
      double x_i;
      for (k = 1; k <= nfs; k++)
      {  x_i = x[i = hh_ind[k]];
         for (end = (ptr = hh_ptr[k]) + hh_len[k]; ptr < end; ptr++)
            x_i -= sv_val[ptr] * x[sv_ind[ptr]];
         x[i] = x_i;
      }
      return;
}

/***********************************************************************
*  fhv_ht_solve - solve system H' * x = b
*
*  This routine solves the system H' * x = b, where H' is a matrix
*  transposed to the matrix H, which is the middle factor of the sparse
*  updatable FHV-factorization.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix H. On exit this array will contain elements of the solution
*  vector x in the same locations. */

void fhv_ht_solve(FHV *fhv, double x[/*1+n*/])
{     SVA *sva = fhv->luf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int nfs = fhv->nfs;
      int *hh_ind = fhv->hh_ind;
      int hh_ref = fhv->hh_ref;
      int *hh_ptr = &sva->ptr[hh_ref-1];
      int *hh_len = &sva->len[hh_ref-1];
      int k, end, ptr;
      double x_j;
      for (k = nfs; k >= 1; k--)
      {  if ((x_j = x[hh_ind[k]]) == 0.0)
            continue;
         for (end = (ptr = hh_ptr[k]) + hh_len[k]; ptr < end; ptr++)
            x[sv_ind[ptr]] -= sv_val[ptr] * x_j;
      }
      return;
}





LUFINT *lufint_create(void)
{     /* create interface to LU-factorization */
      LUFINT *fi;
      fi = talloc(1, LUFINT);
      fi->n_max = 0;
      fi->valid = 0;
      fi->sva = NULL;
      fi->luf = NULL;
      fi->sgf = NULL;
      fi->sva_n_max = fi->sva_size = 0;
      fi->delta_n0 = fi->delta_n = 0;
      fi->sgf_updat = 0;
      fi->sgf_piv_tol = 0.10;
      fi->sgf_piv_lim = 4;
      fi->sgf_suhl = 1;
      fi->sgf_eps_tol = DBL_EPSILON;
      return fi;
}

int lufint_factorize(LUFINT *fi, int n, int (*col)(void *info, int j,
      int ind[], double val[]), void *info)
{     /* compute LU-factorization of specified matrix A */
      SVA *sva;
      LUF *luf;
      SGF *sgf;
      int k;
      xassert(n > 0);
      fi->valid = 0;
      /* create sparse vector area (SVA), if necessary */
      sva = fi->sva;
      if (sva == NULL)
      {  int sva_n_max = fi->sva_n_max;
         int sva_size = fi->sva_size;
         if (sva_n_max == 0)
            sva_n_max = 4 * n;
         if (sva_size == 0)
            sva_size = 10 * n;
         sva = fi->sva = sva_create_area(sva_n_max, sva_size);
      }
      /* allocate/reallocate underlying objects, if necessary */
      if (fi->n_max < n)
      {  int n_max = fi->n_max;
         if (n_max == 0)
            n_max = fi->n_max = n + fi->delta_n0;
         else
            n_max = fi->n_max = n + fi->delta_n;
         xassert(n_max >= n);
         /* allocate/reallocate LU-factorization (LUF) */
         luf = fi->luf;
         if (luf == NULL)
         {  luf = fi->luf = talloc(1, LUF);
            memset(luf, 0, sizeof(LUF));
            luf->sva = sva;
         }
         else
         {  tfree(luf->vr_piv);
            tfree(luf->pp_ind);
            tfree(luf->pp_inv);
            tfree(luf->qq_ind);
            tfree(luf->qq_inv);
         }
         luf->vr_piv = talloc(1+n_max, double);
         luf->pp_ind = talloc(1+n_max, int);
         luf->pp_inv = talloc(1+n_max, int);
         luf->qq_ind = talloc(1+n_max, int);
         luf->qq_inv = talloc(1+n_max, int);
         /* allocate/reallocate factorizer workspace (SGF) */
         sgf = fi->sgf;
         if (sgf == NULL)
         {  sgf = fi->sgf = talloc(1, SGF);
            memset(sgf, 0, sizeof(SGF));
            sgf->luf = luf;
         }
         else
         {  tfree(sgf->rs_head);
            tfree(sgf->rs_prev);
            tfree(sgf->rs_next);
            tfree(sgf->cs_head);
            tfree(sgf->cs_prev);
            tfree(sgf->cs_next);
            tfree(sgf->vr_max);
            tfree(sgf->flag);
            tfree(sgf->work);
         }
         sgf->rs_head = talloc(1+n_max, int);
         sgf->rs_prev = talloc(1+n_max, int);
         sgf->rs_next = talloc(1+n_max, int);
         sgf->cs_head = talloc(1+n_max, int);
         sgf->cs_prev = talloc(1+n_max, int);
         sgf->cs_next = talloc(1+n_max, int);
         sgf->vr_max = talloc(1+n_max, double);
         sgf->flag = talloc(1+n_max, char);
         sgf->work = talloc(1+n_max, double);
      }
      luf = fi->luf;
      sgf = fi->sgf;
#if 1 /* FIXME */
      /* initialize SVA */
      sva->n = 0;
      sva->m_ptr = 1;
      sva->r_ptr = sva->size + 1;
      sva->head = sva->tail = 0;
#endif
      /* allocate sparse vectors in SVA */
      luf->n = n;
      luf->fr_ref = sva_alloc_vecs(sva, n);
      luf->fc_ref = sva_alloc_vecs(sva, n);
      luf->vr_ref = sva_alloc_vecs(sva, n);
      luf->vc_ref = sva_alloc_vecs(sva, n);
      /* store matrix V = A in column-wise format */
      luf_store_v_cols(luf, col, info, sgf->rs_prev, sgf->work);
      /* setup factorizer control parameters */
      sgf->updat = fi->sgf_updat;
      sgf->piv_tol = fi->sgf_piv_tol;
      sgf->piv_lim = fi->sgf_piv_lim;
      sgf->suhl = fi->sgf_suhl;
      sgf->eps_tol = fi->sgf_eps_tol;
      /* compute LU-factorization of specified matrix A */
      k = sgf_factorize(sgf, 1);
      if (k == 0)
         fi->valid = 1;
      return k;
}

void lufint_delete(LUFINT *fi)
{     /* delete interface to LU-factorization */
      SVA *sva = fi->sva;
      LUF *luf = fi->luf;
      SGF *sgf = fi->sgf;
      if (sva != NULL)
         sva_delete_area(sva);
      if (luf != NULL)
      {  tfree(luf->vr_piv);
         tfree(luf->pp_ind);
         tfree(luf->pp_inv);
         tfree(luf->qq_ind);
         tfree(luf->qq_inv);
         tfree(luf);
      }
      if (sgf != NULL)
      {  tfree(sgf->rs_head);
         tfree(sgf->rs_prev);
         tfree(sgf->rs_next);
         tfree(sgf->cs_head);
         tfree(sgf->cs_prev);
         tfree(sgf->cs_next);
         tfree(sgf->vr_max);
         tfree(sgf->flag);
         tfree(sgf->work);
         tfree(sgf);
      }
      tfree(fi);
      return;
}
typedef struct FHVINT FHVINT;

struct FHVINT
{     /* interface to FHV-factorization */
      int valid;
      /* factorization is valid only if this flag is set */
      FHV fhv;
      /* FHV-factorization */
      LUFINT *lufi;
      /* interface to underlying LU-factorization */
      /*--------------------------------------------------------------*/
      /* control parameters */
      int nfs_max;
      /* required maximal number of row-like factors */
};

#define fhvint_create _glp_fhvint_create
FHVINT *fhvint_create(void);
/* create interface to FHV-factorization */

#define fhvint_factorize _glp_fhvint_factorize
int fhvint_factorize(FHVINT *fi, int n, int (*col)(void *info, int j,
      int ind[], double val[]), void *info);
/* compute FHV-factorization of specified matrix A */

#define fhvint_update _glp_fhvint_update
int fhvint_update(FHVINT *fi, int j, int len, const int ind[],
      const double val[]);
/* update FHV-factorization after replacing j-th column of A */

#define fhvint_ftran _glp_fhvint_ftran
void fhvint_ftran(FHVINT *fi, double x[]);
/* solve system A * x = b */

#define fhvint_btran _glp_fhvint_btran
void fhvint_btran(FHVINT *fi, double x[]);
/* solve system A'* x = b */

#define fhvint_estimate _glp_fhvint_estimate
double fhvint_estimate(FHVINT *fi);
/* estimate 1-norm of inv(A) */

#define fhvint_delete _glp_fhvint_delete
void fhvint_delete(FHVINT *fi);
/* delete interface to FHV-factorization */



FHVINT *fhvint_create(void)
{     /* create interface to FHV-factorization */
      FHVINT *fi;
      fi = talloc(1, FHVINT);
      memset(fi, 0, sizeof(FHVINT));
      fi->lufi = lufint_create();
      return fi;
}

int fhvint_factorize(FHVINT *fi, int n, int (*col)(void *info, int j,
      int ind[], double val[]), void *info)
{     /* compute FHV-factorization of specified matrix A */
      int nfs_max, old_n_max, n_max, k, ret;
      xassert(n > 0);
      fi->valid = 0;
      /* get required value of nfs_max */
      nfs_max = fi->nfs_max;
      if (nfs_max == 0)
         nfs_max = 100;
      xassert(nfs_max > 0);
      /* compute factorization of specified matrix A */
      old_n_max = fi->lufi->n_max;
      fi->lufi->sva_n_max = 4 * n + nfs_max;
      fi->lufi->sgf_updat = 1;
      ret = lufint_factorize(fi->lufi, n, col, info);
      n_max = fi->lufi->n_max;
      /* allocate/reallocate arrays, if necessary */
      if (fi->fhv.nfs_max != nfs_max)
      {  if (fi->fhv.hh_ind != NULL)
            tfree(fi->fhv.hh_ind);
         fi->fhv.hh_ind = talloc(1+nfs_max, int);
      }
      if (old_n_max < n_max)
      {  if (fi->fhv.p0_ind != NULL)
            tfree(fi->fhv.p0_ind);
         if (fi->fhv.p0_inv != NULL)
            tfree(fi->fhv.p0_inv);
         fi->fhv.p0_ind = talloc(1+n_max, int);
         fi->fhv.p0_inv = talloc(1+n_max, int);
      }
      /* initialize FHV-factorization */
      fi->fhv.luf = fi->lufi->luf;
      fi->fhv.nfs_max = nfs_max;
      /* H := I */
      fi->fhv.nfs = 0;
      fi->fhv.hh_ref = sva_alloc_vecs(fi->lufi->sva, nfs_max);
      /* P0 := P */
      for (k = 1; k <= n; k++)
      {  fi->fhv.p0_ind[k] = fi->fhv.luf->pp_ind[k];
         fi->fhv.p0_inv[k] = fi->fhv.luf->pp_inv[k];
      }
      /* set validation flag */
      if (ret == 0)
         fi->valid = 1;
      return ret;
}

int fhvint_update(FHVINT *fi, int j, int len, const int ind[],
      const double val[])
{     /* update FHV-factorization after replacing j-th column of A */
      SGF *sgf = fi->lufi->sgf;
      int *ind1 = sgf->rs_next;
      double *val1 = sgf->vr_max;
      double *work = sgf->work;
      int ret;
      xassert(fi->valid);
      ret = fhv_ft_update(&fi->fhv, j, len, ind, val, ind1, val1, work);
      if (ret != 0)
         fi->valid = 0;
      return ret;
}

void fhvint_ftran(FHVINT *fi, double x[])
{     /* solve system A * x = b */
      FHV *fhv = &fi->fhv;
      LUF *luf = fhv->luf;
      int n = luf->n;
      int *pp_ind = luf->pp_ind;
      int *pp_inv = luf->pp_inv;
      SGF *sgf = fi->lufi->sgf;
      double *work = sgf->work;
      xassert(fi->valid);
      /* A = F * H * V */
      /* x = inv(A) * b = inv(V) * inv(H) * inv(F) * b */
      luf->pp_ind = fhv->p0_ind;
      luf->pp_inv = fhv->p0_inv;
      luf_f_solve(luf, x);
      luf->pp_ind = pp_ind;
      luf->pp_inv = pp_inv;
      fhv_h_solve(fhv, x);
      luf_v_solve(luf, x, work);
      memcpy(&x[1], &work[1], n * sizeof(double));
      return;
}

void fhvint_btran(FHVINT *fi, double x[])
{     /* solve system A'* x = b */
      FHV *fhv = &fi->fhv;
      LUF *luf = fhv->luf;
      int n = luf->n;
      int *pp_ind = luf->pp_ind;
      int *pp_inv = luf->pp_inv;
      SGF *sgf = fi->lufi->sgf;
      double *work = sgf->work;
      xassert(fi->valid);
      /* A' = (F * H * V)' = V'* H'* F' */
      /* x = inv(A') * b = inv(F') * inv(H') * inv(V') * b */
      luf_vt_solve(luf, x, work);
      fhv_ht_solve(fhv, work);
      luf->pp_ind = fhv->p0_ind;
      luf->pp_inv = fhv->p0_inv;
      luf_ft_solve(luf, work);
      luf->pp_ind = pp_ind;
      luf->pp_inv = pp_inv;
      memcpy(&x[1], &work[1], n * sizeof(double));
      return;
}

double fhvint_estimate(FHVINT *fi)
{     /* estimate 1-norm of inv(A) */
      double norm;
      xassert(fi->valid);
      xassert(fi->fhv.nfs == 0);
      norm = luf_estimate_norm(fi->fhv.luf, fi->lufi->sgf->vr_max,
         fi->lufi->sgf->work);
      return norm;
}

void fhvint_delete(FHVINT *fi)
{     /* delete interface to FHV-factorization */
      lufint_delete(fi->lufi);
      if (fi->fhv.hh_ind != NULL)
         tfree(fi->fhv.hh_ind);
      if (fi->fhv.p0_ind != NULL)
         tfree(fi->fhv.p0_ind);
      if (fi->fhv.p0_inv != NULL)
         tfree(fi->fhv.p0_inv);
      tfree(fi);
      return;
}


/***********************************************************************
*  The structure BTF describes BT-factorization, which is sparse block
*  triangular LU-factorization.
*
*  The BT-factorization has the following format:
*
*     A = P * A~ * Q,                                                (1)
*
*  where A is a given (unsymmetric) square matrix, A~ is an upper block
*  triangular matrix (see below), P and Q are permutation matrices. All
*  the matrices have the same order n.
*
*  The matrix A~, which is a permuted version of the original matrix A,
*  has the following structure:
*
*     A~[1,1]  A~[1,2]  ...  A~[1,num-1]      A~[1,num]
*
*              A~[2,2]  ...  A~[2,num-1]      A~[2,num]
*
*                       . . . . . . . . .                            (2)
*
*                        A~[num-1,num-1]  A~[num-1,num]
*
*                                           A~[num,num]
*
*  where A~[i,j] is a submatrix called a "block," num is the number of
*  blocks. Each diagonal block A~[k,k] is a non-singular square matrix,
*  and each subdiagonal block A~[i,j], i > j, is a zero submatrix, thus
*  A~ is an upper block triangular matrix.
*
*  Permutation matrices P and Q are stored in ordinary arrays in both
*  row- and column-like formats.
*
*  The original matrix A is stored in both row- and column-wise sparse
*  formats in the associated sparse vector area (SVA). Should note that
*  elements of all diagonal blocks A~[k,k] in matrix A are set to zero
*  (i.e. removed), so only elements of non-diagonal blocks are stored.
*
*  Each diagonal block A~[k,k], 1 <= k <= num, is stored in the form of
*  LU-factorization (see the module LUF). */

typedef struct BTF BTF;

struct BTF
{     /* sparse block triangular LU-factorization */
      int n;
      /* order of matrices A, A~, P, Q */
      SVA *sva;
      /* associated sparse vector area used to store rows and columns
       * of matrix A as well as sparse vectors for LU-factorizations of
       * all diagonal blocks A~[k,k] */
      /*--------------------------------------------------------------*/
      /* matrix P */
      int *pp_ind; /* int pp_ind[1+n]; */
      /* pp_ind[i] = j means that P[i,j] = 1 */
      int *pp_inv; /* int pp_inv[1+n]; */
      /* pp_inv[j] = i means that P[i,j] = 1 */
      /* if i-th row of matrix A is i'-th row of matrix A~, then
       * pp_ind[i] = i' and pp_inv[i'] = i */
      /*--------------------------------------------------------------*/
      /* matrix Q */
      int *qq_ind; /* int qq_ind[1+n]; */
      /* qq_ind[i] = j means that Q[i,j] = 1 */
      int *qq_inv; /* int qq_inv[1+n]; */
      /* qq_inv[j] = i means that Q[i,j] = 1 */
      /* if j-th column of matrix A is j'-th column of matrix A~, then
       * qq_ind[j'] = j and qq_inv[j] = j' */
      /*--------------------------------------------------------------*/
      /* block triangular structure of matrix A~ */
      int num;
      /* number of diagonal blocks, 1 <= num <= n */
      int *beg; /* int beg[1+num+1]; */
      /* beg[0] is not used;
       * beg[k], 1 <= k <= num, is index of first row/column of k-th
       * block of matrix A~;
       * beg[num+1] is always n+1;
       * note that order (size) of k-th diagonal block can be computed
       * as beg[k+1] - beg[k] */
      /*--------------------------------------------------------------*/
      /* original matrix A in row-wise format */
      /* NOTE: elements of all diagonal blocks A~[k,k] are removed */
      int ar_ref;
      /* reference number of sparse vector in SVA, which is the first
       * row of matrix A */
#if 0 + 0
      int *ar_ptr = &sva->ptr[ar_ref-1];
      /* ar_ptr[0] is not used;
       * ar_ptr[i], 1 <= i <= n, is pointer to i-th row in SVA */
      int *ar_len = &sva->ptr[ar_ref-1];
      /* ar_len[0] is not used;
       * ar_len[i], 1 <= i <= n, is length of i-th row */
#endif
      /*--------------------------------------------------------------*/
      /* original matrix A in column-wise format */
      /* NOTE: elements of all diagonal blocks A~[k,k] are removed */
      int ac_ref;
      /* reference number of sparse vector in SVA, which is the first
       * column of matrix A */
#if 0 + 0
      int *ac_ptr = &sva->ptr[ac_ref-1];
      /* ac_ptr[0] is not used;
       * ac_ptr[j], 1 <= j <= n, is pointer to j-th column in SVA */
      int *ac_len = &sva->ptr[ac_ref-1];
      /* ac_len[0] is not used;
       * ac_len[j], 1 <= j <= n, is length of j-th column */
#endif
      /*--------------------------------------------------------------*/
      /* LU-factorizations of diagonal blocks A~[k,k] */
      /* to decrease overhead expenses similar arrays for all LUFs are
       * packed into a single array; for example, elements fr_ptr[1],
       * ..., fr_ptr[n1], where n1 = beg[2] - beg[1], are related to
       * LUF for first diagonal block A~[1,1], elements fr_ptr[n1+1],
       * ..., fr_ptr[n1+n2], where n2 = beg[3] - beg[2], are related to
       * LUF for second diagonal block A~[2,2], etc.; in other words,
       * elements related to LUF for k-th diagonal block A~[k,k] have
       * indices beg[k], beg[k]+1, ..., beg[k+1]-1 */
      /* for details about LUF see description of the LUF module */
      int fr_ref;
      /* reference number of sparse vector in SVA, which is the first
         row of matrix F for first diagonal block A~[1,1] */
      int fc_ref;
      /* reference number of sparse vector in SVA, which is the first
         column of matrix F for first diagonal block A~[1,1] */
      int vr_ref;
      /* reference number of sparse vector in SVA, which is the first
         row of matrix V for first diagonal block A~[1,1] */
      double *vr_piv; /* double vr_piv[1+n]; */
      /* vr_piv[0] is not used;
         vr_piv[1,...,n] are pivot elements for all diagonal blocks */
      int vc_ref;
      /* reference number of sparse vector in SVA, which is the first
         column of matrix V for first diagonal block A~[1,1] */
      int *p1_ind; /* int p1_ind[1+n]; */
      int *p1_inv; /* int p1_inv[1+n]; */
      int *q1_ind; /* int q1_ind[1+n]; */
      int *q1_inv; /* int q1_inv[1+n]; */
      /* permutation matrices P and Q for all diagonal blocks */
};

#define btf_store_a_cols _glp_btf_store_a_cols
int btf_store_a_cols(BTF *btf, int (*col)(void *info, int j, int ind[],
      double val[]), void *info, int ind[], double val[]);
/* store pattern of matrix A in column-wise format */

#define btf_make_blocks _glp_btf_make_blocks
int btf_make_blocks(BTF *btf);
/* permutations to block triangular form */

#define btf_check_blocks _glp_btf_check_blocks
void btf_check_blocks(BTF *btf);
/* check structure of matrix A~ */

#define btf_build_a_rows _glp_btf_build_a_rows
void btf_build_a_rows(BTF *btf, int len[/*1+n*/]);
/* build matrix A in row-wise format */

#define btf_a_solve _glp_btf_a_solve
void btf_a_solve(BTF *btf, double b[/*1+n*/], double x[/*1+n*/],
      double w1[/*1+n*/], double w2[/*1+n*/]);
/* solve system A * x = b */

#define btf_at_solve _glp_btf_at_solve
void btf_at_solve(BTF *btf, double b[/*1+n*/], double x[/*1+n*/],
      double w1[/*1+n*/], double w2[/*1+n*/]);
/* solve system A'* x = b */

#define btf_at_solve1 _glp_btf_at_solve1
void btf_at_solve1(BTF *btf, double e[/*1+n*/], double y[/*1+n*/],
      double w1[/*1+n*/], double w2[/*1+n*/]);
/* solve system A'* y = e' to cause growth in y */

#define btf_estimate_norm _glp_btf_estimate_norm
double btf_estimate_norm(BTF *btf, double w1[/*1+n*/], double
      w2[/*1+n*/], double w3[/*1+n*/], double w4[/*1+n*/]);
/* estimate 1-norm of inv(A) */


#define mc13d _glp_mc13d
int mc13d(int n, const int icn[], const int ip[], const int lenr[],
      int ior[], int ib[], int lowl[], int numb[], int prev[]);
/* permutations to block triangular form */


/***********************************************************************
*  NAME
*
*  mc13d - permutations to block triangular form
*
*  SYNOPSIS
*
*  #include "mc13d.h"
*  int mc13d(int n, const int icn[], const int ip[], const int lenr[],
*     int ior[], int ib[], int lowl[], int numb[], int prev[]);
*
*  DESCRIPTION
*
*  Given the column numbers of the nonzeros in each row of the sparse
*  matrix, the routine mc13d finds a symmetric permutation that makes
*  the matrix block lower triangular.
*
*  INPUT PARAMETERS
*
*  n     order of the matrix.
*
*  icn   array containing the column indices of the non-zeros. Those
*        belonging to a single row must be contiguous but the ordering
*        of column indices within each row is unimportant and wasted
*        space between rows is permitted.
*
*  ip    ip[i], i = 1,2,...,n, is the position in array icn of the
*        first column index of a non-zero in row i.
*
*  lenr  lenr[i], i = 1,2,...,n, is the number of non-zeros in row i.
*
*  OUTPUT PARAMETERS
*
*  ior   ior[i], i = 1,2,...,n, gives the position on the original
*        ordering of the row or column which is in position i in the
*        permuted form.
*
*  ib    ib[i], i = 1,2,...,num, is the row number in the permuted
*        matrix of the beginning of block i, 1 <= num <= n.
*
*  WORKING ARRAYS
*
*  arp   working array of length [1+n], where arp[0] is not used.
*        arp[i] is one less than the number of unsearched edges leaving
*        node i. At the end of the algorithm it is set to a permutation
*        which puts the matrix in block lower triangular form.
*
*  ib    working array of length [1+n], where ib[0] is not used.
*        ib[i] is the position in the ordering of the start of the ith
*        block. ib[n+1-i] holds the node number of the ith node on the
*        stack.
*
*  lowl  working array of length [1+n], where lowl[0] is not used.
*        lowl[i] is the smallest stack position of any node to which a
*        path from node i has been found. It is set to n+1 when node i
*        is removed from the stack.
*
*  numb  working array of length [1+n], where numb[0] is not used.
*        numb[i] is the position of node i in the stack if it is on it,
*        is the permuted order of node i for those nodes whose final
*        position has been found and is otherwise zero.
*
*  prev  working array of length [1+n], where prev[0] is not used.
*        prev[i] is the node at the end of the path when node i was
*        placed on the stack.
*
*  RETURNS
*
*  The routine mc13d returns num, the number of blocks found. */

int mc13d(int n, const int icn[], const int ip[], const int lenr[],
      int ior[], int ib[], int lowl[], int numb[], int prev[])
{     int *arp = ior;
      int dummy, i, i1, i2, icnt, ii, isn, ist, ist1, iv, iw, j, lcnt,
         nnm1, num, stp;
      /* icnt is the number of nodes whose positions in final ordering
       * have been found. */
      icnt = 0;
      /* num is the number of blocks that have been found. */
      num = 0;
      nnm1 = n + n - 1;
      /* Initialization of arrays. */
      for (j = 1; j <= n; j++)
      {  numb[j] = 0;
         arp[j] = lenr[j] - 1;
      }
      for (isn = 1; isn <= n; isn++)
      {  /* Look for a starting node. */
         if (numb[isn] != 0) continue;
         iv = isn;
         /* ist is the number of nodes on the stack ... it is the stack
          * pointer. */
         ist = 1;
         /* Put node iv at beginning of stack. */
         lowl[iv] = numb[iv] = 1;
         ib[n] = iv;
         /* The body of this loop puts a new node on the stack or
          * backtracks. */
         for (dummy = 1; dummy <= nnm1; dummy++)
         {  i1 = arp[iv];
            /* Have all edges leaving node iv been searched? */
            if (i1 >= 0)
            {  i2 = ip[iv] + lenr[iv] - 1;
               i1 = i2 - i1;
               /* Look at edges leaving node iv until one enters a new
                * node or all edges are exhausted. */
               for (ii = i1; ii <= i2; ii++)
               {  iw = icn[ii];
                  /* Has node iw been on stack already? */
                  if (numb[iw] == 0) goto L70;
                  /* Update value of lowl[iv] if necessary. */
                  if (lowl[iw] < lowl[iv]) lowl[iv] = lowl[iw];
               }
               /* There are no more edges leaving node iv. */
               arp[iv] = -1;
            }
            /* Is node iv the root of a block? */
            if (lowl[iv] < numb[iv]) goto L60;
            /* Order nodes in a block. */
            num++;
            ist1 = n + 1 - ist;
            lcnt = icnt + 1;
            /* Peel block off the top of the stack starting at the top
             * and working down to the root of the block. */
            for (stp = ist1; stp <= n; stp++)
            {  iw = ib[stp];
               lowl[iw] = n + 1;
               numb[iw] = ++icnt;
               if (iw == iv) break;
            }
            ist = n - stp;
            ib[num] = lcnt;
            /* Are there any nodes left on the stack? */
            if (ist != 0) goto L60;
            /* Have all the nodes been ordered? */
            if (icnt < n) break;
            goto L100;
L60:        /* Backtrack to previous node on path. */
            iw = iv;
            iv = prev[iv];
            /* Update value of lowl[iv] if necessary. */
            if (lowl[iw] < lowl[iv]) lowl[iv] = lowl[iw];
            continue;
L70:        /* Put new node on the stack. */
            arp[iv] = i2 - ii - 1;
            prev[iw] = iv;
            iv = iw;
            lowl[iv] = numb[iv] = ++ist;
            ib[n+1-ist] = iv;
         }
      }
L100: /* Put permutation in the required form. */
      for (i = 1; i <= n; i++)
         arp[numb[i]] = i;
      return num;
}

/**********************************************************************/

#ifdef GLP_TEST

void test(int n, int ipp);

int main(void)
{     /* test program for routine mc13d */
      test( 1,   0);
      test( 2,   1);
      test( 2,   2);
      test( 3,   3);
      test( 4,   4);
      test( 5,  10);
      test(10,  10);
      test(10,  20);
      test(20,  20);
      test(20,  50);
      test(50,  50);
      test(50, 200);
      return 0;
}

void fa01bs(int max, int *nrand);

void setup(int n, char a[1+50][1+50], int ip[], int icn[], int lenr[]);

void test(int n, int ipp)
{     int ip[1+50], icn[1+1000], ior[1+50], ib[1+51], iw[1+150],
         lenr[1+50];
      char a[1+50][1+50], hold[1+100];
      int i, ii, iblock, ij, index, j, jblock, jj, k9, num;
      xprintf("\n\n\nMatrix is of order %d and has %d off-diagonal non-"
         "zeros\n", n, ipp);
      for (j = 1; j <= n; j++)
      {  for (i = 1; i <= n; i++)
            a[i][j] = 0;
         a[j][j] = 1;
      }
      for (k9 = 1; k9 <= ipp; k9++)
      {  /* these statements should be replaced by calls to your
          * favorite random number generator to place two pseudo-random
          * numbers between 1 and n in the variables i and j */
         for (;;)
         {  fa01bs(n, &i);
            fa01bs(n, &j);
            if (!a[i][j]) break;
         }
         a[i][j] = 1;
      }
      /* setup converts matrix a[i,j] to required sparsity-oriented
       * storage format */
      setup(n, a, ip, icn, lenr);
      num = mc13d(n, icn, ip, lenr, ior, ib, &iw[0], &iw[n], &iw[n+n]);
      /* output reordered matrix with blocking to improve clarity */
      xprintf("\nThe reordered matrix which has %d block%s is of the fo"
         "rm\n", num, num == 1 ? "" : "s");
      ib[num+1] = n + 1;
      index = 100;
      iblock = 1;
      for (i = 1; i <= n; i++)
      {  for (ij = 1; ij <= index; ij++)
            hold[ij] = ' ';
         if (i == ib[iblock])
         {  xprintf("\n");
            iblock++;
         }
         jblock = 1;
         index = 0;
         for (j = 1; j <= n; j++)
         {  if (j == ib[jblock])
            {  hold[++index] = ' ';
               jblock++;
            }
            ii = ior[i];
            jj = ior[j];
            hold[++index] = (char)(a[ii][jj] ? 'X' : '0');
         }
         xprintf("%.*s\n", index, &hold[1]);
      }
      xprintf("\nThe starting point for each block is given by\n");
      for (i = 1; i <= num; i++)
      {  if ((i - 1) % 12 == 0) xprintf("\n");
         xprintf(" %4d", ib[i]);
      }
      xprintf("\n");
      return;
}

void setup(int n, char a[1+50][1+50], int ip[], int icn[], int lenr[])
{     int i, j, ind;
      for (i = 1; i <= n; i++)
         lenr[i] = 0;
      ind = 1;
      for (i = 1; i <= n; i++)
      {  ip[i] = ind;
         for (j = 1; j <= n; j++)
         {  if (a[i][j])
            {  lenr[i]++;
               icn[ind++] = j;
            }
         }
      }
      return;
}

double g = 1431655765.0;

double fa01as(int i)
{     /* random number generator */
      g = fmod(g * 9228907.0, 4294967296.0);
      if (i >= 0)
         return g / 4294967296.0;
      else
         return 2.0 * g / 4294967296.0 - 1.0;
}

void fa01bs(int max, int *nrand)
{     *nrand = (int)(fa01as(1) * (double)max) + 1;
      return;
}
#endif

#define mc21a _glp_mc21a
int mc21a(int n, const int icn[], const int ip[], const int lenr[],
      int iperm[], int pr[], int arp[], int cv[], int out[]);
/* permutations for zero-free diagonal */


/***********************************************************************
*  NAME
*
*  mc21a - permutations for zero-free diagonal
*
*  SYNOPSIS
*
*  #include "mc21a.h"
*  int mc21a(int n, const int icn[], const int ip[], const int lenr[],
*     int iperm[], int pr[], int arp[], int cv[], int out[]);
*
*  DESCRIPTION
*
*  Given the pattern of nonzeros of a sparse matrix, the routine mc21a
*  attempts to find a permutation of its rows that makes the matrix have
*  no zeros on its diagonal.
*
*  INPUT PARAMETERS
*
*  n     order of matrix.
*
*  icn   array containing the column indices of the non-zeros. Those
*        belonging to a single row must be contiguous but the ordering
*        of column indices within each row is unimportant and wasted
*        space between rows is permitted.
*
*  ip    ip[i], i = 1,2,...,n, is the position in array icn of the
*        first column index of a non-zero in row i.
*
*  lenr  lenr[i], i = 1,2,...,n, is the number of non-zeros in row i.
*
*  OUTPUT PARAMETER
*
*  iperm contains permutation to make diagonal have the smallest
*        number of zeros on it. Elements (iperm[i], i), i = 1,2,...,n,
*        are non-zero at the end of the algorithm unless the matrix is
*        structurally singular. In this case, (iperm[i], i) will be
*        zero for n - numnz entries.
*
*  WORKING ARRAYS
*
*  pr    working array of length [1+n], where pr[0] is not used.
*        pr[i] is the previous row to i in the depth first search.
*
*  arp   working array of length [1+n], where arp[0] is not used.
*        arp[i] is one less than the number of non-zeros in row i which
*        have not been scanned when looking for a cheap assignment.
*
*  cv    working array of length [1+n], where cv[0] is not used.
*        cv[i] is the most recent row extension at which column i was
*        visited.
*
*  out   working array of length [1+n], where out[0] is not used.
*        out[i] is one less than the number of non-zeros in row i
*        which have not been scanned during one pass through the main
*        loop.
*
*  RETURNS
*
*  The routine mc21a returns numnz, the number of non-zeros on diagonal
*  of permuted matrix. */

int mc21a(int n, const int icn[], const int ip[], const int lenr[],
      int iperm[], int pr[], int arp[], int cv[], int out[])
{     int i, ii, in1, in2, j, j1, jord, k, kk, numnz;
      /* Initialization of arrays. */
      for (i = 1; i <= n; i++)
      {  arp[i] = lenr[i] - 1;
         cv[i] = iperm[i] = 0;
      }
      numnz = 0;
      /* Main loop. */
      /* Each pass round this loop either results in a new assignment
       * or gives a row with no assignment. */
      for (jord = 1; jord <= n; jord++)
      {  j = jord;
         pr[j] = -1;
         for (k = 1; k <= jord; k++)
         {  /* Look for a cheap assignment. */
            in1 = arp[j];
            if (in1 >= 0)
            {  in2 = ip[j] + lenr[j] - 1;
               in1 = in2 - in1;
               for (ii = in1; ii <= in2; ii++)
               {  i = icn[ii];
                  if (iperm[i] == 0) goto L110;
               }
               /* No cheap assignment in row. */
               arp[j] = -1;
            }
            /* Begin looking for assignment chain starting with row j.*/
            out[j] = lenr[j] - 1;
            /* Inner loop. Extends chain by one or backtracks. */
            for (kk = 1; kk <= jord; kk++)
            {  in1 = out[j];
               if (in1 >= 0)
               {  in2 = ip[j] + lenr[j] - 1;
                  in1 = in2 - in1;
                  /* Forward scan. */
                  for (ii = in1; ii <= in2; ii++)
                  {  i = icn[ii];
                     if (cv[i] != jord)
                     {  /* Column i has not yet been accessed during
                         * this pass. */
                        j1 = j;
                        j = iperm[i];
                        cv[i] = jord;
                        pr[j] = j1;
                        out[j1] = in2 - ii - 1;
                        goto L100;
                     }
                  }
               }
               /* Backtracking step. */
               j = pr[j];
               if (j == -1) goto L130;
            }
L100:       ;
         }
L110:    /* New assignment is made. */
         iperm[i] = j;
         arp[j] = in2 - ii - 1;
         numnz++;
         for (k = 1; k <= jord; k++)
         {  j = pr[j];
            if (j == -1) break;
            ii = ip[j] + lenr[j] - out[j] - 2;
            i = icn[ii];
            iperm[i] = j;
         }
L130:    ;
      }
      /* If matrix is structurally singular, we now complete the
       * permutation iperm. */
      if (numnz < n)
      {  for (i = 1; i <= n; i++)
            arp[i] = 0;
         k = 0;
         for (i = 1; i <= n; i++)
         {  if (iperm[i] == 0)
               out[++k] = i;
            else
               arp[iperm[i]] = i;
         }
         k = 0;
         for (i = 1; i <= n; i++)
         {  if (arp[i] == 0)
               iperm[out[++k]] = i;
         }
      }
      return numnz;
}

/**********************************************************************/

#ifdef GLP_TEST

int sing;

void ranmat(int m, int n, int icn[], int iptr[], int nnnp1, int *knum,
      int iw[]);

void fa01bs(int max, int *nrand);

int main(void)
{     /* test program for the routine mc21a */
      /* these runs on random matrices cause all possible statements in
       * mc21a to be executed */
      int i, iold, j, j1, j2, jj, knum, l, licn, n, nov4, num, numnz;
      int ip[1+21], icn[1+1000], iperm[1+20], lenr[1+20], iw1[1+80];
      licn = 1000;
      /* run on random matrices of orders 1 through 20 */
      for (n = 1; n <= 20; n++)
      {  nov4 = n / 4;
         if (nov4 < 1) nov4 = 1;
L10:     fa01bs(nov4, &l);
         knum = l * n;
         /* knum is requested number of non-zeros in random matrix */
         if (knum > licn) goto L10;
         /* if sing is false, matrix is guaranteed structurally
          * non-singular */
         sing = ((n / 2) * 2 == n);
         /* call to subroutine to generate random matrix */
         ranmat(n, n, icn, ip, n+1, &knum, iw1);
         /* knum is now actual number of non-zeros in random matrix */
         if (knum > licn) goto L10;
         xprintf("n = %2d; nz = %4d; sing = %d\n", n, knum, sing);
         /* set up array of row lengths */
         for (i = 1; i <= n; i++)
            lenr[i] = ip[i+1] - ip[i];
         /* call to mc21a */
         numnz = mc21a(n, icn, ip, lenr, iperm, &iw1[0], &iw1[n],
            &iw1[n+n], &iw1[n+n+n]);
         /* testing to see if there are numnz non-zeros on the diagonal
          * of the permuted matrix. */
         num = 0;
         for (i = 1; i <= n; i++)
         {  iold = iperm[i];
            j1 = ip[iold];
            j2 = j1 + lenr[iold] - 1;
            if (j2 < j1) continue;
            for (jj = j1; jj <= j2; jj++)
            {  j = icn[jj];
               if (j == i)
               {  num++;
                  break;
               }
            }
         }
         if (num != numnz)
            xprintf("Failure in mc21a, numnz = %d instead of %d\n",
               numnz, num);
      }
      return 0;
}

void ranmat(int m, int n, int icn[], int iptr[], int nnnp1, int *knum,
      int iw[])
{     /* subroutine to generate random matrix */
      int i, ii, inum, j, lrow, matnum;
      inum = (*knum / n) * 2;
      if (inum > n-1) inum = n-1;
      matnum = 1;
      /* each pass through this loop generates a row of the matrix */
      for (j = 1; j <= m; j++)
      {  iptr[j] = matnum;
         if (!(sing || j > n))
            icn[matnum++] = j;
         if (n == 1) continue;
         for (i = 1; i <= n; i++) iw[i] = 0;
         if (!sing) iw[j] = 1;
         fa01bs(inum, &lrow);
         lrow--;
         if (lrow == 0) continue;
         /* lrow off-diagonal non-zeros in row j of the matrix */
         for (ii = 1; ii <= lrow; ii++)
         {  for (;;)
            {  fa01bs(n, &i);
               if (iw[i] != 1) break;
            }
            iw[i] = 1;
            icn[matnum++] = i;
         }
      }
      for (i = m+1; i <= nnnp1; i++)
         iptr[i] = matnum;
      *knum = matnum - 1;
      return;
}

double g = 1431655765.0;

double fa01as(int i)
{     /* random number generator */
      g = fmod(g * 9228907.0, 4294967296.0);
      if (i >= 0)
         return g / 4294967296.0;
      else
         return 2.0 * g / 4294967296.0 - 1.0;
}

void fa01bs(int max, int *nrand)
{     *nrand = (int)(fa01as(1) * (double)max) + 1;
      return;
}
#endif

/***********************************************************************
*  btf_store_a_cols - store pattern of matrix A in column-wise format
*
*  This routine stores the pattern (that is, only indices of non-zero
*  elements) of the original matrix A in column-wise format.
*
*  On exit the routine returns the number of non-zeros in matrix A. */

int btf_store_a_cols(BTF *btf, int (*col)(void *info, int j, int ind[],
      double val[]), void *info, int ind[], double val[])
{     int n = btf->n;
      SVA *sva = btf->sva;
      int *sv_ind = sva->ind;
      int ac_ref = btf->ac_ref;
      int *ac_ptr = &sva->ptr[ac_ref-1];
      int *ac_len = &sva->len[ac_ref-1];
      int j, len, ptr, nnz;
      nnz = 0;
      for (j = 1; j <= n; j++)
      {  /* get j-th column */
         len = col(info, j, ind, val);
         xassert(0 <= len && len <= n);
         /* reserve locations for j-th column */
         if (len > 0)
         {  if (sva->r_ptr - sva->m_ptr < len)
            {  sva_more_space(sva, len);
               sv_ind = sva->ind;
            }
            sva_reserve_cap(sva, ac_ref+(j-1), len);
         }
         /* store pattern of j-th column */
         ptr = ac_ptr[j];
         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));
         ac_len[j] = len;
         nnz += len;
      }
      return nnz;
}

/***********************************************************************
*  btf_make_blocks - permutations to block triangular form
*
*  This routine analyzes the pattern of the original matrix A and
*  determines permutation matrices P and Q such that A = P * A~* Q,
*  where A~ is an upper block triangular matrix.
*
*  On exit the routine returns symbolic rank of matrix A. */

int btf_make_blocks(BTF *btf)
{     int n = btf->n;
      SVA *sva = btf->sva;
      int *sv_ind = sva->ind;
      int *pp_ind = btf->pp_ind;
      int *pp_inv = btf->pp_inv;
      int *qq_ind = btf->qq_ind;
      int *qq_inv = btf->qq_inv;
      int *beg = btf->beg;
      int ac_ref = btf->ac_ref;
      int *ac_ptr = &sva->ptr[ac_ref-1];
      int *ac_len = &sva->len[ac_ref-1];
      int i, j, rank, *iperm, *pr, *arp, *cv, *out, *ip, *lenr, *lowl,
         *numb, *prev;
      /* determine column permutation matrix M such that matrix A * M
       * has zero-free diagonal */
      iperm = qq_inv; /* matrix M */
      pr  = btf->p1_ind; /* working array */
      arp = btf->p1_inv; /* working array */
      cv  = btf->q1_ind; /* working array */
      out = btf->q1_inv; /* working array */
      rank = mc21a(n, sv_ind, ac_ptr, ac_len, iperm, pr, arp, cv, out);
      xassert(0 <= rank && rank <= n);
      if (rank < n)
      {  /* A is structurally singular (rank is its symbolic rank) */
         goto done;
      }
      /* build pattern of matrix A * M */
      ip   = pp_ind; /* working array */
      lenr = qq_ind; /* working array */
      for (j = 1; j <= n; j++)
      {  ip[j] = ac_ptr[iperm[j]];
         lenr[j] = ac_len[iperm[j]];
      }
      /* determine symmetric permutation matrix S such that matrix
       * S * (A * M) * S' = A~ is upper block triangular */
      lowl = btf->p1_ind; /* working array */
      numb = btf->p1_inv; /* working array */
      prev = btf->q1_ind; /* working array */
      btf->num =
         mc13d(n, sv_ind, ip, lenr, pp_inv, beg, lowl, numb, prev);
      xassert(beg[1] == 1);
      beg[btf->num+1] = n+1;
      /* A * M = S' * A~ * S ==> A = S' * A~ * (S * M') */
      /* determine permutation matrix P = S' */
      for (j = 1; j <= n; j++)
         pp_ind[pp_inv[j]] = j;
      /* determine permutation matrix Q = S * M' = P' * M' */
      for (i = 1; i <= n; i++)
         qq_ind[i] = iperm[pp_inv[i]];
      for (i = 1; i <= n; i++)
         qq_inv[qq_ind[i]] = i;
done: return rank;
}

/***********************************************************************
*  btf_check_blocks - check structure of matrix A~
*
*  This routine checks that structure of upper block triangular matrix
*  A~ is correct.
*
*  NOTE: For testing/debugging only. */

void btf_check_blocks(BTF *btf)
{     int n = btf->n;
      SVA *sva = btf->sva;
      int *sv_ind = sva->ind;
      int *pp_ind = btf->pp_ind;
      int *pp_inv = btf->pp_inv;
      int *qq_ind = btf->qq_ind;
      int *qq_inv = btf->qq_inv;
      int num = btf->num;
      int *beg = btf->beg;
      int ac_ref = btf->ac_ref;
      int *ac_ptr = &sva->ptr[ac_ref-1];
      int *ac_len = &sva->len[ac_ref-1];
      int i, ii, j, jj, k, size, ptr, end, diag;
      xassert(n > 0);
      /* check permutation matrices P and Q */
      for (k = 1; k <= n; k++)
      {  xassert(1 <= pp_ind[k] && pp_ind[k] <= n);
         xassert(pp_inv[pp_ind[k]] == k);
         xassert(1 <= qq_ind[k] && qq_ind[k] <= n);
         xassert(qq_inv[qq_ind[k]] == k);
      }
      /* check that matrix A~ is upper block triangular with non-zero
       * diagonal */
      xassert(1 <= num && num <= n);
      xassert(beg[1] == 1);
      xassert(beg[num+1] == n+1);
      /* walk thru blocks of A~ */
      for (k = 1; k <= num; k++)
      {  /* determine size of k-th block */
         size = beg[k+1] - beg[k];
         xassert(size >= 1);
         /* walk thru columns of k-th block */
         for (jj = beg[k]; jj < beg[k+1]; jj++)
         {  diag = 0;
            /* jj-th column of A~ = j-th column of A */
            j = qq_ind[jj];
            /* walk thru elements of j-th column of A */
            ptr = ac_ptr[j];
            end = ptr + ac_len[j];
            for (; ptr < end; ptr++)
            {  /* determine row index of a[i,j] */
               i = sv_ind[ptr];
               /* i-th row of A = ii-th row of A~ */
               ii = pp_ind[i];
               /* a~[ii,jj] should not be below k-th block */
               xassert(ii < beg[k+1]);
               if (ii == jj)
               {  /* non-zero diagonal element of A~ encountered */
                  diag = 1;
               }
            }
            xassert(diag);
         }
      }
      return;
}

/***********************************************************************
*  btf_build_a_rows - build matrix A in row-wise format
*
*  This routine builds the row-wise representation of matrix A in the
*  right part of SVA using its column-wise representation.
*
*  The working array len should have at least 1+n elements (len[0] is
*  not used). */

void btf_build_a_rows(BTF *btf, int len[/*1+n*/])
{     int n = btf->n;
      SVA *sva = btf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int ar_ref = btf->ar_ref;
      int *ar_ptr = &sva->ptr[ar_ref-1];
      int *ar_len = &sva->len[ar_ref-1];
      int ac_ref = btf->ac_ref;
      int *ac_ptr = &sva->ptr[ac_ref-1];
      int *ac_len = &sva->len[ac_ref-1];
      int i, j, end, nnz, ptr, ptr1;
      /* calculate the number of non-zeros in each row of matrix A and
       * the total number of non-zeros */
      nnz = 0;
      for (i = 1; i <= n; i++)
         len[i] = 0;
      for (j = 1; j <= n; j++)
      {  nnz += ac_len[j];
         for (end = (ptr = ac_ptr[j]) + ac_len[j]; ptr < end; ptr++)
            len[sv_ind[ptr]]++;
      }
      /* we need at least nnz free locations in SVA */
      if (sva->r_ptr - sva->m_ptr < nnz)
      {  sva_more_space(sva, nnz);
         sv_ind = sva->ind;
         sv_val = sva->val;
      }
      /* reserve locations for rows of matrix A */
      for (i = 1; i <= n; i++)
      {  if (len[i] > 0)
            sva_reserve_cap(sva, ar_ref-1+i, len[i]);
         ar_len[i] = len[i];
      }
      /* walk thru columns of matrix A and build its rows */
      for (j = 1; j <= n; j++)
      {  for (end = (ptr = ac_ptr[j]) + ac_len[j]; ptr < end; ptr++)
         {  i = sv_ind[ptr];
            sv_ind[ptr1 = ar_ptr[i] + (--len[i])] = j;
            sv_val[ptr1] = sv_val[ptr];
         }
      }
      return;
}

/***********************************************************************
*  btf_a_solve - solve system A * x = b
*
*  This routine solves the system A * x = b, where A is the original
*  matrix.
*
*  On entry the array b should contain elements of the right-hand size
*  vector b in locations b[1], ..., b[n], where n is the order of the
*  matrix A. On exit the array x will contain elements of the solution
*  vector in locations x[1], ..., x[n]. Note that the array b will be
*  clobbered on exit.
*
*  The routine also uses locations [1], ..., [max_size] of two working
*  arrays w1 and w2, where max_size is the maximal size of diagonal
*  blocks in BT-factorization (max_size <= n). */

void btf_a_solve(BTF *btf, double b[/*1+n*/], double x[/*1+n*/],
      double w1[/*1+n*/], double w2[/*1+n*/])
{     SVA *sva = btf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int *pp_inv = btf->pp_inv;
      int *qq_ind = btf->qq_ind;
      int num = btf->num;
      int *beg = btf->beg;
      int ac_ref = btf->ac_ref;
      int *ac_ptr = &sva->ptr[ac_ref-1];
      int *ac_len = &sva->len[ac_ref-1];
      double *bb = w1;
      double *xx = w2;
      LUF luf;
      int i, j, jj, k, beg_k, flag;
      double t;
      for (k = num; k >= 1; k--)
      {  /* determine order of diagonal block A~[k,k] */
         luf.n = beg[k+1] - (beg_k = beg[k]);
         if (luf.n == 1)
         {  /* trivial case */
            /* solve system A~[k,k] * X[k] = B[k] */
            t = x[qq_ind[beg_k]] =
               b[pp_inv[beg_k]] / btf->vr_piv[beg_k];
            /* substitute X[k] into other equations */
            if (t != 0.0)
            {  int ptr = ac_ptr[qq_ind[beg_k]];
               int end = ptr + ac_len[qq_ind[beg_k]];
               for (; ptr < end; ptr++)
                  b[sv_ind[ptr]] -= sv_val[ptr] * t;
            }
         }
         else
         {  /* general case */
            /* construct B[k] */
            flag = 0;
            for (i = 1; i <= luf.n; i++)
            {  if ((bb[i] = b[pp_inv[i + (beg_k-1)]]) != 0.0)
                  flag = 1;
            }
            /* solve system A~[k,k] * X[k] = B[k] */
            if (!flag)
            {  /* B[k] = 0, so X[k] = 0 */
               for (j = 1; j <= luf.n; j++)
                  x[qq_ind[j + (beg_k-1)]] = 0.0;
               continue;
            }
            luf.sva = sva;
            luf.fr_ref = btf->fr_ref + (beg_k-1);
            luf.fc_ref = btf->fc_ref + (beg_k-1);
            luf.vr_ref = btf->vr_ref + (beg_k-1);
            luf.vr_piv = btf->vr_piv + (beg_k-1);
            luf.vc_ref = btf->vc_ref + (beg_k-1);
            luf.pp_ind = btf->p1_ind + (beg_k-1);
            luf.pp_inv = btf->p1_inv + (beg_k-1);
            luf.qq_ind = btf->q1_ind + (beg_k-1);
            luf.qq_inv = btf->q1_inv + (beg_k-1);
            luf_f_solve(&luf, bb);
            luf_v_solve(&luf, bb, xx);
            /* store X[k] and substitute it into other equations */
            for (j = 1; j <= luf.n; j++)
            {  jj = j + (beg_k-1);
               t = x[qq_ind[jj]] = xx[j];
               if (t != 0.0)
               {  int ptr = ac_ptr[qq_ind[jj]];
                  int end = ptr + ac_len[qq_ind[jj]];
                  for (; ptr < end; ptr++)
                     b[sv_ind[ptr]] -= sv_val[ptr] * t;
               }
            }
         }
      }
      return;
}

/***********************************************************************
*  btf_at_solve - solve system A'* x = b
*
*  This routine solves the system A'* x = b, where A' is a matrix
*  transposed to the original matrix A.
*
*  On entry the array b should contain elements of the right-hand size
*  vector b in locations b[1], ..., b[n], where n is the order of the
*  matrix A. On exit the array x will contain elements of the solution
*  vector in locations x[1], ..., x[n]. Note that the array b will be
*  clobbered on exit.
*
*  The routine also uses locations [1], ..., [max_size] of two working
*  arrays w1 and w2, where max_size is the maximal size of diagonal
*  blocks in BT-factorization (max_size <= n). */

void btf_at_solve(BTF *btf, double b[/*1+n*/], double x[/*1+n*/],
      double w1[/*1+n*/], double w2[/*1+n*/])
{     SVA *sva = btf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int *pp_inv = btf->pp_inv;
      int *qq_ind = btf->qq_ind;
      int num = btf->num;
      int *beg = btf->beg;
      int ar_ref = btf->ar_ref;
      int *ar_ptr = &sva->ptr[ar_ref-1];
      int *ar_len = &sva->len[ar_ref-1];
      double *bb = w1;
      double *xx = w2;
      LUF luf;
      int i, j, jj, k, beg_k, flag;
      double t;
      for (k = 1; k <= num; k++)
      {  /* determine order of diagonal block A~[k,k] */
         luf.n = beg[k+1] - (beg_k = beg[k]);
         if (luf.n == 1)
         {  /* trivial case */
            /* solve system A~'[k,k] * X[k] = B[k] */
            t = x[pp_inv[beg_k]] =
               b[qq_ind[beg_k]] / btf->vr_piv[beg_k];
            /* substitute X[k] into other equations */
            if (t != 0.0)
            {  int ptr = ar_ptr[pp_inv[beg_k]];
               int end = ptr + ar_len[pp_inv[beg_k]];
               for (; ptr < end; ptr++)
                  b[sv_ind[ptr]] -= sv_val[ptr] * t;
            }
         }
         else
         {  /* general case */
            /* construct B[k] */
            flag = 0;
            for (i = 1; i <= luf.n; i++)
            {  if ((bb[i] = b[qq_ind[i + (beg_k-1)]]) != 0.0)
                  flag = 1;
            }
            /* solve system A~'[k,k] * X[k] = B[k] */
            if (!flag)
            {  /* B[k] = 0, so X[k] = 0 */
               for (j = 1; j <= luf.n; j++)
                  x[pp_inv[j + (beg_k-1)]] = 0.0;
               continue;
            }
            luf.sva = sva;
            luf.fr_ref = btf->fr_ref + (beg_k-1);
            luf.fc_ref = btf->fc_ref + (beg_k-1);
            luf.vr_ref = btf->vr_ref + (beg_k-1);
            luf.vr_piv = btf->vr_piv + (beg_k-1);
            luf.vc_ref = btf->vc_ref + (beg_k-1);
            luf.pp_ind = btf->p1_ind + (beg_k-1);
            luf.pp_inv = btf->p1_inv + (beg_k-1);
            luf.qq_ind = btf->q1_ind + (beg_k-1);
            luf.qq_inv = btf->q1_inv + (beg_k-1);
            luf_vt_solve(&luf, bb, xx);
            luf_ft_solve(&luf, xx);
            /* store X[k] and substitute it into other equations */
            for (j = 1; j <= luf.n; j++)
            {  jj = j + (beg_k-1);
               t = x[pp_inv[jj]] = xx[j];
               if (t != 0.0)
               {  int ptr = ar_ptr[pp_inv[jj]];
                  int end = ptr + ar_len[pp_inv[jj]];
                  for (; ptr < end; ptr++)
                     b[sv_ind[ptr]] -= sv_val[ptr] * t;
               }
            }
         }
      }
      return;
}

/***********************************************************************
*  btf_at_solve1 - solve system A'* y = e' to cause growth in y
*
*  This routine is a special version of btf_at_solve. It solves the
*  system A'* y = e' = e + delta e, where A' is a matrix transposed to
*  the original matrix A, e is the specified right-hand side vector,
*  and delta e is a vector of +1 and -1 chosen to cause growth in the
*  solution vector y.
*
*  On entry the array e should contain elements of the right-hand size
*  vector e in locations e[1], ..., e[n], where n is the order of the
*  matrix A. On exit the array y will contain elements of the solution
*  vector in locations y[1], ..., y[n]. Note that the array e will be
*  clobbered on exit.
*
*  The routine also uses locations [1], ..., [max_size] of two working
*  arrays w1 and w2, where max_size is the maximal size of diagonal
*  blocks in BT-factorization (max_size <= n). */

void btf_at_solve1(BTF *btf, double e[/*1+n*/], double y[/*1+n*/],
      double w1[/*1+n*/], double w2[/*1+n*/])
{     SVA *sva = btf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int *pp_inv = btf->pp_inv;
      int *qq_ind = btf->qq_ind;
      int num = btf->num;
      int *beg = btf->beg;
      int ar_ref = btf->ar_ref;
      int *ar_ptr = &sva->ptr[ar_ref-1];
      int *ar_len = &sva->len[ar_ref-1];
      double *ee = w1;
      double *yy = w2;
      LUF luf;
      int i, j, jj, k, beg_k, ptr, end;
      double e_k, y_k;
      for (k = 1; k <= num; k++)
      {  /* determine order of diagonal block A~[k,k] */
         luf.n = beg[k+1] - (beg_k = beg[k]);
         if (luf.n == 1)
         {  /* trivial case */
            /* determine E'[k] = E[k] + delta E[k] */
            e_k = e[qq_ind[beg_k]];
            e_k = (e_k >= 0.0 ? e_k + 1.0 : e_k - 1.0);
            /* solve system A~'[k,k] * Y[k] = E[k] */
            y_k = y[pp_inv[beg_k]] = e_k / btf->vr_piv[beg_k];
            /* substitute Y[k] into other equations */
            ptr = ar_ptr[pp_inv[beg_k]];
            end = ptr + ar_len[pp_inv[beg_k]];
            for (; ptr < end; ptr++)
               e[sv_ind[ptr]] -= sv_val[ptr] * y_k;
         }
         else
         {  /* general case */
            /* construct E[k] */
            for (i = 1; i <= luf.n; i++)
               ee[i] = e[qq_ind[i + (beg_k-1)]];
            /* solve system A~'[k,k] * Y[k] = E[k] + delta E[k] */
            luf.sva = sva;
            luf.fr_ref = btf->fr_ref + (beg_k-1);
            luf.fc_ref = btf->fc_ref + (beg_k-1);
            luf.vr_ref = btf->vr_ref + (beg_k-1);
            luf.vr_piv = btf->vr_piv + (beg_k-1);
            luf.vc_ref = btf->vc_ref + (beg_k-1);
            luf.pp_ind = btf->p1_ind + (beg_k-1);
            luf.pp_inv = btf->p1_inv + (beg_k-1);
            luf.qq_ind = btf->q1_ind + (beg_k-1);
            luf.qq_inv = btf->q1_inv + (beg_k-1);
            luf_vt_solve1(&luf, ee, yy);
            luf_ft_solve(&luf, yy);
            /* store Y[k] and substitute it into other equations */
            for (j = 1; j <= luf.n; j++)
            {  jj = j + (beg_k-1);
               y_k = y[pp_inv[jj]] = yy[j];
               ptr = ar_ptr[pp_inv[jj]];
               end = ptr + ar_len[pp_inv[jj]];
               for (; ptr < end; ptr++)
                  e[sv_ind[ptr]] -= sv_val[ptr] * y_k;
            }
         }
      }
      return;
}

/***********************************************************************
*  btf_estimate_norm - estimate 1-norm of inv(A)
*
*  This routine estimates 1-norm of inv(A) by one step of inverse
*  iteration for the small singular vector as described in [1]. This
*  involves solving two systems of equations:
*
*     A'* y = e,
*
*     A * z = y,
*
*  where A' is a matrix transposed to A, and e is a vector of +1 and -1
*  chosen to cause growth in y. Then
*
*     estimate 1-norm of inv(A) = (1-norm of z) / (1-norm of y)
*
*  REFERENCES
*
*  1. G.E.Forsythe, M.A.Malcolm, C.B.Moler. Computer Methods for
*     Mathematical Computations. Prentice-Hall, Englewood Cliffs, N.J.,
*     pp. 30-62 (subroutines DECOMP and SOLVE). */

double btf_estimate_norm(BTF *btf, double w1[/*1+n*/], double
      w2[/*1+n*/], double w3[/*1+n*/], double w4[/*1+n*/])
{     int n = btf->n;
      double *e = w1;
      double *y = w2;
      double *z = w1;
      int i;
      double y_norm, z_norm;
      /* compute y = inv(A') * e to cause growth in y */
      for (i = 1; i <= n; i++)
         e[i] = 0.0;
      btf_at_solve1(btf, e, y, w3, w4);
      /* compute 1-norm of y = sum |y[i]| */
      y_norm = 0.0;
      for (i = 1; i <= n; i++)
         y_norm += (y[i] >= 0.0 ? +y[i] : -y[i]);
      /* compute z = inv(A) * y */
      btf_a_solve(btf, y, z, w3, w4);
      /* compute 1-norm of z = sum |z[i]| */
      z_norm = 0.0;
      for (i = 1; i <= n; i++)
         z_norm += (z[i] >= 0.0 ? +z[i] : -z[i]);
      /* estimate 1-norm of inv(A) = (1-norm of z) / (1-norm of y) */
      return z_norm / y_norm;
}

/***********************************************************************
*  The structure IFU describes dense updatable IFU-factorization.
*
*  The IFU-factorization has the following format:
*
*     A = inv(F) * U,                                                (1)
*
*  where A is a given (unsymmetric) nxn square matrix, F is a square
*  matrix, U is an upper triangular matrix. Obviously, the equality (1)
*  is equivalent to the following equality:
*
*     F * A = U.                                                     (2)
*
*  It is assumed that matrix A is small and dense, so matrices F and U
*  are stored by rows in dense format as follows:
*
*        1         n       n_max      1         n       n_max
*      1 * * * * * * x x x x        1 * * * * * * x x x x
*        * * * * * * x x x x          ? * * * * * x x x x
*        * * * * * * x x x x          ? ? * * * * x x x x
*        * * * * * * x x x x          ? ? ? * * * x x x x
*        * * * * * * x x x x          ? ? ? ? * * x x x x
*      n * * * * * * x x x x        n ? ? ? ? ? * x x x x
*        x x x x x x x x x x          x x x x x x x x x x
*        x x x x x x x x x x          x x x x x x x x x x
*        x x x x x x x x x x          x x x x x x x x x x
*  n_max x x x x x x x x x x    n_max x x x x x x x x x x
*
*             matrix F                     matrix U
*
*  where '*' are matrix elements, '?' are unused locations, 'x' are
*  reserved locations. */

typedef struct IFU IFU;

struct IFU
{     /* IFU-factorization */
      int n_max;
      /* maximal order of matrices A, F, U; n_max >= 1 */
      int n;
      /* current order of matrices A, F, U; 0 <= n <= n_max */
      double *f; /* double f[n_max*n_max]; */
      /* matrix F stored by rows */
      double *u; /* double u[n_max*n_max]; */
      /* matrix U stored by rows */
};

#define ifu_expand _glp_ifu_expand
void ifu_expand(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],
      double d);
/* expand IFU-factorization */

#define ifu_bg_update _glp_ifu_bg_update
int ifu_bg_update(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],
      double d);
/* update IFU-factorization (Bartels-Golub) */

#define ifu_gr_update _glp_ifu_gr_update
int ifu_gr_update(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],
      double d);
/* update IFU-factorization (Givens rotations) */

#define ifu_a_solve _glp_ifu_a_solve
void ifu_a_solve(IFU *ifu, double x[/*1+n*/], double w[/*1+n*/]);
/* solve system A * x = b */

#define ifu_at_solve _glp_ifu_at_solve
void ifu_at_solve(IFU *ifu, double x[/*1+n*/], double w[/*1+n*/]);
/* solve system A'* x = b */


/***********************************************************************
*  ifu_expand - expand IFU-factorization
*
*  This routine expands the IFU-factorization of the matrix A according
*  to the following expansion of A:
*
*             ( A  c )
*     new A = (      )
*             ( r' d )
*
*  where c[1,...,n] is a new column, r[1,...,n] is a new row, and d is
*  a new diagonal element.
*
*  From the main equality F * A = U it follows that:
*
*     ( F  0 ) ( A  c )   ( FA  Fc )   ( U  Fc )
*     (      ) (      ) = (        ) = (       ),
*     ( 0  1 ) ( r' d )   ( r'   d )   ( r'  d )
*
*  thus,
*
*             ( F  0 )           ( U  Fc )
*     new F = (      ),  new U = (       ).
*             ( 0  1 )           ( r'  d )
*
*  Note that the resulting matrix U loses its upper triangular form due
*  to row spike r', which should be eliminated. */

void ifu_expand(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],
      double d)
{     /* non-optimized version */
      int n_max = ifu->n_max;
      int n = ifu->n;
      double *f_ = ifu->f;
      double *u_ = ifu->u;
      int i, j;
      double t;
#     define f(i,j) f_[(i)*n_max+(j)]
#     define u(i,j) u_[(i)*n_max+(j)]
      xassert(0 <= n && n < n_max);
      /* adjust indexing */
      c++, r++;
      /* set new zero column of matrix F */
      for (i = 0; i < n; i++)
         f(i,n) = 0.0;
      /* set new zero row of matrix F */
      for (j = 0; j < n; j++)
         f(n,j) = 0.0;
      /* set new unity diagonal element of matrix F */
      f(n,n) = 1.0;
      /* set new column of matrix U to vector (old F) * c */
      for (i = 0; i < n; i++)
      {  /* u[i,n] := (i-th row of old F) * c */
         t = 0.0;
         for (j = 0; j < n; j++)
            t += f(i,j) * c[j];
         u(i,n) = t;
      }
      /* set new row of matrix U to vector r */
      for (j = 0; j < n; j++)
         u(n,j) = r[j];
      /* set new diagonal element of matrix U to scalar d */
      u(n,n) = d;
      /* increase factorization order */
      ifu->n++;
#     undef f
#     undef u
      return;
}

/***********************************************************************
*  ifu_bg_update - update IFU-factorization (Bartels-Golub)
*
*  This routine updates IFU-factorization of the matrix A according to
*  its expansion (see comments to the routine ifu_expand). The routine
*  is based on the method proposed by Bartels and Golub [1].
*
*  RETURNS
*
*  0  The factorization has been successfully updated.
*
*  1  On some elimination step diagional element u[k,k] to be used as
*     pivot is too small in magnitude.
*
*  2  Diagonal element u[n,n] is too small in magnitude (at the end of
*     update).
*
*  REFERENCES
*
*  1. R.H.Bartels, G.H.Golub, "The Simplex Method of Linear Programming
*     Using LU-decomposition", Comm. ACM, 12, pp. 266-68, 1969. */

int ifu_bg_update(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],
      double d)
{     /* non-optimized version */
      int n_max = ifu->n_max;
      int n = ifu->n;
      double *f_ = ifu->f;
      double *u_ = ifu->u;
#if 1 /* FIXME */
      double tol = 1e-5;
#endif
      int j, k;
      double t;
#     define f(i,j) f_[(i)*n_max+(j)]
#     define u(i,j) u_[(i)*n_max+(j)]
      /* expand factorization */
      ifu_expand(ifu, c, r, d);
      /* NOTE: n keeps its old value */
      /* eliminate spike (non-zero subdiagonal elements) in last row of
       * matrix U */
      for (k = 0; k < n; k++)
      {  /* if |u[k,k]| < |u[n,k]|, interchange k-th and n-th rows to
          * provide |u[k,k]| >= |u[n,k]| for numeric stability */
         if (fabs(u(k,k)) < fabs(u(n,k)))
         {  /* interchange k-th and n-th rows of matrix U */
            for (j = k; j <= n; j++)
               t = u(k,j), u(k,j) = u(n,j), u(n,j) = t;
            /* interchange k-th and n-th rows of matrix F to keep the
             * main equality F * A = U */
            for (j = 0; j <= n; j++)
               t = f(k,j), f(k,j) = f(n,j), f(n,j) = t;
         }
         /* now |u[k,k]| >= |u[n,k]| */
         /* check if diagonal element u[k,k] can be used as pivot */
         if (fabs(u(k,k)) < tol)
         {  /* u[k,k] is too small in magnitude */
            return 1;
         }
         /* if u[n,k] = 0, elimination is not needed */
         if (u(n,k) == 0.0)
            continue;
         /* compute gaussian multiplier t = u[n,k] / u[k,k] */
         t = u(n,k) / u(k,k);
         /* apply gaussian transformation to eliminate u[n,k] */
         /* (n-th row of U) := (n-th row of U) - t * (k-th row of U) */
         for (j = k+1; j <= n; j++)
            u(n,j) -= t * u(k,j);
         /* apply the same transformation to matrix F to keep the main
          * equality F * A = U */
         for (j = 0; j <= n; j++)
            f(n,j) -= t * f(k,j);
      }
      /* now matrix U is upper triangular */
      if (fabs(u(n,n)) < tol)
      {  /* u[n,n] is too small in magnitude */
         return 2;
      }
#     undef f
#     undef u
      return 0;
}

/***********************************************************************
*  The routine givens computes the parameters of Givens plane rotation
*  c = cos(teta) and s = sin(teta) such that:
*
*     ( c -s ) ( a )   ( r )
*     (      ) (   ) = (   ) ,
*     ( s  c ) ( b )   ( 0 )
*
*  where a and b are given scalars.
*
*  REFERENCES
*
*  G.H.Golub, C.F.Van Loan, "Matrix Computations", 2nd ed. */

static void givens(double a, double b, double *c, double *s)
{     /* non-optimized version */
      double t;
      if (b == 0.0)
         (*c) = 1.0, (*s) = 0.0;
      else if (fabs(a) <= fabs(b))
         t = - a / b, (*s) = 1.0 / sqrt(1.0 + t * t), (*c) = (*s) * t;
      else
         t = - b / a, (*c) = 1.0 / sqrt(1.0 + t * t), (*s) = (*c) * t;
      return;
}

/***********************************************************************
*  ifu_gr_update - update IFU-factorization (Givens rotations)
*
*  This routine updates IFU-factorization of the matrix A according to
*  its expansion (see comments to the routine ifu_expand). The routine
*  is based on Givens plane rotations [1].
*
*  RETURNS
*
*  0  The factorization has been successfully updated.
*
*  1  On some elimination step both elements u[k,k] and u[n,k] are too
*     small in magnitude.
*
*  2  Diagonal element u[n,n] is too small in magnitude (at the end of
*     update).
*
*  REFERENCES
*
*  1. G.H.Golub, C.F.Van Loan, "Matrix Computations", 2nd ed. */

int ifu_gr_update(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],
      double d)
{     /* non-optimized version */
      int n_max = ifu->n_max;
      int n = ifu->n;
      double *f_ = ifu->f;
      double *u_ = ifu->u;
#if 1 /* FIXME */
      double tol = 1e-5;
#endif
      int j, k;
      double cs, sn;
#     define f(i,j) f_[(i)*n_max+(j)]
#     define u(i,j) u_[(i)*n_max+(j)]
      /* expand factorization */
      ifu_expand(ifu, c, r, d);
      /* NOTE: n keeps its old value */
      /* eliminate spike (non-zero subdiagonal elements) in last row of
       * matrix U */
      for (k = 0; k < n; k++)
      {  /* check if elements u[k,k] and u[n,k] are eligible */
         if (fabs(u(k,k)) < tol && fabs(u(n,k)) < tol)
         {  /* both u[k,k] and u[n,k] are too small in magnitude */
            return 1;
         }
         /* if u[n,k] = 0, elimination is not needed */
         if (u(n,k) == 0.0)
            continue;
         /* compute parameters of Givens plane rotation */
         givens(u(k,k), u(n,k), &cs, &sn);
         /* apply Givens rotation to k-th and n-th rows of matrix U to
          * eliminate u[n,k] */
         for (j = k; j <= n; j++)
         {  double ukj = u(k,j), unj = u(n,j);
            u(k,j) = cs * ukj - sn * unj;
            u(n,j) = sn * ukj + cs * unj;
         }
         /* apply the same transformation to matrix F to keep the main
          * equality F * A = U */
         for (j = 0; j <= n; j++)
         {  double fkj = f(k,j), fnj = f(n,j);
            f(k,j) = cs * fkj - sn * fnj;
            f(n,j) = sn * fkj + cs * fnj;
         }
      }
      /* now matrix U is upper triangular */
      if (fabs(u(n,n)) < tol)
      {  /* u[n,n] is too small in magnitude */
         return 2;
      }
#     undef f
#     undef u
      return 0;
}

/***********************************************************************
*  ifu_a_solve - solve system A * x = b
*
*  This routine solves the system A * x = b, where the matrix A is
*  specified by its IFU-factorization.
*
*  Using the main equality F * A = U we have:
*
*     A * x = b  =>  F * A * x = F * b  =>  U * x = F * b  =>
*
*     x = inv(U) * F * b.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix A. On exit this array will contain elements of the solution
*  vector x in the same locations.
*
*  The working array w should have at least 1+n elements (0-th element
*  is not used). */

void ifu_a_solve(IFU *ifu, double x[/*1+n*/], double w[/*1+n*/])
{     /* non-optimized version */
      int n_max = ifu->n_max;
      int n = ifu->n;
      double *f_ = ifu->f;
      double *u_ = ifu->u;
      int i, j;
      double t;
#     define f(i,j) f_[(i)*n_max+(j)]
#     define u(i,j) u_[(i)*n_max+(j)]
      xassert(0 <= n && n <= n_max);
      /* adjust indexing */
      x++, w++;
      /* y := F * b */
      memcpy(w, x, n * sizeof(double));
      for (i = 0; i < n; i++)
      {  /* y[i] := (i-th row of F) * b */
         t = 0.0;
         for (j = 0; j < n; j++)
            t += f(i,j) * w[j];
         x[i] = t;
      }
      /* x := inv(U) * y */
      for (i = n-1; i >= 0; i--)
      {  t = x[i];
         for (j = i+1; j < n; j++)
            t -= u(i,j) * x[j];
         x[i] = t / u(i,i);
      }
#     undef f
#     undef u
      return;
}

/***********************************************************************
*  ifu_at_solve - solve system A'* x = b
*
*  This routine solves the system A'* x = b, where A' is a matrix
*  transposed to the matrix A, specified by its IFU-factorization.
*
*  Using the main equality F * A = U, from which it follows that
*  A'* F' = U', we have:
*
*     A'* x = b  =>  A'* F'* inv(F') * x = b  =>
*
*     U'* inv(F') * x = b  =>  inv(F') * x = inv(U') * b  =>
*
*     x = F' * inv(U') * b.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix A. On exit this array will contain elements of the solution
*  vector x in the same locations.
*
*  The working array w should have at least 1+n elements (0-th element
*  is not used). */

void ifu_at_solve(IFU *ifu, double x[/*1+n*/], double w[/*1+n*/])
{     /* non-optimized version */
      int n_max = ifu->n_max;
      int n = ifu->n;
      double *f_ = ifu->f;
      double *u_ = ifu->u;
      int i, j;
      double t;
#     define f(i,j) f_[(i)*n_max+(j)]
#     define u(i,j) u_[(i)*n_max+(j)]
      xassert(0 <= n && n <= n_max);
      /* adjust indexing */
      x++, w++;
      /* y := inv(U') * b */
      for (i = 0; i < n; i++)
      {  t = (x[i] /= u(i,i));
         for (j = i+1; j < n; j++)
            x[j] -= u(i,j) * t;
      }
      /* x := F'* y */
      for (j = 0; j < n; j++)
      {  /* x[j] := (j-th column of F) * y */
         t = 0.0;
         for (i = 0; i < n; i++)
            t += f(i,j) * x[i];
         w[j] = t;
      }
      memcpy(x, w, n * sizeof(double));
#     undef f
#     undef u
      return;
}


/***********************************************************************
*  The structure SCF describes sparse updatable factorization based on
*  Schur complement.
*
*  The SCF-factorization has the following format:
*
*     ( A   A1~ )     ( A0  A1 )       ( R0    ) ( S0  S )
*     (         ) = P (        ) Q = P (       ) (       ) Q,        (1)
*     ( A2~ A3~ )     ( A2  A3 )       ( R   I ) (     C )
*
*  where:
*
*  A is current (unsymmetric) square matrix (not stored);
*
*  A1~, A2~, A3~ are some additional matrices (not stored);
*
*  A0 is initial (unsymmetric) square matrix (not stored);
*
*  A1, A2, A3 are some additional matrices (not stored);
*
*  R0 and S0 are matrices that define factorization of the initial
*  matrix A0 = R0 * S0 (stored in an invertable form);
*
*  R is a matrix defined from R * S0 = A2, so R = A2 * inv(S0) (stored
*  in row-wise sparse format);
*
*  S is a matrix defined from R0 * S = A1, so S = inv(R0) * A1 (stored
*  in column-wise sparse format);
*
*  C is Schur complement (to matrix A0) defined from R * S + C = A3,
*  so C = A3 - R * S = A3 - A2 * inv(A0) * A1 (stored in an invertable
*  form).
*
*  P, Q are permutation matrices (stored in both row- and column-like
*  formats). */

typedef struct SCF SCF;

struct SCF
{     /* Schur-complement-based factorization */
      int n;
      /* order of current matrix A */
      /*--------------------------------------------------------------*/
      /* initial matrix A0 = R0 * S0 of order n0 in invertable form */
      int n0;
      /* order of matrix A0 */
      int type;
      /* type of factorization used:
       * 1 - LU-factorization (R0 = F0, S0 = V0)
       * 2 - BT-factorization (R0 = I, S0 = A0) */
      union
      {  LUF *luf; /* type = 1 */
         BTF *btf; /* type = 2 */
      }  a0;
      /* factorization of matrix A0 */
      /*--------------------------------------------------------------*/
      /* augmented matrix (A0, A1; A2, A3) of order n0+nn */
      int nn_max;
      /* maximal number of additional rows and columns in the augmented
       * matrix (this limits the number of updates) */
      int nn;
      /* current number of additional rows and columns in the augmented
       * matrix, 0 <= nn <= nn_max */
      SVA *sva;
      /* associated sparse vector area (SVA) used to store rows of
       * matrix R and columns of matrix S */
      /*--------------------------------------------------------------*/
      /* nn*n0-matrix R in row-wise format */
      int rr_ref;
      /* reference number of sparse vector in SVA, which is the first
       * row of matrix R */
#if 0 + 0
      int *rr_ptr = &sva->ptr[rr_ref-1];
      /* rr_ptr[0] is not used;
       * rr_ptr[i], 1 <= i <= nn, is pointer to i-th row in SVA;
       * rr_ptr[nn+1,...,nn_max] are reserved locations */
      int *rr_len = &sva->len[rr_ref-1];
      /* rr_len[0] is not used;
       * rr_len[i], 1 <= i <= nn, is length of i-th row;
       * rr_len[nn+1,...,nn_max] are reserved locations */
#endif
      /*--------------------------------------------------------------*/
      /* n0*nn-matrix S in column-wise format */
      int ss_ref;
      /* reference number of sparse vector in SVA, which is the first
       * column of matrix S */
#if 0 + 0
      int *ss_ptr = &sva->ptr[ss_ref-1];
      /* ss_ptr[0] is not used;
       * ss_ptr[j], 1 <= j <= nn, is pointer to j-th column in SVA;
       * ss_ptr[nn+1,...,nn_max] are reserved locations */
      int *ss_len = &sva->len[ss_ref-1];
      /* ss_len[0] is not used;
       * ss_len[j], 1 <= j <= nn, is length of j-th column;
       * ss_len[nn+1,...,nn_max] are reserved locations */
#endif
      /*--------------------------------------------------------------*/
      /* Schur complement C of order nn in invertable form */
      IFU ifu;
      /* IFU-factorization of matrix C */
      /*--------------------------------------------------------------*/
      /* permutation matrix P of order n0+nn */
      int *pp_ind; /* int pp_ind[1+n0+nn_max]; */
      /* pp_ind[i] = j means that P[i,j] = 1 */
      int *pp_inv; /* int pp_inv[1+n0+nn_max]; */
      /* pp_inv[j] = i means that P[i,j] = 1 */
      /*--------------------------------------------------------------*/
      /* permutation matrix Q of order n0+nn */
      int *qq_ind; /* int qq_ind[1+n0+nn_max]; */
      /* qq_ind[i] = j means that Q[i,j] = 1 */
      int *qq_inv; /* int qq_inv[1+n0+nn_max]; */
      /* qq_inv[j] = i means that Q[i,j] = 1 */
};

#define scf_swap_q_cols(j1, j2) \
      do \
      {  int i1, i2; \
         i1 = qq_inv[j1], i2 = qq_inv[j2]; \
         qq_ind[i1] = j2, qq_inv[j2] = i1; \
         qq_ind[i2] = j1, qq_inv[j1] = i2; \
      }  while (0)
/* swap columns j1 and j2 of permutation matrix Q */

#define scf_r0_solve _glp_scf_r0_solve
void scf_r0_solve(SCF *scf, int tr, double x[/*1+n0*/]);
/* solve system R0 * x = b or R0'* x = b */

#define scf_s0_solve _glp_scf_s0_solve
void scf_s0_solve(SCF *scf, int tr, double x[/*1+n0*/],
      double w1[/*1+n0*/], double w2[/*1+n0*/], double w3[/*1+n0*/]);
/* solve system S0 * x = b or S0'* x = b */

#define scf_r_prod _glp_scf_r_prod
void scf_r_prod(SCF *scf, double y[/*1+nn*/], double a, const double
      x[/*1+n0*/]);
/* compute product y := y + alpha * R * x */

#define scf_rt_prod _glp_scf_rt_prod
void scf_rt_prod(SCF *scf, double y[/*1+n0*/], double a, const double
      x[/*1+nn*/]);
/* compute product y := y + alpha * R'* x */

#define scf_s_prod _glp_scf_s_prod
void scf_s_prod(SCF *scf, double y[/*1+n0*/], double a, const double
      x[/*1+nn*/]);
/* compute product y := y + alpha * S * x */

#define scf_st_prod _glp_scf_st_prod
void scf_st_prod(SCF *scf, double y[/*1+nn*/], double a, const double
      x[/*1+n0*/]);
/* compute product y := y + alpha * S'* x */

#define scf_a_solve _glp_scf_a_solve
void scf_a_solve(SCF *scf, double x[/*1+n*/],
      double w[/*1+n0+nn*/], double work1[/*1+max(n0,nn)*/],
      double work2[/*1+n*/], double work3[/*1+n*/]);
/* solve system A * x = b */

#define scf_at_solve _glp_scf_at_solve
void scf_at_solve(SCF *scf, double x[/*1+n*/],
      double w[/*1+n0+nn*/], double work1[/*1+max(n0,nn)*/],
      double work2[/*1+n*/], double work3[/*1+n*/]);
/* solve system A'* x = b */

#define scf_add_r_row _glp_scf_add_r_row
void scf_add_r_row(SCF *scf, const double w[/*1+n0*/]);
/* add new row to matrix R */

#define scf_add_s_col _glp_scf_add_s_col
void scf_add_s_col(SCF *scf, const double v[/*1+n0*/]);
/* add new column to matrix S */

#define scf_update_aug _glp_scf_update_aug
int scf_update_aug(SCF *scf, double b[/*1+n0*/], double d[/*1+n0*/],
      double f[/*1+nn*/], double g[/*1+nn*/], double h, int upd,
      double w1[/*1+n0*/], double w2[/*1+n0*/], double w3[/*1+n0*/]);
/* update factorization of augmented matrix */



/***********************************************************************
*  scf_r0_solve - solve system R0 * x = b or R0'* x = b
*
*  This routine solves the system R0 * x = b (if tr is zero) or the
*  system R0'* x = b (if tr is non-zero), where R0 is the left factor
*  of the initial matrix A0 = R0 * S0.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n0], where n0 is the order of the
*  matrix R0. On exit the array x will contain elements of the solution
*  vector in the same locations. */

void scf_r0_solve(SCF *scf, int tr, double x[/*1+n0*/])
{     switch (scf->type)
      {  case 1:
            /* A0 = F0 * V0, so R0 = F0 */
            if (!tr)
               luf_f_solve(scf->a0.luf, x);
            else
               luf_ft_solve(scf->a0.luf, x);
            break;
         case 2:
            /* A0 = I * A0, so R0 = I */
            break;
         default:
            xassert(scf != scf);
      }
      return;
}

/***********************************************************************
*  scf_s0_solve - solve system S0 * x = b or S0'* x = b
*
*  This routine solves the system S0 * x = b (if tr is zero) or the
*  system S0'* x = b (if tr is non-zero), where S0 is the right factor
*  of the initial matrix A0 = R0 * S0.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n0], where n0 is the order of the
*  matrix S0. On exit the array x will contain elements of the solution
*  vector in the same locations.
*
*  The routine uses locations [1], ..., [n0] of three working arrays
*  w1, w2, and w3. (In case of type = 1 arrays w2 and w3 are not used
*  and can be specified as NULL.) */

void scf_s0_solve(SCF *scf, int tr, double x[/*1+n0*/],
      double w1[/*1+n0*/], double w2[/*1+n0*/], double w3[/*1+n0*/])
{     int n0 = scf->n0;
      switch (scf->type)
      {  case 1:
            /* A0 = F0 * V0, so S0 = V0 */
            if (!tr)
               luf_v_solve(scf->a0.luf, x, w1);
            else
               luf_vt_solve(scf->a0.luf, x, w1);
            break;
         case 2:
            /* A0 = I * A0, so S0 = A0 */
            if (!tr)
               btf_a_solve(scf->a0.btf, x, w1, w2, w3);
            else
               btf_at_solve(scf->a0.btf, x, w1, w2, w3);
            break;
         default:
            xassert(scf != scf);
      }
      memcpy(&x[1], &w1[1], n0 * sizeof(double));
      return;
}

/***********************************************************************
*  scf_r_prod - compute product y := y + alpha * R * x
*
*  This routine computes the product y := y + alpha * R * x, where
*  x is a n0-vector, alpha is a scalar, y is a nn-vector.
*
*  Since matrix R is available by rows, the product components are
*  computed as inner products:
*
*     y[i] = y[i] + alpha * (i-th row of R) * x
*
*  for i = 1, 2, ..., nn. */

void scf_r_prod(SCF *scf, double y[/*1+nn*/], double a, const double
      x[/*1+n0*/])
{     int nn = scf->nn;
      SVA *sva = scf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int rr_ref = scf->rr_ref;
      int *rr_ptr = &sva->ptr[rr_ref-1];
      int *rr_len = &sva->len[rr_ref-1];
      int i, ptr, end;
      double t;
      for (i = 1; i <= nn; i++)
      {  /* t := (i-th row of R) * x */
         t = 0.0;
         for (end = (ptr = rr_ptr[i]) + rr_len[i]; ptr < end; ptr++)
            t += sv_val[ptr] * x[sv_ind[ptr]];
         /* y[i] := y[i] + alpha * t */
         y[i] += a * t;
      }
      return;
}

/***********************************************************************
*  scf_rt_prod - compute product y := y + alpha * R'* x
*
*  This routine computes the product y := y + alpha * R'* x, where
*  R' is a matrix transposed to R, x is a nn-vector, alpha is a scalar,
*  y is a n0-vector.
*
*  Since matrix R is available by rows, the product is computed as a
*  linear combination:
*
*     y := y + alpha * (R'[1] * x[1] + ... + R'[nn] * x[nn]),
*
*  where R'[i] is i-th row of R. */

void scf_rt_prod(SCF *scf, double y[/*1+n0*/], double a, const double
      x[/*1+nn*/])
{     int nn = scf->nn;
      SVA *sva = scf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int rr_ref = scf->rr_ref;
      int *rr_ptr = &sva->ptr[rr_ref-1];
      int *rr_len = &sva->len[rr_ref-1];
      int i, ptr, end;
      double t;
      for (i = 1; i <= nn; i++)
      {  if (x[i] == 0.0)
            continue;
         /* y := y + alpha * R'[i] * x[i] */
         t = a * x[i];
         for (end = (ptr = rr_ptr[i]) + rr_len[i]; ptr < end; ptr++)
            y[sv_ind[ptr]] += sv_val[ptr] * t;
      }
      return;
}

/***********************************************************************
*  scf_s_prod - compute product y := y + alpha * S * x
*
*  This routine computes the product y := y + alpha * S * x, where
*  x is a nn-vector, alpha is a scalar, y is a n0 vector.
*
*  Since matrix S is available by columns, the product is computed as
*  a linear combination:
*
*     y := y + alpha * (S[1] * x[1] + ... + S[nn] * x[nn]),
*
*  where S[j] is j-th column of S. */

void scf_s_prod(SCF *scf, double y[/*1+n0*/], double a, const double
      x[/*1+nn*/])
{     int nn = scf->nn;
      SVA *sva = scf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int ss_ref = scf->ss_ref;
      int *ss_ptr = &sva->ptr[ss_ref-1];
      int *ss_len = &sva->len[ss_ref-1];
      int j, ptr, end;
      double t;
      for (j = 1; j <= nn; j++)
      {  if (x[j] == 0.0)
            continue;
         /* y := y + alpha * S[j] * x[j] */
         t = a * x[j];
         for (end = (ptr = ss_ptr[j]) + ss_len[j]; ptr < end; ptr++)
            y[sv_ind[ptr]] += sv_val[ptr] * t;
      }
      return;
}

/***********************************************************************
*  scf_st_prod - compute product y := y + alpha * S'* x
*
*  This routine computes the product y := y + alpha * S'* x, where
*  S' is a matrix transposed to S, x is a n0-vector, alpha is a scalar,
*  y is a nn-vector.
*
*  Since matrix S is available by columns, the product components are
*  computed as inner products:
*
*     y[j] := y[j] + alpha * (j-th column of S) * x
*
*  for j = 1, 2, ..., nn. */

void scf_st_prod(SCF *scf, double y[/*1+nn*/], double a, const double
      x[/*1+n0*/])
{     int nn = scf->nn;
      SVA *sva = scf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int ss_ref = scf->ss_ref;
      int *ss_ptr = &sva->ptr[ss_ref-1];
      int *ss_len = &sva->len[ss_ref-1];
      int j, ptr, end;
      double t;
      for (j = 1; j <= nn; j++)
      {  /* t := (j-th column of S) * x */
         t = 0.0;
         for (end = (ptr = ss_ptr[j]) + ss_len[j]; ptr < end; ptr++)
            t += sv_val[ptr] * x[sv_ind[ptr]];
         /* y[j] := y[j] + alpha * t */
         y[j] += a * t;
      }
      return;
}

/***********************************************************************
*  scf_a_solve - solve system A * x = b
*
*  This routine solves the system A * x = b, where A is the current
*  matrix.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix A. On exit the array x will contain elements of the solution
*  vector in the same locations.
*
*  For details see the program documentation. */

void scf_a_solve(SCF *scf, double x[/*1+n*/],
      double w[/*1+n0+nn*/], double work1[/*1+max(n0,nn)*/],
      double work2[/*1+n*/], double work3[/*1+n*/])
{     int n = scf->n;
      int n0 = scf->n0;
      int nn = scf->nn;
      int *pp_ind = scf->pp_ind;
      int *qq_inv = scf->qq_inv;
      int i, ii;
      /* (u1, u2) := inv(P) * (b, 0) */
      for (ii = 1; ii <= n0+nn; ii++)
      {  i = pp_ind[ii];
#if 1 /* FIXME: currently P = I */
         xassert(i == ii);
#endif
         w[ii] = (i <= n ? x[i] : 0.0);
      }
      /* v1 := inv(R0) * u1 */
      scf_r0_solve(scf, 0, &w[0]);
      /* v2 := u2 - R * v1 */
      scf_r_prod(scf, &w[n0], -1.0, &w[0]);
      /* w2 := inv(C) * v2 */
      ifu_a_solve(&scf->ifu, &w[n0], work1);
      /* w1 := inv(S0) * (v1 - S * w2) */
      scf_s_prod(scf, &w[0], -1.0, &w[n0]);
      scf_s0_solve(scf, 0, &w[0], work1, work2, work3);
      /* (x, x~) := inv(Q) * (w1, w2); x~ is not needed */
      for (i = 1; i <= n; i++)
         x[i] = w[qq_inv[i]];
      return;
}

/***********************************************************************
*  scf_at_solve - solve system A'* x = b
*
*  This routine solves the system A'* x = b, where A' is a matrix
*  transposed to the current matrix A.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix A. On exit the array x will contain elements of the solution
*  vector in the same locations.
*
*  For details see the program documentation. */

void scf_at_solve(SCF *scf, double x[/*1+n*/],
      double w[/*1+n0+nn*/], double work1[/*1+max(n0,nn)*/],
      double work2[/*1+n*/], double work3[/*1+n*/])
{     int n = scf->n;
      int n0 = scf->n0;
      int nn = scf->nn;
      int *pp_inv = scf->pp_inv;
      int *qq_ind = scf->qq_ind;
      int i, ii;
      /* (u1, u2) := Q * (b, 0) */
      for (ii = 1; ii <= n0+nn; ii++)
      {  i = qq_ind[ii];
         w[ii] = (i <= n ? x[i] : 0.0);
      }
      /* v1 := inv(S0') * u1 */
      scf_s0_solve(scf, 1, &w[0], work1, work2, work3);
      /* v2 := inv(C') * (u2 - S'* v1) */
      scf_st_prod(scf, &w[n0], -1.0, &w[0]);
      ifu_at_solve(&scf->ifu, &w[n0], work1);
      /* w2 := v2 */
      /* nop */
      /* w1 := inv(R0') * (v1 - R'* w2) */
      scf_rt_prod(scf, &w[0], -1.0, &w[n0]);
      scf_r0_solve(scf, 1, &w[0]);
      /* compute (x, x~) := P * (w1, w2); x~ is not needed */
      for (i = 1; i <= n; i++)
      {
#if 1 /* FIXME: currently P = I */
         xassert(pp_inv[i] == i);
#endif
         x[i] = w[pp_inv[i]];
      }
      return;
}

/***********************************************************************
*  scf_add_r_row - add new row to matrix R
*
*  This routine adds new (nn+1)-th row to matrix R, whose elements are
*  specified in locations w[1,...,n0]. */

void scf_add_r_row(SCF *scf, const double w[/*1+n0*/])
{     int n0 = scf->n0;
      int nn = scf->nn;
      SVA *sva = scf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int rr_ref = scf->rr_ref;
      int *rr_ptr = &sva->ptr[rr_ref-1];
      int *rr_len = &sva->len[rr_ref-1];
      int j, len, ptr;
      xassert(0 <= nn && nn < scf->nn_max);
      /* determine length of new row */
      len = 0;
      for (j = 1; j <= n0; j++)
      {  if (w[j] != 0.0)
            len++;
      }
      /* reserve locations for new row in static part of SVA */
      if (len > 0)
      {  if (sva->r_ptr - sva->m_ptr < len)
         {  sva_more_space(sva, len);
            sv_ind = sva->ind;
            sv_val = sva->val;
         }
         sva_reserve_cap(sva, rr_ref + nn, len);
      }
      /* store new row in sparse format */
      ptr = rr_ptr[nn+1];
      for (j = 1; j <= n0; j++)
      {  if (w[j] != 0.0)
         {  sv_ind[ptr] = j;
            sv_val[ptr] = w[j];
            ptr++;
         }
      }
      xassert(ptr - rr_ptr[nn+1] == len);
      rr_len[nn+1] = len;
#ifdef GLP_DEBUG
      sva_check_area(sva);
#endif
      return;
}

/***********************************************************************
*  scf_add_s_col - add new column to matrix S
*
*  This routine adds new (nn+1)-th column to matrix S, whose elements
*  are specified in locations v[1,...,n0]. */

void scf_add_s_col(SCF *scf, const double v[/*1+n0*/])
{     int n0 = scf->n0;
      int nn = scf->nn;
      SVA *sva = scf->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      int ss_ref = scf->ss_ref;
      int *ss_ptr = &sva->ptr[ss_ref-1];
      int *ss_len = &sva->len[ss_ref-1];
      int i, len, ptr;
      xassert(0 <= nn && nn < scf->nn_max);
      /* determine length of new column */
      len = 0;
      for (i = 1; i <= n0; i++)
      {  if (v[i] != 0.0)
            len++;
      }
      /* reserve locations for new column in static part of SVA */
      if (len > 0)
      {  if (sva->r_ptr - sva->m_ptr < len)
         {  sva_more_space(sva, len);
            sv_ind = sva->ind;
            sv_val = sva->val;
         }
         sva_reserve_cap(sva, ss_ref + nn, len);
      }
      /* store new column in sparse format */
      ptr = ss_ptr[nn+1];
      for (i = 1; i <= n0; i++)
      {  if (v[i] != 0.0)
         {  sv_ind[ptr] = i;
            sv_val[ptr] = v[i];
            ptr++;
         }
      }
      xassert(ptr - ss_ptr[nn+1] == len);
      ss_len[nn+1] = len;
#ifdef GLP_DEBUG
      sva_check_area(sva);
#endif
      return;
}

/***********************************************************************
*  scf_update_aug - update factorization of augmented matrix
*
*  Given factorization of the current augmented matrix:
*
*     ( A0  A1 )   ( R0    ) ( S0  S )
*     (        ) = (       ) (       ),
*     ( A2  A3 )   ( R   I ) (     C )
*
*  this routine computes factorization of the new augmented matrix:
*
*     ( A0 | A1  b )
*     ( ---+------ )   ( A0  A1^ )   ( R0    ) ( S0  S^ )
*     ( A2 | A3  f ) = (         ) = (       ) (        ),
*     (    |       )   ( A2^ A3^ )   ( R^  I ) (     C^ )
*     ( d' | g'  h )
*
*  where b and d are specified n0-vectors, f and g are specified
*  nn-vectors, and h is a specified scalar. (Note that corresponding
*  arrays are clobbered on exit.)
*
*  The parameter upd specifies how to update factorization of the Schur
*  complement C:
*
*  1  Bartels-Golub updating.
*
*  2  Givens rotations updating.
*
*  The working arrays w1, w2, and w3 are used in the same way as in the
*  routine scf_s0_solve.
*
*  RETURNS
*
*  0  Factorization has been successfully updated.
*
*  1  Updating limit has been reached.
*
*  2  Updating IFU-factorization of matrix C failed.
*
*  For details see the program documentation. */

int scf_update_aug(SCF *scf, double b[/*1+n0*/], double d[/*1+n0*/],
      double f[/*1+nn*/], double g[/*1+nn*/], double h, int upd,
      double w1[/*1+n0*/], double w2[/*1+n0*/], double w3[/*1+n0*/])
{     int n0 = scf->n0;
      int k, ret;
      double *v, *w, *x, *y, z;
      if (scf->nn == scf->nn_max)
      {  /* updating limit has been reached */
         return 1;
      }
      /* v := inv(R0) * b */
      scf_r0_solve(scf, 0, (v = b));
      /* w := inv(S0') * d */
      scf_s0_solve(scf, 1, (w = d), w1, w2, w3);
      /* x := f - R * v */
      scf_r_prod(scf, (x = f), -1.0, v);
      /* y := g - S'* w */
      scf_st_prod(scf, (y = g), -1.0, w);
      /* z := h - v'* w */
      z = h;
      for (k = 1; k <= n0; k++)
         z -= v[k] * w[k];
      /* new R := R with row w added */
      scf_add_r_row(scf, w);
      /* new S := S with column v added */
      scf_add_s_col(scf, v);
      /* update IFU-factorization of C */
      switch (upd)
      {  case 1:
            ret = ifu_bg_update(&scf->ifu, x, y, z);
            break;
         case 2:
            ret = ifu_gr_update(&scf->ifu, x, y, z);
            break;
         default:
            xassert(upd != upd);
      }
      if (ret != 0)
      {  /* updating IFU-factorization failed */
         return 2;
      }
      /* increase number of additional rows and columns */
      scf->nn++;
      /* expand P and Q */
      k = n0 + scf->nn;
      scf->pp_ind[k] = scf->pp_inv[k] = k;
      scf->qq_ind[k] = scf->qq_inv[k] = k;
      /* factorization has been successfully updated */
      return 0;
}
























typedef struct BTFINT BTFINT;

struct BTFINT
{     /* interface to BT-factorization */
      int n_max;
      /* maximal value of n (increased automatically) */
      int valid;
      /* factorization is valid only if this flag is set */
      SVA *sva;
      /* sparse vector area (SVA) */
      BTF *btf;
      /* sparse block triangular LU-factorization */
      SGF *sgf;
      /* sparse Gaussian factorizer workspace */
      /*--------------------------------------------------------------*/
      /* control parameters */
      int sva_n_max, sva_size;
      /* parameters passed to sva_create_area */
      int delta_n0, delta_n;
      /* if n_max = 0, set n_max = n + delta_n0
       * if n_max < n, set n_max = n + delta_n */
      double sgf_piv_tol;
      int sgf_piv_lim;
      int sgf_suhl;
      double sgf_eps_tol;
      /* factorizer control parameters */
};

#define btfint_create _glp_btfint_create
BTFINT *btfint_create(void);
/* create interface to BT-factorization */

#define btfint_factorize _glp_btfint_factorize
int btfint_factorize(BTFINT *fi, int n, int (*col)(void *info, int j,
      int ind[], double val[]), void *info);
/* compute BT-factorization of specified matrix A */

#define btfint_delete _glp_btfint_delete
void btfint_delete(BTFINT *fi);
/* delete interface to BT-factorization */

BTFINT *btfint_create(void)
{     /* create interface to BT-factorization */
      BTFINT *fi;
      fi = talloc(1, BTFINT);
      fi->n_max = 0;
      fi->valid = 0;
      fi->sva = NULL;
      fi->btf = NULL;
      fi->sgf = NULL;
      fi->sva_n_max = fi->sva_size = 0;
      fi->delta_n0 = fi->delta_n = 0;
      fi->sgf_piv_tol = 0.10;
      fi->sgf_piv_lim = 4;
      fi->sgf_suhl = 1;
      fi->sgf_eps_tol = DBL_EPSILON;
      return fi;
}

static void factorize_triv(BTFINT *fi, int k, int (*col)(void *info,
      int j, int ind[], double val[]), void *info)
{     /* compute LU-factorization of diagonal block A~[k,k] and store
       * corresponding columns of matrix A except elements of A~[k,k]
       * (trivial case when the block has unity size) */
      SVA *sva = fi->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      BTF *btf = fi->btf;
      int *pp_inv = btf->pp_inv;
      int *qq_ind = btf->qq_ind;
      int *beg = btf->beg;
      int ac_ref = btf->ac_ref;
      int *ac_ptr = &sva->ptr[ac_ref-1];
      int *ac_len = &sva->len[ac_ref-1];
      SGF *sgf = fi->sgf;
      int *ind = (int *)sgf->vr_max; /* working array */
      double *val = sgf->work; /* working array */
      int i, j, t, len, ptr, beg_k;
      /* diagonal block A~[k,k] has the only element in matrix A~,
       * which is a~[beg[k],beg[k]] = a[i,j] */
      beg_k = beg[k];
      i = pp_inv[beg_k];
      j = qq_ind[beg_k];
      /* get j-th column of A */
      len = col(info, j, ind, val);
      /* find element a[i,j] = a~[beg[k],beg[k]] in j-th column */
      for (t = 1; t <= len; t++)
      {  if (ind[t] == i)
            break;
      }
      xassert(t <= len);
      /* compute LU-factorization of diagonal block A~[k,k], where
       * F = (1), V = (a[i,j]), P = Q = (1) (see the module LUF) */
#if 1 /* FIXME */
      xassert(val[t] != 0.0);
#endif
      btf->vr_piv[beg_k] = val[t];
      btf->p1_ind[beg_k] = btf->p1_inv[beg_k] = 1;
      btf->q1_ind[beg_k] = btf->q1_inv[beg_k] = 1;
      /* remove element a[i,j] = a~[beg[k],beg[k]] from j-th column */
      memmove(&ind[t], &ind[t+1], (len-t) * sizeof(int));
      memmove(&val[t], &val[t+1], (len-t) * sizeof(double));
      len--;
      /* and store resulting j-th column of A into BTF */
      if (len > 0)
      {  /* reserve locations for j-th column of A */
         if (sva->r_ptr - sva->m_ptr < len)
         {  sva_more_space(sva, len);
            sv_ind = sva->ind;
            sv_val = sva->val;
         }
         sva_reserve_cap(sva, ac_ref+(j-1), len);
         /* store j-th column of A (except elements of A~[k,k]) */
         ptr = ac_ptr[j];
         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));
         memcpy(&sv_val[ptr], &val[1], len * sizeof(double));
         ac_len[j] = len;
      }
      return;
}

static int factorize_block(BTFINT *fi, int k, int (*col)(void *info,
      int j, int ind[], double val[]), void *info)
{     /* compute LU-factorization of diagonal block A~[k,k] and store
       * corresponding columns of matrix A except elements of A~[k,k]
       * (general case) */
      SVA *sva = fi->sva;
      int *sv_ind = sva->ind;
      double *sv_val = sva->val;
      BTF *btf = fi->btf;
      int *pp_ind = btf->pp_ind;
      int *qq_ind = btf->qq_ind;
      int *beg = btf->beg;
      int ac_ref = btf->ac_ref;
      int *ac_ptr = &sva->ptr[ac_ref-1];
      int *ac_len = &sva->len[ac_ref-1];
      SGF *sgf = fi->sgf;
      int *ind = (int *)sgf->vr_max; /* working array */
      double *val = sgf->work; /* working array */
      LUF luf;
      int *vc_ptr, *vc_len, *vc_cap;
      int i, ii, j, jj, t, len, cnt, ptr, beg_k;
      /* construct fake LUF for LU-factorization of A~[k,k] */
      sgf->luf = &luf;
      luf.n = beg[k+1] - (beg_k = beg[k]);
      luf.sva = sva;
      luf.fr_ref = btf->fr_ref + (beg_k-1);
      luf.fc_ref = btf->fc_ref + (beg_k-1);
      luf.vr_ref = btf->vr_ref + (beg_k-1);
      luf.vr_piv = btf->vr_piv + (beg_k-1);
      luf.vc_ref = btf->vc_ref + (beg_k-1);
      luf.pp_ind = btf->p1_ind + (beg_k-1);
      luf.pp_inv = btf->p1_inv + (beg_k-1);
      luf.qq_ind = btf->q1_ind + (beg_k-1);
      luf.qq_inv = btf->q1_inv + (beg_k-1);
      /* process columns of k-th block of matrix A~ */
      vc_ptr = &sva->ptr[luf.vc_ref-1];
      vc_len = &sva->len[luf.vc_ref-1];
      vc_cap = &sva->cap[luf.vc_ref-1];
      for (jj = 1; jj <= luf.n; jj++)
      {  /* jj-th column of A~ = j-th column of A */
         j = qq_ind[jj + (beg_k-1)];
         /* get j-th column of A */
         len = col(info, j, ind, val);
         /* move elements of diagonal block A~[k,k] to the beginning of
          * the column list */
         cnt = 0;
         for (t = 1; t <= len; t++)
         {  /* i = row index of element a[i,j] */
            i = ind[t];
            /* i-th row of A = ii-th row of A~ */
            ii = pp_ind[i];
            if (ii >= beg_k)
            {  /* a~[ii,jj] = a[i,j] is in diagonal block A~[k,k] */
               double temp;
               cnt++;
               ind[t] = ind[cnt];
               ind[cnt] = ii - (beg_k-1); /* local index */
               temp = val[t], val[t] = val[cnt], val[cnt] = temp;
            }
         }
         /* first cnt elements in the column list give jj-th column of
          * diagonal block A~[k,k], which is initial matrix V in LUF */
         /* enlarge capacity of jj-th column of V = A~[k,k] */
         if (vc_cap[jj] < cnt)
         {  if (sva->r_ptr - sva->m_ptr < cnt)
            {  sva_more_space(sva, cnt);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_enlarge_cap(sva, luf.vc_ref+(jj-1), cnt, 0);
         }
         /* store jj-th column of V = A~[k,k] */
         ptr = vc_ptr[jj];
         memcpy(&sv_ind[ptr], &ind[1], cnt * sizeof(int));
         memcpy(&sv_val[ptr], &val[1], cnt * sizeof(double));
         vc_len[jj] = cnt;
         /* other (len-cnt) elements in the column list are stored in
          * j-th column of the original matrix A */
         len -= cnt;
         if (len > 0)
         {  /* reserve locations for j-th column of A */
            if (sva->r_ptr - sva->m_ptr < len)
            {  sva_more_space(sva, len);
               sv_ind = sva->ind;
               sv_val = sva->val;
            }
            sva_reserve_cap(sva, ac_ref-1+j, len);
            /* store j-th column of A (except elements of A~[k,k]) */
            ptr = ac_ptr[j];
            memcpy(&sv_ind[ptr], &ind[cnt+1], len * sizeof(int));
            memcpy(&sv_val[ptr], &val[cnt+1], len * sizeof(double));
            ac_len[j] = len;
         }
      }
      /* compute LU-factorization of diagonal block A~[k,k]; may note
       * that A~[k,k] is irreducible (strongly connected), so singleton
       * phase will have no effect */
      k = sgf_factorize(sgf, 0 /* disable singleton phase */);
      /* now left (dynamic) part of SVA should be empty (wichtig!) */
      xassert(sva->m_ptr == 1);
      return k;
}

int btfint_factorize(BTFINT *fi, int n, int (*col)(void *info, int j,
      int ind[], double val[]), void *info)
{     /* compute BT-factorization of specified matrix A */
      SVA *sva;
      BTF *btf;
      SGF *sgf;
      int k, rank;
      xassert(n > 0);
      fi->valid = 0;
      /* create sparse vector area (SVA), if necessary */
      sva = fi->sva;
      if (sva == NULL)
      {  int sva_n_max = fi->sva_n_max;
         int sva_size = fi->sva_size;
         if (sva_n_max == 0)
            sva_n_max = 6 * n;
         if (sva_size == 0)
            sva_size = 10 * n;
         sva = fi->sva = sva_create_area(sva_n_max, sva_size);
      }
      /* allocate/reallocate underlying objects, if necessary */
      if (fi->n_max < n)
      {  int n_max = fi->n_max;
         if (n_max == 0)
            n_max = fi->n_max = n + fi->delta_n0;
         else
            n_max = fi->n_max = n + fi->delta_n;
         xassert(n_max >= n);
         /* allocate/reallocate block triangular factorization (BTF) */
         btf = fi->btf;
         if (btf == NULL)
         {  btf = fi->btf = talloc(1, BTF);
            memset(btf, 0, sizeof(BTF));
            btf->sva = sva;
         }
         else
         {  tfree(btf->pp_ind);
            tfree(btf->pp_inv);
            tfree(btf->qq_ind);
            tfree(btf->qq_inv);
            tfree(btf->beg);
            tfree(btf->vr_piv);
            tfree(btf->p1_ind);
            tfree(btf->p1_inv);
            tfree(btf->q1_ind);
            tfree(btf->q1_inv);
         }
         btf->pp_ind = talloc(1+n_max, int);
         btf->pp_inv = talloc(1+n_max, int);
         btf->qq_ind = talloc(1+n_max, int);
         btf->qq_inv = talloc(1+n_max, int);
         btf->beg = talloc(1+n_max+1, int);
         btf->vr_piv = talloc(1+n_max, double);
         btf->p1_ind = talloc(1+n_max, int);
         btf->p1_inv = talloc(1+n_max, int);
         btf->q1_ind = talloc(1+n_max, int);
         btf->q1_inv = talloc(1+n_max, int);
         /* allocate/reallocate factorizer workspace (SGF) */
         /* (note that for SGF we could use the size of largest block
          * rather than n_max) */
         sgf = fi->sgf;
         sgf = fi->sgf;
         if (sgf == NULL)
         {  sgf = fi->sgf = talloc(1, SGF);
            memset(sgf, 0, sizeof(SGF));
         }
         else
         {  tfree(sgf->rs_head);
            tfree(sgf->rs_prev);
            tfree(sgf->rs_next);
            tfree(sgf->cs_head);
            tfree(sgf->cs_prev);
            tfree(sgf->cs_next);
            tfree(sgf->vr_max);
            tfree(sgf->flag);
            tfree(sgf->work);
         }
         sgf->rs_head = talloc(1+n_max, int);
         sgf->rs_prev = talloc(1+n_max, int);
         sgf->rs_next = talloc(1+n_max, int);
         sgf->cs_head = talloc(1+n_max, int);
         sgf->cs_prev = talloc(1+n_max, int);
         sgf->cs_next = talloc(1+n_max, int);
         sgf->vr_max = talloc(1+n_max, double);
         sgf->flag = talloc(1+n_max, char);
         sgf->work = talloc(1+n_max, double);
      }
      btf = fi->btf;
      btf->n = n;
      sgf = fi->sgf;
#if 1 /* FIXME */
      /* initialize SVA */
      sva->n = 0;
      sva->m_ptr = 1;
      sva->r_ptr = sva->size + 1;
      sva->head = sva->tail = 0;
#endif
      /* store pattern of original matrix A in column-wise format */
      btf->ac_ref = sva_alloc_vecs(btf->sva, btf->n);
      btf_store_a_cols(btf, col, info, btf->pp_ind, btf->vr_piv);
#ifdef GLP_DEBUG
      sva_check_area(sva);
#endif
      /* analyze pattern of original matrix A and determine permutation
       * matrices P and Q such that A = P * A~* Q, where A~ is an upper
       * block triangular matrix */
      rank = btf_make_blocks(btf);
      if (rank != n)
      {  /* original matrix A is structurally singular */
         return 1;
      }
#ifdef GLP_DEBUG
      btf_check_blocks(btf);
#endif
#if 1 /* FIXME */
      /* initialize SVA */
      sva->n = 0;
      sva->m_ptr = 1;
      sva->r_ptr = sva->size + 1;
      sva->head = sva->tail = 0;
#endif
      /* allocate sparse vectors in SVA */
      btf->ar_ref = sva_alloc_vecs(btf->sva, btf->n);
      btf->ac_ref = sva_alloc_vecs(btf->sva, btf->n);
      btf->fr_ref = sva_alloc_vecs(btf->sva, btf->n);
      btf->fc_ref = sva_alloc_vecs(btf->sva, btf->n);
      btf->vr_ref = sva_alloc_vecs(btf->sva, btf->n);
      btf->vc_ref = sva_alloc_vecs(btf->sva, btf->n);
      /* setup factorizer control parameters */
      sgf->updat = 0; /* wichtig! */
      sgf->piv_tol = fi->sgf_piv_tol;
      sgf->piv_lim = fi->sgf_piv_lim;
      sgf->suhl = fi->sgf_suhl;
      sgf->eps_tol = fi->sgf_eps_tol;
      /* compute LU-factorizations of diagonal blocks A~[k,k] and also
       * store corresponding columns of matrix A except elements of all
       * blocks A~[k,k] */
      for (k = 1; k <= btf->num; k++)
      {  if (btf->beg[k+1] - btf->beg[k] == 1)
         {  /* trivial case (A~[k,k] has unity order) */
            factorize_triv(fi, k, col, info);
         }
         else
         {  /* general case */
            if (factorize_block(fi, k, col, info) != 0)
               return 2; /* factorization of A~[k,k] failed */
         }
      }
#ifdef GLP_DEBUG
      sva_check_area(sva);
#endif
      /* build row-wise representation of matrix A */
      btf_build_a_rows(fi->btf, fi->sgf->rs_head);
#ifdef GLP_DEBUG
      sva_check_area(sva);
#endif
      /* BT-factorization has been successfully computed */
      fi->valid = 1;
      return 0;
}

void btfint_delete(BTFINT *fi)
{     /* delete interface to BT-factorization */
      SVA *sva = fi->sva;
      BTF *btf = fi->btf;
      SGF *sgf = fi->sgf;
      if (sva != NULL)
         sva_delete_area(sva);
      if (btf != NULL)
      {  tfree(btf->pp_ind);
         tfree(btf->pp_inv);
         tfree(btf->qq_ind);
         tfree(btf->qq_inv);
         tfree(btf->beg);
         tfree(btf->vr_piv);
         tfree(btf->p1_ind);
         tfree(btf->p1_inv);
         tfree(btf->q1_ind);
         tfree(btf->q1_inv);
         tfree(btf);
      }
      if (sgf != NULL)
      {  tfree(sgf->rs_head);
         tfree(sgf->rs_prev);
         tfree(sgf->rs_next);
         tfree(sgf->cs_head);
         tfree(sgf->cs_prev);
         tfree(sgf->cs_next);
         tfree(sgf->vr_max);
         tfree(sgf->flag);
         tfree(sgf->work);
         tfree(sgf);
      }
      tfree(fi);
      return;
}




typedef struct SCFINT SCFINT;

struct SCFINT
{     /* interface to SC-factorization */
      int valid;
      /* factorization is valid only if this flag is set */
      SCF scf;
      /* Schur-complement based factorization */
      union
      {  LUFINT *lufi; /* scf.type = 1 */
         BTFINT *btfi; /* scf.type = 2 */
      }  u;
      /* interface to factorize initial matrix A0 */
      /*--------------------------------------------------------------*/
      /* working arrays */
      double *w1; /* double w1[1+n0_max]; */
      double *w2; /* double w2[1+n0_max]; */
      double *w3; /* double w3[1+n0_max]; */
      double *w4; /* double w4[1+n0_max+nn_max]; */
      double *w5; /* double w5[1+n0_max+nn_max]; */
      /*--------------------------------------------------------------*/
      /* control parameters */
      int nn_max;
      /* required maximal number of updates */
};

//#define scfint_create _glp_scfint_create
SCFINT *scfint_create(int type);
/* create interface to SC-factorization */

//#define scfint_factorize _glp_scfint_factorize
int scfint_factorize(SCFINT *fi, int n, int (*col)(void *info, int j,
      int ind[], double val[]), void *info);
/* compute SC-factorization of specified matrix A */

//#define scfint_update _glp_scfint_update
int scfint_update(SCFINT *fi, int upd, int j, int len, const int ind[],
      const double val[]);
/* update SC-factorization after replacing j-th column of A */

//#define scfint_ftran _glp_scfint_ftran
void scfint_ftran(SCFINT *fi, double x[]);
/* solve system A * x = b */

//#define scfint_btran _glp_scfint_btran
void scfint_btran(SCFINT *fi, double x[]);
/* solve system A'* x = b */

//#define scfint_estimate _glp_scfint_estimate
double scfint_estimate(SCFINT *fi);
/* estimate 1-norm of inv(A) */

//#define scfint_delete _glp_scfint_delete
void scfint_delete(SCFINT *fi);
/* delete interface to SC-factorization */

SCFINT *scfint_create(int type)
{     /* create interface to SC-factorization */
      SCFINT *fi;
      fi = talloc(1, SCFINT);
      memset(fi, 0, sizeof(SCFINT));
      switch ((fi->scf.type = type))
      {  case 1:
            fi->u.lufi = lufint_create();
            break;
         case 2:
            fi->u.btfi = btfint_create();
            break;
         default:
            xassert(type != type);
      }
      return fi;
}

int scfint_factorize(SCFINT *fi, int n, int (*col)(void *info, int j,
      int ind[], double val[]), void *info)
{     /* compute SC-factorization of specified matrix A */
      int nn_max, old_n0_max, n0_max, k, ret;
      xassert(n > 0);
      fi->valid = 0;
      /* get required value of nn_max */
      nn_max = fi->nn_max;
      if (nn_max == 0)
         nn_max = 100;
      xassert(nn_max > 0);
      /* compute factorization of specified matrix A */
      switch (fi->scf.type)
      {  case 1:
            old_n0_max = fi->u.lufi->n_max;
            fi->u.lufi->sva_n_max = 4 * n + 2 * nn_max;
            ret = lufint_factorize(fi->u.lufi, n, col, info);
            n0_max = fi->u.lufi->n_max;
            fi->scf.sva = fi->u.lufi->sva;
            fi->scf.a0.luf = fi->u.lufi->luf;
            break;
         case 2:
            old_n0_max = fi->u.btfi->n_max;
            fi->u.btfi->sva_n_max = 6 * n + 2 * nn_max;
            ret = btfint_factorize(fi->u.btfi, n, col, info);
            n0_max = fi->u.btfi->n_max;
            fi->scf.sva = fi->u.btfi->sva;
            fi->scf.a0.btf = fi->u.btfi->btf;
            break;
         default:
            xassert(fi != fi);
      }
      /* allocate/reallocate arrays, if necessary */
      if (old_n0_max < n0_max)
      {  if (fi->w1 != NULL)
            tfree(fi->w1);
         if (fi->w2 != NULL)
            tfree(fi->w2);
         if (fi->w3 != NULL)
            tfree(fi->w3);
         fi->w1 = talloc(1+n0_max, double);
         fi->w2 = talloc(1+n0_max, double);
         fi->w3 = talloc(1+n0_max, double);
      }
      if (fi->scf.nn_max != nn_max)
      {  if (fi->scf.ifu.f != NULL)
            tfree(fi->scf.ifu.f);
         if (fi->scf.ifu.u != NULL)
            tfree(fi->scf.ifu.u);
         fi->scf.ifu.f = talloc(nn_max * nn_max, double);
         fi->scf.ifu.u = talloc(nn_max * nn_max, double);
      }
      if (old_n0_max < n0_max || fi->scf.nn_max != nn_max)
      {  if (fi->scf.pp_ind != NULL)
            tfree(fi->scf.pp_ind);
         if (fi->scf.pp_inv != NULL)
            tfree(fi->scf.pp_inv);
         if (fi->scf.qq_ind != NULL)
            tfree(fi->scf.qq_ind);
         if (fi->scf.qq_inv != NULL)
            tfree(fi->scf.qq_inv);
         if (fi->w4 != NULL)
            tfree(fi->w4);
         if (fi->w5 != NULL)
            tfree(fi->w5);
         fi->scf.pp_ind = talloc(1+n0_max+nn_max, int);
         fi->scf.pp_inv = talloc(1+n0_max+nn_max, int);
         fi->scf.qq_ind = talloc(1+n0_max+nn_max, int);
         fi->scf.qq_inv = talloc(1+n0_max+nn_max, int);
         fi->w4 = talloc(1+n0_max+nn_max, double);
         fi->w5 = talloc(1+n0_max+nn_max, double);
      }
      /* initialize SC-factorization */
      fi->scf.n = n;
      fi->scf.n0 = n;
      fi->scf.nn_max = nn_max;
      fi->scf.nn = 0;
      fi->scf.rr_ref = sva_alloc_vecs(fi->scf.sva, nn_max);
      fi->scf.ss_ref = sva_alloc_vecs(fi->scf.sva, nn_max);
      fi->scf.ifu.n_max = nn_max;
      fi->scf.ifu.n = 0;
      for (k = 1; k <= n; k++)
      {  fi->scf.pp_ind[k] = k;
         fi->scf.pp_inv[k] = k;
         fi->scf.qq_ind[k] = k;
         fi->scf.qq_inv[k] = k;
      }
      /* set validation flag */
      if (ret == 0)
         fi->valid = 1;
      return ret;
}

int scfint_update(SCFINT *fi, int upd, int j, int len, const int ind[],
      const double val[])
{     /* update SC-factorization after replacing j-th column of A */
      int n = fi->scf.n;
      int n0 = fi->scf.n0;
      int nn = fi->scf.nn;
      int *pp_ind = fi->scf.pp_ind;
      int *qq_ind = fi->scf.qq_ind;
      int *qq_inv = fi->scf.qq_inv;
      double *bf = fi->w4;
      double *dg = fi->w5;
      int k, t, ret;
      xassert(fi->valid);
      xassert(0 <= n && n <= n0+nn);
      /* (b, f) := inv(P) * (beta, 0) */
      for (k = 1; k <= n0+nn; k++)
         bf[k] = 0.0;
      for (t = 1; t <= len; t++)
      {  k = ind[t];
         xassert(1 <= k && k <= n);
#if 1 /* FIXME: currently P = I */
         xassert(pp_ind[k] == k);
#endif
         xassert(bf[k] == 0.0);
         xassert(val[t] != 0.0);
         bf[k] = val[t];
      }
      /* (d, g) := Q * (cj, 0) */
      for (k = 1; k <= n0+nn; k++)
         dg[k] = 0.0;
      xassert(1 <= j && j <= n);
      dg[fi->scf.qq_inv[j]] = 1;
      /* update factorization of augmented matrix */
      ret = scf_update_aug(&fi->scf, &bf[0], &dg[0], &bf[n0], &dg[n0],
         0.0, upd, fi->w1, fi->w2, fi->w3);
      if (ret == 0)
      {  /* swap j-th and last columns of new matrix Q */
         scf_swap_q_cols(j, n0+nn+1);
      }
      else
      {  /* updating failed */
         fi->valid = 0;
      }
      return ret;
}

void scfint_ftran(SCFINT *fi, double x[])
{     /* solve system A * x = b */
      xassert(fi->valid);
      scf_a_solve(&fi->scf, x, fi->w4, fi->w5, fi->w1, fi->w2);
      return;
}

void scfint_btran(SCFINT *fi, double x[])
{     /* solve system A'* x = b */
      xassert(fi->valid);
      scf_at_solve(&fi->scf, x, fi->w4, fi->w5, fi->w1, fi->w2);
      return;
}

double scfint_estimate(SCFINT *fi)
{     /* estimate 1-norm of inv(A) */
      double norm;
      xassert(fi->valid);
      xassert(fi->scf.n == fi->scf.n0);
      switch (fi->scf.type)
      {  case 1:
            norm = luf_estimate_norm(fi->scf.a0.luf, fi->w1, fi->w2);
            break;
         case 2:
            norm = btf_estimate_norm(fi->scf.a0.btf, fi->w1, fi->w2,
               fi->w3, fi->w4);
            break;
         default:
            xassert(fi != fi);
      }
      return norm;
}

void scfint_delete(SCFINT *fi)
{     /* delete interface to SC-factorization */
      switch (fi->scf.type)
      {  case 1:
            lufint_delete(fi->u.lufi);
            break;
         case 2:
            btfint_delete(fi->u.btfi);
            break;
         default:
            xassert(fi != fi);
      }
      if (fi->scf.ifu.f != NULL)
         tfree(fi->scf.ifu.f);
      if (fi->scf.ifu.u != NULL)
         tfree(fi->scf.ifu.u);
      if (fi->scf.pp_ind != NULL)
         tfree(fi->scf.pp_ind);
      if (fi->scf.pp_inv != NULL)
         tfree(fi->scf.pp_inv);
      if (fi->scf.qq_ind != NULL)
         tfree(fi->scf.qq_ind);
      if (fi->scf.qq_inv != NULL)
         tfree(fi->scf.qq_inv);
      if (fi->w1 != NULL)
         tfree(fi->w1);
      if (fi->w2 != NULL)
         tfree(fi->w2);
      if (fi->w3 != NULL)
         tfree(fi->w3);
      if (fi->w4 != NULL)
         tfree(fi->w4);
      if (fi->w5 != NULL)
         tfree(fi->w5);
      tfree(fi);
      return;
}













typedef struct BFD BFD;

/* return codes: */
#define BFD_ESING    1  /* singular matrix */
#define BFD_ECOND    2  /* ill-conditioned matrix */
#define BFD_ECHECK   3  /* insufficient accuracy */
#define BFD_ELIMIT   4  /* update limit reached */
#if 0 /* 05/III-2014 */
#define BFD_EROOM    5  /* SVA overflow */
#endif

#define bfd_create_it _glp_bfd_create_it
BFD *bfd_create_it(void);
/* create LP basis factorization */

#define bfd_get_bfcp _glp_bfd_get_bfcp
void bfd_get_bfcp(BFD *bfd, void /* glp_bfcp */ *parm);
/* retrieve LP basis factorization control parameters */

#define bfd_set_bfcp _glp_bfd_set_bfcp
void bfd_set_bfcp(BFD *bfd, const void /* glp_bfcp */ *parm);
/* change LP basis factorization control parameters */

#define bfd_factorize _glp_bfd_factorize
int bfd_factorize(BFD *bfd, int m, /*const int bh[],*/ int (*col)
      (void *info, int j, int ind[], double val[]), void *info);
/* compute LP basis factorization */

#if 1 /* 21/IV-2014 */
#define bfd_condest _glp_bfd_condest
double bfd_condest(BFD *bfd);
/* estimate condition of B */
#endif

#define bfd_ftran _glp_bfd_ftran
void bfd_ftran(BFD *bfd, double x[]);
/* perform forward transformation (solve system B*x = b) */

#if 1 /* 30/III-2016 */
#define bfd_ftran_s _glp_bfd_ftran_s
void bfd_ftran_s(BFD *bfd, FVS *x);
/* sparse version of bfd_ftran */
#endif

#define bfd_btran _glp_bfd_btran
void bfd_btran(BFD *bfd, double x[]);
/* perform backward transformation (solve system B'*x = b) */

#if 1 /* 30/III-2016 */
#define bfd_btran_s _glp_bfd_btran_s
void bfd_btran_s(BFD *bfd, FVS *x);
/* sparse version of bfd_btran */
#endif

#define bfd_update _glp_bfd_update
int bfd_update(BFD *bfd, int j, int len, const int ind[], const double
      val[]);
/* update LP basis factorization */

#define bfd_get_count _glp_bfd_get_count
int bfd_get_count(BFD *bfd);
/* determine factorization update count */

#define bfd_delete_it _glp_bfd_delete_it
void bfd_delete_it(BFD *bfd);
/* delete LP basis factorization */

struct BFD
{     /* LP basis factorization driver */
      int valid;
      /* factorization is valid only if this flag is set */
      int type;
      /* type of factorization used:
         0 - interface not established yet
         1 - FHV-factorization
         2 - Schur-complement-based factorization */
      union
      {  void *none;   /* type = 0 */
         FHVINT *fhvi; /* type = 1 */
         SCFINT *scfi; /* type = 2 */
      }  u;
      /* interface to factorization of LP basis */
      glp_bfcp parm;
      /* factorization control parameters */
#ifdef GLP_DEBUG
      SPM *B;
      /* current basis (for testing/debugging only) */
#endif
      int upd_cnt;
      /* factorization update count */
#if 1 /* 21/IV-2014 */
      double b_norm;
      /* 1-norm of matrix B */
      double i_norm;
      /* estimated 1-norm of matrix inv(B) */
#endif
};

BFD *bfd_create_it(void)
{     /* create LP basis factorization */
      BFD *bfd;
#ifdef GLP_DEBUG
      xprintf("bfd_create_it: warning: debugging version used\n");
#endif
      bfd = talloc(1, BFD);
      bfd->valid = 0;
      bfd->type = 0;
      bfd->u.none = NULL;
      bfd_set_bfcp(bfd, NULL);
#ifdef GLP_DEBUG
      bfd->B = NULL;
#endif
      bfd->upd_cnt = 0;
      return bfd;
}

#if 0 /* 08/III-2014 */
void bfd_set_parm(BFD *bfd, const void *parm)
{     /* change LP basis factorization control parameters */
      memcpy(&bfd->parm, parm, sizeof(glp_bfcp));
      return;
}
#endif

void bfd_get_bfcp(BFD *bfd, void /* glp_bfcp */ *parm)
{     /* retrieve LP basis factorization control parameters */
      memcpy(parm, &bfd->parm, sizeof(glp_bfcp));
      return;
}

void bfd_set_bfcp(BFD *bfd, const void /* glp_bfcp */ *parm)
{     /* change LP basis factorization control parameters */
      if (parm == NULL)
      {  /* reset to default */
         memset(&bfd->parm, 0, sizeof(glp_bfcp));
         bfd->parm.type = GLP_BF_LUF + GLP_BF_FT;
         bfd->parm.piv_tol = 0.10;
         bfd->parm.piv_lim = 4;
         bfd->parm.suhl = 1;
         bfd->parm.eps_tol = DBL_EPSILON;
         bfd->parm.nfs_max = 100;
         bfd->parm.nrs_max = 70;
      }
      else
         memcpy(&bfd->parm, parm, sizeof(glp_bfcp));
      return;
}

#if 1 /* 21/IV-2014 */
struct bfd_info
{     BFD *bfd;
      int (*col)(void *info, int j, int ind[], double val[]);
      void *info;
};

static int bfd_col(void *info_, int j, int ind[], double val[])
{     struct bfd_info *info = info_;
      int t, len;
      double sum;
      len = info->col(info->info, j, ind, val);
      sum = 0.0;
      for (t = 1; t <= len; t++)
      {  if (val[t] >= 0.0)
            sum += val[t];
         else
            sum -= val[t];
      }
      if (info->bfd->b_norm < sum)
         info->bfd->b_norm = sum;
      return len;
}
#endif

int bfd_factorize(BFD *bfd, int m, /*const int bh[],*/ int (*col1)
      (void *info, int j, int ind[], double val[]), void *info1)
{     /* compute LP basis factorization */
#if 1 /* 21/IV-2014 */
      struct bfd_info info;
#endif
      int type, ret;
      /*xassert(bh == bh);*/
      /* invalidate current factorization */
      bfd->valid = 0;
      /* determine required factorization type */
      switch (bfd->parm.type)
      {  case GLP_BF_LUF + GLP_BF_FT:
            type = 1;
            break;
         case GLP_BF_LUF + GLP_BF_BG:
         case GLP_BF_LUF + GLP_BF_GR:
         case GLP_BF_BTF + GLP_BF_BG:
         case GLP_BF_BTF + GLP_BF_GR:
            type = 2;
            break;
         default:
            xassert(bfd != bfd);
      }
      /* delete factorization interface, if necessary */
      switch (bfd->type)
      {  case 0:
            break;
         case 1:
            if (type != 1)
            {  bfd->type = 0;
               fhvint_delete(bfd->u.fhvi);
               bfd->u.fhvi = NULL;
            }
            break;
         case 2:
            if (type != 2)
            {  bfd->type = 0;
               scfint_delete(bfd->u.scfi);
               bfd->u.scfi = NULL;
            }
            break;
         default:
            xassert(bfd != bfd);
      }
      /* establish factorization interface, if necessary */
      if (bfd->type == 0)
      {  switch (type)
         {  case 1:
               bfd->type = 1;
               xassert(bfd->u.fhvi == NULL);
               bfd->u.fhvi = fhvint_create();
               break;
            case 2:
               bfd->type = 2;
               xassert(bfd->u.scfi == NULL);
               if (!(bfd->parm.type & GLP_BF_BTF))
                  bfd->u.scfi = scfint_create(1);
               else
                  bfd->u.scfi = scfint_create(2);
               break;
            default:
               xassert(type != type);
         }
      }
      /* try to compute factorization */
#if 1 /* 21/IV-2014 */
      bfd->b_norm = bfd->i_norm = 0.0;
      info.bfd = bfd;
      info.col = col1;
      info.info = info1;
#endif
      switch (bfd->type)
      {  case 1:
            bfd->u.fhvi->lufi->sgf_piv_tol = bfd->parm.piv_tol;
            bfd->u.fhvi->lufi->sgf_piv_lim = bfd->parm.piv_lim;
            bfd->u.fhvi->lufi->sgf_suhl = bfd->parm.suhl;
            bfd->u.fhvi->lufi->sgf_eps_tol = bfd->parm.eps_tol;
            bfd->u.fhvi->nfs_max = bfd->parm.nfs_max;
            ret = fhvint_factorize(bfd->u.fhvi, m, bfd_col, &info);
#if 1 /* FIXME */
            if (ret == 0)
               bfd->i_norm = fhvint_estimate(bfd->u.fhvi);
            else
               ret = BFD_ESING;
#endif
            break;
         case 2:
            if (bfd->u.scfi->scf.type == 1)
            {  bfd->u.scfi->u.lufi->sgf_piv_tol = bfd->parm.piv_tol;
               bfd->u.scfi->u.lufi->sgf_piv_lim = bfd->parm.piv_lim;
               bfd->u.scfi->u.lufi->sgf_suhl = bfd->parm.suhl;
               bfd->u.scfi->u.lufi->sgf_eps_tol = bfd->parm.eps_tol;
            }
            else if (bfd->u.scfi->scf.type == 2)
            {  bfd->u.scfi->u.btfi->sgf_piv_tol = bfd->parm.piv_tol;
               bfd->u.scfi->u.btfi->sgf_piv_lim = bfd->parm.piv_lim;
               bfd->u.scfi->u.btfi->sgf_suhl = bfd->parm.suhl;
               bfd->u.scfi->u.btfi->sgf_eps_tol = bfd->parm.eps_tol;
            }
            else
               xassert(bfd != bfd);
            bfd->u.scfi->nn_max = bfd->parm.nrs_max;
            ret = scfint_factorize(bfd->u.scfi, m, bfd_col, &info);
#if 1 /* FIXME */
            if (ret == 0)
               bfd->i_norm = scfint_estimate(bfd->u.scfi);
            else
               ret = BFD_ESING;
#endif
            break;
         default:
            xassert(bfd != bfd);
      }
#ifdef GLP_DEBUG
      /* save specified LP basis */
      if (bfd->B != NULL)
         spm_delete_mat(bfd->B);
      bfd->B = spm_create_mat(m, m);
      {  int *ind = talloc(1+m, int);
         double *val = talloc(1+m, double);
         int j, k, len;
         for (j = 1; j <= m; j++)
         {  len = col(info, j, ind, val);
            for (k = 1; k <= len; k++)
               spm_new_elem(bfd->B, ind[k], j, val[k]);
         }
         tfree(ind);
         tfree(val);
      }
#endif
      if (ret == 0)
      {  /* factorization has been successfully computed */
         double cond;
         bfd->valid = 1;
#ifdef GLP_DEBUG
         cond = bfd_condest(bfd);
         if (cond > 1e9)
            xprintf("bfd_factorize: warning: cond(B) = %g\n", cond);
#endif
      }
#ifdef GLP_DEBUG
      xprintf("bfd_factorize: m = %d; ret = %d\n", m, ret);
#endif
      bfd->upd_cnt = 0;
      return ret;
}

#if 0 /* 21/IV-2014 */
double bfd_estimate(BFD *bfd)
{     /* estimate 1-norm of inv(B) */
      double norm;
      xassert(bfd->valid);
      xassert(bfd->upd_cnt == 0);
      switch (bfd->type)
      {  case 1:
            norm = fhvint_estimate(bfd->u.fhvi);
            break;
         case 2:
            norm = scfint_estimate(bfd->u.scfi);
            break;
         default:
            xassert(bfd != bfd);
      }
      return norm;
}
#endif

#if 1 /* 21/IV-2014 */
double bfd_condest(BFD *bfd)
{     /* estimate condition of B */
      double cond;
      xassert(bfd->valid);
      /*xassert(bfd->upd_cnt == 0);*/
      cond = bfd->b_norm * bfd->i_norm;
      if (cond < 1.0)
         cond = 1.0;
      return cond;
}
#endif

void bfd_ftran(BFD *bfd, double x[])
{     /* perform forward transformation (solve system B * x = b) */
#ifdef GLP_DEBUG
      SPM *B = bfd->B;
      int m = B->m;
      double *b = talloc(1+m, double);
      SPME *e;
      int k;
      double s, relerr, maxerr;
      for (k = 1; k <= m; k++)
         b[k] = x[k];
#endif
      xassert(bfd->valid);
      switch (bfd->type)
      {  case 1:
            fhvint_ftran(bfd->u.fhvi, x);
            break;
         case 2:
            scfint_ftran(bfd->u.scfi, x);
            break;
         default:
            xassert(bfd != bfd);
      }
#ifdef GLP_DEBUG
      maxerr = 0.0;
      for (k = 1; k <= m; k++)
      {  s = 0.0;
         for (e = B->row[k]; e != NULL; e = e->r_next)
            s += e->val * x[e->j];
         relerr = (b[k] - s) / (1.0 + fabs(b[k]));
         if (maxerr < relerr)
            maxerr = relerr;
      }
      if (maxerr > 1e-8)
         xprintf("bfd_ftran: maxerr = %g; relative error too large\n",
            maxerr);
      tfree(b);
#endif
      return;
}

#if 1 /* 30/III-2016 */
void bfd_ftran_s(BFD *bfd, FVS *x)
{     /* sparse version of bfd_ftran */
      /* (sparse mode is not implemented yet) */
      int n = x->n;
      int *ind = x->ind;
      double *vec = x->vec;
      int j, nnz = 0;
      bfd_ftran(bfd, vec);
      for (j = n; j >= 1; j--)
      {  if (vec[j] != 0.0)
            ind[++nnz] = j;
      }
      x->nnz = nnz;
      return;
}
#endif

void bfd_btran(BFD *bfd, double x[])
{     /* perform backward transformation (solve system B'* x = b) */
#ifdef GLP_DEBUG
      SPM *B = bfd->B;
      int m = B->m;
      double *b = talloc(1+m, double);
      SPME *e;
      int k;
      double s, relerr, maxerr;
      for (k = 1; k <= m; k++)
         b[k] = x[k];
#endif
      xassert(bfd->valid);
      switch (bfd->type)
      {  case 1:
            fhvint_btran(bfd->u.fhvi, x);
            break;
         case 2:
            scfint_btran(bfd->u.scfi, x);
            break;
         default:
            xassert(bfd != bfd);
      }
#ifdef GLP_DEBUG
      maxerr = 0.0;
      for (k = 1; k <= m; k++)
      {  s = 0.0;
         for (e = B->col[k]; e != NULL; e = e->c_next)
            s += e->val * x[e->i];
         relerr = (b[k] - s) / (1.0 + fabs(b[k]));
         if (maxerr < relerr)
            maxerr = relerr;
      }
      if (maxerr > 1e-8)
         xprintf("bfd_btran: maxerr = %g; relative error too large\n",
            maxerr);
      tfree(b);
#endif
      return;
}

#if 1 /* 30/III-2016 */
void bfd_btran_s(BFD *bfd, FVS *x)
{     /* sparse version of bfd_btran */
      /* (sparse mode is not implemented yet) */
      int n = x->n;
      int *ind = x->ind;
      double *vec = x->vec;
      int j, nnz = 0;
      bfd_btran(bfd, vec);
      for (j = n; j >= 1; j--)
      {  if (vec[j] != 0.0)
            ind[++nnz] = j;
      }
      x->nnz = nnz;
      return;
}
#endif

int bfd_update(BFD *bfd, int j, int len, const int ind[], const double
      val[])
{     /* update LP basis factorization */
      int ret;
      xassert(bfd->valid);
      switch (bfd->type)
      {  case 1:
            ret = fhvint_update(bfd->u.fhvi, j, len, ind, val);
#if 1 /* FIXME */
            switch (ret)
            {  case 0:
                  break;
               case 1:
                  ret = BFD_ESING;
                  break;
               case 2:
               case 3:
                  ret = BFD_ECOND;
                  break;
               case 4:
                  ret = BFD_ELIMIT;
                  break;
               case 5:
                  ret = BFD_ECHECK;
                  break;
               default:
                  xassert(ret != ret);
            }
#endif
            break;
         case 2:
            switch (bfd->parm.type & 0x0F)
            {  case GLP_BF_BG:
                  ret = scfint_update(bfd->u.scfi, 1, j, len, ind, val);
                  break;
               case GLP_BF_GR:
                  ret = scfint_update(bfd->u.scfi, 2, j, len, ind, val);
                  break;
               default:
                  xassert(bfd != bfd);
            }
#if 1 /* FIXME */
            switch (ret)
            {  case 0:
                  break;
               case 1:
                  ret = BFD_ELIMIT;
                  break;
               case 2:
                  ret = BFD_ECOND;
                  break;
               default:
                  xassert(ret != ret);
            }
#endif
            break;
         default:
            xassert(bfd != bfd);
      }
      if (ret != 0)
      {  /* updating factorization failed */
         bfd->valid = 0;
      }
#ifdef GLP_DEBUG
      /* save updated LP basis */
      {  SPME *e;
         int k;
         for (e = bfd->B->col[j]; e != NULL; e = e->c_next)
            e->val = 0.0;
         spm_drop_zeros(bfd->B, 0.0);
         for (k = 1; k <= len; k++)
            spm_new_elem(bfd->B, ind[k], j, val[k]);
      }
#endif
      if (ret == 0)
         bfd->upd_cnt++;
      return ret;
}

int bfd_get_count(BFD *bfd)
{     /* determine factorization update count */
      return bfd->upd_cnt;
}

void bfd_delete_it(BFD *bfd)
{     /* delete LP basis factorization */
      switch (bfd->type)
      {  case 0:
            break;
         case 1:
            fhvint_delete(bfd->u.fhvi);
            break;
         case 2:
            scfint_delete(bfd->u.scfi);
            break;
         default:
            xassert(bfd != bfd);
      }
#ifdef GLP_DEBUG
      if (bfd->B != NULL)
         spm_delete_mat(bfd->B);
#endif
      tfree(bfd);
      return;
}






















#if 1 /* 28/III-2016 */
#define GLP_UNDOC 1
#endif

typedef struct GLPROW GLPROW;
typedef struct GLPCOL GLPCOL;
typedef struct GLPAIJ GLPAIJ;

#define GLP_PROB_MAGIC 0xD7D9D6C2

struct glp_prob
{     /* LP/MIP problem object */
      unsigned magic;
      /* magic value used for debugging */
      DMP *pool;
      /* memory pool to store problem object components */
      glp_tree *tree;
      /* pointer to the search tree; set by the MIP solver when this
         object is used in the tree as a core MIP object */
#if 0 /* 08/III-2014 */
      void *parms;
      /* reserved for backward compatibility */
#endif
      /*--------------------------------------------------------------*/
      /* LP/MIP data */
      char *name;
      /* problem name (1 to 255 chars); NULL means no name is assigned
         to the problem */
      char *obj;
      /* objective function name (1 to 255 chars); NULL means no name
         is assigned to the objective function */
      int dir;
      /* optimization direction flag (objective "sense"):
         GLP_MIN - minimization
         GLP_MAX - maximization */
      double c0;
      /* constant term of the objective function ("shift") */
      int m_max;
      /* length of the array of rows (enlarged automatically) */
      int n_max;
      /* length of the array of columns (enlarged automatically) */
      int m;
      /* number of rows, 0 <= m <= m_max */
      int n;
      /* number of columns, 0 <= n <= n_max */
      int nnz;
      /* number of non-zero constraint coefficients, nnz >= 0 */
      GLPROW **row; /* GLPROW *row[1+m_max]; */
      /* row[i], 1 <= i <= m, is a pointer to i-th row */
      GLPCOL **col; /* GLPCOL *col[1+n_max]; */
      /* col[j], 1 <= j <= n, is a pointer to j-th column */
      AVL *r_tree;
      /* row index to find rows by their names; NULL means this index
         does not exist */
      AVL *c_tree;
      /* column index to find columns by their names; NULL means this
         index does not exist */
      /*--------------------------------------------------------------*/
      /* basis factorization (LP) */
      int valid;
      /* the factorization is valid only if this flag is set */
      int *head; /* int head[1+m_max]; */
      /* basis header (valid only if the factorization is valid);
         head[i] = k is the ordinal number of auxiliary (1 <= k <= m)
         or structural (m+1 <= k <= m+n) variable which corresponds to
         i-th basic variable xB[i], 1 <= i <= m */
#if 0 /* 08/III-2014 */
      glp_bfcp *bfcp;
      /* basis factorization control parameters; may be NULL */
#endif
      BFD *bfd; /* BFD bfd[1:m,1:m]; */
      /* basis factorization driver; may be NULL */
      /*--------------------------------------------------------------*/
      /* basic solution (LP) */
      int pbs_stat;
      /* primal basic solution status:
         GLP_UNDEF  - primal solution is undefined
         GLP_FEAS   - primal solution is feasible
         GLP_INFEAS - primal solution is infeasible
         GLP_NOFEAS - no primal feasible solution exists */
      int dbs_stat;
      /* dual basic solution status:
         GLP_UNDEF  - dual solution is undefined
         GLP_FEAS   - dual solution is feasible
         GLP_INFEAS - dual solution is infeasible
         GLP_NOFEAS - no dual feasible solution exists */
      double obj_val;
      /* objective function value */
      int it_cnt;
      /* simplex method iteration count; increases by one on performing
         one simplex iteration */
      int some;
      /* ordinal number of some auxiliary or structural variable having
         certain property, 0 <= some <= m+n */
      /*--------------------------------------------------------------*/
      /* interior-point solution (LP) */
      int ipt_stat;
      /* interior-point solution status:
         GLP_UNDEF  - interior solution is undefined
         GLP_OPT    - interior solution is optimal
         GLP_INFEAS - interior solution is infeasible
         GLP_NOFEAS - no feasible solution exists */
      double ipt_obj;
      /* objective function value */
      /*--------------------------------------------------------------*/
      /* integer solution (MIP) */
      int mip_stat;
      /* integer solution status:
         GLP_UNDEF  - integer solution is undefined
         GLP_OPT    - integer solution is optimal
         GLP_FEAS   - integer solution is feasible
         GLP_NOFEAS - no integer solution exists */
      double mip_obj;
      /* objective function value */
};
typedef struct glp_prob glp_prob;

glp_prob *glp_create_prob(void); // <-------------------------------
/* create problem object */

void glp_set_prob_name(glp_prob *P, const char *name); // <-------------------------------
/* assign (change) problem name */

void glp_set_obj_name(glp_prob *P, const char *name);
/* assign (change) objective function name */

void glp_set_obj_dir(glp_prob *P, int dir);
/* set (change) optimization direction flag */

int glp_add_rows(glp_prob *P, int nrs); // <-------------------------------
/* add new rows to problem object */

int glp_add_cols(glp_prob *P, int ncs); // <-------------------------------
/* add new columns to problem object */

void glp_set_row_name(glp_prob *P, int i, const char *name); // <-------------------------------
/* assign (change) row name */

void glp_set_col_name(glp_prob *P, int j, const char *name); // <-------------------------------
/* assign (change) column name */

void glp_set_row_bnds(glp_prob *P, int i, int type, double lb, // <-------------------------------
      double ub);
/* set (change) row bounds */

void glp_set_col_bnds(glp_prob *P, int j, int type, double lb, // <-------------------------------
      double ub);
/* set (change) column bounds */

void glp_set_obj_coef(glp_prob *P, int j, double coef);
/* set (change) obj. coefficient or constant term */

void glp_set_mat_row(glp_prob *P, int i, int len, const int ind[],
      const double val[]);
/* set (replace) row of the constraint matrix */

void glp_set_mat_col(glp_prob *P, int j, int len, const int ind[],
      const double val[]);
/* set (replace) column of the constraint matrix */

void glp_load_matrix(glp_prob *P, int ne, const int ia[], // <-------------------------------
      const int ja[], const double ar[]);
/* load (replace) the whole constraint matrix */

int glp_check_dup(int m, int n, int ne, const int ia[], const int ja[]);
/* check for duplicate elements in sparse matrix */

void glp_sort_matrix(glp_prob *P);
/* sort elements of the constraint matrix */

void glp_del_rows(glp_prob *P, int nrs, const int num[]);
/* delete specified rows from problem object */

void glp_del_cols(glp_prob *P, int ncs, const int num[]);
/* delete specified columns from problem object */

void glp_copy_prob(glp_prob *dest, glp_prob *prob, int names);
/* copy problem object content */

void glp_erase_prob(glp_prob *P);
/* erase problem object content */

void glp_delete_prob(glp_prob *P);
/* delete problem object */

const char *glp_get_prob_name(glp_prob *P);
/* retrieve problem name */

const char *glp_get_obj_name(glp_prob *P);
/* retrieve objective function name */

int glp_get_obj_dir(glp_prob *P);
/* retrieve optimization direction flag */

int glp_get_num_rows(glp_prob *P);
/* retrieve number of rows */

int glp_get_num_cols(glp_prob *P);
/* retrieve number of columns */

const char *glp_get_row_name(glp_prob *P, int i);
/* retrieve row name */

const char *glp_get_col_name(glp_prob *P, int j);
/* retrieve column name */

int glp_get_row_type(glp_prob *P, int i);
/* retrieve row type */

double glp_get_row_lb(glp_prob *P, int i);
/* retrieve row lower bound */

double glp_get_row_ub(glp_prob *P, int i);
/* retrieve row upper bound */

int glp_get_col_type(glp_prob *P, int j);
/* retrieve column type */

double glp_get_col_lb(glp_prob *P, int j);
/* retrieve column lower bound */

double glp_get_col_ub(glp_prob *P, int j);
/* retrieve column upper bound */

double glp_get_obj_coef(glp_prob *P, int j);
/* retrieve obj. coefficient or constant term */

int glp_get_num_nz(glp_prob *P);
/* retrieve number of constraint coefficients */

int glp_get_mat_row(glp_prob *P, int i, int ind[], double val[]);
/* retrieve row of the constraint matrix */

int glp_get_mat_col(glp_prob *P, int j, int ind[], double val[]);
/* retrieve column of the constraint matrix */

void glp_create_index(glp_prob *P);
/* create the name index */

int glp_find_row(glp_prob *P, const char *name);
/* find row by its name */

int glp_find_col(glp_prob *P, const char *name);
/* find column by its name */

void glp_delete_index(glp_prob *P);
/* delete the name index */

void glp_set_rii(glp_prob *P, int i, double rii);
/* set (change) row scale factor */

void glp_set_sjj(glp_prob *P, int j, double sjj);
/* set (change) column scale factor */

double glp_get_rii(glp_prob *P, int i);
/* retrieve row scale factor */

double glp_get_sjj(glp_prob *P, int j);
/* retrieve column scale factor */

void glp_scale_prob(glp_prob *P, int flags);
/* scale problem data */

void glp_unscale_prob(glp_prob *P);
/* unscale problem data */

void glp_set_row_stat(glp_prob *P, int i, int stat);
/* set (change) row status */

void glp_set_col_stat(glp_prob *P, int j, int stat);
/* set (change) column status */

void glp_std_basis(glp_prob *P);
/* construct standard initial LP basis */

void glp_adv_basis(glp_prob *P, int flags);
/* construct advanced initial LP basis */

void glp_cpx_basis(glp_prob *P);
/* construct Bixby's initial LP basis */

int glp_simplex(glp_prob *P, const glp_smcp *parm);
/* solve LP problem with the simplex method */

int glp_exact(glp_prob *P, const glp_smcp *parm);
/* solve LP problem in exact arithmetic */

void glp_init_smcp(glp_smcp *parm);
/* initialize simplex method control parameters */

int glp_get_status(glp_prob *P);
/* retrieve generic status of basic solution */

int glp_get_prim_stat(glp_prob *P);
/* retrieve status of primal basic solution */

int glp_get_dual_stat(glp_prob *P);
/* retrieve status of dual basic solution */

double glp_get_obj_val(glp_prob *P); // <-------------------------------
/* retrieve objective value (basic solution) */

int glp_get_row_stat(glp_prob *P, int i);
/* retrieve row status */

double glp_get_row_prim(glp_prob *P, int i);
/* retrieve row primal value (basic solution) */

double glp_get_row_dual(glp_prob *P, int i);
/* retrieve row dual value (basic solution) */

int glp_get_col_stat(glp_prob *P, int j);
/* retrieve column status */

double glp_get_col_prim(glp_prob *P, int j);
/* retrieve column primal value (basic solution) */

double glp_get_col_dual(glp_prob *P, int j);
/* retrieve column dual value (basic solution) */

int glp_get_unbnd_ray(glp_prob *P);
/* determine variable causing unboundedness */

#if 1 /* 08/VIII-2013; not documented yet */
int glp_get_it_cnt(glp_prob *P);
/* get simplex solver iteration count */
#endif

#if 1 /* 08/VIII-2013; not documented yet */
void glp_set_it_cnt(glp_prob *P, int it_cnt);
/* set simplex solver iteration count */
#endif

int glp_interior(glp_prob *P, const glp_iptcp *parm);
/* solve LP problem with the interior-point method */

void glp_init_iptcp(glp_iptcp *parm);
/* initialize interior-point solver control parameters */

int glp_ipt_status(glp_prob *P);
/* retrieve status of interior-point solution */

double glp_ipt_obj_val(glp_prob *P);
/* retrieve objective value (interior point) */

double glp_ipt_row_prim(glp_prob *P, int i);
/* retrieve row primal value (interior point) */

double glp_ipt_row_dual(glp_prob *P, int i);
/* retrieve row dual value (interior point) */

double glp_ipt_col_prim(glp_prob *P, int j);
/* retrieve column primal value (interior point) */

double glp_ipt_col_dual(glp_prob *P, int j);
/* retrieve column dual value (interior point) */

void glp_set_col_kind(glp_prob *P, int j, int kind);
/* set (change) column kind */

int glp_get_col_kind(glp_prob *P, int j);
/* retrieve column kind */

int glp_get_num_int(glp_prob *P);
/* retrieve number of integer columns */

int glp_get_num_bin(glp_prob *P);
/* retrieve number of binary columns */

int glp_intopt(glp_prob *P, const glp_iocp *parm); // <-------------------------------
/* solve MIP problem with the branch-and-bound method */

void glp_init_iocp(glp_iocp *parm); // <-------------------------------
/* initialize integer optimizer control parameters */

int glp_mip_status(glp_prob *P);
/* retrieve status of MIP solution */

double glp_mip_obj_val(glp_prob *P);
/* retrieve objective value (MIP solution) */

double glp_mip_row_val(glp_prob *P, int i); // <-------------------------------
/* retrieve row value (MIP solution) */

double glp_mip_col_val(glp_prob *P, int j); // <-------------------------------
/* retrieve column value (MIP solution) */

void glp_check_kkt(glp_prob *P, int sol, int cond, double *ae_max,
      int *ae_ind, double *re_max, int *re_ind);
/* check feasibility/optimality conditions */

int glp_print_sol(glp_prob *P, const char *fname);
/* write basic solution in printable format */

int glp_read_sol(glp_prob *P, const char *fname);
/* read basic solution from text file */

int glp_write_sol(glp_prob *P, const char *fname);
/* write basic solution to text file */

int glp_print_ranges(glp_prob *P, int len, const int list[],
      int flags, const char *fname);
/* print sensitivity analysis report */

int glp_print_ipt(glp_prob *P, const char *fname);
/* write interior-point solution in printable format */

int glp_read_ipt(glp_prob *P, const char *fname);
/* read interior-point solution from text file */

int glp_write_ipt(glp_prob *P, const char *fname);
/* write interior-point solution to text file */

int glp_print_mip(glp_prob *P, const char *fname);
/* write MIP solution in printable format */

int glp_read_mip(glp_prob *P, const char *fname);
/* read MIP solution from text file */

int glp_write_mip(glp_prob *P, const char *fname);
/* write MIP solution to text file */

int glp_bf_exists(glp_prob *P);
/* check if LP basis factorization exists */

int glp_factorize(glp_prob *P);
/* compute LP basis factorization */

int glp_bf_updated(glp_prob *P);
/* check if LP basis factorization has been updated */

void glp_get_bfcp(glp_prob *P, glp_bfcp *parm);
/* retrieve LP basis factorization control parameters */

void glp_set_bfcp(glp_prob *P, const glp_bfcp *parm);
/* change LP basis factorization control parameters */

int glp_get_bhead(glp_prob *P, int k);
/* retrieve LP basis header information */

int glp_get_row_bind(glp_prob *P, int i);
/* retrieve row index in the basis header */

int glp_get_col_bind(glp_prob *P, int j);
/* retrieve column index in the basis header */

void glp_ftran(glp_prob *P, double x[]);
/* perform forward transformation (solve system B*x = b) */

void glp_btran(glp_prob *P, double x[]);
/* perform backward transformation (solve system B'*x = b) */

int glp_warm_up(glp_prob *P);
/* "warm up" LP basis */

int glp_eval_tab_row(glp_prob *P, int k, int ind[], double val[]);
/* compute row of the simplex tableau */

int glp_eval_tab_col(glp_prob *P, int k, int ind[], double val[]);
/* compute column of the simplex tableau */

int glp_transform_row(glp_prob *P, int len, int ind[], double val[]);
/* transform explicitly specified row */

int glp_transform_col(glp_prob *P, int len, int ind[], double val[]);
/* transform explicitly specified column */

int glp_prim_rtest(glp_prob *P, int len, const int ind[],
      const double val[], int dir, double eps);
/* perform primal ratio test */

int glp_dual_rtest(glp_prob *P, int len, const int ind[],
      const double val[], int dir, double eps);
/* perform dual ratio test */

void glp_analyze_bound(glp_prob *P, int k, double *value1, int *var1,
      double *value2, int *var2);
/* analyze active bound of non-basic variable */

void glp_analyze_coef(glp_prob *P, int k, double *coef1, int *var1,
      double *value1, double *coef2, int *var2, double *value2);
/* analyze objective coefficient at basic variable */

int glp_ios_reason(glp_tree *T);
/* determine reason for calling the callback routine */

glp_prob *glp_ios_get_prob(glp_tree *T);
/* access the problem object */

void glp_ios_tree_size(glp_tree *T, int *a_cnt, int *n_cnt,
      int *t_cnt);
/* determine size of the branch-and-bound tree */

int glp_ios_curr_node(glp_tree *T);
/* determine current active subproblem */

int glp_ios_next_node(glp_tree *T, int p);
/* determine next active subproblem */

int glp_ios_prev_node(glp_tree *T, int p);
/* determine previous active subproblem */

int glp_ios_up_node(glp_tree *T, int p);
/* determine parent subproblem */

int glp_ios_node_level(glp_tree *T, int p);
/* determine subproblem level */

double glp_ios_node_bound(glp_tree *T, int p);
/* determine subproblem local bound */

int glp_ios_best_node(glp_tree *T);
/* find active subproblem with best local bound */

double glp_ios_mip_gap(glp_tree *T);
/* compute relative MIP gap */

void *glp_ios_node_data(glp_tree *T, int p);
/* access subproblem application-specific data */

void glp_ios_row_attr(glp_tree *T, int i, glp_attr *attr);
/* retrieve additional row attributes */

int glp_ios_pool_size(glp_tree *T);
/* determine current size of the cut pool */

int glp_ios_add_row(glp_tree *T,
      const char *name, int klass, int flags, int len, const int ind[],
      const double val[], int type, double rhs);
/* add row (constraint) to the cut pool */

void glp_ios_del_row(glp_tree *T, int i);
/* remove row (constraint) from the cut pool */

void glp_ios_clear_pool(glp_tree *T);
/* remove all rows (constraints) from the cut pool */

int glp_ios_can_branch(glp_tree *T, int j);
/* check if can branch upon specified variable */

void glp_ios_branch_upon(glp_tree *T, int j, int sel);
/* choose variable to branch upon */

void glp_ios_select_node(glp_tree *T, int p);
/* select subproblem to continue the search */

int glp_ios_heur_sol(glp_tree *T, const double x[]);
/* provide solution found by heuristic */

void glp_ios_terminate(glp_tree *T);
/* terminate the solution process */



#ifdef GLP_UNDOC
int glp_gmi_cut(glp_prob *P, int j, int ind[], double val[], double
      phi[]);
/* generate Gomory's mixed integer cut (core routine) */
#endif

#ifdef GLP_UNDOC
int glp_gmi_gen(glp_prob *P, glp_prob *pool, int max_cuts);
/* generate Gomory's mixed integer cuts */
#endif

#ifdef GLP_UNDOC
typedef struct glp_mir glp_mir;
/* MIR cut generator workspace */
#endif

#ifdef GLP_UNDOC
glp_mir *glp_mir_init(glp_prob *P);
/* create and initialize MIR cut generator */
#endif

#ifdef GLP_UNDOC
int glp_mir_gen(glp_prob *P, glp_mir *mir, glp_prob *pool);
/* generate mixed integer rounding (MIR) cuts */
#endif

#ifdef GLP_UNDOC
void glp_mir_free(glp_mir *mir);
/* delete MIR cut generator workspace */
#endif

#ifdef GLP_UNDOC
typedef struct glp_cfg glp_cfg;
/* conflict graph descriptor */
#endif

#ifdef GLP_UNDOC
glp_cfg *glp_cfg_init(glp_prob *P);
/* create and initialize conflict graph */
#endif

#ifdef GLP_UNDOC
void glp_cfg_free(glp_cfg *G);
/* delete conflict graph descriptor */
#endif

#ifdef GLP_UNDOC
int glp_clq_cut(glp_prob *P, glp_cfg *G, int ind[], double val[]);
/* generate clique cut from conflict graph */
#endif

void glp_init_mpscp(glp_mpscp *parm);
/* initialize MPS format control parameters */

int glp_read_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
      const char *fname);
/* read problem data in MPS format */

int glp_write_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
      const char *fname);
/* write problem data in MPS format */

void glp_init_cpxcp(glp_cpxcp *parm);
/* initialize CPLEX LP format control parameters */

int glp_read_lp(glp_prob *P, const glp_cpxcp *parm, const char *fname);
/* read problem data in CPLEX LP format */

int glp_write_lp(glp_prob *P, const glp_cpxcp *parm, const char *fname);
/* write problem data in CPLEX LP format */

int glp_read_prob(glp_prob *P, int flags, const char *fname);
/* read problem data in GLPK format */

int glp_write_prob(glp_prob *P, int flags, const char *fname);
/* write problem data in GLPK format */

glp_tran *glp_mpl_alloc_wksp(void);
/* allocate the MathProg translator workspace */

void glp_mpl_init_rand(glp_tran *tran, int seed);
/* initialize pseudo-random number generator */

int glp_mpl_read_model(glp_tran *tran, const char *fname, int skip);
/* read and translate model section */

int glp_mpl_read_data(glp_tran *tran, const char *fname);
/* read and translate data section */

int glp_mpl_generate(glp_tran *tran, const char *fname);
/* generate the model */

void glp_mpl_build_prob(glp_tran *tran, glp_prob *prob);
/* build LP/MIP problem instance from the model */

int glp_mpl_postsolve(glp_tran *tran, glp_prob *prob, int sol);
/* postsolve the model */

void glp_mpl_free_wksp(glp_tran *tran);
/* free the MathProg translator workspace */

int glp_read_cnfsat(glp_prob *P, const char *fname);
/* read CNF-SAT problem data in DIMACS format */

int glp_check_cnfsat(glp_prob *P);
/* check for CNF-SAT problem instance */

int glp_write_cnfsat(glp_prob *P, const char *fname);
/* write CNF-SAT problem data in DIMACS format */

int glp_minisat1(glp_prob *P);
/* solve CNF-SAT problem with MiniSat solver */

int glp_intfeas1(glp_prob *P, int use_bound, int obj_bound);
/* solve integer feasibility problem */

int glp_init_env(void);
/* initialize GLPK environment */

const char *glp_version(void);
/* determine library version */

int glp_free_env(void);
/* free GLPK environment */

void glp_puts(const char *s);
/* write string on terminal */

void glp_printf(const char *fmt, ...);
/* write formatted output on terminal */

void glp_vprintf(const char *fmt, va_list arg);
/* write formatted output on terminal */

int glp_term_out(int flag);
/* enable/disable terminal output */

void glp_term_hook(int (*func)(void *info, const char *s), void *info);
/* install hook to intercept terminal output */

int glp_open_tee(const char *name);
/* start copying terminal output to text file */

int glp_close_tee(void);
/* stop copying terminal output to text file */

#ifndef GLP_ERRFUNC_DEFINED
#define GLP_ERRFUNC_DEFINED
typedef void (*glp_errfunc)(const char *fmt, ...);
#endif

#define glp_error glp_error_(__FILE__, __LINE__)
glp_errfunc glp_error_(const char *file, int line);
/* display fatal error message and terminate execution */

#if 1 /* 07/XI-2015 */
int glp_at_error(void);
/* check for error state */
#endif

#define glp_assert(expr) \
      ((void)((expr) || (glp_assert_(#expr, __FILE__, __LINE__), 1)))
void glp_assert_(const char *expr, const char *file, int line);
/* check for logical condition */

void glp_error_hook(void (*func)(void *info), void *info);
/* install hook to intercept abnormal termination */

#define glp_malloc(size) glp_alloc(1, size)
/* allocate memory block (obsolete) */

#define glp_calloc(n, size) glp_alloc(n, size)
/* allocate memory block (obsolete) */

void *glp_alloc(int n, int size);
/* allocate memory block */

void *glp_realloc(void *ptr, int n, int size);
/* reallocate memory block */

void glp_free(void *ptr);
/* free (deallocate) memory block */

void glp_mem_limit(int limit);
/* set memory usage limit */

void glp_mem_usage(int *count, int *cpeak, size_t *total,
      size_t *tpeak);
/* get memory usage information */

double glp_time(void);
/* determine current universal time */

double glp_difftime(double t1, double t0);
/* compute difference between two time values */

typedef struct glp_graph glp_graph;
typedef struct glp_vertex glp_vertex;
typedef struct glp_arc glp_arc;

struct glp_graph
{     /* graph descriptor */
      void *pool; /* DMP *pool; */
      /* memory pool to store graph components */
      char *name;
      /* graph name (1 to 255 chars); NULL means no name is assigned
         to the graph */
      int nv_max;
      /* length of the vertex list (enlarged automatically) */
      int nv;
      /* number of vertices in the graph, 0 <= nv <= nv_max */
      int na;
      /* number of arcs in the graph, na >= 0 */
      glp_vertex **v; /* glp_vertex *v[1+nv_max]; */
      /* v[i], 1 <= i <= nv, is a pointer to i-th vertex */
      void *index; /* AVL *index; */
      /* vertex index to find vertices by their names; NULL means the
         index does not exist */
      int v_size;
      /* size of data associated with each vertex (0 to 256 bytes) */
      int a_size;
      /* size of data associated with each arc (0 to 256 bytes) */
};

struct glp_vertex
{     /* vertex descriptor */
      int i;
      /* vertex ordinal number, 1 <= i <= nv */
      char *name;
      /* vertex name (1 to 255 chars); NULL means no name is assigned
         to the vertex */
      void *entry; /* AVLNODE *entry; */
      /* pointer to corresponding entry in the vertex index; NULL means
         that either the index does not exist or the vertex has no name
         assigned */
      void *data;
      /* pointer to data associated with the vertex */
      void *temp;
      /* working pointer */
      glp_arc *in;
      /* pointer to the (unordered) list of incoming arcs */
      glp_arc *out;
      /* pointer to the (unordered) list of outgoing arcs */
};

struct glp_arc
{     /* arc descriptor */
      glp_vertex *tail;
      /* pointer to the tail endpoint */
      glp_vertex *head;
      /* pointer to the head endpoint */
      void *data;
      /* pointer to data associated with the arc */
      void *temp;
      /* working pointer */
      glp_arc *t_prev;
      /* pointer to previous arc having the same tail endpoint */
      glp_arc *t_next;
      /* pointer to next arc having the same tail endpoint */
      glp_arc *h_prev;
      /* pointer to previous arc having the same head endpoint */
      glp_arc *h_next;
      /* pointer to next arc having the same head endpoint */
};

glp_graph *glp_create_graph(int v_size, int a_size);
/* create graph */

void glp_set_graph_name(glp_graph *G, const char *name);
/* assign (change) graph name */

int glp_add_vertices(glp_graph *G, int nadd);
/* add new vertices to graph */

void glp_set_vertex_name(glp_graph *G, int i, const char *name);
/* assign (change) vertex name */

glp_arc *glp_add_arc(glp_graph *G, int i, int j);
/* add new arc to graph */

void glp_del_vertices(glp_graph *G, int ndel, const int num[]);
/* delete vertices from graph */

void glp_del_arc(glp_graph *G, glp_arc *a);
/* delete arc from graph */

void glp_erase_graph(glp_graph *G, int v_size, int a_size);
/* erase graph content */

void glp_delete_graph(glp_graph *G);
/* delete graph */

void glp_create_v_index(glp_graph *G);
/* create vertex name index */

int glp_find_vertex(glp_graph *G, const char *name);
/* find vertex by its name */

void glp_delete_v_index(glp_graph *G);
/* delete vertex name index */

int glp_read_graph(glp_graph *G, const char *fname);
/* read graph from plain text file */

int glp_write_graph(glp_graph *G, const char *fname);
/* write graph to plain text file */

void glp_mincost_lp(glp_prob *P, glp_graph *G, int names, int v_rhs,
      int a_low, int a_cap, int a_cost);
/* convert minimum cost flow problem to LP */

int glp_mincost_okalg(glp_graph *G, int v_rhs, int a_low, int a_cap,
      int a_cost, double *sol, int a_x, int v_pi);
/* find minimum-cost flow with out-of-kilter algorithm */

int glp_mincost_relax4(glp_graph *G, int v_rhs, int a_low, int a_cap,
      int a_cost, int crash, double *sol, int a_x, int a_rc);
/* find minimum-cost flow with Bertsekas-Tseng relaxation method */

void glp_maxflow_lp(glp_prob *P, glp_graph *G, int names, int s,
      int t, int a_cap);
/* convert maximum flow problem to LP */

int glp_maxflow_ffalg(glp_graph *G, int s, int t, int a_cap,
      double *sol, int a_x, int v_cut);
/* find maximal flow with Ford-Fulkerson algorithm */

int glp_check_asnprob(glp_graph *G, int v_set);
/* check correctness of assignment problem data */

/* assignment problem formulation: */
#define GLP_ASN_MIN        1  /* perfect matching (minimization) */
#define GLP_ASN_MAX        2  /* perfect matching (maximization) */
#define GLP_ASN_MMP        3  /* maximum matching */

int glp_asnprob_lp(glp_prob *P, int form, glp_graph *G, int names,
      int v_set, int a_cost);
/* convert assignment problem to LP */

int glp_asnprob_okalg(int form, glp_graph *G, int v_set, int a_cost,
      double *sol, int a_x);
/* solve assignment problem with out-of-kilter algorithm */

int glp_asnprob_hall(glp_graph *G, int v_set, int a_x);
/* find bipartite matching of maximum cardinality */

double glp_cpp(glp_graph *G, int v_t, int v_es, int v_ls);
/* solve critical path problem */

int glp_read_mincost(glp_graph *G, int v_rhs, int a_low, int a_cap,
      int a_cost, const char *fname);
/* read min-cost flow problem data in DIMACS format */

int glp_write_mincost(glp_graph *G, int v_rhs, int a_low, int a_cap,
      int a_cost, const char *fname);
/* write min-cost flow problem data in DIMACS format */

int glp_read_maxflow(glp_graph *G, int *s, int *t, int a_cap,
      const char *fname);
/* read maximum flow problem data in DIMACS format */

int glp_write_maxflow(glp_graph *G, int s, int t, int a_cap,
      const char *fname);
/* write maximum flow problem data in DIMACS format */

int glp_read_asnprob(glp_graph *G, int v_set, int a_cost, const char
      *fname);
/* read assignment problem data in DIMACS format */

int glp_write_asnprob(glp_graph *G, int v_set, int a_cost, const char
      *fname);
/* write assignment problem data in DIMACS format */

int glp_read_ccdata(glp_graph *G, int v_wgt, const char *fname);
/* read graph in DIMACS clique/coloring format */

int glp_write_ccdata(glp_graph *G, int v_wgt, const char *fname);
/* write graph in DIMACS clique/coloring format */

int glp_netgen(glp_graph *G, int v_rhs, int a_cap, int a_cost,
      const int parm[1+15]);
/* Klingman's network problem generator */

void glp_netgen_prob(int nprob, int parm[1+15]);
/* Klingman's standard network problem instance */

int glp_gridgen(glp_graph *G, int v_rhs, int a_cap, int a_cost,
      const int parm[1+14]);
/* grid-like network problem generator */

int glp_rmfgen(glp_graph *G, int *s, int *t, int a_cap,
      const int parm[1+5]);
/* Goldfarb's maximum flow problem generator */

int glp_weak_comp(glp_graph *G, int v_num);
/* find all weakly connected components of graph */

int glp_strong_comp(glp_graph *G, int v_num);
/* find all strongly connected components of graph */

int glp_top_sort(glp_graph *G, int v_num);
/* topological sorting of acyclic digraph */

int glp_wclique_exact(glp_graph *G, int v_wgt, double *sol, int v_set);
/* find maximum weight clique with exact algorithm */

#ifdef __cplusplus
}
#endif






struct GLPROW
{     /* LP/MIP row (auxiliary variable) */
      int i;
      /* ordinal number (1 to m) assigned to this row */
      char *name;
      /* row name (1 to 255 chars); NULL means no name is assigned to
         this row */
      AVLNODE *node;
      /* pointer to corresponding node in the row index; NULL means
         that either the row index does not exist or this row has no
         name assigned */
#if 1 /* 20/IX-2008 */
      int level;
      unsigned char origin;
      unsigned char klass;
#endif
      int type;
      /* type of the auxiliary variable:
         GLP_FR - free variable
         GLP_LO - variable with lower bound
         GLP_UP - variable with upper bound
         GLP_DB - double-bounded variable
         GLP_FX - fixed variable */
      double lb; /* non-scaled */
      /* lower bound; if the row has no lower bound, lb is zero */
      double ub; /* non-scaled */
      /* upper bound; if the row has no upper bound, ub is zero */
      /* if the row type is GLP_FX, ub is equal to lb */
      GLPAIJ *ptr; /* non-scaled */
      /* pointer to doubly linked list of constraint coefficients which
         are placed in this row */
      double rii;
      /* diagonal element r[i,i] of scaling matrix R for this row;
         if the scaling is not used, r[i,i] is 1 */
      int stat;
      /* status of the auxiliary variable:
         GLP_BS - basic variable
         GLP_NL - non-basic variable on lower bound
         GLP_NU - non-basic variable on upper bound
         GLP_NF - non-basic free variable
         GLP_NS - non-basic fixed variable */
      int bind;
      /* if the auxiliary variable is basic, head[bind] refers to this
         row, otherwise, bind is 0; this attribute is valid only if the
         basis factorization is valid */
      double prim; /* non-scaled */
      /* primal value of the auxiliary variable in basic solution */
      double dual; /* non-scaled */
      /* dual value of the auxiliary variable in basic solution */
      double pval; /* non-scaled */
      /* primal value of the auxiliary variable in interior solution */
      double dval; /* non-scaled */
      /* dual value of the auxiliary variable in interior solution */
      double mipx; /* non-scaled */
      /* primal value of the auxiliary variable in integer solution */
};

struct GLPCOL
{     /* LP/MIP column (structural variable) */
      int j;
      /* ordinal number (1 to n) assigned to this column */
      char *name;
      /* column name (1 to 255 chars); NULL means no name is assigned
         to this column */
      AVLNODE *node;
      /* pointer to corresponding node in the column index; NULL means
         that either the column index does not exist or the column has
         no name assigned */
      int kind;
      /* kind of the structural variable:
         GLP_CV - continuous variable
         GLP_IV - integer or binary variable */
      int type;
      /* type of the structural variable:
         GLP_FR - free variable
         GLP_LO - variable with lower bound
         GLP_UP - variable with upper bound
         GLP_DB - double-bounded variable
         GLP_FX - fixed variable */
      double lb; /* non-scaled */
      /* lower bound; if the column has no lower bound, lb is zero */
      double ub; /* non-scaled */
      /* upper bound; if the column has no upper bound, ub is zero */
      /* if the column type is GLP_FX, ub is equal to lb */
      double coef; /* non-scaled */
      /* objective coefficient at the structural variable */
      GLPAIJ *ptr; /* non-scaled */
      /* pointer to doubly linked list of constraint coefficients which
         are placed in this column */
      double sjj;
      /* diagonal element s[j,j] of scaling matrix S for this column;
         if the scaling is not used, s[j,j] is 1 */
      int stat;
      /* status of the structural variable:
         GLP_BS - basic variable
         GLP_NL - non-basic variable on lower bound
         GLP_NU - non-basic variable on upper bound
         GLP_NF - non-basic free variable
         GLP_NS - non-basic fixed variable */
      int bind;
      /* if the structural variable is basic, head[bind] refers to
         this column; otherwise, bind is 0; this attribute is valid only
         if the basis factorization is valid */
      double prim; /* non-scaled */
      /* primal value of the structural variable in basic solution */
      double dual; /* non-scaled */
      /* dual value of the structural variable in basic solution */
      double pval; /* non-scaled */
      /* primal value of the structural variable in interior solution */
      double dval; /* non-scaled */
      /* dual value of the structural variable in interior solution */
      double mipx; /* non-scaled */
      /* primal value of the structural variable in integer solution */
};

struct GLPAIJ
{     /* constraint coefficient a[i,j] */
      GLPROW *row;
      /* pointer to row, where this coefficient is placed */
      GLPCOL *col;
      /* pointer to column, where this coefficient is placed */
      double val;
      /* numeric (non-zero) value of this coefficient */
      GLPAIJ *r_prev;
      /* pointer to previous coefficient in the same row */
      GLPAIJ *r_next;
      /* pointer to next coefficient in the same row */
      GLPAIJ *c_prev;
      /* pointer to previous coefficient in the same column */
      GLPAIJ *c_next;
      /* pointer to next coefficient in the same column */
};


typedef struct SPV SPV;

struct SPV
{     /* sparse vector v = (v[j]) */
      int n;
      /* dimension, n >= 0 */
      int nnz;
      /* number of non-zero components, 0 <= nnz <= n */
      int *pos; /* int pos[1+n]; */
      /* pos[j] = k, 1 <= j <= n, is position of (non-zero) v[j] in the
         arrays ind and val, where 1 <= k <= nnz; pos[j] = 0 means that
         v[j] is structural zero */
      int *ind; /* int ind[1+n]; */
      /* ind[k] = j, 1 <= k <= nnz, is index of v[j] */
      double *val; /* double val[1+n]; */
      /* val[k], 1 <= k <= nnz, is a numeric value of v[j] */
};

#define spv_create_vec _glp_spv_create_vec
SPV *spv_create_vec(int n);
/* create sparse vector */

#define spv_check_vec _glp_spv_check_vec
void spv_check_vec(SPV *v);
/* check that sparse vector has correct representation */

#define spv_get_vj _glp_spv_get_vj
double spv_get_vj(SPV *v, int j);
/* retrieve component of sparse vector */

#define spv_set_vj _glp_spv_set_vj
void spv_set_vj(SPV *v, int j, double val);
/* set/change component of sparse vector */

#define spv_clear_vec _glp_spv_clear_vec
void spv_clear_vec(SPV *v);
/* set all components of sparse vector to zero */

#define spv_clean_vec _glp_spv_clean_vec
void spv_clean_vec(SPV *v, double eps);
/* remove zero or small components from sparse vector */

#define spv_copy_vec _glp_spv_copy_vec
void spv_copy_vec(SPV *x, SPV *y);
/* copy sparse vector (x := y) */

#define spv_linear_comb _glp_spv_linear_comb
void spv_linear_comb(SPV *x, double a, SPV *y);
/* compute linear combination (x := x + a * y) */

#define spv_delete_vec _glp_spv_delete_vec
void spv_delete_vec(SPV *v);
/* delete sparse vector */



SPV *spv_create_vec(int n)
{     SPV *v;
      xassert(n >= 0);
      v = xmalloc(sizeof(SPV));
      v->n = n;
      v->nnz = 0;
      v->pos = xcalloc(1+n, sizeof(int));
      memset(&v->pos[1], 0, n * sizeof(int));
      v->ind = xcalloc(1+n, sizeof(int));
      v->val = xcalloc(1+n, sizeof(double));
      return v;
}

void spv_check_vec(SPV *v)
{     int j, k, nnz;
      xassert(v->n >= 0);
      nnz = 0;
      for (j = v->n; j >= 1; j--)
      {  k = v->pos[j];
         xassert(0 <= k && k <= v->nnz);
         if (k != 0)
         {  xassert(v->ind[k] == j);
            nnz++;
         }
      }
      xassert(v->nnz == nnz);
      return;
}


double spv_get_vj(SPV *v, int j)
{     int k;
      xassert(1 <= j && j <= v->n);
      k = v->pos[j];
      xassert(0 <= k && k <= v->nnz);
      return (k == 0 ? 0.0 : v->val[k]);
}


void spv_set_vj(SPV *v, int j, double val)
{     int k;
      xassert(1 <= j && j <= v->n);
      k = v->pos[j];
      if (val == 0.0)
      {  if (k != 0)
         {  /* remove j-th component */
            v->pos[j] = 0;
            if (k < v->nnz)
            {  v->pos[v->ind[v->nnz]] = k;
               v->ind[k] = v->ind[v->nnz];
               v->val[k] = v->val[v->nnz];
            }
            v->nnz--;
         }
      }
      else
      {  if (k == 0)
         {  /* create j-th component */
            k = ++(v->nnz);
            v->pos[j] = k;
            v->ind[k] = j;
         }
         v->val[k] = val;
      }
      return;
}

void spv_clear_vec(SPV *v)
{     int k;
      for (k = 1; k <= v->nnz; k++)
         v->pos[v->ind[k]] = 0;
      v->nnz = 0;
      return;
}


void spv_clean_vec(SPV *v, double eps)
{     int k, nnz;
      nnz = 0;
      for (k = 1; k <= v->nnz; k++)
      {  if (fabs(v->val[k]) == 0.0 || fabs(v->val[k]) < eps)
         {  /* remove component */
            v->pos[v->ind[k]] = 0;
         }
         else
         {  /* keep component */
            nnz++;
            v->pos[v->ind[k]] = nnz;
            v->ind[nnz] = v->ind[k];
            v->val[nnz] = v->val[k];
         }
      }
      v->nnz = nnz;
      return;
}

void spv_copy_vec(SPV *x, SPV *y)
{     int j;
      xassert(x != y);
      xassert(x->n == y->n);
      spv_clear_vec(x);
      x->nnz = y->nnz;
      memcpy(&x->ind[1], &y->ind[1], x->nnz * sizeof(int));
      memcpy(&x->val[1], &y->val[1], x->nnz * sizeof(double));
      for (j = 1; j <= x->nnz; j++)
         x->pos[x->ind[j]] = j;
      return;
}

void spv_linear_comb(SPV *x, double a, SPV *y)
{     int j, k;
      double xj, yj;
      xassert(x != y);
      xassert(x->n == y->n);
      for (k = 1; k <= y->nnz; k++)
      {  j = y->ind[k];
         xj = spv_get_vj(x, j);
         yj = y->val[k];
         spv_set_vj(x, j, xj + a * yj);
      }
      return;
}

void spv_delete_vec(SPV *v)
{     /* delete sparse vector */
      xfree(v->pos);
      xfree(v->ind);
      xfree(v->val);
      xfree(v);
      return;
}
#define MIR_DEBUG 0

#define MAXAGGR 5
/* maximal number of rows that can be aggregated */


typedef struct glp_mir glp_mir;
struct glp_mir
{     /* MIR cut generator working area */
      /*--------------------------------------------------------------*/
      /* global information valid for the root subproblem */
      int m;
      /* number of rows (in the root subproblem) */
      int n;
      /* number of columns */
      char *skip; /* char skip[1+m]; */
      /* skip[i], 1 <= i <= m, is a flag that means that row i should
         not be used because (1) it is not suitable, or (2) because it
         has been used in the aggregated constraint */
      char *isint; /* char isint[1+m+n]; */
      /* isint[k], 1 <= k <= m+n, is a flag that means that variable
         x[k] is integer (otherwise, continuous) */
      double *lb; /* double lb[1+m+n]; */
      /* lb[k], 1 <= k <= m+n, is lower bound of x[k]; -DBL_MAX means
         that x[k] has no lower bound */
      int *vlb; /* int vlb[1+m+n]; */
      /* vlb[k] = k', 1 <= k <= m+n, is the number of integer variable,
         which defines variable lower bound x[k] >= lb[k] * x[k']; zero
         means that x[k] has simple lower bound */
      double *ub; /* double ub[1+m+n]; */
      /* ub[k], 1 <= k <= m+n, is upper bound of x[k]; +DBL_MAX means
         that x[k] has no upper bound */
      int *vub; /* int vub[1+m+n]; */
      /* vub[k] = k', 1 <= k <= m+n, is the number of integer variable,
         which defines variable upper bound x[k] <= ub[k] * x[k']; zero
         means that x[k] has simple upper bound */
      /*--------------------------------------------------------------*/
      /* current (fractional) point to be separated */
      double *x; /* double x[1+m+n]; */
      /* x[k] is current value of auxiliary (1 <= k <= m) or structural
         (m+1 <= k <= m+n) variable */
      /*--------------------------------------------------------------*/
      /* aggregated constraint sum a[k] * x[k] = b, which is a linear
         combination of original constraints transformed to equalities
         by introducing auxiliary variables */
      int agg_cnt;
      /* number of rows (original constraints) used to build aggregated
         constraint, 1 <= agg_cnt <= MAXAGGR */
      int *agg_row; /* int agg_row[1+MAXAGGR]; */
      /* agg_row[k], 1 <= k <= agg_cnt, is the row number used to build
         aggregated constraint */
      SPV *agg_vec; /* SPV agg_vec[1:m+n]; */
      /* sparse vector of aggregated constraint coefficients, a[k] */
      double agg_rhs;
      /* right-hand side of the aggregated constraint, b */
      /*--------------------------------------------------------------*/
      /* bound substitution flags for modified constraint */
      char *subst; /* char subst[1+m+n]; */
      /* subst[k], 1 <= k <= m+n, is a bound substitution flag used for
         variable x[k]:
         '?' - x[k] is missing in modified constraint
         'L' - x[k] = (lower bound) + x'[k]
         'U' - x[k] = (upper bound) - x'[k] */
      /*--------------------------------------------------------------*/
      /* modified constraint sum a'[k] * x'[k] = b', where x'[k] >= 0,
         derived from aggregated constraint by substituting bounds;
         note that due to substitution of variable bounds there may be
         additional terms in the modified constraint */
      SPV *mod_vec; /* SPV mod_vec[1:m+n]; */
      /* sparse vector of modified constraint coefficients, a'[k] */
      double mod_rhs;
      /* right-hand side of the modified constraint, b' */
      /*--------------------------------------------------------------*/
      /* cutting plane sum alpha[k] * x[k] <= beta */
      SPV *cut_vec; /* SPV cut_vec[1:m+n]; */
      /* sparse vector of cutting plane coefficients, alpha[k] */
      double cut_rhs;
      /* right-hand size of the cutting plane, beta */
};

static void set_row_attrib(glp_prob *mip, glp_mir *mir)
{     /* set global row attributes */
      int m = mir->m;
      int k;
      for (k = 1; k <= m; k++)
      {  GLPROW *row = mip->row[k];
         mir->skip[k] = 0;
         mir->isint[k] = 0;
         switch (row->type)
         {  case GLP_FR:
               mir->lb[k] = -DBL_MAX, mir->ub[k] = +DBL_MAX; break;
            case GLP_LO:
               mir->lb[k] = row->lb, mir->ub[k] = +DBL_MAX; break;
            case GLP_UP:
               mir->lb[k] = -DBL_MAX, mir->ub[k] = row->ub; break;
            case GLP_DB:
               mir->lb[k] = row->lb, mir->ub[k] = row->ub; break;
            case GLP_FX:
               mir->lb[k] = mir->ub[k] = row->lb; break;
            default:
               xassert(row != row);
         }
         mir->vlb[k] = mir->vub[k] = 0;
      }
      return;
}

static void set_col_attrib(glp_prob *mip, glp_mir *mir)
{     /* set global column attributes */
      int m = mir->m;
      int n = mir->n;
      int k;
      for (k = m+1; k <= m+n; k++)
      {  GLPCOL *col = mip->col[k-m];
         switch (col->kind)
         {  case GLP_CV:
               mir->isint[k] = 0; break;
            case GLP_IV:
               mir->isint[k] = 1; break;
            default:
               xassert(col != col);
         }
         switch (col->type)
         {  case GLP_FR:
               mir->lb[k] = -DBL_MAX, mir->ub[k] = +DBL_MAX; break;
            case GLP_LO:
               mir->lb[k] = col->lb, mir->ub[k] = +DBL_MAX; break;
            case GLP_UP:
               mir->lb[k] = -DBL_MAX, mir->ub[k] = col->ub; break;
            case GLP_DB:
               mir->lb[k] = col->lb, mir->ub[k] = col->ub; break;
            case GLP_FX:
               mir->lb[k] = mir->ub[k] = col->lb; break;
            default:
               xassert(col != col);
         }
         mir->vlb[k] = mir->vub[k] = 0;
      }
      return;
}

static void set_var_bounds(glp_prob *mip, glp_mir *mir)
{     /* set variable bounds */
      int m = mir->m;
      GLPAIJ *aij;
      int i, k1, k2;
      double a1, a2;
      for (i = 1; i <= m; i++)
      {  /* we need the row to be '>= 0' or '<= 0' */
         if (!(mir->lb[i] == 0.0 && mir->ub[i] == +DBL_MAX ||
               mir->lb[i] == -DBL_MAX && mir->ub[i] == 0.0)) continue;
         /* take first term */
         aij = mip->row[i]->ptr;
         if (aij == NULL) continue;
         k1 = m + aij->col->j, a1 = aij->val;
         /* take second term */
         aij = aij->r_next;
         if (aij == NULL) continue;
         k2 = m + aij->col->j, a2 = aij->val;
         /* there must be only two terms */
         if (aij->r_next != NULL) continue;
         /* interchange terms, if needed */
         if (!mir->isint[k1] && mir->isint[k2])
            ;
         else if (mir->isint[k1] && !mir->isint[k2])
         {  k2 = k1, a2 = a1;
            k1 = m + aij->col->j, a1 = aij->val;
         }
         else
         {  /* both terms are either continuous or integer */
            continue;
         }
         /* x[k2] should be double-bounded */
         if (mir->lb[k2] == -DBL_MAX || mir->ub[k2] == +DBL_MAX ||
             mir->lb[k2] == mir->ub[k2]) continue;
         /* change signs, if necessary */
         if (mir->ub[i] == 0.0) a1 = - a1, a2 = - a2;
         /* now the row has the form a1 * x1 + a2 * x2 >= 0, where x1
            is continuous, x2 is integer */
         if (a1 > 0.0)
         {  /* x1 >= - (a2 / a1) * x2 */
            if (mir->vlb[k1] == 0)
            {  /* set variable lower bound for x1 */
               mir->lb[k1] = - a2 / a1;
               mir->vlb[k1] = k2;
               /* the row should not be used */
               mir->skip[i] = 1;
            }
         }
         else /* a1 < 0.0 */
         {  /* x1 <= - (a2 / a1) * x2 */
            if (mir->vub[k1] == 0)
            {  /* set variable upper bound for x1 */
               mir->ub[k1] = - a2 / a1;
               mir->vub[k1] = k2;
               /* the row should not be used */
               mir->skip[i] = 1;
            }
         }
      }
      return;
}

static void mark_useless_rows(glp_prob *mip, glp_mir *mir)
{     /* mark rows which should not be used */
      int m = mir->m;
      GLPAIJ *aij;
      int i, k, nv;
      for (i = 1; i <= m; i++)
      {  /* free rows should not be used */
         if (mir->lb[i] == -DBL_MAX && mir->ub[i] == +DBL_MAX)
         {  mir->skip[i] = 1;
            continue;
         }
         nv = 0;
         for (aij = mip->row[i]->ptr; aij != NULL; aij = aij->r_next)
         {  k = m + aij->col->j;
            /* rows with free variables should not be used */
            if (mir->lb[k] == -DBL_MAX && mir->ub[k] == +DBL_MAX)
            {  mir->skip[i] = 1;
               break;
            }
            /* rows with integer variables having infinite (lower or
               upper) bound should not be used */
            if (mir->isint[k] && mir->lb[k] == -DBL_MAX ||
                mir->isint[k] && mir->ub[k] == +DBL_MAX)
            {  mir->skip[i] = 1;
               break;
            }
            /* count non-fixed variables */
            if (!(mir->vlb[k] == 0 && mir->vub[k] == 0 &&
                  mir->lb[k] == mir->ub[k])) nv++;
         }
         /* rows with all variables fixed should not be used */
         if (nv == 0)
         {  mir->skip[i] = 1;
            continue;
         }
      }
      return;
}

glp_mir *glp_mir_init(glp_prob *mip)
{     /* create and initialize MIR cut generator */
      int m = mip->m;
      int n = mip->n;
      glp_mir *mir;
#if MIR_DEBUG
      xprintf("ios_mir_init: warning: debug mode enabled\n");
#endif
      /* allocate working area */
      mir = xmalloc(sizeof(glp_mir));
      mir->m = m;
      mir->n = n;
      mir->skip = xcalloc(1+m, sizeof(char));
      mir->isint = xcalloc(1+m+n, sizeof(char));
      mir->lb = xcalloc(1+m+n, sizeof(double));
      mir->vlb = xcalloc(1+m+n, sizeof(int));
      mir->ub = xcalloc(1+m+n, sizeof(double));
      mir->vub = xcalloc(1+m+n, sizeof(int));
      mir->x = xcalloc(1+m+n, sizeof(double));
      mir->agg_row = xcalloc(1+MAXAGGR, sizeof(int));
      mir->agg_vec = spv_create_vec(m+n);
      mir->subst = xcalloc(1+m+n, sizeof(char));
      mir->mod_vec = spv_create_vec(m+n);
      mir->cut_vec = spv_create_vec(m+n);
      /* set global row attributes */
      set_row_attrib(mip, mir);
      /* set global column attributes */
      set_col_attrib(mip, mir);
      /* set variable bounds */
      set_var_bounds(mip, mir);
      /* mark rows which should not be used */
      mark_useless_rows(mip, mir);
      return mir;
}

static void get_current_point(glp_prob *mip, glp_mir *mir)
{     /* obtain current point */
      int m = mir->m;
      int n = mir->n;
      int k;
      for (k = 1; k <= m; k++)
         mir->x[k] = mip->row[k]->prim;
      for (k = m+1; k <= m+n; k++)
         mir->x[k] = mip->col[k-m]->prim;
      return;
}

#if MIR_DEBUG
static void check_current_point(glp_mir *mir)
{     /* check current point */
      int m = mir->m;
      int n = mir->n;
      int k, kk;
      double lb, ub, eps;
      for (k = 1; k <= m+n; k++)
      {  /* determine lower bound */
         lb = mir->lb[k];
         kk = mir->vlb[k];
         if (kk != 0)
         {  xassert(lb != -DBL_MAX);
            xassert(!mir->isint[k]);
            xassert(mir->isint[kk]);
            lb *= mir->x[kk];
         }
         /* check lower bound */
         if (lb != -DBL_MAX)
         {  eps = 1e-6 * (1.0 + fabs(lb));
            xassert(mir->x[k] >= lb - eps);
         }
         /* determine upper bound */
         ub = mir->ub[k];
         kk = mir->vub[k];
         if (kk != 0)
         {  xassert(ub != +DBL_MAX);
            xassert(!mir->isint[k]);
            xassert(mir->isint[kk]);
            ub *= mir->x[kk];
         }
         /* check upper bound */
         if (ub != +DBL_MAX)
         {  eps = 1e-6 * (1.0 + fabs(ub));
            xassert(mir->x[k] <= ub + eps);
         }
      }
      return;
}
#endif

static void initial_agg_row(glp_prob *mip, glp_mir *mir, int i)
{     /* use original i-th row as initial aggregated constraint */
      int m = mir->m;
      GLPAIJ *aij;
      xassert(1 <= i && i <= m);
      xassert(!mir->skip[i]);
      /* mark i-th row in order not to use it in the same aggregated
         constraint */
      mir->skip[i] = 2;
      mir->agg_cnt = 1;
      mir->agg_row[1] = i;
      /* use x[i] - sum a[i,j] * x[m+j] = 0, where x[i] is auxiliary
         variable of row i, x[m+j] are structural variables */
      spv_clear_vec(mir->agg_vec);
      spv_set_vj(mir->agg_vec, i, 1.0);
      for (aij = mip->row[i]->ptr; aij != NULL; aij = aij->r_next)
         spv_set_vj(mir->agg_vec, m + aij->col->j, - aij->val);
      mir->agg_rhs = 0.0;
#if MIR_DEBUG
      spv_check_vec(mir->agg_vec);
#endif
      return;
}

#if MIR_DEBUG
static void check_agg_row(glp_mir *mir)
{     /* check aggregated constraint */
      int m = mir->m;
      int n = mir->n;
      int j, k;
      double r, big;
      /* compute the residual r = sum a[k] * x[k] - b and determine
         big = max(1, |a[k]|, |b|) */
      r = 0.0, big = 1.0;
      for (j = 1; j <= mir->agg_vec->nnz; j++)
      {  k = mir->agg_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         r += mir->agg_vec->val[j] * mir->x[k];
         if (big < fabs(mir->agg_vec->val[j]))
            big = fabs(mir->agg_vec->val[j]);
      }
      r -= mir->agg_rhs;
      if (big < fabs(mir->agg_rhs))
         big = fabs(mir->agg_rhs);
      /* the residual must be close to zero */
      xassert(fabs(r) <= 1e-6 * big);
      return;
}
#endif

static void subst_fixed_vars(glp_mir *mir)
{     /* substitute fixed variables into aggregated constraint */
      int m = mir->m;
      int n = mir->n;
      int j, k;
      for (j = 1; j <= mir->agg_vec->nnz; j++)
      {  k = mir->agg_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (mir->vlb[k] == 0 && mir->vub[k] == 0 &&
             mir->lb[k] == mir->ub[k])
         {  /* x[k] is fixed */
            mir->agg_rhs -= mir->agg_vec->val[j] * mir->lb[k];
            mir->agg_vec->val[j] = 0.0;
         }
      }
      /* remove terms corresponding to fixed variables */
      spv_clean_vec(mir->agg_vec, DBL_EPSILON);
#if MIR_DEBUG
      spv_check_vec(mir->agg_vec);
#endif
      return;
}

static void bound_subst_heur(glp_mir *mir)
{     /* bound substitution heuristic */
      int m = mir->m;
      int n = mir->n;
      int j, k, kk;
      double d1, d2;
      for (j = 1; j <= mir->agg_vec->nnz; j++)
      {  k = mir->agg_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (mir->isint[k]) continue; /* skip integer variable */
         /* compute distance from x[k] to its lower bound */
         kk = mir->vlb[k];
         if (kk == 0)
         {  if (mir->lb[k] == -DBL_MAX)
               d1 = DBL_MAX;
            else
               d1 = mir->x[k] - mir->lb[k];
         }
         else
         {  xassert(1 <= kk && kk <= m+n);
            xassert(mir->isint[kk]);
            xassert(mir->lb[k] != -DBL_MAX);
            d1 = mir->x[k] - mir->lb[k] * mir->x[kk];
         }
         /* compute distance from x[k] to its upper bound */
         kk = mir->vub[k];
         if (kk == 0)
         {  if (mir->vub[k] == +DBL_MAX)
               d2 = DBL_MAX;
            else
               d2 = mir->ub[k] - mir->x[k];
         }
         else
         {  xassert(1 <= kk && kk <= m+n);
            xassert(mir->isint[kk]);
            xassert(mir->ub[k] != +DBL_MAX);
            d2 = mir->ub[k] * mir->x[kk] - mir->x[k];
         }
         /* x[k] cannot be free */
         xassert(d1 != DBL_MAX || d2 != DBL_MAX);
         /* choose the bound which is closer to x[k] */
         xassert(mir->subst[k] == '?');
         if (d1 <= d2)
            mir->subst[k] = 'L';
         else
            mir->subst[k] = 'U';
      }
      return;
}

static void build_mod_row(glp_mir *mir)
{     /* substitute bounds and build modified constraint */
      int m = mir->m;
      int n = mir->n;
      int j, jj, k, kk;
      /* initially modified constraint is aggregated constraint */
      spv_copy_vec(mir->mod_vec, mir->agg_vec);
      mir->mod_rhs = mir->agg_rhs;
#if MIR_DEBUG
      spv_check_vec(mir->mod_vec);
#endif
      /* substitute bounds for continuous variables; note that due to
         substitution of variable bounds additional terms may appear in
         modified constraint */
      for (j = mir->mod_vec->nnz; j >= 1; j--)
      {  k = mir->mod_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (mir->isint[k]) continue; /* skip integer variable */
         if (mir->subst[k] == 'L')
         {  /* x[k] = (lower bound) + x'[k] */
            xassert(mir->lb[k] != -DBL_MAX);
            kk = mir->vlb[k];
            if (kk == 0)
            {  /* x[k] = lb[k] + x'[k] */
               mir->mod_rhs -= mir->mod_vec->val[j] * mir->lb[k];
            }
            else
            {  /* x[k] = lb[k] * x[kk] + x'[k] */
               xassert(mir->isint[kk]);
               jj = mir->mod_vec->pos[kk];
               if (jj == 0)
               {  spv_set_vj(mir->mod_vec, kk, 1.0);
                  jj = mir->mod_vec->pos[kk];
                  mir->mod_vec->val[jj] = 0.0;
               }
               mir->mod_vec->val[jj] +=
                  mir->mod_vec->val[j] * mir->lb[k];
            }
         }
         else if (mir->subst[k] == 'U')
         {  /* x[k] = (upper bound) - x'[k] */
            xassert(mir->ub[k] != +DBL_MAX);
            kk = mir->vub[k];
            if (kk == 0)
            {  /* x[k] = ub[k] - x'[k] */
               mir->mod_rhs -= mir->mod_vec->val[j] * mir->ub[k];
            }
            else
            {  /* x[k] = ub[k] * x[kk] - x'[k] */
               xassert(mir->isint[kk]);
               jj = mir->mod_vec->pos[kk];
               if (jj == 0)
               {  spv_set_vj(mir->mod_vec, kk, 1.0);
                  jj = mir->mod_vec->pos[kk];
                  mir->mod_vec->val[jj] = 0.0;
               }
               mir->mod_vec->val[jj] +=
                  mir->mod_vec->val[j] * mir->ub[k];
            }
            mir->mod_vec->val[j] = - mir->mod_vec->val[j];
         }
         else
            xassert(k != k);
      }
#if MIR_DEBUG
      spv_check_vec(mir->mod_vec);
#endif
      /* substitute bounds for integer variables */
      for (j = 1; j <= mir->mod_vec->nnz; j++)
      {  k = mir->mod_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (!mir->isint[k]) continue; /* skip continuous variable */
         xassert(mir->subst[k] == '?');
         xassert(mir->vlb[k] == 0 && mir->vub[k] == 0);
         xassert(mir->lb[k] != -DBL_MAX && mir->ub[k] != +DBL_MAX);
         if (fabs(mir->lb[k]) <= fabs(mir->ub[k]))
         {  /* x[k] = lb[k] + x'[k] */
            mir->subst[k] = 'L';
            mir->mod_rhs -= mir->mod_vec->val[j] * mir->lb[k];
         }
         else
         {  /* x[k] = ub[k] - x'[k] */
            mir->subst[k] = 'U';
            mir->mod_rhs -= mir->mod_vec->val[j] * mir->ub[k];
            mir->mod_vec->val[j] = - mir->mod_vec->val[j];
         }
      }
#if MIR_DEBUG
      spv_check_vec(mir->mod_vec);
#endif
      return;
}

#if MIR_DEBUG
static void check_mod_row(glp_mir *mir)
{     /* check modified constraint */
      int m = mir->m;
      int n = mir->n;
      int j, k, kk;
      double r, big, x;
      /* compute the residual r = sum a'[k] * x'[k] - b' and determine
         big = max(1, |a[k]|, |b|) */
      r = 0.0, big = 1.0;
      for (j = 1; j <= mir->mod_vec->nnz; j++)
      {  k = mir->mod_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (mir->subst[k] == 'L')
         {  /* x'[k] = x[k] - (lower bound) */
            xassert(mir->lb[k] != -DBL_MAX);
            kk = mir->vlb[k];
            if (kk == 0)
               x = mir->x[k] - mir->lb[k];
            else
               x = mir->x[k] - mir->lb[k] * mir->x[kk];
         }
         else if (mir->subst[k] == 'U')
         {  /* x'[k] = (upper bound) - x[k] */
            xassert(mir->ub[k] != +DBL_MAX);
            kk = mir->vub[k];
            if (kk == 0)
               x = mir->ub[k] - mir->x[k];
            else
               x = mir->ub[k] * mir->x[kk] - mir->x[k];
         }
         else
            xassert(k != k);
         r += mir->mod_vec->val[j] * x;
         if (big < fabs(mir->mod_vec->val[j]))
            big = fabs(mir->mod_vec->val[j]);
      }
      r -= mir->mod_rhs;
      if (big < fabs(mir->mod_rhs))
         big = fabs(mir->mod_rhs);
      /* the residual must be close to zero */
      xassert(fabs(r) <= 1e-6 * big);
      return;
}
#endif


static int mir_ineq(const int n, const double a[], const double b,
      double alpha[], double *beta, double *gamma)
{     int j;
      double f, t;
      if (fabs(b - floor(b + .5)) < 0.01)
         return 1;
      f = b - floor(b);
      for (j = 1; j <= n; j++)
      {  t = (a[j] - floor(a[j])) - f;
         if (t <= 0.0)
            alpha[j] = floor(a[j]);
         else
            alpha[j] = floor(a[j]) + t / (1.0 - f);
      }
      *beta = floor(b);
      *gamma = 1.0 / (1.0 - f);
      return 0;
}

static int cmir_ineq(const int n, const double a[], const double b,
      const double u[], const char cset[], const double delta,
      double alpha[], double *beta, double *gamma)
{     int j;
      double *aa, bb;
      aa = alpha, bb = b;
      for (j = 1; j <= n; j++)
      {  aa[j] = a[j] / delta;
         if (cset[j])
            aa[j] = - aa[j], bb -= a[j] * u[j];
      }
      bb /= delta;
      if (mir_ineq(n, aa, bb, alpha, beta, gamma)) return 1;
      for (j = 1; j <= n; j++)
      {  if (cset[j])
            alpha[j] = - alpha[j], *beta += alpha[j] * u[j];
      }
      *gamma /= delta;
      return 0;
}

struct vset { int j; double v; };

static int cmir_cmp(const void *p1, const void *p2)
{     const struct vset *v1 = p1, *v2 = p2;
      if (v1->v < v2->v) return -1;
      if (v1->v > v2->v) return +1;
      return 0;
}

static double cmir_sep(const int n, const double a[], const double b,
      const double u[], const double x[], const double s,
      double alpha[], double *beta, double *gamma)
{     int fail, j, k, nv, v;
      double delta, eps, d_try[1+3], r, r_best;
      char *cset;
      struct vset *vset;
      /* allocate working arrays */
      cset = xcalloc(1+n, sizeof(char));
      vset = xcalloc(1+n, sizeof(struct vset));
      /* choose initial C */
      for (j = 1; j <= n; j++)
         cset[j] = (char)(x[j] >= 0.5 * u[j]);
      /* choose initial delta */
      r_best = delta = 0.0;
      for (j = 1; j <= n; j++)
      {  xassert(a[j] != 0.0);
         /* if x[j] is close to its bounds, skip it */
         eps = 1e-9 * (1.0 + fabs(u[j]));
         if (x[j] < eps || x[j] > u[j] - eps) continue;
         /* try delta = |a[j]| to construct c-MIR inequality */
         fail = cmir_ineq(n, a, b, u, cset, fabs(a[j]), alpha, beta,
            gamma);
         if (fail) continue;
         /* compute violation */
         r = - (*beta) - (*gamma) * s;
         for (k = 1; k <= n; k++) r += alpha[k] * x[k];
         if (r_best < r) r_best = r, delta = fabs(a[j]);
      }
      if (r_best < 0.001) r_best = 0.0;
      if (r_best == 0.0) goto done;
      xassert(delta > 0.0);
      /* try to increase violation by dividing delta by 2, 4, and 8,
         respectively */
      d_try[1] = delta / 2.0;
      d_try[2] = delta / 4.0;
      d_try[3] = delta / 8.0;
      for (j = 1; j <= 3; j++)
      {  /* construct c-MIR inequality */
         fail = cmir_ineq(n, a, b, u, cset, d_try[j], alpha, beta,
            gamma);
         if (fail) continue;
         /* compute violation */
         r = - (*beta) - (*gamma) * s;
         for (k = 1; k <= n; k++) r += alpha[k] * x[k];
         if (r_best < r) r_best = r, delta = d_try[j];
      }
      /* build subset of variables lying strictly between their bounds
         and order it by nondecreasing values of |x[j] - u[j]/2| */
      nv = 0;
      for (j = 1; j <= n; j++)
      {  /* if x[j] is close to its bounds, skip it */
         eps = 1e-9 * (1.0 + fabs(u[j]));
         if (x[j] < eps || x[j] > u[j] - eps) continue;
         /* add x[j] to the subset */
         nv++;
         vset[nv].j = j;
         vset[nv].v = fabs(x[j] - 0.5 * u[j]);
      }
      qsort(&vset[1], nv, sizeof(struct vset), cmir_cmp);
      /* try to increase violation by successively complementing each
         variable in the subset */
      for (v = 1; v <= nv; v++)
      {  j = vset[v].j;
         /* replace x[j] by its complement or vice versa */
         cset[j] = (char)!cset[j];
         /* construct c-MIR inequality */
         fail = cmir_ineq(n, a, b, u, cset, delta, alpha, beta, gamma);
         /* restore the variable */
         cset[j] = (char)!cset[j];
         /* do not replace the variable in case of failure */
         if (fail) continue;
         /* compute violation */
         r = - (*beta) - (*gamma) * s;
         for (k = 1; k <= n; k++) r += alpha[k] * x[k];
         if (r_best < r) r_best = r, cset[j] = (char)!cset[j];
      }
      /* construct the best c-MIR inequality chosen */
      fail = cmir_ineq(n, a, b, u, cset, delta, alpha, beta, gamma);
      xassert(!fail);
done: /* free working arrays */
      xfree(cset);
      xfree(vset);
      /* return to the calling routine */
      return r_best;
}

static double generate(glp_mir *mir)
{     /* try to generate violated c-MIR cut for modified constraint */
      int m = mir->m;
      int n = mir->n;
      int j, k, kk, nint;
      double s, *u, *x, *alpha, r_best = 0.0, b, beta, gamma;
      spv_copy_vec(mir->cut_vec, mir->mod_vec);
      mir->cut_rhs = mir->mod_rhs;
      /* remove small terms, which can appear due to substitution of
         variable bounds */
      spv_clean_vec(mir->cut_vec, DBL_EPSILON);
#if MIR_DEBUG
      spv_check_vec(mir->cut_vec);
#endif
      /* remove positive continuous terms to obtain MK relaxation */
      for (j = 1; j <= mir->cut_vec->nnz; j++)
      {  k = mir->cut_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (!mir->isint[k] && mir->cut_vec->val[j] > 0.0)
            mir->cut_vec->val[j] = 0.0;
      }
      spv_clean_vec(mir->cut_vec, 0.0);
#if MIR_DEBUG
      spv_check_vec(mir->cut_vec);
#endif
      /* move integer terms to the beginning of the sparse vector and
         determine the number of integer variables */
      nint = 0;
      for (j = 1; j <= mir->cut_vec->nnz; j++)
      {  k = mir->cut_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (mir->isint[k])
         {  double temp;
            nint++;
            /* interchange elements [nint] and [j] */
            kk = mir->cut_vec->ind[nint];
            mir->cut_vec->pos[k] = nint;
            mir->cut_vec->pos[kk] = j;
            mir->cut_vec->ind[nint] = k;
            mir->cut_vec->ind[j] = kk;
            temp = mir->cut_vec->val[nint];
            mir->cut_vec->val[nint] = mir->cut_vec->val[j];
            mir->cut_vec->val[j] = temp;
         }
      }
#if MIR_DEBUG
      spv_check_vec(mir->cut_vec);
#endif
      /* if there is no integer variable, nothing to generate */
      if (nint == 0) goto done;
      /* allocate working arrays */
      u = xcalloc(1+nint, sizeof(double));
      x = xcalloc(1+nint, sizeof(double));
      alpha = xcalloc(1+nint, sizeof(double));
      /* determine u and x */
      for (j = 1; j <= nint; j++)
      {  k = mir->cut_vec->ind[j];
         xassert(m+1 <= k && k <= m+n);
         xassert(mir->isint[k]);
         u[j] = mir->ub[k] - mir->lb[k];
         xassert(u[j] >= 1.0);
         if (mir->subst[k] == 'L')
            x[j] = mir->x[k] - mir->lb[k];
         else if (mir->subst[k] == 'U')
            x[j] = mir->ub[k] - mir->x[k];
         else
            xassert(k != k);
#if 0 /* 06/III-2016; notorious bug reported many times */
         xassert(x[j] >= -0.001);
#else
         if (x[j] < -0.001)
         {  xprintf("glp_mir_gen: warning: x[%d] = %g\n", j, x[j]);
            r_best = 0.0;
            goto skip;
         }
#endif
         if (x[j] < 0.0) x[j] = 0.0;
      }
      /* compute s = - sum of continuous terms */
      s = 0.0;
      for (j = nint+1; j <= mir->cut_vec->nnz; j++)
      {  double x;
         k = mir->cut_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         /* must be continuous */
         xassert(!mir->isint[k]);
         if (mir->subst[k] == 'L')
         {  xassert(mir->lb[k] != -DBL_MAX);
            kk = mir->vlb[k];
            if (kk == 0)
               x = mir->x[k] - mir->lb[k];
            else
               x = mir->x[k] - mir->lb[k] * mir->x[kk];
         }
         else if (mir->subst[k] == 'U')
         {  xassert(mir->ub[k] != +DBL_MAX);
            kk = mir->vub[k];
            if (kk == 0)
               x = mir->ub[k] - mir->x[k];
            else
               x = mir->ub[k] * mir->x[kk] - mir->x[k];
         }
         else
            xassert(k != k);
#if 0 /* 06/III-2016; notorious bug reported many times */
         xassert(x >= -0.001);
#else
         if (x < -0.001)
         {  xprintf("glp_mir_gen: warning: x = %g\n", x);
            r_best = 0.0;
            goto skip;
         }
#endif
         if (x < 0.0) x = 0.0;
         s -= mir->cut_vec->val[j] * x;
      }
      xassert(s >= 0.0);
      /* apply heuristic to obtain most violated c-MIR inequality */
      b = mir->cut_rhs;
      r_best = cmir_sep(nint, mir->cut_vec->val, b, u, x, s, alpha,
         &beta, &gamma);
      if (r_best == 0.0) goto skip;
      xassert(r_best > 0.0);
      /* convert to raw cut */
      /* sum alpha[j] * x[j] <= beta + gamma * s */
      for (j = 1; j <= nint; j++)
         mir->cut_vec->val[j] = alpha[j];
      for (j = nint+1; j <= mir->cut_vec->nnz; j++)
      {  k = mir->cut_vec->ind[j];
         if (k <= m+n) mir->cut_vec->val[j] *= gamma;
      }
      mir->cut_rhs = beta;
#if MIR_DEBUG
      spv_check_vec(mir->cut_vec);
#endif
skip: /* free working arrays */
      xfree(u);
      xfree(x);
      xfree(alpha);
done: return r_best;
}

#if MIR_DEBUG
static void check_raw_cut(glp_mir *mir, double r_best)
{     /* check raw cut before back bound substitution */
      int m = mir->m;
      int n = mir->n;
      int j, k, kk;
      double r, big, x;
      /* compute the residual r = sum a[k] * x[k] - b and determine
         big = max(1, |a[k]|, |b|) */
      r = 0.0, big = 1.0;
      for (j = 1; j <= mir->cut_vec->nnz; j++)
      {  k = mir->cut_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (mir->subst[k] == 'L')
         {  xassert(mir->lb[k] != -DBL_MAX);
            kk = mir->vlb[k];
            if (kk == 0)
               x = mir->x[k] - mir->lb[k];
            else
               x = mir->x[k] - mir->lb[k] * mir->x[kk];
         }
         else if (mir->subst[k] == 'U')
         {  xassert(mir->ub[k] != +DBL_MAX);
            kk = mir->vub[k];
            if (kk == 0)
               x = mir->ub[k] - mir->x[k];
            else
               x = mir->ub[k] * mir->x[kk] - mir->x[k];
         }
         else
            xassert(k != k);
         r += mir->cut_vec->val[j] * x;
         if (big < fabs(mir->cut_vec->val[j]))
            big = fabs(mir->cut_vec->val[j]);
      }
      r -= mir->cut_rhs;
      if (big < fabs(mir->cut_rhs))
         big = fabs(mir->cut_rhs);
      /* the residual must be close to r_best */
      xassert(fabs(r - r_best) <= 1e-6 * big);
      return;
}
#endif

static void back_subst(glp_mir *mir)
{     /* back substitution of original bounds */
      int m = mir->m;
      int n = mir->n;
      int j, jj, k, kk;
      /* at first, restore bounds of integer variables (because on
         restoring variable bounds of continuous variables we need
         original, not shifted, bounds of integer variables) */
      for (j = 1; j <= mir->cut_vec->nnz; j++)
      {  k = mir->cut_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (!mir->isint[k]) continue; /* skip continuous */
         if (mir->subst[k] == 'L')
         {  /* x'[k] = x[k] - lb[k] */
            xassert(mir->lb[k] != -DBL_MAX);
            xassert(mir->vlb[k] == 0);
            mir->cut_rhs += mir->cut_vec->val[j] * mir->lb[k];
         }
         else if (mir->subst[k] == 'U')
         {  /* x'[k] = ub[k] - x[k] */
            xassert(mir->ub[k] != +DBL_MAX);
            xassert(mir->vub[k] == 0);
            mir->cut_rhs -= mir->cut_vec->val[j] * mir->ub[k];
            mir->cut_vec->val[j] = - mir->cut_vec->val[j];
         }
         else
            xassert(k != k);
      }
      /* now restore bounds of continuous variables */
      for (j = 1; j <= mir->cut_vec->nnz; j++)
      {  k = mir->cut_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (mir->isint[k]) continue; /* skip integer */
         if (mir->subst[k] == 'L')
         {  /* x'[k] = x[k] - (lower bound) */
            xassert(mir->lb[k] != -DBL_MAX);
            kk = mir->vlb[k];
            if (kk == 0)
            {  /* x'[k] = x[k] - lb[k] */
               mir->cut_rhs += mir->cut_vec->val[j] * mir->lb[k];
            }
            else
            {  /* x'[k] = x[k] - lb[k] * x[kk] */
               jj = mir->cut_vec->pos[kk];
#if 0
               xassert(jj != 0);
#else
               if (jj == 0)
               {  spv_set_vj(mir->cut_vec, kk, 1.0);
                  jj = mir->cut_vec->pos[kk];
                  xassert(jj != 0);
                  mir->cut_vec->val[jj] = 0.0;
               }
#endif
               mir->cut_vec->val[jj] -= mir->cut_vec->val[j] *
                  mir->lb[k];
            }
         }
         else if (mir->subst[k] == 'U')
         {  /* x'[k] = (upper bound) - x[k] */
            xassert(mir->ub[k] != +DBL_MAX);
            kk = mir->vub[k];
            if (kk == 0)
            {  /* x'[k] = ub[k] - x[k] */
               mir->cut_rhs -= mir->cut_vec->val[j] * mir->ub[k];
            }
            else
            {  /* x'[k] = ub[k] * x[kk] - x[k] */
               jj = mir->cut_vec->pos[kk];
               if (jj == 0)
               {  spv_set_vj(mir->cut_vec, kk, 1.0);
                  jj = mir->cut_vec->pos[kk];
                  xassert(jj != 0);
                  mir->cut_vec->val[jj] = 0.0;
               }
               mir->cut_vec->val[jj] += mir->cut_vec->val[j] *
                  mir->ub[k];
            }
            mir->cut_vec->val[j] = - mir->cut_vec->val[j];
         }
         else
            xassert(k != k);
      }
#if MIR_DEBUG
      spv_check_vec(mir->cut_vec);
#endif
      return;
}

#if MIR_DEBUG
static void check_cut_row(glp_mir *mir, double r_best)
{     /* check the cut after back bound substitution or elimination of
         auxiliary variables */
      int m = mir->m;
      int n = mir->n;
      int j, k;
      double r, big;
      /* compute the residual r = sum a[k] * x[k] - b and determine
         big = max(1, |a[k]|, |b|) */
      r = 0.0, big = 1.0;
      for (j = 1; j <= mir->cut_vec->nnz; j++)
      {  k = mir->cut_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         r += mir->cut_vec->val[j] * mir->x[k];
         if (big < fabs(mir->cut_vec->val[j]))
            big = fabs(mir->cut_vec->val[j]);
      }
      r -= mir->cut_rhs;
      if (big < fabs(mir->cut_rhs))
         big = fabs(mir->cut_rhs);
      /* the residual must be close to r_best */
      xassert(fabs(r - r_best) <= 1e-6 * big);
      return;
}
#endif

static void subst_aux_vars(glp_prob *mip, glp_mir *mir)
{     /* final substitution to eliminate auxiliary variables */
      int m = mir->m;
      int n = mir->n;
      GLPAIJ *aij;
      int j, k, kk, jj;
      for (j = mir->cut_vec->nnz; j >= 1; j--)
      {  k = mir->cut_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (k > m) continue; /* skip structurals */
         for (aij = mip->row[k]->ptr; aij != NULL; aij = aij->r_next)
         {  kk = m + aij->col->j; /* structural */
            jj = mir->cut_vec->pos[kk];
            if (jj == 0)
            {  spv_set_vj(mir->cut_vec, kk, 1.0);
               jj = mir->cut_vec->pos[kk];
               mir->cut_vec->val[jj] = 0.0;
            }
            mir->cut_vec->val[jj] += mir->cut_vec->val[j] * aij->val;
         }
         mir->cut_vec->val[j] = 0.0;
      }
      spv_clean_vec(mir->cut_vec, 0.0);
      return;
}

extern void glp_set_row_bnds(glp_prob *lp, int i, int type, double lb, double ub);
extern void glp_set_mat_row(glp_prob *lp, int i, int len, const int ind[], const double val[]);
static void add_cut(glp_mir *mir, glp_prob *pool)
{     /* add constructed cut inequality to the cut pool */
      int m = mir->m;
      int n = mir->n;
      int j, k, len;
      int *ind = xcalloc(1+n, sizeof(int));
      double *val = xcalloc(1+n, sizeof(double));
      len = 0;
      for (j = mir->cut_vec->nnz; j >= 1; j--)
      {  k = mir->cut_vec->ind[j];
         xassert(m+1 <= k && k <= m+n);
         len++, ind[len] = k - m, val[len] = mir->cut_vec->val[j];
      }
#if 0
#if 0
      ios_add_cut_row(tree, pool, GLP_RF_MIR, len, ind, val, GLP_UP,
         mir->cut_rhs);
#else
      glp_ios_add_row(tree, NULL, GLP_RF_MIR, 0, len, ind, val, GLP_UP,
         mir->cut_rhs);
#endif
#else
      {  int i;
         i = glp_add_rows(pool, 1);
         glp_set_row_bnds(pool, i, GLP_UP, 0, mir->cut_rhs);
         glp_set_mat_row(pool, i, len, ind, val);
      }
#endif
      xfree(ind);
      xfree(val);
      return;
}

#if 0 /* 29/II-2016 by Chris */
static int aggregate_row(glp_prob *mip, glp_mir *mir)
#else
static int aggregate_row(glp_prob *mip, glp_mir *mir, SPV *v)
#endif
{     /* try to aggregate another row */
      int m = mir->m;
      int n = mir->n;
      GLPAIJ *aij;
#if 0 /* 29/II-2016 by Chris */
      SPV *v;
#endif
      int ii, j, jj, k, kk, kappa = 0, ret = 0;
      double d1, d2, d, d_max = 0.0;
      /* choose appropriate structural variable in the aggregated row
         to be substituted */
      for (j = 1; j <= mir->agg_vec->nnz; j++)
      {  k = mir->agg_vec->ind[j];
         xassert(1 <= k && k <= m+n);
         if (k <= m) continue; /* skip auxiliary var */
         if (mir->isint[k]) continue; /* skip integer var */
         if (fabs(mir->agg_vec->val[j]) < 0.001) continue;
         /* compute distance from x[k] to its lower bound */
         kk = mir->vlb[k];
         if (kk == 0)
         {  if (mir->lb[k] == -DBL_MAX)
               d1 = DBL_MAX;
            else
               d1 = mir->x[k] - mir->lb[k];
         }
         else
         {  xassert(1 <= kk && kk <= m+n);
            xassert(mir->isint[kk]);
            xassert(mir->lb[k] != -DBL_MAX);
            d1 = mir->x[k] - mir->lb[k] * mir->x[kk];
         }
         /* compute distance from x[k] to its upper bound */
         kk = mir->vub[k];
         if (kk == 0)
         {  if (mir->vub[k] == +DBL_MAX)
               d2 = DBL_MAX;
            else
               d2 = mir->ub[k] - mir->x[k];
         }
         else
         {  xassert(1 <= kk && kk <= m+n);
            xassert(mir->isint[kk]);
            xassert(mir->ub[k] != +DBL_MAX);
            d2 = mir->ub[k] * mir->x[kk] - mir->x[k];
         }
         /* x[k] cannot be free */
         xassert(d1 != DBL_MAX || d2 != DBL_MAX);
         /* d = min(d1, d2) */
         d = (d1 <= d2 ? d1 : d2);
         xassert(d != DBL_MAX);
         /* should not be close to corresponding bound */
         if (d < 0.001) continue;
         if (d_max < d) d_max = d, kappa = k;
      }
      if (kappa == 0)
      {  /* nothing chosen */
         ret = 1;
         goto done;
      }
      /* x[kappa] has been chosen */
      xassert(m+1 <= kappa && kappa <= m+n);
      xassert(!mir->isint[kappa]);
      /* find another row, which have not been used yet, to eliminate
         x[kappa] from the aggregated row */
#if 0 /* 29/II-2016 by Chris */
      for (ii = 1; ii <= m; ii++)
      {  if (mir->skip[ii]) continue;
         for (aij = mip->row[ii]->ptr; aij != NULL; aij = aij->r_next)
            if (aij->col->j == kappa - m) break;
         if (aij != NULL && fabs(aij->val) >= 0.001) break;
#else
      ii = 0;
      for (aij = mip->col[kappa - m]->ptr; aij != NULL;
         aij = aij->c_next)
      {  if (aij->row->i > m) continue;
         if (mir->skip[aij->row->i]) continue;
         if (fabs(aij->val) >= 0.001)
         {  ii = aij->row->i;
            break;
         }
#endif
      }
#if 0 /* 29/II-2016 by Chris */
      if (ii > m)
#else
      if (ii == 0)
#endif
      {  /* nothing found */
         ret = 2;
         goto done;
      }
      /* row ii has been found; include it in the aggregated list */
      mir->agg_cnt++;
      xassert(mir->agg_cnt <= MAXAGGR);
      mir->agg_row[mir->agg_cnt] = ii;
      mir->skip[ii] = 2;
      /* v := new row */
#if 0 /* 29/II-2016 by Chris */
      v = ios_create_vec(m+n);
#else
      spv_clear_vec(v);
#endif
      spv_set_vj(v, ii, 1.0);
      for (aij = mip->row[ii]->ptr; aij != NULL; aij = aij->r_next)
         spv_set_vj(v, m + aij->col->j, - aij->val);
#if MIR_DEBUG
      spv_check_vec(v);
#endif
      /* perform gaussian elimination to remove x[kappa] */
      j = mir->agg_vec->pos[kappa];
      xassert(j != 0);
      jj = v->pos[kappa];
      xassert(jj != 0);
      spv_linear_comb(mir->agg_vec,
         - mir->agg_vec->val[j] / v->val[jj], v);
#if 0 /* 29/II-2016 by Chris */
      ios_delete_vec(v);
#endif
      spv_set_vj(mir->agg_vec, kappa, 0.0);
#if MIR_DEBUG
      spv_check_vec(mir->agg_vec);
#endif
done: return ret;
}

int glp_mir_gen(glp_prob *mip, glp_mir *mir, glp_prob *pool)
{     /* main routine to generate MIR cuts */
      int m = mir->m;
      int n = mir->n;
      int i, nnn = 0;
      double r_best;
#if 1 /* 29/II-2016 by Chris */
      SPV *work;
#endif
      xassert(mip->m >= m);
      xassert(mip->n == n);
      /* obtain current point */
      get_current_point(mip, mir);
#if MIR_DEBUG
      /* check current point */
      check_current_point(mir);
#endif
      /* reset bound substitution flags */
      memset(&mir->subst[1], '?', m+n);
#if 1 /* 29/II-2016 by Chris */
      work = spv_create_vec(m+n);
#endif
      /* try to generate a set of violated MIR cuts */
      for (i = 1; i <= m; i++)
      {  if (mir->skip[i]) continue;
         /* use original i-th row as initial aggregated constraint */
         initial_agg_row(mip, mir, i);
loop:    ;
#if MIR_DEBUG
         /* check aggregated row */
         check_agg_row(mir);
#endif
         /* substitute fixed variables into aggregated constraint */
         subst_fixed_vars(mir);
#if MIR_DEBUG
         /* check aggregated row */
         check_agg_row(mir);
#endif
#if MIR_DEBUG
         /* check bound substitution flags */
         {  int k;
            for (k = 1; k <= m+n; k++)
               xassert(mir->subst[k] == '?');
         }
#endif
         /* apply bound substitution heuristic */
         bound_subst_heur(mir);
         /* substitute bounds and build modified constraint */
         build_mod_row(mir);
#if MIR_DEBUG
         /* check modified row */
         check_mod_row(mir);
#endif
         /* try to generate violated c-MIR cut for modified row */
         r_best = generate(mir);
         if (r_best > 0.0)
         {  /* success */
#if MIR_DEBUG
            /* check raw cut before back bound substitution */
            check_raw_cut(mir, r_best);
#endif
            /* back substitution of original bounds */
            back_subst(mir);
#if MIR_DEBUG
            /* check the cut after back bound substitution */
            check_cut_row(mir, r_best);
#endif
            /* final substitution to eliminate auxiliary variables */
            subst_aux_vars(mip, mir);
#if MIR_DEBUG
            /* check the cut after elimination of auxiliaries */
            check_cut_row(mir, r_best);
#endif
            /* add constructed cut inequality to the cut pool */
            add_cut(mir, pool), nnn++;
         }
         /* reset bound substitution flags */
         {  int j, k;
            for (j = 1; j <= mir->mod_vec->nnz; j++)
            {  k = mir->mod_vec->ind[j];
               xassert(1 <= k && k <= m+n);
               xassert(mir->subst[k] != '?');
               mir->subst[k] = '?';
            }
         }
         if (r_best == 0.0)
         {  /* failure */
            if (mir->agg_cnt < MAXAGGR)
            {  /* try to aggregate another row */
#if 0 /* 29/II-2016 by Chris */
               if (aggregate_row(mip, mir) == 0) goto loop;
#else
               if (aggregate_row(mip, mir, work) == 0) goto loop;
#endif
            }
         }
         /* unmark rows used in the aggregated constraint */
         {  int k, ii;
            for (k = 1; k <= mir->agg_cnt; k++)
            {  ii = mir->agg_row[k];
               xassert(1 <= ii && ii <= m);
               xassert(mir->skip[ii] == 2);
               mir->skip[ii] = 0;
            }
         }
      }
#if 1 /* 29/II-2016 by Chris */
      spv_delete_vec(work);
#endif
      return nnn;
}


void glp_mir_free(glp_mir *mir)
{     xfree(mir->skip);
      xfree(mir->isint);
      xfree(mir->lb);
      xfree(mir->vlb);
      xfree(mir->ub);
      xfree(mir->vub);
      xfree(mir->x);
      xfree(mir->agg_row);
      spv_delete_vec(mir->agg_vec);
      xfree(mir->subst);
      spv_delete_vec(mir->mod_vec);
      spv_delete_vec(mir->cut_vec);
      xfree(mir);
      return;
}







typedef struct glp_cfg CFG;
typedef struct glp_cfg glp_cfg;
typedef struct CFGVLE CFGVLE;
typedef struct CFGCLE CFGCLE;

#if 0 /* 08/III-2016 */
struct CFG
#else
struct glp_cfg
#endif
{     /* conflict graph descriptor */
      int n;
      /* number of *all* variables (columns) in corresponding MIP */
      int *pos; /* int pos[1+n]; */
      /* pos[0] is not used;
       * pos[j] = v, 1 <= j <= n, means that vertex v corresponds to
       * original binary variable x[j], and pos[j] = 0 means that the
       * conflict graph has no such vertex */
      int *neg; /* int neg[1+n]; */
      /* neg[0] is not used;
       * neg[j] = v, 1 <= j <= n, means that vertex v corresponds to
       * complement of original binary variable x[j], and neg[j] = 0
       * means that the conflict graph has no such vertex */
      DMP *pool;
      /* memory pool to allocate elements of the conflict graph */
      int nv_max;
      /* maximal number of vertices in the conflict graph */
      int nv;
      /* current number of vertices in the conflict graph */
      int *ref; /* int ref[1+nv_max]; */
      /* ref[v] = j, 1 <= v <= nv, means that vertex v corresponds
       * either to original binary variable x[j] or to its complement,
       * i.e. either pos[j] = v or neg[j] = v */
      CFGVLE **vptr; /* CFGVLE *vptr[1+nv_max]; */
      /* vptr[v], 1 <= v <= nv, is an initial pointer to the list of
       * vertices adjacent to vertex v */
      CFGCLE **cptr; /* CFGCLE *cptr[1+nv_max]; */
      /* cptr[v], 1 <= v <= nv, is an initial pointer to the list of
       * cliques that contain vertex v */
};

struct CFGVLE
{     /* vertex list element */
      int v;
      /* vertex number, 1 <= v <= nv */
      CFGVLE *next;
      /* pointer to next vertex list element */
};

struct CFGCLE
{     /* clique list element */
      CFGVLE *vptr;
      /* initial pointer to the list of clique vertices */
      CFGCLE *next;
      /* pointer to next clique list element */
};

#define cfg_create_graph _glp_cfg_create_graph
CFG *cfg_create_graph(int n, int nv_max);
/* create conflict graph */

#define cfg_add_clique _glp_cfg_add_clique
void cfg_add_clique(CFG *G, int size, const int ind[]);
/* add clique to conflict graph */

#define cfg_get_adjacent _glp_cfg_get_adjacent
int cfg_get_adjacent(CFG *G, int v, int ind[]);
/* get vertices adjacent to specified vertex */

#define cfg_expand_clique _glp_cfg_expand_clique
int cfg_expand_clique(CFG *G, int c_len, int c_ind[]);
/* expand specified clique to maximal clique */

#define cfg_check_clique _glp_cfg_check_clique
void cfg_check_clique(CFG *G, int c_len, const int c_ind[]);
/* check clique in conflict graph */

#define cfg_delete_graph _glp_cfg_delete_graph
void cfg_delete_graph(CFG *G);
/* delete conflict graph */

#define cfg_build_graph _glp_cfg_build_graph
CFG *cfg_build_graph(void /* glp_prob */ *P);
/* build conflict graph */

#define cfg_find_clique _glp_cfg_find_clique
int cfg_find_clique(void /* glp_prob */ *P, CFG *G, int ind[],
      double *sum);
/* find maximum weight clique in conflict graph */


CFG *cfg_create_graph(int n, int nv_max)
{     CFG *G;
      xassert(n >= 0);
      xassert(0 <= nv_max && nv_max <= n + n);
      G = talloc(1, CFG);
      G->n = n;
      G->pos = talloc(1+n, int);
      memset(&G->pos[1], 0, n * sizeof(int));
      G->neg = talloc(1+n, int);
      memset(&G->neg[1], 0, n * sizeof(int));
      G->pool = dmp_create_pool();
      G->nv_max = nv_max;
      G->nv = 0;
      G->ref = talloc(1+nv_max, int);
      G->vptr = talloc(1+nv_max, CFGVLE *);
      G->cptr = talloc(1+nv_max, CFGCLE *);
      return G;
}

static void add_edge(CFG *G, int v, int w)
{     /* add clique of size 2 */
      DMP *pool = G->pool;
      int nv = G->nv;
      CFGVLE **vptr = G->vptr;
      CFGVLE *vle;
      xassert(1 <= v && v <= nv);
      xassert(1 <= w && w <= nv);
      xassert(v != w);
      vle = dmp_talloc(pool, CFGVLE);
      vle->v = w;
      vle->next = vptr[v];
      vptr[v] = vle;
      vle = dmp_talloc(pool, CFGVLE);
      vle->v = v;
      vle->next = vptr[w];
      vptr[w] = vle;
      return;
}

void cfg_add_clique(CFG *G, int size, const int ind[])
{     int n = G->n;
      int *pos = G->pos;
      int *neg = G->neg;
      DMP *pool = G->pool;
      int nv_max = G->nv_max;
      int *ref = G->ref;
      CFGVLE **vptr = G->vptr;
      CFGCLE **cptr = G->cptr;
      int j, k, v;
      xassert(2 <= size && size <= nv_max);
      /* add new vertices to the conflict graph */
      for (k = 1; k <= size; k++)
      {  j = ind[k];
         if (j > 0)
         {  /* vertex corresponds to x[j] */
            xassert(1 <= j && j <= n);
            if (pos[j] == 0)
            {  /* no such vertex exists; add it */
               v = pos[j] = ++(G->nv);
               xassert(v <= nv_max);
               ref[v] = j;
               vptr[v] = NULL;
               cptr[v] = NULL;
               if (neg[j] != 0)
               {  /* now both vertices for x[j] and (1 - x[j]) exist */
                  add_edge(G, v, neg[j]);
               }
            }
         }
         else
         {  /* vertex corresponds to (1 - x[j]) */
            j = -j;
            xassert(1 <= j && j <= n);
            if (neg[j] == 0)
            {  /* no such vertex exists; add it */
               v = neg[j] = ++(G->nv);
               xassert(v <= nv_max);
               ref[v] = j;
               vptr[v] = NULL;
               cptr[v] = NULL;
               if (pos[j] != 0)
               {  /* now both vertices for x[j] and (1 - x[j]) exist */
                  add_edge(G, v, pos[j]);
               }
            }
         }
      }
      /* add specified clique to the conflict graph */
      if (size == 2)
         add_edge(G,
            ind[1] > 0 ? pos[+ind[1]] : neg[-ind[1]],
            ind[2] > 0 ? pos[+ind[2]] : neg[-ind[2]]);
      else
      {  CFGVLE *vp, *vle;
         CFGCLE *cle;
         /* build list of clique vertices */
         vp = NULL;
         for (k = 1; k <= size; k++)
         {  vle = dmp_talloc(pool, CFGVLE);
            vle->v = ind[k] > 0 ? pos[+ind[k]] : neg[-ind[k]];
            vle->next = vp;
            vp = vle;
         }
         /* attach the clique to all its vertices */
         for (k = 1; k <= size; k++)
         {  cle = dmp_talloc(pool, CFGCLE);
            cle->vptr = vp;
            v = ind[k] > 0 ? pos[+ind[k]] : neg[-ind[k]];
            cle->next = cptr[v];
            cptr[v] = cle;
         }
      }
      return;
}

int cfg_get_adjacent(CFG *G, int v, int ind[])
{     int nv = G->nv;
      int *ref = G->ref;
      CFGVLE **vptr = G->vptr;
      CFGCLE **cptr = G->cptr;
      CFGVLE *vle;
      CFGCLE *cle;
      int k, w, len;
      xassert(1 <= v && v <= nv);
      len = 0;
      /* walk thru the list of adjacent vertices */
      for (vle = vptr[v]; vle != NULL; vle = vle->next)
      {  w = vle->v;
         xassert(1 <= w && w <= nv);
         xassert(w != v);
         if (ref[w] > 0)
         {  ind[++len] = w;
            ref[w] = -ref[w];
         }
      }
      /* walk thru the list of incident cliques */
      for (cle = cptr[v]; cle != NULL; cle = cle->next)
      {  /* walk thru the list of clique vertices */
         for (vle = cle->vptr; vle != NULL; vle = vle->next)
         {  w = vle->v;
            xassert(1 <= w && w <= nv);
            if (w != v && ref[w] > 0)
            {  ind[++len] = w;
               ref[w] = -ref[w];
            }
         }
      }
      xassert(1 <= len && len < nv);
      /* unmark vertices included in the resultant adjacency list */
      for (k = 1; k <= len; k++)
      {  w = ind[k];
         ref[w] = -ref[w];
      }
      return len;
}


static int intersection(int d_len, int d_ind[], int d_pos[], int len,
      const int ind[])
{     /* compute intersection D := D inter W, where W is some specified
       * set of vertices */
      int k, t, v, new_len;
      /* walk thru vertices in W and mark vertices in D */
      for (t = 1; t <= len; t++)
      {  /* v in W */
         v = ind[t];
         /* determine position of v in D */
         k = d_pos[v];
         if (k != 0)
         {  /* v in D */
            xassert(d_ind[k] == v);
            /* mark v to keep it in D */
            d_ind[k] = -v;
         }
      }
      /* remove all unmarked vertices from D */
      new_len = 0;
      for (k = 1; k <= d_len; k++)
      {  /* v in D */
         v = d_ind[k];
         if (v < 0)
         {  /* v is marked; keep it */
            v = -v;
            new_len++;
            d_ind[new_len] = v;
            d_pos[v] = new_len;
         }
         else
         {  /* v is not marked; remove it */
            d_pos[v] = 0;
         }
      }
      return new_len;
}

int cfg_expand_clique(CFG *G, int c_len, int c_ind[])
{     int nv = G->nv;
      int d_len, *d_ind, *d_pos, len, *ind;
      int k, v;
      xassert(0 <= c_len && c_len <= nv);
      /* allocate working arrays */
      d_ind = talloc(1+nv, int);
      d_pos = talloc(1+nv, int);
      ind = talloc(1+nv, int);
      /* initialize C := 0, D := V */
      d_len = nv;
      for (k = 1; k <= nv; k++)
         d_ind[k] = d_pos[k] = k;
      /* expand C by vertices of specified initial clique C0 */
      for (k = 1; k <= c_len; k++)
      {  /* v in C0 */
         v = c_ind[k];
         xassert(1 <= v && v <= nv);
         /* since C0 is clique, v should be in D */
         xassert(d_pos[v] != 0);
         /* W := set of vertices adjacent to v */
         len = cfg_get_adjacent(G, v, ind);
         /* D := D inter W */
         d_len = intersection(d_len, d_ind, d_pos, len, ind);
         /* since v not in W, now v should be not in D */
         xassert(d_pos[v] == 0);
      }
      /* expand C by some other vertices until D is empty */
      while (d_len > 0)
      {  /* v in D */
         v = d_ind[1];
         xassert(1 <= v && v <= nv);
         /* note that v is adjacent to all vertices in C (by design),
          * so add v to C */
         c_ind[++c_len] = v;
         /* W := set of vertices adjacent to v */
         len = cfg_get_adjacent(G, v, ind);
         /* D := D inter W */
         d_len = intersection(d_len, d_ind, d_pos, len, ind);
         /* since v not in W, now v should be not in D */
         xassert(d_pos[v] == 0);
      }
      /* free working arrays */
      tfree(d_ind);
      tfree(d_pos);
      tfree(ind);
      /* bring maximal clique to calling routine */
      return c_len;
}

void cfg_check_clique(CFG *G, int c_len, const int c_ind[])
{     int nv = G->nv;
      int k, kk, v, w, len, *ind;
      char *flag;
      ind = talloc(1+nv, int);
      flag = talloc(1+nv, char);
      memset(&flag[1], 0, nv);
      /* walk thru clique vertices */
      xassert(c_len >= 0);
      for (k = 1; k <= c_len; k++)
      {  /* get clique vertex v */
         v = c_ind[k];
         xassert(1 <= v && v <= nv);
         /* get vertices adjacent to vertex v */
         len = cfg_get_adjacent(G, v, ind);
         for (kk = 1; kk <= len; kk++)
         {  w = ind[kk];
            xassert(1 <= w && w <= nv);
            xassert(w != v);
            flag[w] = 1;
         }
         /* check that all clique vertices other than v are adjacent
            to v */
         for (kk = 1; kk <= c_len; kk++)
         {  w = c_ind[kk];
            xassert(1 <= w && w <= nv);
            if (w != v)
               xassert(flag[w]);
         }
         /* reset vertex flags */
         for (kk = 1; kk <= len; kk++)
            flag[ind[kk]] = 0;
      }
      tfree(ind);
      tfree(flag);
      return;
}


void cfg_delete_graph(CFG *G)
{     tfree(G->pos);
      tfree(G->neg);
      dmp_delete_pool(G->pool);
      tfree(G->ref);
      tfree(G->vptr);
      tfree(G->cptr);
      tfree(G);
      return;
}

















typedef struct IOSLOT IOSLOT;
typedef struct IOSNPD IOSNPD;
typedef struct IOSBND IOSBND;
typedef struct IOSTAT IOSTAT;
typedef struct IOSROW IOSROW;
typedef struct IOSAIJ IOSAIJ;
typedef struct IOSPOOL IOSPOOL;
typedef struct IOSCUT IOSCUT;

struct glp_tree
{     /* branch-and-bound tree */
      int magic;
      /* magic value used for debugging */
      DMP *pool;
      /* memory pool to store all IOS components */
      int n;
      /* number of columns (variables) */
      /*--------------------------------------------------------------*/
      /* problem components corresponding to the original MIP and its
         LP relaxation (used to restore the original problem object on
         exit from the solver) */
      int orig_m;
      /* number of rows */
      unsigned char *orig_type; /* uchar orig_type[1+orig_m+n]; */
      /* types of all variables */
      double *orig_lb; /* double orig_lb[1+orig_m+n]; */
      /* lower bounds of all variables */
      double *orig_ub; /* double orig_ub[1+orig_m+n]; */
      /* upper bounds of all variables */
      unsigned char *orig_stat; /* uchar orig_stat[1+orig_m+n]; */
      /* statuses of all variables */
      double *orig_prim; /* double orig_prim[1+orig_m+n]; */
      /* primal values of all variables */
      double *orig_dual; /* double orig_dual[1+orig_m+n]; */
      /* dual values of all variables */
      double orig_obj;
      /* optimal objective value for LP relaxation */
      /*--------------------------------------------------------------*/
      /* branch-and-bound tree */
      int nslots;
      /* length of the array of slots (enlarged automatically) */
      int avail;
      /* index of the first free slot; 0 means all slots are in use */
      IOSLOT *slot; /* IOSLOT slot[1+nslots]; */
      /* array of slots:
         slot[0] is not used;
         slot[p], 1 <= p <= nslots, either contains a pointer to some
         node of the branch-and-bound tree, in which case p is used on
         API level as the reference number of corresponding subproblem,
         or is free; all free slots are linked into single linked list;
         slot[1] always contains a pointer to the root node (it is free
         only if the tree is empty) */
      IOSNPD *head;
      /* pointer to the head of the active list */
      IOSNPD *tail;
      /* pointer to the tail of the active list */
      /* the active list is a doubly linked list of active subproblems
         which correspond to leaves of the tree; all subproblems in the
         active list are ordered chronologically (each a new subproblem
         is always added to the tail of the list) */
      int a_cnt;
      /* current number of active nodes (including the current one) */
      int n_cnt;
      /* current number of all (active and inactive) nodes */
      int t_cnt;
      /* total number of nodes including those which have been already
         removed from the tree; this count is increased by one whenever
         a new node is created and never decreased */
      /*--------------------------------------------------------------*/
      /* problem components corresponding to the root subproblem */
      int root_m;
      /* number of rows */
      unsigned char *root_type; /* uchar root_type[1+root_m+n]; */
      /* types of all variables */
      double *root_lb; /* double root_lb[1+root_m+n]; */
      /* lower bounds of all variables */
      double *root_ub; /* double root_ub[1+root_m+n]; */
      /* upper bounds of all variables */
      unsigned char *root_stat; /* uchar root_stat[1+root_m+n]; */
      /* statuses of all variables */
      /*--------------------------------------------------------------*/
      /* current subproblem and its LP relaxation */
      IOSNPD *curr;
      /* pointer to the current subproblem (which can be only active);
         NULL means the current subproblem does not exist */
      glp_prob *mip;
      /* original problem object passed to the solver; if the current
         subproblem exists, its LP segment corresponds to LP relaxation
         of the current subproblem; if the current subproblem does not
         exist, its LP segment corresponds to LP relaxation of the root
         subproblem (note that the root subproblem may differ from the
         original MIP, because it may be preprocessed and/or may have
         additional rows) */
      unsigned char *non_int; /* uchar non_int[1+n]; */
      /* these column flags are set each time when LP relaxation of the
         current subproblem has been solved;
         non_int[0] is not used;
         non_int[j], 1 <= j <= n, is j-th column flag; if this flag is
         set, corresponding variable is required to be integer, but its
         value in basic solution is fractional */
      /*--------------------------------------------------------------*/
      /* problem components corresponding to the parent (predecessor)
         subproblem for the current subproblem; used to inspect changes
         on freezing the current subproblem */
      int pred_m;
      /* number of rows */
      int pred_max;
      /* length of the following four arrays (enlarged automatically),
         pred_max >= pred_m + n */
      unsigned char *pred_type; /* uchar pred_type[1+pred_m+n]; */
      /* types of all variables */
      double *pred_lb; /* double pred_lb[1+pred_m+n]; */
      /* lower bounds of all variables */
      double *pred_ub; /* double pred_ub[1+pred_m+n]; */
      /* upper bounds of all variables */
      unsigned char *pred_stat; /* uchar pred_stat[1+pred_m+n]; */
      /* statuses of all variables */
      /****************************************************************/
      /* built-in cut generators segment */
      IOSPOOL *local;
      /* local cut pool */
#if 0 /* 06/III-2016 */
      void *mir_gen;
#else
      glp_mir *mir_gen;
#endif
      /* pointer to working area used by the MIR cut generator */
#if 0 /* 08/III-2016 */
      void *clq_gen;
      /* pointer to working area used by the clique cut generator */
#else
      glp_cfg *clq_gen;
      /* pointer to conflict graph used by the clique cut generator */
#endif
      /*--------------------------------------------------------------*/
      void *pcost;
      /* pointer to working area used on pseudocost branching */
      int *iwrk; /* int iwrk[1+n]; */
      /* working array */
      double *dwrk; /* double dwrk[1+n]; */
      /* working array */
      /*--------------------------------------------------------------*/
      /* control parameters and statistics */
      const glp_iocp *parm;
      /* copy of control parameters passed to the solver */
#if 0 /* 10/VI-2013 */
      glp_long tm_beg;
#else
      double tm_beg;
#endif
      /* starting time of the search, in seconds; the total time of the
         search is the difference between xtime() and tm_beg */
#if 0 /* 10/VI-2013 */
      glp_long tm_lag;
#else
      double tm_lag;
#endif
      /* the most recent time, in seconds, at which the progress of the
         the search was displayed */
      int sol_cnt;
      /* number of integer feasible solutions found */
#if 1 /* 11/VII-2013 */
      void *P; /* glp_prob *P; */
      /* problem passed to glp_intopt */
      void *npp; /* NPP *npp; */
      /* preprocessor workspace or NULL */
      const char *save_sol;
      /* filename (template) to save every new solution */
      int save_cnt;
      /* count to generate filename */
#endif
      /*--------------------------------------------------------------*/
      /* advanced solver interface */
      int reason;
      /* flag indicating the reason why the callback routine is being
         called (see glpk.h) */
      int stop;
      /* flag indicating that the callback routine requires premature
         termination of the search */
      int next_p;
      /* reference number of active subproblem selected to continue
         the search; 0 means no subproblem has been selected */
      int reopt;
      /* flag indicating that the current LP relaxation needs to be
         re-optimized */
      int reinv;
      /* flag indicating that some (non-active) rows were removed from
         the current LP relaxation, so if there no new rows appear, the
         basis must be re-factorized */
      int br_var;
      /* the number of variable chosen to branch on */
      int br_sel;
      /* flag indicating which branch (subproblem) is suggested to be
         selected to continue the search:
         GLP_DN_BRNCH - select down-branch
         GLP_UP_BRNCH - select up-branch
         GLP_NO_BRNCH - use general selection technique */
      int child;
      /* subproblem reference number corresponding to br_sel */
};

struct IOSLOT
{     /* node subproblem slot */
      IOSNPD *node;
      /* pointer to subproblem descriptor; NULL means free slot */
      int next;
      /* index of another free slot (only if this slot is free) */
};

struct IOSNPD
{     /* node subproblem descriptor */
      int p;
      /* subproblem reference number (it is the index to corresponding
         slot, i.e. slot[p] points to this descriptor) */
      IOSNPD *up;
      /* pointer to the parent subproblem; NULL means this node is the
         root of the tree, in which case p = 1 */
      int level;
      /* node level (the root node has level 0) */
      int count;
      /* if count = 0, this subproblem is active; if count > 0, this
         subproblem is inactive, in which case count is the number of
         its child subproblems */
      /* the following three linked lists are destroyed on reviving and
         built anew on freezing the subproblem: */
      IOSBND *b_ptr;
      /* linked list of rows and columns of the parent subproblem whose
         types and bounds were changed */
      IOSTAT *s_ptr;
      /* linked list of rows and columns of the parent subproblem whose
         statuses were changed */
      IOSROW *r_ptr;
      /* linked list of rows (cuts) added to the parent subproblem */
      int solved;
      /* how many times LP relaxation of this subproblem was solved;
         for inactive subproblem this count is always non-zero;
         for active subproblem, which is not current, this count may be
         non-zero, if the subproblem was temporarily suspended */
      double lp_obj;
      /* optimal objective value to LP relaxation of this subproblem;
         on creating a subproblem this value is inherited from its
         parent; for the root subproblem, which has no parent, this
         value is initially set to -DBL_MAX (minimization) or +DBL_MAX
         (maximization); each time the subproblem is re-optimized, this
         value is appropriately changed */
      double bound;
      /* local lower (minimization) or upper (maximization) bound for
         integer optimal solution to *this* subproblem; this bound is
         local in the sense that only subproblems in the subtree rooted
         at this node cannot have better integer feasible solutions;
         on creating a subproblem its local bound is inherited from its
         parent and then can be made stronger (never weaker); for the
         root subproblem its local bound is initially set to -DBL_MAX
         (minimization) or +DBL_MAX (maximization) and then improved as
         the root LP relaxation has been solved */
      /* the following two quantities are defined only if LP relaxation
         of this subproblem was solved at least once (solved > 0): */
      int ii_cnt;
      /* number of integer variables whose value in optimal solution to
         LP relaxation of this subproblem is fractional */
      double ii_sum;
      /* sum of integer infeasibilities */
#if 1 /* 30/XI-2009 */
      int changed;
      /* how many times this subproblem was re-formulated (by adding
         cutting plane constraints) */
#endif
      int br_var;
      /* ordinal number of branching variable, 1 <= br_var <= n, used
         to split this subproblem; 0 means that either this subproblem
         is active or branching was made on a constraint */
      double br_val;
      /* (fractional) value of branching variable in optimal solution
         to final LP relaxation of this subproblem */
      void *data; /* char data[tree->cb_size]; */
      /* pointer to the application-specific data */
      IOSNPD *temp;
      /* working pointer used by some routines */
      IOSNPD *prev;
      /* pointer to previous subproblem in the active list */
      IOSNPD *next;
      /* pointer to next subproblem in the active list */
};

struct IOSBND
{     /* bounds change entry */
      int k;
      /* ordinal number of corresponding row (1 <= k <= m) or column
         (m+1 <= k <= m+n), where m and n are the number of rows and
         columns, resp., in the parent subproblem */
      unsigned char type;
      /* new type */
      double lb;
      /* new lower bound */
      double ub;
      /* new upper bound */
      IOSBND *next;
      /* pointer to next entry for the same subproblem */
};

struct IOSTAT
{     /* status change entry */
      int k;
      /* ordinal number of corresponding row (1 <= k <= m) or column
         (m+1 <= k <= m+n), where m and n are the number of rows and
         columns, resp., in the parent subproblem */
      unsigned char stat;
      /* new status */
      IOSTAT *next;
      /* pointer to next entry for the same subproblem */
};

struct IOSROW
{     /* row (constraint) addition entry */
      char *name;
      /* row name or NULL */
      unsigned char origin;
      /* row origin flag (see glp_attr.origin) */
      unsigned char klass;
      /* row class descriptor (see glp_attr.klass) */
      unsigned char type;
      /* row type (GLP_LO, GLP_UP, etc.) */
      double lb;
      /* row lower bound */
      double ub;
      /* row upper bound */
      IOSAIJ *ptr;
      /* pointer to the row coefficient list */
      double rii;
      /* row scale factor */
      unsigned char stat;
      /* row status (GLP_BS, GLP_NL, etc.) */
      IOSROW *next;
      /* pointer to next entry for the same subproblem */
};

struct IOSAIJ
{     /* constraint coefficient */
      int j;
      /* variable (column) number, 1 <= j <= n */
      double val;
      /* non-zero coefficient value */
      IOSAIJ *next;
      /* pointer to next coefficient for the same row */
};

struct IOSPOOL
{     /* cut pool */
      int size;
      /* pool size = number of cuts in the pool */
      IOSCUT *head;
      /* pointer to the first cut */
      IOSCUT *tail;
      /* pointer to the last cut */
      int ord;
      /* ordinal number of the current cut, 1 <= ord <= size */
      IOSCUT *curr;
      /* pointer to the current cut */
};

struct IOSCUT
{     /* cut (cutting plane constraint) */
      char *name;
      /* cut name or NULL */
      unsigned char klass;
      /* cut class descriptor (see glp_attr.klass) */
      IOSAIJ *ptr;
      /* pointer to the cut coefficient list */
      unsigned char type;
      /* cut type:
         GLP_LO: sum a[j] * x[j] >= b
         GLP_UP: sum a[j] * x[j] <= b
         GLP_FX: sum a[j] * x[j]  = b */
      double rhs;
      /* cut right-hand side */
      IOSCUT *prev;
      /* pointer to previous cut */
      IOSCUT *next;
      /* pointer to next cut */
};

#define ios_create_tree _glp_ios_create_tree
glp_tree *ios_create_tree(glp_prob *mip, const glp_iocp *parm);
/* create branch-and-bound tree */

#define ios_revive_node _glp_ios_revive_node
void ios_revive_node(glp_tree *tree, int p);
/* revive specified subproblem */

#define ios_freeze_node _glp_ios_freeze_node
void ios_freeze_node(glp_tree *tree);
/* freeze current subproblem */

#define ios_clone_node _glp_ios_clone_node
void ios_clone_node(glp_tree *tree, int p, int nnn, int ref[]);
/* clone specified subproblem */

#define ios_delete_node _glp_ios_delete_node
void ios_delete_node(glp_tree *tree, int p);
/* delete specified subproblem */

#define ios_delete_tree _glp_ios_delete_tree
void ios_delete_tree(glp_tree *tree);
/* delete branch-and-bound tree */

#define ios_eval_degrad _glp_ios_eval_degrad
void ios_eval_degrad(glp_tree *tree, int j, double *dn, double *up);
/* estimate obj. degrad. for down- and up-branches */

#define ios_round_bound _glp_ios_round_bound
double ios_round_bound(glp_tree *tree, double bound);
/* improve local bound by rounding */

#define ios_is_hopeful _glp_ios_is_hopeful
int ios_is_hopeful(glp_tree *tree, double bound);
/* check if subproblem is hopeful */

#define ios_best_node _glp_ios_best_node
int ios_best_node(glp_tree *tree);
/* find active node with best local bound */

#define ios_relative_gap _glp_ios_relative_gap
double ios_relative_gap(glp_tree *tree);
/* compute relative mip gap */

#define ios_solve_node _glp_ios_solve_node
int ios_solve_node(glp_tree *tree);
/* solve LP relaxation of current subproblem */

#define ios_create_pool _glp_ios_create_pool
IOSPOOL *ios_create_pool(glp_tree *tree);
/* create cut pool */

#define ios_add_row _glp_ios_add_row
int ios_add_row(glp_tree *tree, IOSPOOL *pool,
      const char *name, int klass, int flags, int len, const int ind[],
      const double val[], int type, double rhs);
/* add row (constraint) to the cut pool */

#define ios_find_row _glp_ios_find_row
IOSCUT *ios_find_row(IOSPOOL *pool, int i);
/* find row (constraint) in the cut pool */

#define ios_del_row _glp_ios_del_row
void ios_del_row(glp_tree *tree, IOSPOOL *pool, int i);
/* remove row (constraint) from the cut pool */

#define ios_clear_pool _glp_ios_clear_pool
void ios_clear_pool(glp_tree *tree, IOSPOOL *pool);
/* remove all rows (constraints) from the cut pool */

#define ios_delete_pool _glp_ios_delete_pool
void ios_delete_pool(glp_tree *tree, IOSPOOL *pool);
/* delete cut pool */

#if 1 /* 11/VII-2013 */
#define ios_process_sol _glp_ios_process_sol
void ios_process_sol(glp_tree *T);
/* process integer feasible solution just found */
#endif

#define ios_preprocess_node _glp_ios_preprocess_node
int ios_preprocess_node(glp_tree *tree, int max_pass);
/* preprocess current subproblem */

#define ios_driver _glp_ios_driver
int ios_driver(glp_tree *tree);
/* branch-and-bound driver */

#define ios_cov_gen _glp_ios_cov_gen
void ios_cov_gen(glp_tree *tree);
/* generate mixed cover cuts */

#define ios_pcost_init _glp_ios_pcost_init
void *ios_pcost_init(glp_tree *tree);
/* initialize working data used on pseudocost branching */

#define ios_pcost_branch _glp_ios_pcost_branch
int ios_pcost_branch(glp_tree *T, int *next);
/* choose branching variable with pseudocost branching */

#define ios_pcost_update _glp_ios_pcost_update
void ios_pcost_update(glp_tree *tree);
/* update history information for pseudocost branching */

#define ios_pcost_free _glp_ios_pcost_free
void ios_pcost_free(glp_tree *tree);
/* free working area used on pseudocost branching */

#define ios_feas_pump _glp_ios_feas_pump
void ios_feas_pump(glp_tree *T);
/* feasibility pump heuristic */

#if 1 /* 25/V-2013 */
#define ios_proxy_heur _glp_ios_proxy_heur
void ios_proxy_heur(glp_tree *T);
/* proximity search heuristic */
#endif

#define ios_process_cuts _glp_ios_process_cuts
void ios_process_cuts(glp_tree *T);
/* process cuts stored in the local cut pool */

#define ios_choose_node _glp_ios_choose_node
int ios_choose_node(glp_tree *T);
/* select subproblem to continue the search */

#define ios_choose_var _glp_ios_choose_var
int ios_choose_var(glp_tree *T, int *next);
/* select variable to branch on */

/* CAUTION: DO NOT CHANGE THE LIMITS BELOW */

#define M_MAX 100000000 /* = 100*10^6 */
/* maximal number of rows in the problem object */

#define N_MAX 100000000 /* = 100*10^6 */
/* maximal number of columns in the problem object */

#define NNZ_MAX 500000000 /* = 500*10^6 */
/* maximal number of constraint coefficients in the problem object */

static void create_prob(glp_prob *lp)
{     lp->magic = GLP_PROB_MAGIC;
      lp->pool = dmp_create_pool();
#if 0 /* 08/III-2014 */
#if 0 /* 17/XI-2009 */
      lp->cps = xmalloc(sizeof(struct LPXCPS));
      lpx_reset_parms(lp);
#else
      lp->parms = NULL;
#endif
#endif
      lp->tree = NULL;
#if 0
      lp->lwa = 0;
      lp->cwa = NULL;
#endif
      /* LP/MIP data */
      lp->name = NULL;
      lp->obj = NULL;
      lp->dir = GLP_MIN;
      lp->c0 = 0.0;
      lp->m_max = 100;
      lp->n_max = 200;
      lp->m = lp->n = 0;
      lp->nnz = 0;
      lp->row = xcalloc(1+lp->m_max, sizeof(GLPROW *));
      lp->col = xcalloc(1+lp->n_max, sizeof(GLPCOL *));
      lp->r_tree = lp->c_tree = NULL;
      /* basis factorization */
      lp->valid = 0;
      lp->head = xcalloc(1+lp->m_max, sizeof(int));
#if 0 /* 08/III-2014 */
      lp->bfcp = NULL;
#endif
      lp->bfd = NULL;
      /* basic solution (LP) */
      lp->pbs_stat = lp->dbs_stat = GLP_UNDEF;
      lp->obj_val = 0.0;
      lp->it_cnt = 0;
      lp->some = 0;
      /* interior-point solution (LP) */
      lp->ipt_stat = GLP_UNDEF;
      lp->ipt_obj = 0.0;
      /* integer solution (MIP) */
      lp->mip_stat = GLP_UNDEF;
      lp->mip_obj = 0.0;
      return;
}

glp_prob *glp_create_prob(void)
{     glp_prob *lp;
      lp = xmalloc(sizeof(glp_prob));
      create_prob(lp);
      return lp;
}

void glp_set_prob_name(glp_prob *lp, const char *name)
{     glp_tree *tree = lp->tree;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_set_prob_name: operation not allowed\n");
      if (lp->name != NULL)
      {  dmp_free_atom(lp->pool, lp->name, strlen(lp->name)+1);
         lp->name = NULL;
      }
      if (!(name == NULL || name[0] == '\0'))
      {  int k;
         for (k = 0; name[k] != '\0'; k++)
         {  if (k == 256)
               xerror("glp_set_prob_name: problem name too long\n");
            if (iscntrl((unsigned char)name[k]))
               xerror("glp_set_prob_name: problem name contains invalid"
                  " character(s)\n");
         }
         lp->name = dmp_get_atom(lp->pool, strlen(name)+1);
         strcpy(lp->name, name);
      }
      return;
}


void glp_set_obj_name(glp_prob *lp, const char *name)
{     glp_tree *tree = lp->tree;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_set_obj_name: operation not allowed\n");
     if (lp->obj != NULL)
      {  dmp_free_atom(lp->pool, lp->obj, strlen(lp->obj)+1);
         lp->obj = NULL;
      }
      if (!(name == NULL || name[0] == '\0'))
      {  int k;
         for (k = 0; name[k] != '\0'; k++)
         {  if (k == 256)
               xerror("glp_set_obj_name: objective name too long\n");
            if (iscntrl((unsigned char)name[k]))
               xerror("glp_set_obj_name: objective name contains invali"
                  "d character(s)\n");
         }
         lp->obj = dmp_get_atom(lp->pool, strlen(name)+1);
         strcpy(lp->obj, name);
      }
      return;
}


void glp_set_obj_dir(glp_prob *lp, int dir)
{     glp_tree *tree = lp->tree;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_set_obj_dir: operation not allowed\n");
     if (!(dir == GLP_MIN || dir == GLP_MAX))
         xerror("glp_set_obj_dir: dir = %d; invalid direction flag\n",
            dir);
      lp->dir = dir;
      return;
}

int glp_add_rows(glp_prob *lp, int nrs)
{     glp_tree *tree = lp->tree;
      GLPROW *row;
      int m_new, i;
      /* determine new number of rows */
      if (nrs < 1)
         xerror("glp_add_rows: nrs = %d; invalid number of rows\n",
            nrs);
      if (nrs > M_MAX - lp->m)
         xerror("glp_add_rows: nrs = %d; too many rows\n", nrs);
      m_new = lp->m + nrs;
      /* increase the room, if necessary */
      if (lp->m_max < m_new)
      {  GLPROW **save = lp->row;
         while (lp->m_max < m_new)
         {  lp->m_max += lp->m_max;
            xassert(lp->m_max > 0);
         }
         lp->row = xcalloc(1+lp->m_max, sizeof(GLPROW *));
         memcpy(&lp->row[1], &save[1], lp->m * sizeof(GLPROW *));
         xfree(save);
         /* do not forget about the basis header */
         xfree(lp->head);
         lp->head = xcalloc(1+lp->m_max, sizeof(int));
      }
      /* add new rows to the end of the row list */
      for (i = lp->m+1; i <= m_new; i++)
      {  /* create row descriptor */
         lp->row[i] = row = dmp_get_atom(lp->pool, sizeof(GLPROW));
         row->i = i;
         row->name = NULL;
         row->node = NULL;
#if 1 /* 20/IX-2008 */
         row->level = 0;
         row->origin = 0;
         row->klass = 0;
         if (tree != NULL)
         {  switch (tree->reason)
            {  case 0:
                  break;
               case GLP_IROWGEN:
                  xassert(tree->curr != NULL);
                  row->level = tree->curr->level;
                  row->origin = GLP_RF_LAZY;
                  break;
               case GLP_ICUTGEN:
                  xassert(tree->curr != NULL);
                  row->level = tree->curr->level;
                  row->origin = GLP_RF_CUT;
                  break;
               default:
                  xassert(tree != tree);
            }
         }
#endif
         row->type = GLP_FR;
         row->lb = row->ub = 0.0;
         row->ptr = NULL;
         row->rii = 1.0;
         row->stat = GLP_BS;
#if 0
         row->bind = -1;
#else
         row->bind = 0;
#endif
         row->prim = row->dual = 0.0;
         row->pval = row->dval = 0.0;
         row->mipx = 0.0;
      }
      /* set new number of rows */
      lp->m = m_new;
      /* invalidate the basis factorization */
      lp->valid = 0;
#if 1
      if (tree != NULL && tree->reason != 0) tree->reopt = 1;
#endif
      /* return the ordinal number of the first row added */
      return m_new - nrs + 1;
}


int glp_add_cols(glp_prob *lp, int ncs)
{     glp_tree *tree = lp->tree;
      GLPCOL *col;
      int n_new, j;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_add_cols: operation not allowed\n");
      /* determine new number of columns */
      if (ncs < 1)
         xerror("glp_add_cols: ncs = %d; invalid number of columns\n",
            ncs);
      if (ncs > N_MAX - lp->n)
         xerror("glp_add_cols: ncs = %d; too many columns\n", ncs);
      n_new = lp->n + ncs;
      /* increase the room, if necessary */
      if (lp->n_max < n_new)
      {  GLPCOL **save = lp->col;
         while (lp->n_max < n_new)
         {  lp->n_max += lp->n_max;
            xassert(lp->n_max > 0);
         }
         lp->col = xcalloc(1+lp->n_max, sizeof(GLPCOL *));
         memcpy(&lp->col[1], &save[1], lp->n * sizeof(GLPCOL *));
         xfree(save);
      }
      /* add new columns to the end of the column list */
      for (j = lp->n+1; j <= n_new; j++)
      {  /* create column descriptor */
         lp->col[j] = col = dmp_get_atom(lp->pool, sizeof(GLPCOL));
         col->j = j;
         col->name = NULL;
         col->node = NULL;
         col->kind = GLP_CV;
         col->type = GLP_FX;
         col->lb = col->ub = 0.0;
         col->coef = 0.0;
         col->ptr = NULL;
         col->sjj = 1.0;
         col->stat = GLP_NS;
#if 0
         col->bind = -1;
#else
         col->bind = 0; /* the basis may remain valid */
#endif
         col->prim = col->dual = 0.0;
         col->pval = col->dval = 0.0;
         col->mipx = 0.0;
      }
      /* set new number of columns */
      lp->n = n_new;
      /* return the ordinal number of the first column added */
      return n_new - ncs + 1;
}


void glp_set_row_name(glp_prob *lp, int i, const char *name)
{     glp_tree *tree = lp->tree;
      GLPROW *row;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_set_row_name: i = %d; row number out of range\n",
            i);
      row = lp->row[i];
      if (tree != NULL && tree->reason != 0)
      {  xassert(tree->curr != NULL);
         xassert(row->level == tree->curr->level);
      }
      if (row->name != NULL)
      {  if (row->node != NULL)
         {  xassert(lp->r_tree != NULL);
            avl_delete_node(lp->r_tree, row->node);
            row->node = NULL;
         }
         dmp_free_atom(lp->pool, row->name, strlen(row->name)+1);
         row->name = NULL;
      }
      if (!(name == NULL || name[0] == '\0'))
      {  int k;
         for (k = 0; name[k] != '\0'; k++)
         {  if (k == 256)
               xerror("glp_set_row_name: i = %d; row name too long\n",
                  i);
            if (iscntrl((unsigned char)name[k]))
               xerror("glp_set_row_name: i = %d: row name contains inva"
                  "lid character(s)\n", i);
         }
         row->name = dmp_get_atom(lp->pool, strlen(name)+1);
         strcpy(row->name, name);
         if (lp->r_tree != NULL)
         {  xassert(row->node == NULL);
            row->node = avl_insert_node(lp->r_tree, row->name);
            avl_set_node_link(row->node, row);
         }
      }
      return;
}

void glp_set_col_name(glp_prob *lp, int j, const char *name)
{     glp_tree *tree = lp->tree;
      GLPCOL *col;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_set_col_name: operation not allowed\n");
      if (!(1 <= j && j <= lp->n))
         xerror("glp_set_col_name: j = %d; column number out of range\n"
            , j);
      col = lp->col[j];
      if (col->name != NULL)
      {  if (col->node != NULL)
         {  xassert(lp->c_tree != NULL);
            avl_delete_node(lp->c_tree, col->node);
            col->node = NULL;
         }
         dmp_free_atom(lp->pool, col->name, strlen(col->name)+1);
         col->name = NULL;
      }
      if (!(name == NULL || name[0] == '\0'))
      {  int k;
         for (k = 0; name[k] != '\0'; k++)
         {  if (k == 256)
               xerror("glp_set_col_name: j = %d; column name too long\n"
                  , j);
            if (iscntrl((unsigned char)name[k]))
               xerror("glp_set_col_name: j = %d: column name contains i"
                  "nvalid character(s)\n", j);
         }
         col->name = dmp_get_atom(lp->pool, strlen(name)+1);
         strcpy(col->name, name);
         if (lp->c_tree != NULL && col->name != NULL)
         {  xassert(col->node == NULL);
            col->node = avl_insert_node(lp->c_tree, col->name);
            avl_set_node_link(col->node, col);
         }
      }
      return;
}

void glp_set_row_bnds(glp_prob *lp, int i, int type, double lb, double ub)
{     GLPROW *row;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_set_row_bnds: i = %d; row number out of range\n",
            i);
      row = lp->row[i];
      row->type = type;
      switch (type)
      {  case GLP_FR:
            row->lb = row->ub = 0.0;
            if (row->stat != GLP_BS) row->stat = GLP_NF;
            break;
         case GLP_LO:
            row->lb = lb, row->ub = 0.0;
            if (row->stat != GLP_BS) row->stat = GLP_NL;
            break;
         case GLP_UP:
            row->lb = 0.0, row->ub = ub;
            if (row->stat != GLP_BS) row->stat = GLP_NU;
            break;
         case GLP_DB:
            row->lb = lb, row->ub = ub;
            if (!(row->stat == GLP_BS ||
                  row->stat == GLP_NL || row->stat == GLP_NU))
               row->stat = (fabs(lb) <= fabs(ub) ? GLP_NL : GLP_NU);
            break;
         case GLP_FX:
            row->lb = row->ub = lb;
            if (row->stat != GLP_BS) row->stat = GLP_NS;
            break;
         default:
            xerror("glp_set_row_bnds: i = %d; type = %d; invalid row ty"
               "pe\n", i, type);
      }
      return;
}

void glp_set_col_bnds(glp_prob *lp, int j, int type, double lb,
      double ub)
{     GLPCOL *col;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_set_col_bnds: j = %d; column number out of range\n"
            , j);
      col = lp->col[j];
      col->type = type;
      switch (type)
      {  case GLP_FR:
            col->lb = col->ub = 0.0;
            if (col->stat != GLP_BS) col->stat = GLP_NF;
            break;
         case GLP_LO:
            col->lb = lb, col->ub = 0.0;
            if (col->stat != GLP_BS) col->stat = GLP_NL;
            break;
         case GLP_UP:
            col->lb = 0.0, col->ub = ub;
            if (col->stat != GLP_BS) col->stat = GLP_NU;
            break;
         case GLP_DB:
            col->lb = lb, col->ub = ub;
            if (!(col->stat == GLP_BS ||
                  col->stat == GLP_NL || col->stat == GLP_NU))
               col->stat = (fabs(lb) <= fabs(ub) ? GLP_NL : GLP_NU);
            break;
         case GLP_FX:
            col->lb = col->ub = lb;
            if (col->stat != GLP_BS) col->stat = GLP_NS;
            break;
         default:
            xerror("glp_set_col_bnds: j = %d; type = %d; invalid column"
               " type\n", j, type);
      }
      return;
}


void glp_set_obj_coef(glp_prob *lp, int j, double coef)
{     glp_tree *tree = lp->tree;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_set_obj_coef: operation not allowed\n");
      if (!(0 <= j && j <= lp->n))
         xerror("glp_set_obj_coef: j = %d; column number out of range\n"
            , j);
      if (j == 0)
         lp->c0 = coef;
      else
         lp->col[j]->coef = coef;
      return;
}

void glp_set_mat_row(glp_prob *lp, int i, int len, const int ind[], const double val[])
{     glp_tree *tree = lp->tree;
      GLPROW *row;
      GLPCOL *col;
      GLPAIJ *aij, *next;
      int j, k;
      /* obtain pointer to i-th row */
      if (!(1 <= i && i <= lp->m))
         xerror("glp_set_mat_row: i = %d; row number out of range\n",
            i);
      row = lp->row[i];
      if (tree != NULL && tree->reason != 0)
      {  xassert(tree->curr != NULL);
         xassert(row->level == tree->curr->level);
      }
      /* remove all existing elements from i-th row */
      while (row->ptr != NULL)
      {  /* take next element in the row */
         aij = row->ptr;
         /* remove the element from the row list */
         row->ptr = aij->r_next;
         /* obtain pointer to corresponding column */
         col = aij->col;
         /* remove the element from the column list */
         if (aij->c_prev == NULL)
            col->ptr = aij->c_next;
         else
            aij->c_prev->c_next = aij->c_next;
         if (aij->c_next == NULL)
            ;
         else
            aij->c_next->c_prev = aij->c_prev;
         /* return the element to the memory pool */
         dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;
         /* if the corresponding column is basic, invalidate the basis
            factorization */
         if (col->stat == GLP_BS) lp->valid = 0;
      }
      /* store new contents of i-th row */
      if (!(0 <= len && len <= lp->n))
         xerror("glp_set_mat_row: i = %d; len = %d; invalid row length "
            "\n", i, len);
      if (len > NNZ_MAX - lp->nnz)
         xerror("glp_set_mat_row: i = %d; len = %d; too many constraint"
            " coefficients\n", i, len);
      for (k = 1; k <= len; k++)
      {  /* take number j of corresponding column */
         j = ind[k];
         /* obtain pointer to j-th column */
         if (!(1 <= j && j <= lp->n))
            xerror("glp_set_mat_row: i = %d; ind[%d] = %d; column index"
               " out of range\n", i, k, j);
         col = lp->col[j];
         /* if there is element with the same column index, it can only
            be found in the beginning of j-th column list */
         if (col->ptr != NULL && col->ptr->row->i == i)
            xerror("glp_set_mat_row: i = %d; ind[%d] = %d; duplicate co"
               "lumn indices not allowed\n", i, k, j);
         /* create new element */
         aij = dmp_get_atom(lp->pool, sizeof(GLPAIJ)), lp->nnz++;
         aij->row = row;
         aij->col = col;
         aij->val = val[k];
         /* add the new element to the beginning of i-th row and j-th
            column lists */
         aij->r_prev = NULL;
         aij->r_next = row->ptr;
         aij->c_prev = NULL;
         aij->c_next = col->ptr;
         if (aij->r_next != NULL) aij->r_next->r_prev = aij;
         if (aij->c_next != NULL) aij->c_next->c_prev = aij;
         row->ptr = col->ptr = aij;
         /* if the corresponding column is basic, invalidate the basis
            factorization */
         if (col->stat == GLP_BS && aij->val != 0.0) lp->valid = 0;
      }
      /* remove zero elements from i-th row */
      for (aij = row->ptr; aij != NULL; aij = next)
      {  next = aij->r_next;
         if (aij->val == 0.0)
         {  /* remove the element from the row list */
            if (aij->r_prev == NULL)
               row->ptr = next;
            else
               aij->r_prev->r_next = next;
            if (next == NULL)
               ;
            else
               next->r_prev = aij->r_prev;
            /* remove the element from the column list */
            xassert(aij->c_prev == NULL);
            aij->col->ptr = aij->c_next;
            if (aij->c_next != NULL) aij->c_next->c_prev = NULL;
            /* return the element to the memory pool */
            dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;
         }
      }
      return;
}

void glp_set_mat_col(glp_prob *lp, int j, int len, const int ind[],
      const double val[])
{     glp_tree *tree = lp->tree;
      GLPROW *row;
      GLPCOL *col;
      GLPAIJ *aij, *next;
      int i, k;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_set_mat_col: operation not allowed\n");
      /* obtain pointer to j-th column */
      if (!(1 <= j && j <= lp->n))
         xerror("glp_set_mat_col: j = %d; column number out of range\n",
            j);
      col = lp->col[j];
      /* remove all existing elements from j-th column */
      while (col->ptr != NULL)
      {  /* take next element in the column */
         aij = col->ptr;
         /* remove the element from the column list */
         col->ptr = aij->c_next;
         /* obtain pointer to corresponding row */
         row = aij->row;
         /* remove the element from the row list */
         if (aij->r_prev == NULL)
            row->ptr = aij->r_next;
         else
            aij->r_prev->r_next = aij->r_next;
         if (aij->r_next == NULL)
            ;
         else
            aij->r_next->r_prev = aij->r_prev;
         /* return the element to the memory pool */
         dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;
      }
      /* store new contents of j-th column */
      if (!(0 <= len && len <= lp->m))
         xerror("glp_set_mat_col: j = %d; len = %d; invalid column leng"
            "th\n", j, len);
      if (len > NNZ_MAX - lp->nnz)
         xerror("glp_set_mat_col: j = %d; len = %d; too many constraint"
            " coefficients\n", j, len);
      for (k = 1; k <= len; k++)
      {  /* take number i of corresponding row */
         i = ind[k];
         /* obtain pointer to i-th row */
         if (!(1 <= i && i <= lp->m))
            xerror("glp_set_mat_col: j = %d; ind[%d] = %d; row index ou"
               "t of range\n", j, k, i);
         row = lp->row[i];
         /* if there is element with the same row index, it can only be
            found in the beginning of i-th row list */
         if (row->ptr != NULL && row->ptr->col->j == j)
            xerror("glp_set_mat_col: j = %d; ind[%d] = %d; duplicate ro"
               "w indices not allowed\n", j, k, i);
         /* create new element */
         aij = dmp_get_atom(lp->pool, sizeof(GLPAIJ)), lp->nnz++;
         aij->row = row;
         aij->col = col;
         aij->val = val[k];
         /* add the new element to the beginning of i-th row and j-th
            column lists */
         aij->r_prev = NULL;
         aij->r_next = row->ptr;
         aij->c_prev = NULL;
         aij->c_next = col->ptr;
         if (aij->r_next != NULL) aij->r_next->r_prev = aij;
         if (aij->c_next != NULL) aij->c_next->c_prev = aij;
         row->ptr = col->ptr = aij;
      }
      /* remove zero elements from j-th column */
      for (aij = col->ptr; aij != NULL; aij = next)
      {  next = aij->c_next;
         if (aij->val == 0.0)
         {  /* remove the element from the row list */
            xassert(aij->r_prev == NULL);
            aij->row->ptr = aij->r_next;
            if (aij->r_next != NULL) aij->r_next->r_prev = NULL;
            /* remove the element from the column list */
            if (aij->c_prev == NULL)
               col->ptr = next;
            else
               aij->c_prev->c_next = next;
            if (next == NULL)
               ;
            else
               next->c_prev = aij->c_prev;
            /* return the element to the memory pool */
            dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;
         }
      }
      /* if j-th column is basic, invalidate the basis factorization */
      if (col->stat == GLP_BS) lp->valid = 0;
      return;
}

void glp_load_matrix(glp_prob *lp, int ne, const int ia[],
      const int ja[], const double ar[])
{     glp_tree *tree = lp->tree;
      GLPROW *row;
      GLPCOL *col;
      GLPAIJ *aij, *next;
      int i, j, k;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_load_matrix: operation not allowed\n");
      /* clear the constraint matrix */
      for (i = 1; i <= lp->m; i++)
      {  row = lp->row[i];
         while (row->ptr != NULL)
         {  aij = row->ptr;
            row->ptr = aij->r_next;
            dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;
         }
      }
      xassert(lp->nnz == 0);
      for (j = 1; j <= lp->n; j++) lp->col[j]->ptr = NULL;
      /* load the new contents of the constraint matrix and build its
         row lists */
      if (ne < 0)
         xerror("glp_load_matrix: ne = %d; invalid number of constraint"
            " coefficients\n", ne);
      if (ne > NNZ_MAX)
         xerror("glp_load_matrix: ne = %d; too many constraint coeffici"
            "ents\n", ne);
      for (k = 1; k <= ne; k++)
      {  /* take indices of new element */
         i = ia[k], j = ja[k];
         /* obtain pointer to i-th row */
         if (!(1 <= i && i <= lp->m))
            xerror("glp_load_matrix: ia[%d] = %d; row index out of rang"
               "e\n", k, i);
         row = lp->row[i];
         /* obtain pointer to j-th column */
         if (!(1 <= j && j <= lp->n))
            xerror("glp_load_matrix: ja[%d] = %d; column index out of r"
               "ange\n", k, j);
         col = lp->col[j];
         /* create new element */
         aij = dmp_get_atom(lp->pool, sizeof(GLPAIJ)), lp->nnz++;
         aij->row = row;
         aij->col = col;
         aij->val = ar[k];
         /* add the new element to the beginning of i-th row list */
         aij->r_prev = NULL;
         aij->r_next = row->ptr;
         if (aij->r_next != NULL) aij->r_next->r_prev = aij;
         row->ptr = aij;
      }
      xassert(lp->nnz == ne);
      /* build column lists of the constraint matrix and check elements
         with identical indices */
      for (i = 1; i <= lp->m; i++)
      {  for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)
         {  /* obtain pointer to corresponding column */
            col = aij->col;
            /* if there is element with identical indices, it can only
               be found in the beginning of j-th column list */
            if (col->ptr != NULL && col->ptr->row->i == i)
            {  for (k = 1; k <= ne; k++)
                  if (ia[k] == i && ja[k] == col->j) break;
               xerror("glp_load_mat: ia[%d] = %d; ja[%d] = %d; duplicat"
                  "e indices not allowed\n", k, i, k, col->j);
            }
            /* add the element to the beginning of j-th column list */
            aij->c_prev = NULL;
            aij->c_next = col->ptr;
            if (aij->c_next != NULL) aij->c_next->c_prev = aij;
            col->ptr = aij;
         }
      }
      /* remove zero elements from the constraint matrix */
      for (i = 1; i <= lp->m; i++)
      {  row = lp->row[i];
         for (aij = row->ptr; aij != NULL; aij = next)
         {  next = aij->r_next;
            if (aij->val == 0.0)
            {  /* remove the element from the row list */
               if (aij->r_prev == NULL)
                  row->ptr = next;
               else
                  aij->r_prev->r_next = next;
               if (next == NULL)
                  ;
               else
                  next->r_prev = aij->r_prev;
               /* remove the element from the column list */
               if (aij->c_prev == NULL)
                  aij->col->ptr = aij->c_next;
               else
                  aij->c_prev->c_next = aij->c_next;
               if (aij->c_next == NULL)
                  ;
               else
                  aij->c_next->c_prev = aij->c_prev;
               /* return the element to the memory pool */
               dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;
            }
         }
      }
      /* invalidate the basis factorization */
      lp->valid = 0;
      return;
}

int glp_check_dup(int m, int n, int ne, const int ia[], const int ja[])
{     int i, j, k, *ptr, *next, ret;
      char *flag;
      if (m < 0)
         xerror("glp_check_dup: m = %d; invalid parameter\n");
      if (n < 0)
         xerror("glp_check_dup: n = %d; invalid parameter\n");
      if (ne < 0)
         xerror("glp_check_dup: ne = %d; invalid parameter\n");
      if (ne > 0 && ia == NULL)
         xerror("glp_check_dup: ia = %p; invalid parameter\n", ia);
      if (ne > 0 && ja == NULL)
         xerror("glp_check_dup: ja = %p; invalid parameter\n", ja);
      for (k = 1; k <= ne; k++)
      {  i = ia[k], j = ja[k];
         if (!(1 <= i && i <= m && 1 <= j && j <= n))
         {  ret = -k;
            goto done;
         }
      }
      if (m == 0 || n == 0)
      {  ret = 0;
         goto done;
      }
      /* allocate working arrays */
      ptr = xcalloc(1+m, sizeof(int));
      next = xcalloc(1+ne, sizeof(int));
      flag = xcalloc(1+n, sizeof(char));
      /* build row lists */
      for (i = 1; i <= m; i++)
         ptr[i] = 0;
      for (k = 1; k <= ne; k++)
      {  i = ia[k];
         next[k] = ptr[i];
         ptr[i] = k;
      }
      /* clear column flags */
      for (j = 1; j <= n; j++)
         flag[j] = 0;
      /* check for duplicate elements */
      for (i = 1; i <= m; i++)
      {  for (k = ptr[i]; k != 0; k = next[k])
         {  j = ja[k];
            if (flag[j])
            {  /* find first element (i,j) */
               for (k = 1; k <= ne; k++)
                  if (ia[k] == i && ja[k] == j) break;
               xassert(k <= ne);
               /* find next (duplicate) element (i,j) */
               for (k++; k <= ne; k++)
                  if (ia[k] == i && ja[k] == j) break;
               xassert(k <= ne);
               ret = +k;
               goto skip;
            }
            flag[j] = 1;
         }
         /* clear column flags */
         for (k = ptr[i]; k != 0; k = next[k])
            flag[ja[k]] = 0;
      }
      /* no duplicate element found */
      ret = 0;
skip: /* free working arrays */
      xfree(ptr);
      xfree(next);
      xfree(flag);
done: return ret;
}

void glp_sort_matrix(glp_prob *P)
{     GLPAIJ *aij;
      int i, j;
      if (P == NULL || P->magic != GLP_PROB_MAGIC)
         xerror("glp_sort_matrix: P = %p; invalid problem object\n",
            P);
      /* rebuild row linked lists */
      for (i = P->m; i >= 1; i--)
         P->row[i]->ptr = NULL;
      for (j = P->n; j >= 1; j--)
      {  for (aij = P->col[j]->ptr; aij != NULL; aij = aij->c_next)
         {  i = aij->row->i;
            aij->r_prev = NULL;
            aij->r_next = P->row[i]->ptr;
            if (aij->r_next != NULL) aij->r_next->r_prev = aij;
            P->row[i]->ptr = aij;
         }
      }
      /* rebuild column linked lists */
      for (j = P->n; j >= 1; j--)
         P->col[j]->ptr = NULL;
      for (i = P->m; i >= 1; i--)
      {  for (aij = P->row[i]->ptr; aij != NULL; aij = aij->r_next)
         {  j = aij->col->j;
            aij->c_prev = NULL;
            aij->c_next = P->col[j]->ptr;
            if (aij->c_next != NULL) aij->c_next->c_prev = aij;
            P->col[j]->ptr = aij;
         }
      }
      return;
}

void glp_del_rows(glp_prob *lp, int nrs, const int num[])
{     glp_tree *tree = lp->tree;
      GLPROW *row;
      int i, k, m_new;
      /* mark rows to be deleted */
      if (!(1 <= nrs && nrs <= lp->m))
         xerror("glp_del_rows: nrs = %d; invalid number of rows\n",
            nrs);
      for (k = 1; k <= nrs; k++)
      {  /* take the number of row to be deleted */
         i = num[k];
         /* obtain pointer to i-th row */
         if (!(1 <= i && i <= lp->m))
            xerror("glp_del_rows: num[%d] = %d; row number out of range"
               "\n", k, i);
         row = lp->row[i];
         if (tree != NULL && tree->reason != 0)
         {  if (!(tree->reason == GLP_IROWGEN ||
                  tree->reason == GLP_ICUTGEN))
               xerror("glp_del_rows: operation not allowed\n");
            xassert(tree->curr != NULL);
            if (row->level != tree->curr->level)
               xerror("glp_del_rows: num[%d] = %d; invalid attempt to d"
                  "elete row created not in current subproblem\n", k,i);
            if (row->stat != GLP_BS)
               xerror("glp_del_rows: num[%d] = %d; invalid attempt to d"
                  "elete active row (constraint)\n", k, i);
            tree->reinv = 1;
         }
         /* check that the row is not marked yet */
         if (row->i == 0)
            xerror("glp_del_rows: num[%d] = %d; duplicate row numbers n"
               "ot allowed\n", k, i);
         /* erase symbolic name assigned to the row */
         glp_set_row_name(lp, i, NULL);
         xassert(row->node == NULL);
         /* erase corresponding row of the constraint matrix */
         glp_set_mat_row(lp, i, 0, NULL, NULL);
         xassert(row->ptr == NULL);
         /* mark the row to be deleted */
         row->i = 0;
      }
      /* delete all marked rows from the row list */
      m_new = 0;
      for (i = 1; i <= lp->m; i++)
      {  /* obtain pointer to i-th row */
         row = lp->row[i];
         /* check if the row is marked */
         if (row->i == 0)
         {  /* it is marked, delete it */
            dmp_free_atom(lp->pool, row, sizeof(GLPROW));
         }
         else
         {  /* it is not marked; keep it */
            row->i = ++m_new;
            lp->row[row->i] = row;
         }
      }
      /* set new number of rows */
      lp->m = m_new;
      /* invalidate the basis factorization */
      lp->valid = 0;
      return;
}

void glp_del_cols(glp_prob *lp, int ncs, const int num[])
{     glp_tree *tree = lp->tree;
      GLPCOL *col;
      int j, k, n_new;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_del_cols: operation not allowed\n");
      /* mark columns to be deleted */
      if (!(1 <= ncs && ncs <= lp->n))
         xerror("glp_del_cols: ncs = %d; invalid number of columns\n",
            ncs);
      for (k = 1; k <= ncs; k++)
      {  /* take the number of column to be deleted */
         j = num[k];
         /* obtain pointer to j-th column */
         if (!(1 <= j && j <= lp->n))
            xerror("glp_del_cols: num[%d] = %d; column number out of ra"
               "nge", k, j);
         col = lp->col[j];
         /* check that the column is not marked yet */
         if (col->j == 0)
            xerror("glp_del_cols: num[%d] = %d; duplicate column number"
               "s not allowed\n", k, j);
         /* erase symbolic name assigned to the column */
         glp_set_col_name(lp, j, NULL);
         xassert(col->node == NULL);
         /* erase corresponding column of the constraint matrix */
         glp_set_mat_col(lp, j, 0, NULL, NULL);
         xassert(col->ptr == NULL);
         /* mark the column to be deleted */
         col->j = 0;
         /* if it is basic, invalidate the basis factorization */
         if (col->stat == GLP_BS) lp->valid = 0;
      }
      /* delete all marked columns from the column list */
      n_new = 0;
      for (j = 1; j <= lp->n; j++)
      {  /* obtain pointer to j-th column */
         col = lp->col[j];
         /* check if the column is marked */
         if (col->j == 0)
         {  /* it is marked; delete it */
            dmp_free_atom(lp->pool, col, sizeof(GLPCOL));
         }
         else
         {  /* it is not marked; keep it */
            col->j = ++n_new;
            lp->col[col->j] = col;
         }
      }
      /* set new number of columns */
      lp->n = n_new;
      /* if the basis header is still valid, adjust it */
      if (lp->valid)
      {  int m = lp->m;
         int *head = lp->head;
         for (j = 1; j <= n_new; j++)
         {  k = lp->col[j]->bind;
            if (k != 0)
            {  xassert(1 <= k && k <= m);
               head[k] = m + j;
            }
         }
      }
      return;
}

static void delete_prob(glp_prob *lp);
void glp_erase_prob(glp_prob *lp)
{     glp_tree *tree = lp->tree;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_erase_prob: operation not allowed\n");
      delete_prob(lp);
      create_prob(lp);
      return;
}
void glp_copy_prob(glp_prob *dest, glp_prob *prob, int names)
{     glp_tree *tree = dest->tree;
      glp_bfcp bfcp;
      int i, j, len, *ind;
      double *val;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_copy_prob: operation not allowed\n");
      if (dest == prob)
         xerror("glp_copy_prob: copying problem object to itself not al"
            "lowed\n");
      if (!(names == GLP_ON || names == GLP_OFF))
         xerror("glp_copy_prob: names = %d; invalid parameter\n",
            names);
      glp_erase_prob(dest);
      if (names && prob->name != NULL)
         glp_set_prob_name(dest, prob->name);
      if (names && prob->obj != NULL)
         glp_set_obj_name(dest, prob->obj);
      dest->dir = prob->dir;
      dest->c0 = prob->c0;
      if (prob->m > 0)
         glp_add_rows(dest, prob->m);
      if (prob->n > 0)
         glp_add_cols(dest, prob->n);
      glp_get_bfcp(prob, &bfcp);
      glp_set_bfcp(dest, &bfcp);
      dest->pbs_stat = prob->pbs_stat;
      dest->dbs_stat = prob->dbs_stat;
      dest->obj_val = prob->obj_val;
      dest->some = prob->some;
      dest->ipt_stat = prob->ipt_stat;
      dest->ipt_obj = prob->ipt_obj;
      dest->mip_stat = prob->mip_stat;
      dest->mip_obj = prob->mip_obj;
      for (i = 1; i <= prob->m; i++)
      {  GLPROW *to = dest->row[i];
         GLPROW *from = prob->row[i];
         if (names && from->name != NULL)
            glp_set_row_name(dest, i, from->name);
         to->type = from->type;
         to->lb = from->lb;
         to->ub = from->ub;
         to->rii = from->rii;
         to->stat = from->stat;
         to->prim = from->prim;
         to->dual = from->dual;
         to->pval = from->pval;
         to->dval = from->dval;
         to->mipx = from->mipx;
      }
      ind = xcalloc(1+prob->m, sizeof(int));
      val = xcalloc(1+prob->m, sizeof(double));
      for (j = 1; j <= prob->n; j++)
      {  GLPCOL *to = dest->col[j];
         GLPCOL *from = prob->col[j];
         if (names && from->name != NULL)
            glp_set_col_name(dest, j, from->name);
         to->kind = from->kind;
         to->type = from->type;
         to->lb = from->lb;
         to->ub = from->ub;
         to->coef = from->coef;
         len = glp_get_mat_col(prob, j, ind, val);
         glp_set_mat_col(dest, j, len, ind, val);
         to->sjj = from->sjj;
         to->stat = from->stat;
         to->prim = from->prim;
         to->dual = from->dual;
         to->pval = from->pval;
         to->dval = from->dval;
         to->mipx = from->mipx;
      }
      xfree(ind);
      xfree(val);
      return;
}


static void delete_prob(glp_prob *lp)
{     lp->magic = 0x3F3F3F3F;
      dmp_delete_pool(lp->pool);
      xassert(lp->tree == NULL);
      xfree(lp->row);
      xfree(lp->col);
      if (lp->r_tree != NULL) avl_delete_tree(lp->r_tree);
      if (lp->c_tree != NULL) avl_delete_tree(lp->c_tree);
      xfree(lp->head);
      if (lp->bfd != NULL) bfd_delete_it(lp->bfd);
      return;
}

void glp_delete_prob(glp_prob *lp)
{     glp_tree *tree = lp->tree;
      if (tree != NULL && tree->reason != 0)
         xerror("glp_delete_prob: operation not allowed\n");
      delete_prob(lp);
      xfree(lp);
      return;
}



#define GLP_UNDOC 1
int _glp_analyze_row(glp_prob *P, int len, const int ind[],
      const double val[], int type, double rhs, double eps, int *_piv,
      double *_x, double *_dx, double *_y, double *_dy, double *_dz);
/* simulate one iteration of dual simplex method */

/***********************************************************************
*  NAME
*
*  glp_bf_exists - check if the basis factorization exists
*
*  SYNOPSIS
*
*  int glp_bf_exists(glp_prob *lp);
*
*  RETURNS
*
*  If the basis factorization for the current basis associated with
*  the specified problem object exists and therefore is available for
*  computations, the routine glp_bf_exists returns non-zero. Otherwise
*  the routine returns zero. */

int glp_bf_exists(glp_prob *lp)
{     int ret;
      ret = (lp->m == 0 || lp->valid);
      return ret;
}

/***********************************************************************
*  NAME
*
*  glp_factorize - compute the basis factorization
*
*  SYNOPSIS
*
*  int glp_factorize(glp_prob *lp);
*
*  DESCRIPTION
*
*  The routine glp_factorize computes the basis factorization for the
*  current basis associated with the specified problem object.
*
*  RETURNS
*
*  0  The basis factorization has been successfully computed.
*
*  GLP_EBADB
*     The basis matrix is invalid, i.e. the number of basic (auxiliary
*     and structural) variables differs from the number of rows in the
*     problem object.
*
*  GLP_ESING
*     The basis matrix is singular within the working precision.
*
*  GLP_ECOND
*     The basis matrix is ill-conditioned. */

static int b_col(void *info, int j, int ind[], double val[])
{     glp_prob *lp = info;
      int m = lp->m;
      GLPAIJ *aij;
      int k, len;
      xassert(1 <= j && j <= m);
      /* determine the ordinal number of basic auxiliary or structural
         variable x[k] corresponding to basic variable xB[j] */
      k = lp->head[j];
      /* build j-th column of the basic matrix, which is k-th column of
         the scaled augmented matrix (I | -R*A*S) */
      if (k <= m)
      {  /* x[k] is auxiliary variable */
         len = 1;
         ind[1] = k;
         val[1] = 1.0;
      }
      else
      {  /* x[k] is structural variable */
         len = 0;
         for (aij = lp->col[k-m]->ptr; aij != NULL; aij = aij->c_next)
         {  len++;
            ind[len] = aij->row->i;
            val[len] = - aij->row->rii * aij->val * aij->col->sjj;
         }
      }
      return len;
}

int glp_factorize(glp_prob *lp)
{     int m = lp->m;
      int n = lp->n;
      GLPROW **row = lp->row;
      GLPCOL **col = lp->col;
      int *head = lp->head;
      int j, k, stat, ret;
      /* invalidate the basis factorization */
      lp->valid = 0;
      /* build the basis header */
      j = 0;
      for (k = 1; k <= m+n; k++)
      {  if (k <= m)
         {  stat = row[k]->stat;
            row[k]->bind = 0;
         }
         else
         {  stat = col[k-m]->stat;
            col[k-m]->bind = 0;
         }
         if (stat == GLP_BS)
         {  j++;
            if (j > m)
            {  /* too many basic variables */
               ret = GLP_EBADB;
               goto fini;
            }
            head[j] = k;
            if (k <= m)
               row[k]->bind = j;
            else
               col[k-m]->bind = j;
         }
      }
      if (j < m)
      {  /* too few basic variables */
         ret = GLP_EBADB;
         goto fini;
      }
      /* try to factorize the basis matrix */
      if (m > 0)
      {  if (lp->bfd == NULL)
         {  lp->bfd = bfd_create_it();
#if 0 /* 08/III-2014 */
            copy_bfcp(lp);
#endif
         }
         switch (bfd_factorize(lp->bfd, m, /*lp->head,*/ b_col, lp))
         {  case 0:
               /* ok */
               break;
            case BFD_ESING:
               /* singular matrix */
               ret = GLP_ESING;
               goto fini;
            case BFD_ECOND:
               /* ill-conditioned matrix */
               ret = GLP_ECOND;
               goto fini;
            default:
               xassert(lp != lp);
         }
         lp->valid = 1;
      }
      /* factorization successful */
      ret = 0;
fini: /* bring the return code to the calling program */
      return ret;
}

/***********************************************************************
*  NAME
*
*  glp_bf_updated - check if the basis factorization has been updated
*
*  SYNOPSIS
*
*  int glp_bf_updated(glp_prob *lp);
*
*  RETURNS
*
*  If the basis factorization has been just computed from scratch, the
*  routine glp_bf_updated returns zero. Otherwise, if the factorization
*  has been updated one or more times, the routine returns non-zero. */

int glp_bf_updated(glp_prob *lp)
{     int cnt;
      if (!(lp->m == 0 || lp->valid))
         xerror("glp_bf_update: basis factorization does not exist\n");
#if 0 /* 15/XI-2009 */
      cnt = (lp->m == 0 ? 0 : lp->bfd->upd_cnt);
#else
      cnt = (lp->m == 0 ? 0 : bfd_get_count(lp->bfd));
#endif
      return cnt;
}

/***********************************************************************
*  NAME
*
*  glp_get_bfcp - retrieve basis factorization control parameters
*
*  SYNOPSIS
*
*  void glp_get_bfcp(glp_prob *lp, glp_bfcp *parm);
*
*  DESCRIPTION
*
*  The routine glp_get_bfcp retrieves control parameters, which are
*  used on computing and updating the basis factorization associated
*  with the specified problem object.
*
*  Current values of control parameters are stored by the routine in
*  a glp_bfcp structure, which the parameter parm points to. */

#if 1 /* 08/III-2014 */
void glp_get_bfcp(glp_prob *P, glp_bfcp *parm)
{     if (P->bfd == NULL)
         P->bfd = bfd_create_it();
      bfd_get_bfcp(P->bfd, parm);
      return;
}
#endif

/***********************************************************************
*  NAME
*
*  glp_set_bfcp - change basis factorization control parameters
*
*  SYNOPSIS
*
*  void glp_set_bfcp(glp_prob *lp, const glp_bfcp *parm);
*
*  DESCRIPTION
*
*  The routine glp_set_bfcp changes control parameters, which are used
*  by internal GLPK routines in computing and updating the basis
*  factorization associated with the specified problem object.
*
*  New values of the control parameters should be passed in a structure
*  glp_bfcp, which the parameter parm points to.
*
*  The parameter parm can be specified as NULL, in which case all
*  control parameters are reset to their default values. */

#if 1 /* 08/III-2014 */
void glp_set_bfcp(glp_prob *P, const glp_bfcp *parm)
{     if (P->bfd == NULL)
         P->bfd = bfd_create_it();
      if (parm != NULL)
      {  if (!(parm->type == GLP_BF_LUF + GLP_BF_FT ||
               parm->type == GLP_BF_LUF + GLP_BF_BG ||
               parm->type == GLP_BF_LUF + GLP_BF_GR ||
               parm->type == GLP_BF_BTF + GLP_BF_BG ||
               parm->type == GLP_BF_BTF + GLP_BF_GR))
            xerror("glp_set_bfcp: type = 0x%02X; invalid parameter\n",
               parm->type);
         if (!(0.0 < parm->piv_tol && parm->piv_tol < 1.0))
            xerror("glp_set_bfcp: piv_tol = %g; invalid parameter\n",
               parm->piv_tol);
         if (parm->piv_lim < 1)
            xerror("glp_set_bfcp: piv_lim = %d; invalid parameter\n",
               parm->piv_lim);
         if (!(parm->suhl == GLP_ON || parm->suhl == GLP_OFF))
            xerror("glp_set_bfcp: suhl = %d; invalid parameter\n",
               parm->suhl);
         if (!(0.0 <= parm->eps_tol && parm->eps_tol <= 1e-6))
            xerror("glp_set_bfcp: eps_tol = %g; invalid parameter\n",
               parm->eps_tol);
         if (!(1 <= parm->nfs_max && parm->nfs_max <= 32767))
            xerror("glp_set_bfcp: nfs_max = %d; invalid parameter\n",
               parm->nfs_max);
         if (!(1 <= parm->nrs_max && parm->nrs_max <= 32767))
            xerror("glp_set_bfcp: nrs_max = %d; invalid parameter\n",
               parm->nrs_max);
      }
      bfd_set_bfcp(P->bfd, parm);
      return;
}
#endif

/***********************************************************************
*  NAME
*
*  glp_get_bhead - retrieve the basis header information
*
*  SYNOPSIS
*
*  int glp_get_bhead(glp_prob *lp, int k);
*
*  DESCRIPTION
*
*  The routine glp_get_bhead returns the basis header information for
*  the current basis associated with the specified problem object.
*
*  RETURNS
*
*  If xB[k], 1 <= k <= m, is i-th auxiliary variable (1 <= i <= m), the
*  routine returns i. Otherwise, if xB[k] is j-th structural variable
*  (1 <= j <= n), the routine returns m+j. Here m is the number of rows
*  and n is the number of columns in the problem object. */

int glp_get_bhead(glp_prob *lp, int k)
{     if (!(lp->m == 0 || lp->valid))
         xerror("glp_get_bhead: basis factorization does not exist\n");
      if (!(1 <= k && k <= lp->m))
         xerror("glp_get_bhead: k = %d; index out of range\n", k);
      return lp->head[k];
}

/***********************************************************************
*  NAME
*
*  glp_get_row_bind - retrieve row index in the basis header
*
*  SYNOPSIS
*
*  int glp_get_row_bind(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_row_bind returns the index k of basic variable
*  xB[k], 1 <= k <= m, which is i-th auxiliary variable, 1 <= i <= m,
*  in the current basis associated with the specified problem object,
*  where m is the number of rows. However, if i-th auxiliary variable
*  is non-basic, the routine returns zero. */

int glp_get_row_bind(glp_prob *lp, int i)
{     if (!(lp->m == 0 || lp->valid))
         xerror("glp_get_row_bind: basis factorization does not exist\n"
            );
      if (!(1 <= i && i <= lp->m))
         xerror("glp_get_row_bind: i = %d; row number out of range\n",
            i);
      return lp->row[i]->bind;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_bind - retrieve column index in the basis header
*
*  SYNOPSIS
*
*  int glp_get_col_bind(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_col_bind returns the index k of basic variable
*  xB[k], 1 <= k <= m, which is j-th structural variable, 1 <= j <= n,
*  in the current basis associated with the specified problem object,
*  where m is the number of rows, n is the number of columns. However,
*  if j-th structural variable is non-basic, the routine returns zero.*/

int glp_get_col_bind(glp_prob *lp, int j)
{     if (!(lp->m == 0 || lp->valid))
         xerror("glp_get_col_bind: basis factorization does not exist\n"
            );
      if (!(1 <= j && j <= lp->n))
         xerror("glp_get_col_bind: j = %d; column number out of range\n"
            , j);
      return lp->col[j]->bind;
}

/***********************************************************************
*  NAME
*
*  glp_ftran - perform forward transformation (solve system B*x = b)
*
*  SYNOPSIS
*
*  void glp_ftran(glp_prob *lp, double x[]);
*
*  DESCRIPTION
*
*  The routine glp_ftran performs forward transformation, i.e. solves
*  the system B*x = b, where B is the basis matrix corresponding to the
*  current basis for the specified problem object, x is the vector of
*  unknowns to be computed, b is the vector of right-hand sides.
*
*  On entry elements of the vector b should be stored in dense format
*  in locations x[1], ..., x[m], where m is the number of rows. On exit
*  the routine stores elements of the vector x in the same locations.
*
*  SCALING/UNSCALING
*
*  Let A~ = (I | -A) is the augmented constraint matrix of the original
*  (unscaled) problem. In the scaled LP problem instead the matrix A the
*  scaled matrix A" = R*A*S is actually used, so
*
*     A~" = (I | A") = (I | R*A*S) = (R*I*inv(R) | R*A*S) =
*                                                                    (1)
*         = R*(I | A)*S~ = R*A~*S~,
*
*  is the scaled augmented constraint matrix, where R and S are diagonal
*  scaling matrices used to scale rows and columns of the matrix A, and
*
*     S~ = diag(inv(R) | S)                                          (2)
*
*  is an augmented diagonal scaling matrix.
*
*  By definition:
*
*     A~ = (B | N),                                                  (3)
*
*  where B is the basic matrix, which consists of basic columns of the
*  augmented constraint matrix A~, and N is a matrix, which consists of
*  non-basic columns of A~. From (1) it follows that:
*
*     A~" = (B" | N") = (R*B*SB | R*N*SN),                           (4)
*
*  where SB and SN are parts of the augmented scaling matrix S~, which
*  correspond to basic and non-basic variables, respectively. Therefore
*
*     B" = R*B*SB,                                                   (5)
*
*  which is the scaled basis matrix. */

void glp_ftran(glp_prob *lp, double x[])
{     int m = lp->m;
      GLPROW **row = lp->row;
      GLPCOL **col = lp->col;
      int i, k;
      /* B*x = b ===> (R*B*SB)*(inv(SB)*x) = R*b ===>
         B"*x" = b", where b" = R*b, x = SB*x" */
      if (!(m == 0 || lp->valid))
         xerror("glp_ftran: basis factorization does not exist\n");
      /* b" := R*b */
      for (i = 1; i <= m; i++)
         x[i] *= row[i]->rii;
      /* x" := inv(B")*b" */
      if (m > 0) bfd_ftran(lp->bfd, x);
      /* x := SB*x" */
      for (i = 1; i <= m; i++)
      {  k = lp->head[i];
         if (k <= m)
            x[i] /= row[k]->rii;
         else
            x[i] *= col[k-m]->sjj;
      }
      return;
}

/***********************************************************************
*  NAME
*
*  glp_btran - perform backward transformation (solve system B'*x = b)
*
*  SYNOPSIS
*
*  void glp_btran(glp_prob *lp, double x[]);
*
*  DESCRIPTION
*
*  The routine glp_btran performs backward transformation, i.e. solves
*  the system B'*x = b, where B' is a matrix transposed to the basis
*  matrix corresponding to the current basis for the specified problem
*  problem object, x is the vector of unknowns to be computed, b is the
*  vector of right-hand sides.
*
*  On entry elements of the vector b should be stored in dense format
*  in locations x[1], ..., x[m], where m is the number of rows. On exit
*  the routine stores elements of the vector x in the same locations.
*
*  SCALING/UNSCALING
*
*  See comments to the routine glp_ftran. */

void glp_btran(glp_prob *lp, double x[])
{     int m = lp->m;
      GLPROW **row = lp->row;
      GLPCOL **col = lp->col;
      int i, k;
      /* B'*x = b ===> (SB*B'*R)*(inv(R)*x) = SB*b ===>
         (B")'*x" = b", where b" = SB*b, x = R*x" */
      if (!(m == 0 || lp->valid))
         xerror("glp_btran: basis factorization does not exist\n");
      /* b" := SB*b */
      for (i = 1; i <= m; i++)
      {  k = lp->head[i];
         if (k <= m)
            x[i] /= row[k]->rii;
         else
            x[i] *= col[k-m]->sjj;
      }
      /* x" := inv[(B")']*b" */
      if (m > 0) bfd_btran(lp->bfd, x);
      /* x := R*x" */
      for (i = 1; i <= m; i++)
         x[i] *= row[i]->rii;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_warm_up - "warm up" LP basis
*
*  SYNOPSIS
*
*  int glp_warm_up(glp_prob *P);
*
*  DESCRIPTION
*
*  The routine glp_warm_up "warms up" the LP basis for the specified
*  problem object using current statuses assigned to rows and columns
*  (that is, to auxiliary and structural variables).
*
*  This operation includes computing factorization of the basis matrix
*  (if it does not exist), computing primal and dual components of basic
*  solution, and determining the solution status.
*
*  RETURNS
*
*  0  The operation has been successfully performed.
*
*  GLP_EBADB
*     The basis matrix is invalid, i.e. the number of basic (auxiliary
*     and structural) variables differs from the number of rows in the
*     problem object.
*
*  GLP_ESING
*     The basis matrix is singular within the working precision.
*
*  GLP_ECOND
*     The basis matrix is ill-conditioned. */

int glp_warm_up(glp_prob *P)
{     GLPROW *row;
      GLPCOL *col;
      GLPAIJ *aij;
      int i, j, type, stat, ret;
      double eps, temp, *work;
      /* invalidate basic solution */
      P->pbs_stat = P->dbs_stat = GLP_UNDEF;
      P->obj_val = 0.0;
      P->some = 0;
      for (i = 1; i <= P->m; i++)
      {  row = P->row[i];
         row->prim = row->dual = 0.0;
      }
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         col->prim = col->dual = 0.0;
      }
      /* compute the basis factorization, if necessary */
      if (!glp_bf_exists(P))
      {  ret = glp_factorize(P);
         if (ret != 0) goto done;
      }
      /* allocate working array */
      work = xcalloc(1+P->m, sizeof(double));
      /* determine and store values of non-basic variables, compute
         vector (- N * xN) */
      for (i = 1; i <= P->m; i++)
         work[i] = 0.0;
      for (i = 1; i <= P->m; i++)
      {  row = P->row[i];
         if (row->stat == GLP_BS)
            continue;
         else if (row->stat == GLP_NL)
            row->prim = row->lb;
         else if (row->stat == GLP_NU)
            row->prim = row->ub;
         else if (row->stat == GLP_NF)
            row->prim = 0.0;
         else if (row->stat == GLP_NS)
            row->prim = row->lb;
         else
            xassert(row != row);
         /* N[j] is i-th column of matrix (I|-A) */
         work[i] -= row->prim;
      }
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         if (col->stat == GLP_BS)
            continue;
         else if (col->stat == GLP_NL)
            col->prim = col->lb;
         else if (col->stat == GLP_NU)
            col->prim = col->ub;
         else if (col->stat == GLP_NF)
            col->prim = 0.0;
         else if (col->stat == GLP_NS)
            col->prim = col->lb;
         else
            xassert(col != col);
         /* N[j] is (m+j)-th column of matrix (I|-A) */
         if (col->prim != 0.0)
         {  for (aij = col->ptr; aij != NULL; aij = aij->c_next)
               work[aij->row->i] += aij->val * col->prim;
         }
      }
      /* compute vector of basic variables xB = - inv(B) * N * xN */
      glp_ftran(P, work);
      /* store values of basic variables, check primal feasibility */
      P->pbs_stat = GLP_FEAS;
      for (i = 1; i <= P->m; i++)
      {  row = P->row[i];
         if (row->stat != GLP_BS)
            continue;
         row->prim = work[row->bind];
         type = row->type;
         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)
         {  eps = 1e-6 + 1e-9 * fabs(row->lb);
            if (row->prim < row->lb - eps)
               P->pbs_stat = GLP_INFEAS;
         }
         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)
         {  eps = 1e-6 + 1e-9 * fabs(row->ub);
            if (row->prim > row->ub + eps)
               P->pbs_stat = GLP_INFEAS;
         }
      }
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         if (col->stat != GLP_BS)
            continue;
         col->prim = work[col->bind];
         type = col->type;
         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)
         {  eps = 1e-6 + 1e-9 * fabs(col->lb);
            if (col->prim < col->lb - eps)
               P->pbs_stat = GLP_INFEAS;
         }
         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)
         {  eps = 1e-6 + 1e-9 * fabs(col->ub);
            if (col->prim > col->ub + eps)
               P->pbs_stat = GLP_INFEAS;
         }
      }
      /* compute value of the objective function */
      P->obj_val = P->c0;
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         P->obj_val += col->coef * col->prim;
      }
      /* build vector cB of objective coefficients at basic variables */
      for (i = 1; i <= P->m; i++)
         work[i] = 0.0;
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         if (col->stat == GLP_BS)
            work[col->bind] = col->coef;
      }
      /* compute vector of simplex multipliers pi = inv(B') * cB */
      glp_btran(P, work);
      /* compute and store reduced costs of non-basic variables d[j] =
         c[j] - N'[j] * pi, check dual feasibility */
      P->dbs_stat = GLP_FEAS;
      for (i = 1; i <= P->m; i++)
      {  row = P->row[i];
         if (row->stat == GLP_BS)
         {  row->dual = 0.0;
            continue;
         }
         /* N[j] is i-th column of matrix (I|-A) */
         row->dual = - work[i];
#if 0 /* 07/III-2013 */
         type = row->type;
         temp = (P->dir == GLP_MIN ? + row->dual : - row->dual);
         if ((type == GLP_FR || type == GLP_LO) && temp < -1e-5 ||
             (type == GLP_FR || type == GLP_UP) && temp > +1e-5)
            P->dbs_stat = GLP_INFEAS;
#else
         stat = row->stat;
         temp = (P->dir == GLP_MIN ? + row->dual : - row->dual);
         if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||
             (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)
            P->dbs_stat = GLP_INFEAS;
#endif
      }
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         if (col->stat == GLP_BS)
         {  col->dual = 0.0;
            continue;
         }
         /* N[j] is (m+j)-th column of matrix (I|-A) */
         col->dual = col->coef;
         for (aij = col->ptr; aij != NULL; aij = aij->c_next)
            col->dual += aij->val * work[aij->row->i];
#if 0 /* 07/III-2013 */
         type = col->type;
         temp = (P->dir == GLP_MIN ? + col->dual : - col->dual);
         if ((type == GLP_FR || type == GLP_LO) && temp < -1e-5 ||
             (type == GLP_FR || type == GLP_UP) && temp > +1e-5)
            P->dbs_stat = GLP_INFEAS;
#else
         stat = col->stat;
         temp = (P->dir == GLP_MIN ? + col->dual : - col->dual);
         if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||
             (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)
            P->dbs_stat = GLP_INFEAS;
#endif
      }
      /* free working array */
      xfree(work);
      ret = 0;
done: return ret;
}

/***********************************************************************
*  NAME
*
*  glp_eval_tab_row - compute row of the simplex tableau
*
*  SYNOPSIS
*
*  int glp_eval_tab_row(glp_prob *lp, int k, int ind[], double val[]);
*
*  DESCRIPTION
*
*  The routine glp_eval_tab_row computes a row of the current simplex
*  tableau for the basic variable, which is specified by the number k:
*  if 1 <= k <= m, x[k] is k-th auxiliary variable; if m+1 <= k <= m+n,
*  x[k] is (k-m)-th structural variable, where m is number of rows, and
*  n is number of columns. The current basis must be available.
*
*  The routine stores column indices and numerical values of non-zero
*  elements of the computed row using sparse format to the locations
*  ind[1], ..., ind[len] and val[1], ..., val[len], respectively, where
*  0 <= len <= n is number of non-zeros returned on exit.
*
*  Element indices stored in the array ind have the same sense as the
*  index k, i.e. indices 1 to m denote auxiliary variables and indices
*  m+1 to m+n denote structural ones (all these variables are obviously
*  non-basic by definition).
*
*  The computed row shows how the specified basic variable x[k] = xB[i]
*  depends on non-basic variables:
*
*     xB[i] = alfa[i,1]*xN[1] + alfa[i,2]*xN[2] + ... + alfa[i,n]*xN[n],
*
*  where alfa[i,j] are elements of the simplex table row, xN[j] are
*  non-basic (auxiliary and structural) variables.
*
*  RETURNS
*
*  The routine returns number of non-zero elements in the simplex table
*  row stored in the arrays ind and val.
*
*  BACKGROUND
*
*  The system of equality constraints of the LP problem is:
*
*     xR = A * xS,                                                   (1)
*
*  where xR is the vector of auxliary variables, xS is the vector of
*  structural variables, A is the matrix of constraint coefficients.
*
*  The system (1) can be written in homogenous form as follows:
*
*     A~ * x = 0,                                                    (2)
*
*  where A~ = (I | -A) is the augmented constraint matrix (has m rows
*  and m+n columns), x = (xR | xS) is the vector of all (auxiliary and
*  structural) variables.
*
*  By definition for the current basis we have:
*
*     A~ = (B | N),                                                  (3)
*
*  where B is the basis matrix. Thus, the system (2) can be written as:
*
*     B * xB + N * xN = 0.                                           (4)
*
*  From (4) it follows that:
*
*     xB = A^ * xN,                                                  (5)
*
*  where the matrix
*
*     A^ = - inv(B) * N                                              (6)
*
*  is called the simplex table.
*
*  It is understood that i-th row of the simplex table is:
*
*     e * A^ = - e * inv(B) * N,                                     (7)
*
*  where e is a unity vector with e[i] = 1.
*
*  To compute i-th row of the simplex table the routine first computes
*  i-th row of the inverse:
*
*     rho = inv(B') * e,                                             (8)
*
*  where B' is a matrix transposed to B, and then computes elements of
*  i-th row of the simplex table as scalar products:
*
*     alfa[i,j] = - rho * N[j]   for all j,                          (9)
*
*  where N[j] is a column of the augmented constraint matrix A~, which
*  corresponds to some non-basic auxiliary or structural variable. */

int glp_eval_tab_row(glp_prob *lp, int k, int ind[], double val[])
{     int m = lp->m;
      int n = lp->n;
      int i, t, len, lll, *iii;
      double alfa, *rho, *vvv;
      if (!(m == 0 || lp->valid))
         xerror("glp_eval_tab_row: basis factorization does not exist\n"
            );
      if (!(1 <= k && k <= m+n))
         xerror("glp_eval_tab_row: k = %d; variable number out of range"
            , k);
      /* determine xB[i] which corresponds to x[k] */
      if (k <= m)
         i = glp_get_row_bind(lp, k);
      else
         i = glp_get_col_bind(lp, k-m);
      if (i == 0)
         xerror("glp_eval_tab_row: k = %d; variable must be basic", k);
      xassert(1 <= i && i <= m);
      /* allocate working arrays */
      rho = xcalloc(1+m, sizeof(double));
      iii = xcalloc(1+m, sizeof(int));
      vvv = xcalloc(1+m, sizeof(double));
      /* compute i-th row of the inverse; see (8) */
      for (t = 1; t <= m; t++) rho[t] = 0.0;
      rho[i] = 1.0;
      glp_btran(lp, rho);
      /* compute i-th row of the simplex table */
      len = 0;
      for (k = 1; k <= m+n; k++)
      {  if (k <= m)
         {  /* x[k] is auxiliary variable, so N[k] is a unity column */
            if (glp_get_row_stat(lp, k) == GLP_BS) continue;
            /* compute alfa[i,j]; see (9) */
            alfa = - rho[k];
         }
         else
         {  /* x[k] is structural variable, so N[k] is a column of the
               original constraint matrix A with negative sign */
            if (glp_get_col_stat(lp, k-m) == GLP_BS) continue;
            /* compute alfa[i,j]; see (9) */
            lll = glp_get_mat_col(lp, k-m, iii, vvv);
            alfa = 0.0;
            for (t = 1; t <= lll; t++) alfa += rho[iii[t]] * vvv[t];
         }
         /* store alfa[i,j] */
         if (alfa != 0.0) len++, ind[len] = k, val[len] = alfa;
      }
      xassert(len <= n);
      /* free working arrays */
      xfree(rho);
      xfree(iii);
      xfree(vvv);
      /* return to the calling program */
      return len;
}

/***********************************************************************
*  NAME
*
*  glp_eval_tab_col - compute column of the simplex tableau
*
*  SYNOPSIS
*
*  int glp_eval_tab_col(glp_prob *lp, int k, int ind[], double val[]);
*
*  DESCRIPTION
*
*  The routine glp_eval_tab_col computes a column of the current simplex
*  table for the non-basic variable, which is specified by the number k:
*  if 1 <= k <= m, x[k] is k-th auxiliary variable; if m+1 <= k <= m+n,
*  x[k] is (k-m)-th structural variable, where m is number of rows, and
*  n is number of columns. The current basis must be available.
*
*  The routine stores row indices and numerical values of non-zero
*  elements of the computed column using sparse format to the locations
*  ind[1], ..., ind[len] and val[1], ..., val[len] respectively, where
*  0 <= len <= m is number of non-zeros returned on exit.
*
*  Element indices stored in the array ind have the same sense as the
*  index k, i.e. indices 1 to m denote auxiliary variables and indices
*  m+1 to m+n denote structural ones (all these variables are obviously
*  basic by the definition).
*
*  The computed column shows how basic variables depend on the specified
*  non-basic variable x[k] = xN[j]:
*
*     xB[1] = ... + alfa[1,j]*xN[j] + ...
*     xB[2] = ... + alfa[2,j]*xN[j] + ...
*              . . . . . .
*     xB[m] = ... + alfa[m,j]*xN[j] + ...
*
*  where alfa[i,j] are elements of the simplex table column, xB[i] are
*  basic (auxiliary and structural) variables.
*
*  RETURNS
*
*  The routine returns number of non-zero elements in the simplex table
*  column stored in the arrays ind and val.
*
*  BACKGROUND
*
*  As it was explained in comments to the routine glp_eval_tab_row (see
*  above) the simplex table is the following matrix:
*
*     A^ = - inv(B) * N.                                             (1)
*
*  Therefore j-th column of the simplex table is:
*
*     A^ * e = - inv(B) * N * e = - inv(B) * N[j],                   (2)
*
*  where e is a unity vector with e[j] = 1, B is the basis matrix, N[j]
*  is a column of the augmented constraint matrix A~, which corresponds
*  to the given non-basic auxiliary or structural variable. */

int glp_eval_tab_col(glp_prob *lp, int k, int ind[], double val[])
{     int m = lp->m;
      int n = lp->n;
      int t, len, stat;
      double *col;
      if (!(m == 0 || lp->valid))
         xerror("glp_eval_tab_col: basis factorization does not exist\n"
            );
      if (!(1 <= k && k <= m+n))
         xerror("glp_eval_tab_col: k = %d; variable number out of range"
            , k);
      if (k <= m)
         stat = glp_get_row_stat(lp, k);
      else
         stat = glp_get_col_stat(lp, k-m);
      if (stat == GLP_BS)
         xerror("glp_eval_tab_col: k = %d; variable must be non-basic",
            k);
      /* obtain column N[k] with negative sign */
      col = xcalloc(1+m, sizeof(double));
      for (t = 1; t <= m; t++) col[t] = 0.0;
      if (k <= m)
      {  /* x[k] is auxiliary variable, so N[k] is a unity column */
         col[k] = -1.0;
      }
      else
      {  /* x[k] is structural variable, so N[k] is a column of the
            original constraint matrix A with negative sign */
         len = glp_get_mat_col(lp, k-m, ind, val);
         for (t = 1; t <= len; t++) col[ind[t]] = val[t];
      }
      /* compute column of the simplex table, which corresponds to the
         specified non-basic variable x[k] */
      glp_ftran(lp, col);
      len = 0;
      for (t = 1; t <= m; t++)
      {  if (col[t] != 0.0)
         {  len++;
            ind[len] = glp_get_bhead(lp, t);
            val[len] = col[t];
         }
      }
      xfree(col);
      /* return to the calling program */
      return len;
}

/***********************************************************************
*  NAME
*
*  glp_transform_row - transform explicitly specified row
*
*  SYNOPSIS
*
*  int glp_transform_row(glp_prob *P, int len, int ind[], double val[]);
*
*  DESCRIPTION
*
*  The routine glp_transform_row performs the same operation as the
*  routine glp_eval_tab_row with exception that the row to be
*  transformed is specified explicitly as a sparse vector.
*
*  The explicitly specified row may be thought as a linear form:
*
*     x = a[1]*x[m+1] + a[2]*x[m+2] + ... + a[n]*x[m+n],             (1)
*
*  where x is an auxiliary variable for this row, a[j] are coefficients
*  of the linear form, x[m+j] are structural variables.
*
*  On entry column indices and numerical values of non-zero elements of
*  the row should be stored in locations ind[1], ..., ind[len] and
*  val[1], ..., val[len], where len is the number of non-zero elements.
*
*  This routine uses the system of equality constraints and the current
*  basis in order to express the auxiliary variable x in (1) through the
*  current non-basic variables (as if the transformed row were added to
*  the problem object and its auxiliary variable were basic), i.e. the
*  resultant row has the form:
*
*     x = alfa[1]*xN[1] + alfa[2]*xN[2] + ... + alfa[n]*xN[n],       (2)
*
*  where xN[j] are non-basic (auxiliary or structural) variables, n is
*  the number of columns in the LP problem object.
*
*  On exit the routine stores indices and numerical values of non-zero
*  elements of the resultant row (2) in locations ind[1], ..., ind[len']
*  and val[1], ..., val[len'], where 0 <= len' <= n is the number of
*  non-zero elements in the resultant row returned by the routine. Note
*  that indices (numbers) of non-basic variables stored in the array ind
*  correspond to original ordinal numbers of variables: indices 1 to m
*  mean auxiliary variables and indices m+1 to m+n mean structural ones.
*
*  RETURNS
*
*  The routine returns len', which is the number of non-zero elements in
*  the resultant row stored in the arrays ind and val.
*
*  BACKGROUND
*
*  The explicitly specified row (1) is transformed in the same way as it
*  were the objective function row.
*
*  From (1) it follows that:
*
*     x = aB * xB + aN * xN,                                         (3)
*
*  where xB is the vector of basic variables, xN is the vector of
*  non-basic variables.
*
*  The simplex table, which corresponds to the current basis, is:
*
*     xB = [-inv(B) * N] * xN.                                       (4)
*
*  Therefore substituting xB from (4) to (3) we have:
*
*     x = aB * [-inv(B) * N] * xN + aN * xN =
*                                                                    (5)
*       = rho * (-N) * xN + aN * xN = alfa * xN,
*
*  where:
*
*     rho = inv(B') * aB,                                            (6)
*
*  and
*
*     alfa = aN + rho * (-N)                                         (7)
*
*  is the resultant row computed by the routine. */

int glp_transform_row(glp_prob *P, int len, int ind[], double val[])
{     int i, j, k, m, n, t, lll, *iii;
      double alfa, *a, *aB, *rho, *vvv;
      if (!glp_bf_exists(P))
         xerror("glp_transform_row: basis factorization does not exist "
            "\n");
      m = glp_get_num_rows(P);
      n = glp_get_num_cols(P);
      /* unpack the row to be transformed to the array a */
      a = xcalloc(1+n, sizeof(double));
      for (j = 1; j <= n; j++) a[j] = 0.0;
      if (!(0 <= len && len <= n))
         xerror("glp_transform_row: len = %d; invalid row length\n",
            len);
      for (t = 1; t <= len; t++)
      {  j = ind[t];
         if (!(1 <= j && j <= n))
            xerror("glp_transform_row: ind[%d] = %d; column index out o"
               "f range\n", t, j);
         if (val[t] == 0.0)
            xerror("glp_transform_row: val[%d] = 0; zero coefficient no"
               "t allowed\n", t);
         if (a[j] != 0.0)
            xerror("glp_transform_row: ind[%d] = %d; duplicate column i"
               "ndices not allowed\n", t, j);
         a[j] = val[t];
      }
      /* construct the vector aB */
      aB = xcalloc(1+m, sizeof(double));
      for (i = 1; i <= m; i++)
      {  k = glp_get_bhead(P, i);
         /* xB[i] is k-th original variable */
         xassert(1 <= k && k <= m+n);
         aB[i] = (k <= m ? 0.0 : a[k-m]);
      }
      /* solve the system B'*rho = aB to compute the vector rho */
      rho = aB, glp_btran(P, rho);
      /* compute coefficients at non-basic auxiliary variables */
      len = 0;
      for (i = 1; i <= m; i++)
      {  if (glp_get_row_stat(P, i) != GLP_BS)
         {  alfa = - rho[i];
            if (alfa != 0.0)
            {  len++;
               ind[len] = i;
               val[len] = alfa;
            }
         }
      }
      /* compute coefficients at non-basic structural variables */
      iii = xcalloc(1+m, sizeof(int));
      vvv = xcalloc(1+m, sizeof(double));
      for (j = 1; j <= n; j++)
      {  if (glp_get_col_stat(P, j) != GLP_BS)
         {  alfa = a[j];
            lll = glp_get_mat_col(P, j, iii, vvv);
            for (t = 1; t <= lll; t++) alfa += vvv[t] * rho[iii[t]];
            if (alfa != 0.0)
            {  len++;
               ind[len] = m+j;
               val[len] = alfa;
            }
         }
      }
      xassert(len <= n);
      xfree(iii);
      xfree(vvv);
      xfree(aB);
      xfree(a);
      return len;
}

/***********************************************************************
*  NAME
*
*  glp_transform_col - transform explicitly specified column
*
*  SYNOPSIS
*
*  int glp_transform_col(glp_prob *P, int len, int ind[], double val[]);
*
*  DESCRIPTION
*
*  The routine glp_transform_col performs the same operation as the
*  routine glp_eval_tab_col with exception that the column to be
*  transformed is specified explicitly as a sparse vector.
*
*  The explicitly specified column may be thought as if it were added
*  to the original system of equality constraints:
*
*     x[1] = a[1,1]*x[m+1] + ... + a[1,n]*x[m+n] + a[1]*x
*     x[2] = a[2,1]*x[m+1] + ... + a[2,n]*x[m+n] + a[2]*x            (1)
*        .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
*     x[m] = a[m,1]*x[m+1] + ... + a[m,n]*x[m+n] + a[m]*x
*
*  where x[i] are auxiliary variables, x[m+j] are structural variables,
*  x is a structural variable for the explicitly specified column, a[i]
*  are constraint coefficients for x.
*
*  On entry row indices and numerical values of non-zero elements of
*  the column should be stored in locations ind[1], ..., ind[len] and
*  val[1], ..., val[len], where len is the number of non-zero elements.
*
*  This routine uses the system of equality constraints and the current
*  basis in order to express the current basic variables through the
*  structural variable x in (1) (as if the transformed column were added
*  to the problem object and the variable x were non-basic), i.e. the
*  resultant column has the form:
*
*     xB[1] = ... + alfa[1]*x
*     xB[2] = ... + alfa[2]*x                                        (2)
*        .  .  .  .  .  .
*     xB[m] = ... + alfa[m]*x
*
*  where xB are basic (auxiliary and structural) variables, m is the
*  number of rows in the problem object.
*
*  On exit the routine stores indices and numerical values of non-zero
*  elements of the resultant column (2) in locations ind[1], ...,
*  ind[len'] and val[1], ..., val[len'], where 0 <= len' <= m is the
*  number of non-zero element in the resultant column returned by the
*  routine. Note that indices (numbers) of basic variables stored in
*  the array ind correspond to original ordinal numbers of variables:
*  indices 1 to m mean auxiliary variables and indices m+1 to m+n mean
*  structural ones.
*
*  RETURNS
*
*  The routine returns len', which is the number of non-zero elements
*  in the resultant column stored in the arrays ind and val.
*
*  BACKGROUND
*
*  The explicitly specified column (1) is transformed in the same way
*  as any other column of the constraint matrix using the formula:
*
*     alfa = inv(B) * a,                                             (3)
*
*  where alfa is the resultant column computed by the routine. */

int glp_transform_col(glp_prob *P, int len, int ind[], double val[])
{     int i, m, t;
      double *a, *alfa;
      if (!glp_bf_exists(P))
         xerror("glp_transform_col: basis factorization does not exist "
            "\n");
      m = glp_get_num_rows(P);
      /* unpack the column to be transformed to the array a */
      a = xcalloc(1+m, sizeof(double));
      for (i = 1; i <= m; i++) a[i] = 0.0;
      if (!(0 <= len && len <= m))
         xerror("glp_transform_col: len = %d; invalid column length\n",
            len);
      for (t = 1; t <= len; t++)
      {  i = ind[t];
         if (!(1 <= i && i <= m))
            xerror("glp_transform_col: ind[%d] = %d; row index out of r"
               "ange\n", t, i);
         if (val[t] == 0.0)
            xerror("glp_transform_col: val[%d] = 0; zero coefficient no"
               "t allowed\n", t);
         if (a[i] != 0.0)
            xerror("glp_transform_col: ind[%d] = %d; duplicate row indi"
               "ces not allowed\n", t, i);
         a[i] = val[t];
      }
      /* solve the system B*a = alfa to compute the vector alfa */
      alfa = a, glp_ftran(P, alfa);
      /* store resultant coefficients */
      len = 0;
      for (i = 1; i <= m; i++)
      {  if (alfa[i] != 0.0)
         {  len++;
            ind[len] = glp_get_bhead(P, i);
            val[len] = alfa[i];
         }
      }
      xfree(a);
      return len;
}

/***********************************************************************
*  NAME
*
*  glp_prim_rtest - perform primal ratio test
*
*  SYNOPSIS
*
*  int glp_prim_rtest(glp_prob *P, int len, const int ind[],
*     const double val[], int dir, double eps);
*
*  DESCRIPTION
*
*  The routine glp_prim_rtest performs the primal ratio test using an
*  explicitly specified column of the simplex table.
*
*  The current basic solution associated with the LP problem object
*  must be primal feasible.
*
*  The explicitly specified column of the simplex table shows how the
*  basic variables xB depend on some non-basic variable x (which is not
*  necessarily presented in the problem object):
*
*     xB[1] = ... + alfa[1] * x + ...
*     xB[2] = ... + alfa[2] * x + ...                                (*)
*         .  .  .  .  .  .  .  .
*     xB[m] = ... + alfa[m] * x + ...
*
*  The column (*) is specifed on entry to the routine using the sparse
*  format. Ordinal numbers of basic variables xB[i] should be placed in
*  locations ind[1], ..., ind[len], where ordinal number 1 to m denote
*  auxiliary variables, and ordinal numbers m+1 to m+n denote structural
*  variables. The corresponding non-zero coefficients alfa[i] should be
*  placed in locations val[1], ..., val[len]. The arrays ind and val are
*  not changed on exit.
*
*  The parameter dir specifies direction in which the variable x changes
*  on entering the basis: +1 means increasing, -1 means decreasing.
*
*  The parameter eps is an absolute tolerance (small positive number)
*  used by the routine to skip small alfa[j] of the row (*).
*
*  The routine determines which basic variable (among specified in
*  ind[1], ..., ind[len]) should leave the basis in order to keep primal
*  feasibility.
*
*  RETURNS
*
*  The routine glp_prim_rtest returns the index piv in the arrays ind
*  and val corresponding to the pivot element chosen, 1 <= piv <= len.
*  If the adjacent basic solution is primal unbounded and therefore the
*  choice cannot be made, the routine returns zero.
*
*  COMMENTS
*
*  If the non-basic variable x is presented in the LP problem object,
*  the column (*) can be computed with the routine glp_eval_tab_col;
*  otherwise it can be computed with the routine glp_transform_col. */

int glp_prim_rtest(glp_prob *P, int len, const int ind[],
      const double val[], int dir, double eps)
{     int k, m, n, piv, t, type, stat;
      double alfa, big, beta, lb, ub, temp, teta;
      if (glp_get_prim_stat(P) != GLP_FEAS)
         xerror("glp_prim_rtest: basic solution is not primal feasible "
            "\n");
      if (!(dir == +1 || dir == -1))
         xerror("glp_prim_rtest: dir = %d; invalid parameter\n", dir);
      if (!(0.0 < eps && eps < 1.0))
         xerror("glp_prim_rtest: eps = %g; invalid parameter\n", eps);
      m = glp_get_num_rows(P);
      n = glp_get_num_cols(P);
      /* initial settings */
      piv = 0, teta = DBL_MAX, big = 0.0;
      /* walk through the entries of the specified column */
      for (t = 1; t <= len; t++)
      {  /* get the ordinal number of basic variable */
         k = ind[t];
         if (!(1 <= k && k <= m+n))
            xerror("glp_prim_rtest: ind[%d] = %d; variable number out o"
               "f range\n", t, k);
         /* determine type, bounds, status and primal value of basic
            variable xB[i] = x[k] in the current basic solution */
         if (k <= m)
         {  type = glp_get_row_type(P, k);
            lb = glp_get_row_lb(P, k);
            ub = glp_get_row_ub(P, k);
            stat = glp_get_row_stat(P, k);
            beta = glp_get_row_prim(P, k);
         }
         else
         {  type = glp_get_col_type(P, k-m);
            lb = glp_get_col_lb(P, k-m);
            ub = glp_get_col_ub(P, k-m);
            stat = glp_get_col_stat(P, k-m);
            beta = glp_get_col_prim(P, k-m);
         }
         if (stat != GLP_BS)
            xerror("glp_prim_rtest: ind[%d] = %d; non-basic variable no"
               "t allowed\n", t, k);
         /* determine influence coefficient at basic variable xB[i]
            in the explicitly specified column and turn to the case of
            increasing the variable x in order to simplify the program
            logic */
         alfa = (dir > 0 ? + val[t] : - val[t]);
         /* analyze main cases */
         if (type == GLP_FR)
         {  /* xB[i] is free variable */
            continue;
         }
         else if (type == GLP_LO)
lo:      {  /* xB[i] has an lower bound */
            if (alfa > - eps) continue;
            temp = (lb - beta) / alfa;
         }
         else if (type == GLP_UP)
up:      {  /* xB[i] has an upper bound */
            if (alfa < + eps) continue;
            temp = (ub - beta) / alfa;
         }
         else if (type == GLP_DB)
         {  /* xB[i] has both lower and upper bounds */
            if (alfa < 0.0) goto lo; else goto up;
         }
         else if (type == GLP_FX)
         {  /* xB[i] is fixed variable */
            if (- eps < alfa && alfa < + eps) continue;
            temp = 0.0;
         }
         else
            xassert(type != type);
         /* if the value of the variable xB[i] violates its lower or
            upper bound (slightly, because the current basis is assumed
            to be primal feasible), temp is negative; we can think this
            happens due to round-off errors and the value is exactly on
            the bound; this allows replacing temp by zero */
         if (temp < 0.0) temp = 0.0;
         /* apply the minimal ratio test */
         if (teta > temp || teta == temp && big < fabs(alfa))
            piv = t, teta = temp, big = fabs(alfa);
      }
      /* return index of the pivot element chosen */
      return piv;
}

/***********************************************************************
*  NAME
*
*  glp_dual_rtest - perform dual ratio test
*
*  SYNOPSIS
*
*  int glp_dual_rtest(glp_prob *P, int len, const int ind[],
*     const double val[], int dir, double eps);
*
*  DESCRIPTION
*
*  The routine glp_dual_rtest performs the dual ratio test using an
*  explicitly specified row of the simplex table.
*
*  The current basic solution associated with the LP problem object
*  must be dual feasible.
*
*  The explicitly specified row of the simplex table is a linear form
*  that shows how some basic variable x (which is not necessarily
*  presented in the problem object) depends on non-basic variables xN:
*
*     x = alfa[1] * xN[1] + alfa[2] * xN[2] + ... + alfa[n] * xN[n]. (*)
*
*  The row (*) is specified on entry to the routine using the sparse
*  format. Ordinal numbers of non-basic variables xN[j] should be placed
*  in locations ind[1], ..., ind[len], where ordinal numbers 1 to m
*  denote auxiliary variables, and ordinal numbers m+1 to m+n denote
*  structural variables. The corresponding non-zero coefficients alfa[j]
*  should be placed in locations val[1], ..., val[len]. The arrays ind
*  and val are not changed on exit.
*
*  The parameter dir specifies direction in which the variable x changes
*  on leaving the basis: +1 means that x goes to its lower bound, and -1
*  means that x goes to its upper bound.
*
*  The parameter eps is an absolute tolerance (small positive number)
*  used by the routine to skip small alfa[j] of the row (*).
*
*  The routine determines which non-basic variable (among specified in
*  ind[1], ..., ind[len]) should enter the basis in order to keep dual
*  feasibility.
*
*  RETURNS
*
*  The routine glp_dual_rtest returns the index piv in the arrays ind
*  and val corresponding to the pivot element chosen, 1 <= piv <= len.
*  If the adjacent basic solution is dual unbounded and therefore the
*  choice cannot be made, the routine returns zero.
*
*  COMMENTS
*
*  If the basic variable x is presented in the LP problem object, the
*  row (*) can be computed with the routine glp_eval_tab_row; otherwise
*  it can be computed with the routine glp_transform_row. */

int glp_dual_rtest(glp_prob *P, int len, const int ind[],
      const double val[], int dir, double eps)
{     int k, m, n, piv, t, stat;
      double alfa, big, cost, obj, temp, teta;
      if (glp_get_dual_stat(P) != GLP_FEAS)
         xerror("glp_dual_rtest: basic solution is not dual feasible\n")
            ;
      if (!(dir == +1 || dir == -1))
         xerror("glp_dual_rtest: dir = %d; invalid parameter\n", dir);
      if (!(0.0 < eps && eps < 1.0))
         xerror("glp_dual_rtest: eps = %g; invalid parameter\n", eps);
      m = glp_get_num_rows(P);
      n = glp_get_num_cols(P);
      /* take into account optimization direction */
      obj = (glp_get_obj_dir(P) == GLP_MIN ? +1.0 : -1.0);
      /* initial settings */
      piv = 0, teta = DBL_MAX, big = 0.0;
      /* walk through the entries of the specified row */
      for (t = 1; t <= len; t++)
      {  /* get ordinal number of non-basic variable */
         k = ind[t];
         if (!(1 <= k && k <= m+n))
            xerror("glp_dual_rtest: ind[%d] = %d; variable number out o"
               "f range\n", t, k);
         /* determine status and reduced cost of non-basic variable
            x[k] = xN[j] in the current basic solution */
         if (k <= m)
         {  stat = glp_get_row_stat(P, k);
            cost = glp_get_row_dual(P, k);
         }
         else
         {  stat = glp_get_col_stat(P, k-m);
            cost = glp_get_col_dual(P, k-m);
         }
         if (stat == GLP_BS)
            xerror("glp_dual_rtest: ind[%d] = %d; basic variable not al"
               "lowed\n", t, k);
         /* determine influence coefficient at non-basic variable xN[j]
            in the explicitly specified row and turn to the case of
            increasing the variable x in order to simplify the program
            logic */
         alfa = (dir > 0 ? + val[t] : - val[t]);
         /* analyze main cases */
         if (stat == GLP_NL)
         {  /* xN[j] is on its lower bound */
            if (alfa < + eps) continue;
            temp = (obj * cost) / alfa;
         }
         else if (stat == GLP_NU)
         {  /* xN[j] is on its upper bound */
            if (alfa > - eps) continue;
            temp = (obj * cost) / alfa;
         }
         else if (stat == GLP_NF)
         {  /* xN[j] is non-basic free variable */
            if (- eps < alfa && alfa < + eps) continue;
            temp = 0.0;
         }
         else if (stat == GLP_NS)
         {  /* xN[j] is non-basic fixed variable */
            continue;
         }
         else
            xassert(stat != stat);
         /* if the reduced cost of the variable xN[j] violates its zero
            bound (slightly, because the current basis is assumed to be
            dual feasible), temp is negative; we can think this happens
            due to round-off errors and the reduced cost is exact zero;
            this allows replacing temp by zero */
         if (temp < 0.0) temp = 0.0;
         /* apply the minimal ratio test */
         if (teta > temp || teta == temp && big < fabs(alfa))
            piv = t, teta = temp, big = fabs(alfa);
      }
      /* return index of the pivot element chosen */
      return piv;
}

/***********************************************************************
*  NAME
*
*  glp_analyze_row - simulate one iteration of dual simplex method
*
*  SYNOPSIS
*
*  int glp_analyze_row(glp_prob *P, int len, const int ind[],
*     const double val[], int type, double rhs, double eps, int *piv,
*     double *x, double *dx, double *y, double *dy, double *dz);
*
*  DESCRIPTION
*
*  Let the current basis be optimal or dual feasible, and there be
*  specified a row (constraint), which is violated by the current basic
*  solution. The routine glp_analyze_row simulates one iteration of the
*  dual simplex method to determine some information on the adjacent
*  basis (see below), where the specified row becomes active constraint
*  (i.e. its auxiliary variable becomes non-basic).
*
*  The current basic solution associated with the problem object passed
*  to the routine must be dual feasible, and its primal components must
*  be defined.
*
*  The row to be analyzed must be previously transformed either with
*  the routine glp_eval_tab_row (if the row is in the problem object)
*  or with the routine glp_transform_row (if the row is external, i.e.
*  not in the problem object). This is needed to express the row only
*  through (auxiliary and structural) variables, which are non-basic in
*  the current basis:
*
*     y = alfa[1] * xN[1] + alfa[2] * xN[2] + ... + alfa[n] * xN[n],
*
*  where y is an auxiliary variable of the row, alfa[j] is an influence
*  coefficient, xN[j] is a non-basic variable.
*
*  The row is passed to the routine in sparse format. Ordinal numbers
*  of non-basic variables are stored in locations ind[1], ..., ind[len],
*  where numbers 1 to m denote auxiliary variables while numbers m+1 to
*  m+n denote structural variables. Corresponding non-zero coefficients
*  alfa[j] are stored in locations val[1], ..., val[len]. The arrays
*  ind and val are ot changed on exit.
*
*  The parameters type and rhs specify the row type and its right-hand
*  side as follows:
*
*     type = GLP_LO: y = sum alfa[j] * xN[j] >= rhs
*
*     type = GLP_UP: y = sum alfa[j] * xN[j] <= rhs
*
*  The parameter eps is an absolute tolerance (small positive number)
*  used by the routine to skip small coefficients alfa[j] on performing
*  the dual ratio test.
*
*  If the operation was successful, the routine stores the following
*  information to corresponding location (if some parameter is NULL,
*  its value is not stored):
*
*  piv   index in the array ind and val, 1 <= piv <= len, determining
*        the non-basic variable, which would enter the adjacent basis;
*
*  x     value of the non-basic variable in the current basis;
*
*  dx    difference between values of the non-basic variable in the
*        adjacent and current bases, dx = x.new - x.old;
*
*  y     value of the row (i.e. of its auxiliary variable) in the
*        current basis;
*
*  dy    difference between values of the row in the adjacent and
*        current bases, dy = y.new - y.old;
*
*  dz    difference between values of the objective function in the
*        adjacent and current bases, dz = z.new - z.old. Note that in
*        case of minimization dz >= 0, and in case of maximization
*        dz <= 0, i.e. in the adjacent basis the objective function
*        always gets worse (degrades). */

int _glp_analyze_row(glp_prob *P, int len, const int ind[],
      const double val[], int type, double rhs, double eps, int *_piv,
      double *_x, double *_dx, double *_y, double *_dy, double *_dz)
{     int t, k, dir, piv, ret = 0;
      double x, dx, y, dy, dz;
      if (P->pbs_stat == GLP_UNDEF)
         xerror("glp_analyze_row: primal basic solution components are "
            "undefined\n");
      if (P->dbs_stat != GLP_FEAS)
         xerror("glp_analyze_row: basic solution is not dual feasible\n"
            );
      /* compute the row value y = sum alfa[j] * xN[j] in the current
         basis */
      if (!(0 <= len && len <= P->n))
         xerror("glp_analyze_row: len = %d; invalid row length\n", len);
      y = 0.0;
      for (t = 1; t <= len; t++)
      {  /* determine value of x[k] = xN[j] in the current basis */
         k = ind[t];
         if (!(1 <= k && k <= P->m+P->n))
            xerror("glp_analyze_row: ind[%d] = %d; row/column index out"
               " of range\n", t, k);
         if (k <= P->m)
         {  /* x[k] is auxiliary variable */
            if (P->row[k]->stat == GLP_BS)
               xerror("glp_analyze_row: ind[%d] = %d; basic auxiliary v"
                  "ariable is not allowed\n", t, k);
            x = P->row[k]->prim;
         }
         else
         {  /* x[k] is structural variable */
            if (P->col[k-P->m]->stat == GLP_BS)
               xerror("glp_analyze_row: ind[%d] = %d; basic structural "
                  "variable is not allowed\n", t, k);
            x = P->col[k-P->m]->prim;
         }
         y += val[t] * x;
      }
      /* check if the row is primal infeasible in the current basis,
         i.e. the constraint is violated at the current point */
      if (type == GLP_LO)
      {  if (y >= rhs)
         {  /* the constraint is not violated */
            ret = 1;
            goto done;
         }
         /* in the adjacent basis y goes to its lower bound */
         dir = +1;
      }
      else if (type == GLP_UP)
      {  if (y <= rhs)
         {  /* the constraint is not violated */
            ret = 1;
            goto done;
         }
         /* in the adjacent basis y goes to its upper bound */
         dir = -1;
      }
      else
         xerror("glp_analyze_row: type = %d; invalid parameter\n",
            type);
      /* compute dy = y.new - y.old */
      dy = rhs - y;
      /* perform dual ratio test to determine which non-basic variable
         should enter the adjacent basis to keep it dual feasible */
      piv = glp_dual_rtest(P, len, ind, val, dir, eps);
      if (piv == 0)
      {  /* no dual feasible adjacent basis exists */
         ret = 2;
         goto done;
      }
      /* non-basic variable x[k] = xN[j] should enter the basis */
      k = ind[piv];
      xassert(1 <= k && k <= P->m+P->n);
      /* determine its value in the current basis */
      if (k <= P->m)
         x = P->row[k]->prim;
      else
         x = P->col[k-P->m]->prim;
      /* compute dx = x.new - x.old = dy / alfa[j] */
      xassert(val[piv] != 0.0);
      dx = dy / val[piv];
      /* compute dz = z.new - z.old = d[j] * dx, where d[j] is reduced
         cost of xN[j] in the current basis */
      if (k <= P->m)
         dz = P->row[k]->dual * dx;
      else
         dz = P->col[k-P->m]->dual * dx;
      /* store the analysis results */
      if (_piv != NULL) *_piv = piv;
      if (_x   != NULL) *_x   = x;
      if (_dx  != NULL) *_dx  = dx;
      if (_y   != NULL) *_y   = y;
      if (_dy  != NULL) *_dy  = dy;
      if (_dz  != NULL) *_dz  = dz;
done: return ret;
}

#if 0
int main(void)
{     /* example program for the routine glp_analyze_row */
      glp_prob *P;
      glp_smcp parm;
      int i, k, len, piv, ret, ind[1+100];
      double rhs, x, dx, y, dy, dz, val[1+100];
      P = glp_create_prob();
      /* read plan.mps (see glpk/examples) */
      ret = glp_read_mps(P, GLP_MPS_DECK, NULL, "plan.mps");
      glp_assert(ret == 0);
      /* and solve it to optimality */
      ret = glp_simplex(P, NULL);
      glp_assert(ret == 0);
      glp_assert(glp_get_status(P) == GLP_OPT);
      /* the optimal objective value is 296.217 */
      /* we would like to know what happens if we would add a new row
         (constraint) to plan.mps:
         .01 * bin1 + .01 * bin2 + .02 * bin4 + .02 * bin5 <= 12 */
      /* first, we specify this new row */
      glp_create_index(P);
      len = 0;
      ind[++len] = glp_find_col(P, "BIN1"), val[len] = .01;
      ind[++len] = glp_find_col(P, "BIN2"), val[len] = .01;
      ind[++len] = glp_find_col(P, "BIN4"), val[len] = .02;
      ind[++len] = glp_find_col(P, "BIN5"), val[len] = .02;
      rhs = 12;
      /* then we can compute value of the row (i.e. of its auxiliary
         variable) in the current basis to see if the constraint is
         violated */
      y = 0.0;
      for (k = 1; k <= len; k++)
         y += val[k] * glp_get_col_prim(P, ind[k]);
      glp_printf("y = %g\n", y);
      /* this prints y = 15.1372, so the constraint is violated, since
         we require that y <= rhs = 12 */
      /* now we transform the row to express it only through non-basic
         (auxiliary and artificial) variables */
      len = glp_transform_row(P, len, ind, val);
      /* finally, we simulate one step of the dual simplex method to
         obtain necessary information for the adjacent basis */
      ret = _glp_analyze_row(P, len, ind, val, GLP_UP, rhs, 1e-9, &piv,
         &x, &dx, &y, &dy, &dz);
      glp_assert(ret == 0);
      glp_printf("k = %d, x = %g; dx = %g; y = %g; dy = %g; dz = %g\n",
         ind[piv], x, dx, y, dy, dz);
      /* this prints dz = 5.64418 and means that in the adjacent basis
         the objective function would be 296.217 + 5.64418 = 301.861 */
      /* now we actually include the row into the problem object; note
         that the arrays ind and val are clobbered, so we need to build
         them once again */
      len = 0;
      ind[++len] = glp_find_col(P, "BIN1"), val[len] = .01;
      ind[++len] = glp_find_col(P, "BIN2"), val[len] = .01;
      ind[++len] = glp_find_col(P, "BIN4"), val[len] = .02;
      ind[++len] = glp_find_col(P, "BIN5"), val[len] = .02;
      rhs = 12;
      i = glp_add_rows(P, 1);
      glp_set_row_bnds(P, i, GLP_UP, 0, rhs);
      glp_set_mat_row(P, i, len, ind, val);
      /* and perform one dual simplex iteration */
      glp_init_smcp(&parm);
      parm.meth = GLP_DUAL;
      parm.it_lim = 1;
      glp_simplex(P, &parm);
      /* the current objective value is 301.861 */
      return 0;
}
#endif

/***********************************************************************
*  NAME
*
*  glp_analyze_bound - analyze active bound of non-basic variable
*
*  SYNOPSIS
*
*  void glp_analyze_bound(glp_prob *P, int k, double *limit1, int *var1,
*     double *limit2, int *var2);
*
*  DESCRIPTION
*
*  The routine glp_analyze_bound analyzes the effect of varying the
*  active bound of specified non-basic variable.
*
*  The non-basic variable is specified by the parameter k, where
*  1 <= k <= m means auxiliary variable of corresponding row while
*  m+1 <= k <= m+n means structural variable (column).
*
*  Note that the current basic solution must be optimal, and the basis
*  factorization must exist.
*
*  Results of the analysis have the following meaning.
*
*  value1 is the minimal value of the active bound, at which the basis
*  still remains primal feasible and thus optimal. -DBL_MAX means that
*  the active bound has no lower limit.
*
*  var1 is the ordinal number of an auxiliary (1 to m) or structural
*  (m+1 to n) basic variable, which reaches its bound first and thereby
*  limits further decreasing the active bound being analyzed.
*  if value1 = -DBL_MAX, var1 is set to 0.
*
*  value2 is the maximal value of the active bound, at which the basis
*  still remains primal feasible and thus optimal. +DBL_MAX means that
*  the active bound has no upper limit.
*
*  var2 is the ordinal number of an auxiliary (1 to m) or structural
*  (m+1 to n) basic variable, which reaches its bound first and thereby
*  limits further increasing the active bound being analyzed.
*  if value2 = +DBL_MAX, var2 is set to 0. */

void glp_analyze_bound(glp_prob *P, int k, double *value1, int *var1,
      double *value2, int *var2)
{     GLPROW *row;
      GLPCOL *col;
      int m, n, stat, kase, p, len, piv, *ind;
      double x, new_x, ll, uu, xx, delta, *val;
      /* sanity checks */
      if (P == NULL || P->magic != GLP_PROB_MAGIC)
         xerror("glp_analyze_bound: P = %p; invalid problem object\n",
            P);
      m = P->m, n = P->n;
      if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))
         xerror("glp_analyze_bound: optimal basic solution required\n");
      if (!(m == 0 || P->valid))
         xerror("glp_analyze_bound: basis factorization required\n");
      if (!(1 <= k && k <= m+n))
         xerror("glp_analyze_bound: k = %d; variable number out of rang"
            "e\n", k);
      /* retrieve information about the specified non-basic variable
         x[k] whose active bound is to be analyzed */
      if (k <= m)
      {  row = P->row[k];
         stat = row->stat;
         x = row->prim;
      }
      else
      {  col = P->col[k-m];
         stat = col->stat;
         x = col->prim;
      }
      if (stat == GLP_BS)
         xerror("glp_analyze_bound: k = %d; basic variable not allowed "
            "\n", k);
      /* allocate working arrays */
      ind = xcalloc(1+m, sizeof(int));
      val = xcalloc(1+m, sizeof(double));
      /* compute column of the simplex table corresponding to the
         non-basic variable x[k] */
      len = glp_eval_tab_col(P, k, ind, val);
      xassert(0 <= len && len <= m);
      /* perform analysis */
      for (kase = -1; kase <= +1; kase += 2)
      {  /* kase < 0 means active bound of x[k] is decreasing;
            kase > 0 means active bound of x[k] is increasing */
         /* use the primal ratio test to determine some basic variable
            x[p] which reaches its bound first */
         piv = glp_prim_rtest(P, len, ind, val, kase, 1e-9);
         if (piv == 0)
         {  /* nothing limits changing the active bound of x[k] */
            p = 0;
            new_x = (kase < 0 ? -DBL_MAX : +DBL_MAX);
            goto store;
         }
         /* basic variable x[p] limits changing the active bound of
            x[k]; determine its value in the current basis */
         xassert(1 <= piv && piv <= len);
         p = ind[piv];
         if (p <= m)
         {  row = P->row[p];
            ll = glp_get_row_lb(P, row->i);
            uu = glp_get_row_ub(P, row->i);
            stat = row->stat;
            xx = row->prim;
         }
         else
         {  col = P->col[p-m];
            ll = glp_get_col_lb(P, col->j);
            uu = glp_get_col_ub(P, col->j);
            stat = col->stat;
            xx = col->prim;
         }
         xassert(stat == GLP_BS);
         /* determine delta x[p] = bound of x[p] - value of x[p] */
         if (kase < 0 && val[piv] > 0.0 ||
             kase > 0 && val[piv] < 0.0)
         {  /* delta x[p] < 0, so x[p] goes toward its lower bound */
            xassert(ll != -DBL_MAX);
            delta = ll - xx;
         }
         else
         {  /* delta x[p] > 0, so x[p] goes toward its upper bound */
            xassert(uu != +DBL_MAX);
            delta = uu - xx;
         }
         /* delta x[p] = alfa[p,k] * delta x[k], so new x[k] = x[k] +
            delta x[k] = x[k] + delta x[p] / alfa[p,k] is the value of
            x[k] in the adjacent basis */
         xassert(val[piv] != 0.0);
         new_x = x + delta / val[piv];
store:   /* store analysis results */
         if (kase < 0)
         {  if (value1 != NULL) *value1 = new_x;
            if (var1 != NULL) *var1 = p;
         }
         else
         {  if (value2 != NULL) *value2 = new_x;
            if (var2 != NULL) *var2 = p;
         }
      }
      /* free working arrays */
      xfree(ind);
      xfree(val);
      return;
}

/***********************************************************************
*  NAME
*
*  glp_analyze_coef - analyze objective coefficient at basic variable
*
*  SYNOPSIS
*
*  void glp_analyze_coef(glp_prob *P, int k, double *coef1, int *var1,
*     double *value1, double *coef2, int *var2, double *value2);
*
*  DESCRIPTION
*
*  The routine glp_analyze_coef analyzes the effect of varying the
*  objective coefficient at specified basic variable.
*
*  The basic variable is specified by the parameter k, where
*  1 <= k <= m means auxiliary variable of corresponding row while
*  m+1 <= k <= m+n means structural variable (column).
*
*  Note that the current basic solution must be optimal, and the basis
*  factorization must exist.
*
*  Results of the analysis have the following meaning.
*
*  coef1 is the minimal value of the objective coefficient, at which
*  the basis still remains dual feasible and thus optimal. -DBL_MAX
*  means that the objective coefficient has no lower limit.
*
*  var1 is the ordinal number of an auxiliary (1 to m) or structural
*  (m+1 to n) non-basic variable, whose reduced cost reaches its zero
*  bound first and thereby limits further decreasing the objective
*  coefficient being analyzed. If coef1 = -DBL_MAX, var1 is set to 0.
*
*  value1 is value of the basic variable being analyzed in an adjacent
*  basis, which is defined as follows. Let the objective coefficient
*  reaches its minimal value (coef1) and continues decreasing. Then the
*  reduced cost of the limiting non-basic variable (var1) becomes dual
*  infeasible and the current basis becomes non-optimal that forces the
*  limiting non-basic variable to enter the basis replacing there some
*  basic variable that leaves the basis to keep primal feasibility.
*  Should note that on determining the adjacent basis current bounds
*  of the basic variable being analyzed are ignored as if it were free
*  (unbounded) variable, so it cannot leave the basis. It may happen
*  that no dual feasible adjacent basis exists, in which case value1 is
*  set to -DBL_MAX or +DBL_MAX.
*
*  coef2 is the maximal value of the objective coefficient, at which
*  the basis still remains dual feasible and thus optimal. +DBL_MAX
*  means that the objective coefficient has no upper limit.
*
*  var2 is the ordinal number of an auxiliary (1 to m) or structural
*  (m+1 to n) non-basic variable, whose reduced cost reaches its zero
*  bound first and thereby limits further increasing the objective
*  coefficient being analyzed. If coef2 = +DBL_MAX, var2 is set to 0.
*
*  value2 is value of the basic variable being analyzed in an adjacent
*  basis, which is defined exactly in the same way as value1 above with
*  exception that now the objective coefficient is increasing. */

void glp_analyze_coef(glp_prob *P, int k, double *coef1, int *var1,
      double *value1, double *coef2, int *var2, double *value2)
{     GLPROW *row; GLPCOL *col;
      int m, n, type, stat, kase, p, q, dir, clen, cpiv, rlen, rpiv,
         *cind, *rind;
      double lb, ub, coef, x, lim_coef, new_x, d, delta, ll, uu, xx,
         *rval, *cval;
      /* sanity checks */
      if (P == NULL || P->magic != GLP_PROB_MAGIC)
         xerror("glp_analyze_coef: P = %p; invalid problem object\n",
            P);
      m = P->m, n = P->n;
      if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))
         xerror("glp_analyze_coef: optimal basic solution required\n");
      if (!(m == 0 || P->valid))
         xerror("glp_analyze_coef: basis factorization required\n");
      if (!(1 <= k && k <= m+n))
         xerror("glp_analyze_coef: k = %d; variable number out of range"
            "\n", k);
      /* retrieve information about the specified basic variable x[k]
         whose objective coefficient c[k] is to be analyzed */
      if (k <= m)
      {  row = P->row[k];
         type = row->type;
         lb = row->lb;
         ub = row->ub;
         coef = 0.0;
         stat = row->stat;
         x = row->prim;
      }
      else
      {  col = P->col[k-m];
         type = col->type;
         lb = col->lb;
         ub = col->ub;
         coef = col->coef;
         stat = col->stat;
         x = col->prim;
      }
      if (stat != GLP_BS)
         xerror("glp_analyze_coef: k = %d; non-basic variable not allow"
            "ed\n", k);
      /* allocate working arrays */
      cind = xcalloc(1+m, sizeof(int));
      cval = xcalloc(1+m, sizeof(double));
      rind = xcalloc(1+n, sizeof(int));
      rval = xcalloc(1+n, sizeof(double));
      /* compute row of the simplex table corresponding to the basic
         variable x[k] */
      rlen = glp_eval_tab_row(P, k, rind, rval);
      xassert(0 <= rlen && rlen <= n);
      /* perform analysis */
      for (kase = -1; kase <= +1; kase += 2)
      {  /* kase < 0 means objective coefficient c[k] is decreasing;
            kase > 0 means objective coefficient c[k] is increasing */
         /* note that decreasing c[k] is equivalent to increasing dual
            variable lambda[k] and vice versa; we need to correctly set
            the dir flag as required by the routine glp_dual_rtest */
         if (P->dir == GLP_MIN)
            dir = - kase;
         else if (P->dir == GLP_MAX)
            dir = + kase;
         else
            xassert(P != P);
         /* use the dual ratio test to determine non-basic variable
            x[q] whose reduced cost d[q] reaches zero bound first */
         rpiv = glp_dual_rtest(P, rlen, rind, rval, dir, 1e-9);
         if (rpiv == 0)
         {  /* nothing limits changing c[k] */
            lim_coef = (kase < 0 ? -DBL_MAX : +DBL_MAX);
            q = 0;
            /* x[k] keeps its current value */
            new_x = x;
            goto store;
         }
         /* non-basic variable x[q] limits changing coefficient c[k];
            determine its status and reduced cost d[k] in the current
            basis */
         xassert(1 <= rpiv && rpiv <= rlen);
         q = rind[rpiv];
         xassert(1 <= q && q <= m+n);
         if (q <= m)
         {  row = P->row[q];
            stat = row->stat;
            d = row->dual;
         }
         else
         {  col = P->col[q-m];
            stat = col->stat;
            d = col->dual;
         }
         /* note that delta d[q] = new d[q] - d[q] = - d[q], because
            new d[q] = 0; delta d[q] = alfa[k,q] * delta c[k], so
            delta c[k] = delta d[q] / alfa[k,q] = - d[q] / alfa[k,q] */
         xassert(rval[rpiv] != 0.0);
         delta = - d / rval[rpiv];
         /* compute new c[k] = c[k] + delta c[k], which is the limiting
            value of the objective coefficient c[k] */
         lim_coef = coef + delta;
         /* let c[k] continue decreasing/increasing that makes d[q]
            dual infeasible and forces x[q] to enter the basis;
            to perform the primal ratio test we need to know in which
            direction x[q] changes on entering the basis; we determine
            that analyzing the sign of delta d[q] (see above), since
            d[q] may be close to zero having wrong sign */
         /* let, for simplicity, the problem is minimization */
         if (kase < 0 && rval[rpiv] > 0.0 ||
             kase > 0 && rval[rpiv] < 0.0)
         {  /* delta d[q] < 0, so d[q] being non-negative will become
               negative, so x[q] will increase */
            dir = +1;
         }
         else
         {  /* delta d[q] > 0, so d[q] being non-positive will become
               positive, so x[q] will decrease */
            dir = -1;
         }
         /* if the problem is maximization, correct the direction */
         if (P->dir == GLP_MAX) dir = - dir;
         /* check that we didn't make a silly mistake */
         if (dir > 0)
            xassert(stat == GLP_NL || stat == GLP_NF);
         else
            xassert(stat == GLP_NU || stat == GLP_NF);
         /* compute column of the simplex table corresponding to the
            non-basic variable x[q] */
         clen = glp_eval_tab_col(P, q, cind, cval);
         /* make x[k] temporarily free (unbounded) */
         if (k <= m)
         {  row = P->row[k];
            row->type = GLP_FR;
            row->lb = row->ub = 0.0;
         }
         else
         {  col = P->col[k-m];
            col->type = GLP_FR;
            col->lb = col->ub = 0.0;
         }
         /* use the primal ratio test to determine some basic variable
            which leaves the basis */
         cpiv = glp_prim_rtest(P, clen, cind, cval, dir, 1e-9);
         /* restore original bounds of the basic variable x[k] */
         if (k <= m)
         {  row = P->row[k];
            row->type = type;
            row->lb = lb, row->ub = ub;
         }
         else
         {  col = P->col[k-m];
            col->type = type;
            col->lb = lb, col->ub = ub;
         }
         if (cpiv == 0)
         {  /* non-basic variable x[q] can change unlimitedly */
            if (dir < 0 && rval[rpiv] > 0.0 ||
                dir > 0 && rval[rpiv] < 0.0)
            {  /* delta x[k] = alfa[k,q] * delta x[q] < 0 */
               new_x = -DBL_MAX;
            }
            else
            {  /* delta x[k] = alfa[k,q] * delta x[q] > 0 */
               new_x = +DBL_MAX;
            }
            goto store;
         }
         /* some basic variable x[p] limits changing non-basic variable
            x[q] in the adjacent basis */
         xassert(1 <= cpiv && cpiv <= clen);
         p = cind[cpiv];
         xassert(1 <= p && p <= m+n);
         xassert(p != k);
         if (p <= m)
         {  row = P->row[p];
            xassert(row->stat == GLP_BS);
            ll = glp_get_row_lb(P, row->i);
            uu = glp_get_row_ub(P, row->i);
            xx = row->prim;
         }
         else
         {  col = P->col[p-m];
            xassert(col->stat == GLP_BS);
            ll = glp_get_col_lb(P, col->j);
            uu = glp_get_col_ub(P, col->j);
            xx = col->prim;
         }
         /* determine delta x[p] = new x[p] - x[p] */
         if (dir < 0 && cval[cpiv] > 0.0 ||
             dir > 0 && cval[cpiv] < 0.0)
         {  /* delta x[p] < 0, so x[p] goes toward its lower bound */
            xassert(ll != -DBL_MAX);
            delta = ll - xx;
         }
         else
         {  /* delta x[p] > 0, so x[p] goes toward its upper bound */
            xassert(uu != +DBL_MAX);
            delta = uu - xx;
         }
         /* compute new x[k] = x[k] + alfa[k,q] * delta x[q], where
            delta x[q] = delta x[p] / alfa[p,q] */
         xassert(cval[cpiv] != 0.0);
         new_x = x + (rval[rpiv] / cval[cpiv]) * delta;
store:   /* store analysis results */
         if (kase < 0)
         {  if (coef1 != NULL) *coef1 = lim_coef;
            if (var1 != NULL) *var1 = q;
            if (value1 != NULL) *value1 = new_x;
         }
         else
         {  if (coef2 != NULL) *coef2 = lim_coef;
            if (var2 != NULL) *var2 = q;
            if (value2 != NULL) *value2 = new_x;
         }
      }
      /* free working arrays */
      xfree(cind);
      xfree(cval);
      xfree(rind);
      xfree(rval);
      return;
}


/***********************************************************************
*  NAME
*
*  glp_get_prob_name - retrieve problem name
*
*  SYNOPSIS
*
*  const char *glp_get_prob_name(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_prob_name returns a pointer to an internal
*  buffer, which contains symbolic name of the problem. However, if the
*  problem has no assigned name, the routine returns NULL. */

const char *glp_get_prob_name(glp_prob *lp)
{     char *name;
      name = lp->name;
      return name;
}

/***********************************************************************
*  NAME
*
*  glp_get_obj_name - retrieve objective function name
*
*  SYNOPSIS
*
*  const char *glp_get_obj_name(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_obj_name returns a pointer to an internal
*  buffer, which contains a symbolic name of the objective function.
*  However, if the objective function has no assigned name, the routine
*  returns NULL. */

const char *glp_get_obj_name(glp_prob *lp)
{     char *name;
      name = lp->obj;
      return name;
}

/***********************************************************************
*  NAME
*
*  glp_get_obj_dir - retrieve optimization direction flag
*
*  SYNOPSIS
*
*  int glp_get_obj_dir(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_obj_dir returns the optimization direction flag
*  (i.e. "sense" of the objective function):
*
*  GLP_MIN - minimization;
*  GLP_MAX - maximization. */

int glp_get_obj_dir(glp_prob *lp)
{     int dir = lp->dir;
      return dir;
}

/***********************************************************************
*  NAME
*
*  glp_get_num_rows - retrieve number of rows
*
*  SYNOPSIS
*
*  int glp_get_num_rows(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_num_rows returns the current number of rows in
*  the specified problem object. */

int glp_get_num_rows(glp_prob *lp)
{     int m = lp->m;
      return m;
}

/***********************************************************************
*  NAME
*
*  glp_get_num_cols - retrieve number of columns
*
*  SYNOPSIS
*
*  int glp_get_num_cols(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_num_cols returns the current number of columns
*  in the specified problem object. */

int glp_get_num_cols(glp_prob *lp)
{     int n = lp->n;
      return n;
}

/***********************************************************************
*  NAME
*
*  glp_get_row_name - retrieve row name
*
*  SYNOPSIS
*
*  const char *glp_get_row_name(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_row_name returns a pointer to an internal
*  buffer, which contains symbolic name of i-th row. However, if i-th
*  row has no assigned name, the routine returns NULL. */

const char *glp_get_row_name(glp_prob *lp, int i)
{     char *name;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_get_row_name: i = %d; row number out of range\n",
            i);
      name = lp->row[i]->name;
      return name;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_name - retrieve column name
*
*  SYNOPSIS
*
*  const char *glp_get_col_name(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_col_name returns a pointer to an internal
*  buffer, which contains symbolic name of j-th column. However, if j-th
*  column has no assigned name, the routine returns NULL. */

const char *glp_get_col_name(glp_prob *lp, int j)
{     char *name;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_get_col_name: j = %d; column number out of range\n"
            , j);
      name = lp->col[j]->name;
      return name;
}

/***********************************************************************
*  NAME
*
*  glp_get_row_type - retrieve row type
*
*  SYNOPSIS
*
*  int glp_get_row_type(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_row_type returns the type of i-th row, i.e. the
*  type of corresponding auxiliary variable, as follows:
*
*  GLP_FR - free (unbounded) variable;
*  GLP_LO - variable with lower bound;
*  GLP_UP - variable with upper bound;
*  GLP_DB - double-bounded variable;
*  GLP_FX - fixed variable. */

int glp_get_row_type(glp_prob *lp, int i)
{     if (!(1 <= i && i <= lp->m))
         xerror("glp_get_row_type: i = %d; row number out of range\n",
            i);
      return lp->row[i]->type;
}

/***********************************************************************
*  NAME
*
*  glp_get_row_lb - retrieve row lower bound
*
*  SYNOPSIS
*
*  double glp_get_row_lb(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_row_lb returns the lower bound of i-th row, i.e.
*  the lower bound of corresponding auxiliary variable. However, if the
*  row has no lower bound, the routine returns -DBL_MAX. */

double glp_get_row_lb(glp_prob *lp, int i)
{     double lb;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_get_row_lb: i = %d; row number out of range\n", i);
      switch (lp->row[i]->type)
      {  case GLP_FR:
         case GLP_UP:
            lb = -DBL_MAX; break;
         case GLP_LO:
         case GLP_DB:
         case GLP_FX:
            lb = lp->row[i]->lb; break;
         default:
            xassert(lp != lp);
      }
      return lb;
}

/***********************************************************************
*  NAME
*
*  glp_get_row_ub - retrieve row upper bound
*
*  SYNOPSIS
*
*  double glp_get_row_ub(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_row_ub returns the upper bound of i-th row, i.e.
*  the upper bound of corresponding auxiliary variable. However, if the
*  row has no upper bound, the routine returns +DBL_MAX. */

double glp_get_row_ub(glp_prob *lp, int i)
{     double ub;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_get_row_ub: i = %d; row number out of range\n", i);
      switch (lp->row[i]->type)
      {  case GLP_FR:
         case GLP_LO:
            ub = +DBL_MAX; break;
         case GLP_UP:
         case GLP_DB:
         case GLP_FX:
            ub = lp->row[i]->ub; break;
         default:
            xassert(lp != lp);
      }
      return ub;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_type - retrieve column type
*
*  SYNOPSIS
*
*  int glp_get_col_type(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_col_type returns the type of j-th column, i.e.
*  the type of corresponding structural variable, as follows:
*
*  GLP_FR - free (unbounded) variable;
*  GLP_LO - variable with lower bound;
*  GLP_UP - variable with upper bound;
*  GLP_DB - double-bounded variable;
*  GLP_FX - fixed variable. */

int glp_get_col_type(glp_prob *lp, int j)
{     if (!(1 <= j && j <= lp->n))
         xerror("glp_get_col_type: j = %d; column number out of range\n"
            , j);
      return lp->col[j]->type;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_lb - retrieve column lower bound
*
*  SYNOPSIS
*
*  double glp_get_col_lb(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_col_lb returns the lower bound of j-th column,
*  i.e. the lower bound of corresponding structural variable. However,
*  if the column has no lower bound, the routine returns -DBL_MAX. */

double glp_get_col_lb(glp_prob *lp, int j)
{     double lb;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_get_col_lb: j = %d; column number out of range\n",
            j);
      switch (lp->col[j]->type)
      {  case GLP_FR:
         case GLP_UP:
            lb = -DBL_MAX; break;
         case GLP_LO:
         case GLP_DB:
         case GLP_FX:
            lb = lp->col[j]->lb; break;
         default:
            xassert(lp != lp);
      }
      return lb;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_ub - retrieve column upper bound
*
*  SYNOPSIS
*
*  double glp_get_col_ub(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_col_ub returns the upper bound of j-th column,
*  i.e. the upper bound of corresponding structural variable. However,
*  if the column has no upper bound, the routine returns +DBL_MAX. */

double glp_get_col_ub(glp_prob *lp, int j)
{     double ub;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_get_col_ub: j = %d; column number out of range\n",
            j);
      switch (lp->col[j]->type)
      {  case GLP_FR:
         case GLP_LO:
            ub = +DBL_MAX; break;
         case GLP_UP:
         case GLP_DB:
         case GLP_FX:
            ub = lp->col[j]->ub; break;
         default:
            xassert(lp != lp);
      }
      return ub;
}

/***********************************************************************
*  NAME
*
*  glp_get_obj_coef - retrieve obj. coefficient or constant term
*
*  SYNOPSIS
*
*  double glp_get_obj_coef(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_obj_coef returns the objective coefficient at
*  j-th structural variable (column) of the specified problem object.
*
*  If the parameter j is zero, the routine returns the constant term
*  ("shift") of the objective function. */

double glp_get_obj_coef(glp_prob *lp, int j)
{     if (!(0 <= j && j <= lp->n))
         xerror("glp_get_obj_coef: j = %d; column number out of range\n"
            , j);
      return j == 0 ? lp->c0 : lp->col[j]->coef;
}

/***********************************************************************
*  NAME
*
*  glp_get_num_nz - retrieve number of constraint coefficients
*
*  SYNOPSIS
*
*  int glp_get_num_nz(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_num_nz returns the number of (non-zero) elements
*  in the constraint matrix of the specified problem object. */

int glp_get_num_nz(glp_prob *lp)
{     int nnz = lp->nnz;
      return nnz;
}

/***********************************************************************
*  NAME
*
*  glp_get_mat_row - retrieve row of the constraint matrix
*
*  SYNOPSIS
*
*  int glp_get_mat_row(glp_prob *lp, int i, int ind[], double val[]);
*
*  DESCRIPTION
*
*  The routine glp_get_mat_row scans (non-zero) elements of i-th row
*  of the constraint matrix of the specified problem object and stores
*  their column indices and numeric values to locations ind[1], ...,
*  ind[len] and val[1], ..., val[len], respectively, where 0 <= len <= n
*  is the number of elements in i-th row, n is the number of columns.
*
*  The parameter ind and/or val can be specified as NULL, in which case
*  corresponding information is not stored.
*
*  RETURNS
*
*  The routine glp_get_mat_row returns the length len, i.e. the number
*  of (non-zero) elements in i-th row. */

int glp_get_mat_row(glp_prob *lp, int i, int ind[], double val[])
{     GLPAIJ *aij;
      int len;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_get_mat_row: i = %d; row number out of range\n",
            i);
      len = 0;
      for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)
      {  len++;
         if (ind != NULL) ind[len] = aij->col->j;
         if (val != NULL) val[len] = aij->val;
      }
      xassert(len <= lp->n);
      return len;
}

/***********************************************************************
*  NAME
*
*  glp_get_mat_col - retrieve column of the constraint matrix
*
*  SYNOPSIS
*
*  int glp_get_mat_col(glp_prob *lp, int j, int ind[], double val[]);
*
*  DESCRIPTION
*
*  The routine glp_get_mat_col scans (non-zero) elements of j-th column
*  of the constraint matrix of the specified problem object and stores
*  their row indices and numeric values to locations ind[1], ...,
*  ind[len] and val[1], ..., val[len], respectively, where 0 <= len <= m
*  is the number of elements in j-th column, m is the number of rows.
*
*  The parameter ind or/and val can be specified as NULL, in which case
*  corresponding information is not stored.
*
*  RETURNS
*
*  The routine glp_get_mat_col returns the length len, i.e. the number
*  of (non-zero) elements in j-th column. */

int glp_get_mat_col(glp_prob *lp, int j, int ind[], double val[])
{     GLPAIJ *aij;
      int len;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_get_mat_col: j = %d; column number out of range\n",
            j);
      len = 0;
      for (aij = lp->col[j]->ptr; aij != NULL; aij = aij->c_next)
      {  len++;
         if (ind != NULL) ind[len] = aij->row->i;
         if (val != NULL) val[len] = aij->val;
      }
      xassert(len <= lp->m);
      return len;
}






























typedef struct NPP NPP;
typedef struct NPPROW NPPROW;
typedef struct NPPCOL NPPCOL;
typedef struct NPPAIJ NPPAIJ;
typedef struct NPPTSE NPPTSE;
typedef struct NPPLFE NPPLFE;

struct NPP
{     /* LP/MIP preprocessor workspace */
      /*--------------------------------------------------------------*/
      /* original problem segment */
      int orig_dir;
      /* optimization direction flag:
         GLP_MIN - minimization
         GLP_MAX - maximization */
      int orig_m;
      /* number of rows */
      int orig_n;
      /* number of columns */
      int orig_nnz;
      /* number of non-zero constraint coefficients */
      /*--------------------------------------------------------------*/
      /* transformed problem segment (always minimization) */
      DMP *pool;
      /* memory pool to store problem components */
      char *name;
      /* problem name (1 to 255 chars); NULL means no name is assigned
         to the problem */
      char *obj;
      /* objective function name (1 to 255 chars); NULL means no name
         is assigned to the objective function */
      double c0;
      /* constant term of the objective function */
      int nrows;
      /* number of rows introduced into the problem; this count
         increases by one every time a new row is added and never
         decreases; thus, actual number of rows may be less than nrows
         due to row deletions */
      int ncols;
      /* number of columns introduced into the problem; this count
         increases by one every time a new column is added and never
         decreases; thus, actual number of column may be less than
         ncols due to column deletions */
      NPPROW *r_head;
      /* pointer to the beginning of the row list */
      NPPROW *r_tail;
      /* pointer to the end of the row list */
      NPPCOL *c_head;
      /* pointer to the beginning of the column list */
      NPPCOL *c_tail;
      /* pointer to the end of the column list */
      /*--------------------------------------------------------------*/
      /* transformation history */
      DMP *stack;
      /* memory pool to store transformation entries */
      NPPTSE *top;
      /* pointer to most recent transformation entry */
#if 0 /* 16/XII-2009 */
      int count[1+25];
      /* transformation statistics */
#endif
      /*--------------------------------------------------------------*/
      /* resultant (preprocessed) problem segment */
      int m;
      /* number of rows */
      int n;
      /* number of columns */
      int nnz;
      /* number of non-zero constraint coefficients */
      int *row_ref; /* int row_ref[1+m]; */
      /* row_ref[i], 1 <= i <= m, is the reference number assigned to
         a row, which is i-th row of the resultant problem */
      int *col_ref; /* int col_ref[1+n]; */
      /* col_ref[j], 1 <= j <= n, is the reference number assigned to
         a column, which is j-th column of the resultant problem */
      /*--------------------------------------------------------------*/
      /* recovered solution segment */
      int sol;
      /* solution indicator:
         GLP_SOL - basic solution
         GLP_IPT - interior-point solution
         GLP_MIP - mixed integer solution */
      int scaling;
      /* scaling option:
         GLP_OFF - scaling is disabled
         GLP_ON  - scaling is enabled */
      int p_stat;
      /* status of primal basic solution:
         GLP_UNDEF  - primal solution is undefined
         GLP_FEAS   - primal solution is feasible
         GLP_INFEAS - primal solution is infeasible
         GLP_NOFEAS - no primal feasible solution exists */
      int d_stat;
      /* status of dual basic solution:
         GLP_UNDEF  - dual solution is undefined
         GLP_FEAS   - dual solution is feasible
         GLP_INFEAS - dual solution is infeasible
         GLP_NOFEAS - no dual feasible solution exists */
      int t_stat;
      /* status of interior-point solution:
         GLP_UNDEF  - interior solution is undefined
         GLP_OPT    - interior solution is optimal */
      int i_stat;
      /* status of mixed integer solution:
         GLP_UNDEF  - integer solution is undefined
         GLP_OPT    - integer solution is optimal
         GLP_FEAS   - integer solution is feasible
         GLP_NOFEAS - no integer solution exists */
      char *r_stat; /* char r_stat[1+nrows]; */
      /* r_stat[i], 1 <= i <= nrows, is status of i-th row:
         GLP_BS - inactive constraint
         GLP_NL - active constraint on lower bound
         GLP_NU - active constraint on upper bound
         GLP_NF - active free row
         GLP_NS - active equality constraint */
      char *c_stat; /* char c_stat[1+nrows]; */
      /* c_stat[j], 1 <= j <= nrows, is status of j-th column:
         GLP_BS - basic variable
         GLP_NL - non-basic variable on lower bound
         GLP_NU - non-basic variable on upper bound
         GLP_NF - non-basic free variable
         GLP_NS - non-basic fixed variable */
      double *r_pi; /* double r_pi[1+nrows]; */
      /* r_pi[i], 1 <= i <= nrows, is Lagrange multiplier (dual value)
         for i-th row (constraint) */
      double *c_value; /* double c_value[1+ncols]; */
      /* c_value[j], 1 <= j <= ncols, is primal value of j-th column
         (structural variable) */
};

struct NPPROW
{     /* row (constraint) */
      int i;
      /* reference number assigned to the row, 1 <= i <= nrows */
      char *name;
      /* row name (1 to 255 chars); NULL means no name is assigned to
         the row */
      double lb;
      /* lower bound; -DBL_MAX means the row has no lower bound */
      double ub;
      /* upper bound; +DBL_MAX means the row has no upper bound */
      NPPAIJ *ptr;
      /* pointer to the linked list of constraint coefficients */
      int temp;
      /* working field used by preprocessor routines */
      NPPROW *prev;
      /* pointer to previous row in the row list */
      NPPROW *next;
      /* pointer to next row in the row list */
};

struct NPPCOL
{     /* column (variable) */
      int j;
      /* reference number assigned to the column, 1 <= j <= ncols */
      char *name;
      /* column name (1 to 255 chars); NULL means no name is assigned
         to the column */
      char is_int;
      /* 0 means continuous variable; 1 means integer variable */
      double lb;
      /* lower bound; -DBL_MAX means the column has no lower bound */
      double ub;
      /* upper bound; +DBL_MAX means the column has no upper bound */
      double coef;
      /* objective coefficient */
      NPPAIJ *ptr;
      /* pointer to the linked list of constraint coefficients */
      int temp;
      /* working field used by preprocessor routines */
#if 1 /* 28/XII-2009 */
      union
      {  double ll;
         /* implied column lower bound */
         int pos;
         /* vertex ordinal number corresponding to this binary column
            in the conflict graph (0, if the vertex does not exist) */
      }  ll;
      union
      {  double uu;
         /* implied column upper bound */
         int neg;
         /* vertex ordinal number corresponding to complement of this
            binary column in the conflict graph (0, if the vertex does
            not exist) */
      }  uu;
#endif
      NPPCOL *prev;
      /* pointer to previous column in the column list */
      NPPCOL *next;
      /* pointer to next column in the column list */
};

struct NPPAIJ
{     /* constraint coefficient */
      NPPROW *row;
      /* pointer to corresponding row */
      NPPCOL *col;
      /* pointer to corresponding column */
      double val;
      /* (non-zero) coefficient value */
      NPPAIJ *r_prev;
      /* pointer to previous coefficient in the same row */
      NPPAIJ *r_next;
      /* pointer to next coefficient in the same row */
      NPPAIJ *c_prev;
      /* pointer to previous coefficient in the same column */
      NPPAIJ *c_next;
      /* pointer to next coefficient in the same column */
};

struct NPPTSE
{     /* transformation stack entry */
      int (*func)(NPP *npp, void *info);
      /* pointer to routine performing back transformation */
      void *info;
      /* pointer to specific info (depends on the transformation) */
      NPPTSE *link;
      /* pointer to another entry created *before* this entry */
};

struct NPPLFE
{     /* linear form element */
      int ref;
      /* row/column reference number */
      double val;
      /* (non-zero) coefficient value */
      NPPLFE *next;
      /* pointer to another element */
};

#define npp_create_wksp _glp_npp_create_wksp
NPP *npp_create_wksp(void);
/* create LP/MIP preprocessor workspace */

#define npp_insert_row _glp_npp_insert_row
void npp_insert_row(NPP *npp, NPPROW *row, int where);
/* insert row to the row list */

#define npp_remove_row _glp_npp_remove_row
void npp_remove_row(NPP *npp, NPPROW *row);
/* remove row from the row list */

#define npp_activate_row _glp_npp_activate_row
void npp_activate_row(NPP *npp, NPPROW *row);
/* make row active */

#define npp_deactivate_row _glp_npp_deactivate_row
void npp_deactivate_row(NPP *npp, NPPROW *row);
/* make row inactive */

#define npp_insert_col _glp_npp_insert_col
void npp_insert_col(NPP *npp, NPPCOL *col, int where);
/* insert column to the column list */

#define npp_remove_col _glp_npp_remove_col
void npp_remove_col(NPP *npp, NPPCOL *col);
/* remove column from the column list */

#define npp_activate_col _glp_npp_activate_col
void npp_activate_col(NPP *npp, NPPCOL *col);
/* make column active */

#define npp_deactivate_col _glp_npp_deactivate_col
void npp_deactivate_col(NPP *npp, NPPCOL *col);
/* make column inactive */

#define npp_add_row _glp_npp_add_row
NPPROW *npp_add_row(NPP *npp);
/* add new row to the current problem */

#define npp_add_col _glp_npp_add_col
NPPCOL *npp_add_col(NPP *npp);
/* add new column to the current problem */

#define npp_add_aij _glp_npp_add_aij
NPPAIJ *npp_add_aij(NPP *npp, NPPROW *row, NPPCOL *col, double val);
/* add new element to the constraint matrix */

#define npp_row_nnz _glp_npp_row_nnz
int npp_row_nnz(NPP *npp, NPPROW *row);
/* count number of non-zero coefficients in row */

#define npp_col_nnz _glp_npp_col_nnz
int npp_col_nnz(NPP *npp, NPPCOL *col);
/* count number of non-zero coefficients in column */

#define npp_push_tse _glp_npp_push_tse
void *npp_push_tse(NPP *npp, int (*func)(NPP *npp, void *info),
      int size);
/* push new entry to the transformation stack */

#define npp_erase_row _glp_npp_erase_row
void npp_erase_row(NPP *npp, NPPROW *row);
/* erase row content to make it empty */

#define npp_del_row _glp_npp_del_row
void npp_del_row(NPP *npp, NPPROW *row);
/* remove row from the current problem */

#define npp_del_col _glp_npp_del_col
void npp_del_col(NPP *npp, NPPCOL *col);
/* remove column from the current problem */

#define npp_del_aij _glp_npp_del_aij
void npp_del_aij(NPP *npp, NPPAIJ *aij);
/* remove element from the constraint matrix */

#define npp_load_prob _glp_npp_load_prob
void npp_load_prob(NPP *npp, glp_prob *orig, int names, int sol,
      int scaling);
/* load original problem into the preprocessor workspace */

#define npp_build_prob _glp_npp_build_prob
void npp_build_prob(NPP *npp, glp_prob *prob);
/* build resultant (preprocessed) problem */

#define npp_postprocess _glp_npp_postprocess
void npp_postprocess(NPP *npp, glp_prob *prob);
/* postprocess solution from the resultant problem */

#define npp_unload_sol _glp_npp_unload_sol
void npp_unload_sol(NPP *npp, glp_prob *orig);
/* store solution to the original problem */

#define npp_delete_wksp _glp_npp_delete_wksp
void npp_delete_wksp(NPP *npp);
/* delete LP/MIP preprocessor workspace */

#define npp_error()

#define npp_free_row _glp_npp_free_row
void npp_free_row(NPP *npp, NPPROW *p);
/* process free (unbounded) row */

#define npp_geq_row _glp_npp_geq_row
void npp_geq_row(NPP *npp, NPPROW *p);
/* process row of 'not less than' type */

#define npp_leq_row _glp_npp_leq_row
void npp_leq_row(NPP *npp, NPPROW *p);
/* process row of 'not greater than' type */

#define npp_free_col _glp_npp_free_col
void npp_free_col(NPP *npp, NPPCOL *q);
/* process free (unbounded) column */

#define npp_lbnd_col _glp_npp_lbnd_col
void npp_lbnd_col(NPP *npp, NPPCOL *q);
/* process column with (non-zero) lower bound */

#define npp_ubnd_col _glp_npp_ubnd_col
void npp_ubnd_col(NPP *npp, NPPCOL *q);
/* process column with upper bound */

#define npp_dbnd_col _glp_npp_dbnd_col
void npp_dbnd_col(NPP *npp, NPPCOL *q);
/* process non-negative column with upper bound */

#define npp_fixed_col _glp_npp_fixed_col
void npp_fixed_col(NPP *npp, NPPCOL *q);
/* process fixed column */

#define npp_make_equality _glp_npp_make_equality
int npp_make_equality(NPP *npp, NPPROW *p);
/* process row with almost identical bounds */

#define npp_make_fixed _glp_npp_make_fixed
int npp_make_fixed(NPP *npp, NPPCOL *q);
/* process column with almost identical bounds */

#define npp_empty_row _glp_npp_empty_row
int npp_empty_row(NPP *npp, NPPROW *p);
/* process empty row */

#define npp_empty_col _glp_npp_empty_col
int npp_empty_col(NPP *npp, NPPCOL *q);
/* process empty column */

#define npp_implied_value _glp_npp_implied_value
int npp_implied_value(NPP *npp, NPPCOL *q, double s);
/* process implied column value */

#define npp_eq_singlet _glp_npp_eq_singlet
int npp_eq_singlet(NPP *npp, NPPROW *p);
/* process row singleton (equality constraint) */

#define npp_implied_lower _glp_npp_implied_lower
int npp_implied_lower(NPP *npp, NPPCOL *q, double l);
/* process implied column lower bound */

#define npp_implied_upper _glp_npp_implied_upper
int npp_implied_upper(NPP *npp, NPPCOL *q, double u);
/* process implied upper bound of column */

#define npp_ineq_singlet _glp_npp_ineq_singlet
int npp_ineq_singlet(NPP *npp, NPPROW *p);
/* process row singleton (inequality constraint) */

#define npp_implied_slack _glp_npp_implied_slack
void npp_implied_slack(NPP *npp, NPPCOL *q);
/* process column singleton (implied slack variable) */

#define npp_implied_free _glp_npp_implied_free
int npp_implied_free(NPP *npp, NPPCOL *q);
/* process column singleton (implied free variable) */

#define npp_eq_doublet _glp_npp_eq_doublet
NPPCOL *npp_eq_doublet(NPP *npp, NPPROW *p);
/* process row doubleton (equality constraint) */

#define npp_forcing_row _glp_npp_forcing_row
int npp_forcing_row(NPP *npp, NPPROW *p, int at);
/* process forcing row */

#define npp_analyze_row _glp_npp_analyze_row
int npp_analyze_row(NPP *npp, NPPROW *p);
/* perform general row analysis */

#define npp_inactive_bound _glp_npp_inactive_bound
void npp_inactive_bound(NPP *npp, NPPROW *p, int which);
/* remove row lower/upper inactive bound */

#define npp_implied_bounds _glp_npp_implied_bounds
void npp_implied_bounds(NPP *npp, NPPROW *p);
/* determine implied column bounds */

#define npp_binarize_prob _glp_npp_binarize_prob
int npp_binarize_prob(NPP *npp);
/* binarize MIP problem */

#define npp_is_packing _glp_npp_is_packing
int npp_is_packing(NPP *npp, NPPROW *row);
/* test if constraint is packing inequality */

#define npp_hidden_packing _glp_npp_hidden_packing
int npp_hidden_packing(NPP *npp, NPPROW *row);
/* identify hidden packing inequality */

#define npp_implied_packing _glp_npp_implied_packing
int npp_implied_packing(NPP *npp, NPPROW *row, int which,
      NPPCOL *var[], char set[]);
/* identify implied packing inequality */

#define npp_is_covering _glp_npp_is_covering
int npp_is_covering(NPP *npp, NPPROW *row);
/* test if constraint is covering inequality */

#define npp_hidden_covering _glp_npp_hidden_covering
int npp_hidden_covering(NPP *npp, NPPROW *row);
/* identify hidden covering inequality */

#define npp_is_partitioning _glp_npp_is_partitioning
int npp_is_partitioning(NPP *npp, NPPROW *row);
/* test if constraint is partitioning equality */

#define npp_reduce_ineq_coef _glp_npp_reduce_ineq_coef
int npp_reduce_ineq_coef(NPP *npp, NPPROW *row);
/* reduce inequality constraint coefficients */

#define npp_clean_prob _glp_npp_clean_prob
void npp_clean_prob(NPP *npp);
/* perform initial LP/MIP processing */

#define npp_process_row _glp_npp_process_row
int npp_process_row(NPP *npp, NPPROW *row, int hard);
/* perform basic row processing */

#define npp_improve_bounds _glp_npp_improve_bounds
int npp_improve_bounds(NPP *npp, NPPROW *row, int flag);
/* improve current column bounds */

#define npp_process_col _glp_npp_process_col
int npp_process_col(NPP *npp, NPPCOL *col);
/* perform basic column processing */

#define npp_process_prob _glp_npp_process_prob
int npp_process_prob(NPP *npp, int hard);
/* perform basic LP/MIP processing */

#define npp_simplex _glp_npp_simplex
int npp_simplex(NPP *npp, const glp_smcp *parm);
/* process LP prior to applying primal/dual simplex method */

#define npp_integer _glp_npp_integer
int npp_integer(NPP *npp, const glp_iocp *parm);
/* process MIP prior to applying branch-and-bound method */

/**********************************************************************/

#define npp_sat_free_row _glp_npp_sat_free_row
void npp_sat_free_row(NPP *npp, NPPROW *p);
/* process free (unbounded) row */

#define npp_sat_fixed_col _glp_npp_sat_fixed_col
int npp_sat_fixed_col(NPP *npp, NPPCOL *q);
/* process fixed column */

#define npp_sat_is_bin_comb _glp_npp_sat_is_bin_comb
int npp_sat_is_bin_comb(NPP *npp, NPPROW *row);
/* test if row is binary combination */

#define npp_sat_num_pos_coef _glp_npp_sat_num_pos_coef
int npp_sat_num_pos_coef(NPP *npp, NPPROW *row);
/* determine number of positive coefficients */

#define npp_sat_num_neg_coef _glp_npp_sat_num_neg_coef
int npp_sat_num_neg_coef(NPP *npp, NPPROW *row);
/* determine number of negative coefficients */

#define npp_sat_is_cover_ineq _glp_npp_sat_is_cover_ineq
int npp_sat_is_cover_ineq(NPP *npp, NPPROW *row);
/* test if row is covering inequality */

#define npp_sat_is_pack_ineq _glp_npp_sat_is_pack_ineq
int npp_sat_is_pack_ineq(NPP *npp, NPPROW *row);
/* test if row is packing inequality */

#define npp_sat_is_partn_eq _glp_npp_sat_is_partn_eq
int npp_sat_is_partn_eq(NPP *npp, NPPROW *row);
/* test if row is partitioning equality */

#define npp_sat_reverse_row _glp_npp_sat_reverse_row
int npp_sat_reverse_row(NPP *npp, NPPROW *row);
/* multiply both sides of row by -1 */

#define npp_sat_split_pack _glp_npp_sat_split_pack
NPPROW *npp_sat_split_pack(NPP *npp, NPPROW *row, int nnn);
/* split packing inequality */

#define npp_sat_encode_pack _glp_npp_sat_encode_pack
void npp_sat_encode_pack(NPP *npp, NPPROW *row);
/* encode packing inequality */

typedef struct NPPLIT NPPLIT;
typedef struct NPPLSE NPPLSE;
typedef struct NPPSED NPPSED;

struct NPPLIT
{     /* literal (binary variable or its negation) */
      NPPCOL *col;
      /* pointer to binary variable; NULL means constant false */
      int neg;
      /* negation flag:
         0 - literal is variable (or constant false)
         1 - literal is negation of variable (or constant true) */
};

struct NPPLSE
{     /* literal set element */
      NPPLIT lit;
      /* literal */
      NPPLSE *next;
      /* pointer to another element */
};

struct NPPSED
{     /* summation encoding descriptor */
      /* this struct describes the equality
            x + y + z = s + 2 * c,
         which was encoded as CNF and included into the transformed
         problem; here x and y are literals, z is either a literal or
         constant zero, s and c are binary variables modeling, resp.,
         the low and high (carry) sum bits */
      NPPLIT x, y, z;
      /* literals; if z.col = NULL, z is constant zero */
      NPPCOL *s, *c;
      /* binary variables modeling the sum bits */
};

#define npp_sat_encode_sum2 _glp_npp_sat_encode_sum2
void npp_sat_encode_sum2(NPP *npp, NPPLSE *set, NPPSED *sed);
/* encode 2-bit summation */

#define npp_sat_encode_sum3 _glp_npp_sat_encode_sum3
void npp_sat_encode_sum3(NPP *npp, NPPLSE *set, NPPSED *sed);
/* encode 3-bit summation */

#define npp_sat_encode_sum_ax _glp_npp_sat_encode_sum_ax
int npp_sat_encode_sum_ax(NPP *npp, NPPROW *row, NPPLIT y[]);
/* encode linear combination of 0-1 variables */

#define npp_sat_normalize_clause _glp_npp_sat_normalize_clause
int npp_sat_normalize_clause(NPP *npp, int size, NPPLIT lit[]);
/* normalize clause */

#define npp_sat_encode_clause _glp_npp_sat_encode_clause
NPPROW *npp_sat_encode_clause(NPP *npp, int size, NPPLIT lit[]);
/* translate clause to cover inequality */

#define npp_sat_encode_geq _glp_npp_sat_encode_geq
int npp_sat_encode_geq(NPP *npp, int n, NPPLIT y[], int rhs);
/* encode "not less than" constraint */

#define npp_sat_encode_leq _glp_npp_sat_encode_leq
int npp_sat_encode_leq(NPP *npp, int n, NPPLIT y[], int rhs);
/* encode "not greater than" constraint */

#define npp_sat_encode_row _glp_npp_sat_encode_row
int npp_sat_encode_row(NPP *npp, NPPROW *row);
/* encode constraint (row) of general type */

#define npp_sat_encode_prob _glp_npp_sat_encode_prob
int npp_sat_encode_prob(NPP *npp);
/* encode 0-1 feasibility problem */










NPP *npp_create_wksp(void)
{     /* create LP/MIP preprocessor workspace */
      NPP *npp;
      npp = xmalloc(sizeof(NPP));
      npp->orig_dir = 0;
      npp->orig_m = npp->orig_n = npp->orig_nnz = 0;
      npp->pool = dmp_create_pool();
      npp->name = npp->obj = NULL;
      npp->c0 = 0.0;
      npp->nrows = npp->ncols = 0;
      npp->r_head = npp->r_tail = NULL;
      npp->c_head = npp->c_tail = NULL;
      npp->stack = dmp_create_pool();
      npp->top = NULL;
#if 0 /* 16/XII-2009 */
      memset(&npp->count, 0, sizeof(npp->count));
#endif
      npp->m = npp->n = npp->nnz = 0;
      npp->row_ref = npp->col_ref = NULL;
      npp->sol = npp->scaling = 0;
      npp->p_stat = npp->d_stat = npp->t_stat = npp->i_stat = 0;
      npp->r_stat = NULL;
      /*npp->r_prim =*/ npp->r_pi = NULL;
      npp->c_stat = NULL;
      npp->c_value = /*npp->c_dual =*/ NULL;
      return npp;
}

void npp_insert_row(NPP *npp, NPPROW *row, int where)
{     /* insert row to the row list */
      if (where == 0)
      {  /* insert row to the beginning of the row list */
         row->prev = NULL;
         row->next = npp->r_head;
         if (row->next == NULL)
            npp->r_tail = row;
         else
            row->next->prev = row;
         npp->r_head = row;
      }
      else
      {  /* insert row to the end of the row list */
         row->prev = npp->r_tail;
         row->next = NULL;
         if (row->prev == NULL)
            npp->r_head = row;
         else
            row->prev->next = row;
         npp->r_tail = row;
      }
      return;
}

void npp_remove_row(NPP *npp, NPPROW *row)
{     /* remove row from the row list */
      if (row->prev == NULL)
         npp->r_head = row->next;
      else
         row->prev->next = row->next;
      if (row->next == NULL)
         npp->r_tail = row->prev;
      else
         row->next->prev = row->prev;
      return;
}

void npp_activate_row(NPP *npp, NPPROW *row)
{     /* make row active */
      if (!row->temp)
      {  row->temp = 1;
         /* move the row to the beginning of the row list */
         npp_remove_row(npp, row);
         npp_insert_row(npp, row, 0);
      }
      return;
}

void npp_deactivate_row(NPP *npp, NPPROW *row)
{     /* make row inactive */
      if (row->temp)
      {  row->temp = 0;
         /* move the row to the end of the row list */
         npp_remove_row(npp, row);
         npp_insert_row(npp, row, 1);
      }
      return;
}

void npp_insert_col(NPP *npp, NPPCOL *col, int where)
{     /* insert column to the column list */
      if (where == 0)
      {  /* insert column to the beginning of the column list */
         col->prev = NULL;
         col->next = npp->c_head;
         if (col->next == NULL)
            npp->c_tail = col;
         else
            col->next->prev = col;
         npp->c_head = col;
      }
      else
      {  /* insert column to the end of the column list */
         col->prev = npp->c_tail;
         col->next = NULL;
         if (col->prev == NULL)
            npp->c_head = col;
         else
            col->prev->next = col;
         npp->c_tail = col;
      }
      return;
}

void npp_remove_col(NPP *npp, NPPCOL *col)
{     /* remove column from the column list */
      if (col->prev == NULL)
         npp->c_head = col->next;
      else
         col->prev->next = col->next;
      if (col->next == NULL)
         npp->c_tail = col->prev;
      else
         col->next->prev = col->prev;
      return;
}

void npp_activate_col(NPP *npp, NPPCOL *col)
{     /* make column active */
      if (!col->temp)
      {  col->temp = 1;
         /* move the column to the beginning of the column list */
         npp_remove_col(npp, col);
         npp_insert_col(npp, col, 0);
      }
      return;
}

void npp_deactivate_col(NPP *npp, NPPCOL *col)
{     /* make column inactive */
      if (col->temp)
      {  col->temp = 0;
         /* move the column to the end of the column list */
         npp_remove_col(npp, col);
         npp_insert_col(npp, col, 1);
      }
      return;
}

NPPROW *npp_add_row(NPP *npp)
{     /* add new row to the current problem */
      NPPROW *row;
      row = dmp_get_atom(npp->pool, sizeof(NPPROW));
      row->i = ++(npp->nrows);
      row->name = NULL;
      row->lb = -DBL_MAX, row->ub = +DBL_MAX;
      row->ptr = NULL;
      row->temp = 0;
      npp_insert_row(npp, row, 1);
      return row;
}

NPPCOL *npp_add_col(NPP *npp)
{     /* add new column to the current problem */
      NPPCOL *col;
      col = dmp_get_atom(npp->pool, sizeof(NPPCOL));
      col->j = ++(npp->ncols);
      col->name = NULL;
#if 0
      col->kind = GLP_CV;
#else
      col->is_int = 0;
#endif
      col->lb = col->ub = col->coef = 0.0;
      col->ptr = NULL;
      col->temp = 0;
      npp_insert_col(npp, col, 1);
      return col;
}

NPPAIJ *npp_add_aij(NPP *npp, NPPROW *row, NPPCOL *col, double val)
{     /* add new element to the constraint matrix */
      NPPAIJ *aij;
      aij = dmp_get_atom(npp->pool, sizeof(NPPAIJ));
      aij->row = row;
      aij->col = col;
      aij->val = val;
      aij->r_prev = NULL;
      aij->r_next = row->ptr;
      aij->c_prev = NULL;
      aij->c_next = col->ptr;
      if (aij->r_next != NULL)
         aij->r_next->r_prev = aij;
      if (aij->c_next != NULL)
         aij->c_next->c_prev = aij;
      row->ptr = col->ptr = aij;
      return aij;
}

int npp_row_nnz(NPP *npp, NPPROW *row)
{     /* count number of non-zero coefficients in row */
      NPPAIJ *aij;
      int nnz;
      xassert(npp == npp);
      nnz = 0;
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
         nnz++;
      return nnz;
}

int npp_col_nnz(NPP *npp, NPPCOL *col)
{     /* count number of non-zero coefficients in column */
      NPPAIJ *aij;
      int nnz;
      xassert(npp == npp);
      nnz = 0;
      for (aij = col->ptr; aij != NULL; aij = aij->c_next)
         nnz++;
      return nnz;
}

void *npp_push_tse(NPP *npp, int (*func)(NPP *npp, void *info),
      int size)
{     /* push new entry to the transformation stack */
      NPPTSE *tse;
      tse = dmp_get_atom(npp->stack, sizeof(NPPTSE));
      tse->func = func;
      tse->info = dmp_get_atom(npp->stack, size);
      tse->link = npp->top;
      npp->top = tse;
      return tse->info;
}

#if 1 /* 23/XII-2009 */
void npp_erase_row(NPP *npp, NPPROW *row)
{     /* erase row content to make it empty */
      NPPAIJ *aij;
      while (row->ptr != NULL)
      {  aij = row->ptr;
         row->ptr = aij->r_next;
         if (aij->c_prev == NULL)
            aij->col->ptr = aij->c_next;
         else
            aij->c_prev->c_next = aij->c_next;
         if (aij->c_next == NULL)
            ;
         else
            aij->c_next->c_prev = aij->c_prev;
         dmp_free_atom(npp->pool, aij, sizeof(NPPAIJ));
      }
      return;
}
#endif

void npp_del_row(NPP *npp, NPPROW *row)
{     /* remove row from the current problem */
#if 0 /* 23/XII-2009 */
      NPPAIJ *aij;
#endif
      if (row->name != NULL)
         dmp_free_atom(npp->pool, row->name, strlen(row->name)+1);
#if 0 /* 23/XII-2009 */
      while (row->ptr != NULL)
      {  aij = row->ptr;
         row->ptr = aij->r_next;
         if (aij->c_prev == NULL)
            aij->col->ptr = aij->c_next;
         else
            aij->c_prev->c_next = aij->c_next;
         if (aij->c_next == NULL)
            ;
         else
            aij->c_next->c_prev = aij->c_prev;
         dmp_free_atom(npp->pool, aij, sizeof(NPPAIJ));
      }
#else
      npp_erase_row(npp, row);
#endif
      npp_remove_row(npp, row);
      dmp_free_atom(npp->pool, row, sizeof(NPPROW));
      return;
}

void npp_del_col(NPP *npp, NPPCOL *col)
{     /* remove column from the current problem */
      NPPAIJ *aij;
      if (col->name != NULL)
         dmp_free_atom(npp->pool, col->name, strlen(col->name)+1);
      while (col->ptr != NULL)
      {  aij = col->ptr;
         col->ptr = aij->c_next;
         if (aij->r_prev == NULL)
            aij->row->ptr = aij->r_next;
         else
            aij->r_prev->r_next = aij->r_next;
         if (aij->r_next == NULL)
            ;
         else
            aij->r_next->r_prev = aij->r_prev;
         dmp_free_atom(npp->pool, aij, sizeof(NPPAIJ));
      }
      npp_remove_col(npp, col);
      dmp_free_atom(npp->pool, col, sizeof(NPPCOL));
      return;
}

void npp_del_aij(NPP *npp, NPPAIJ *aij)
{     /* remove element from the constraint matrix */
      if (aij->r_prev == NULL)
         aij->row->ptr = aij->r_next;
      else
         aij->r_prev->r_next = aij->r_next;
      if (aij->r_next == NULL)
         ;
      else
         aij->r_next->r_prev = aij->r_prev;
      if (aij->c_prev == NULL)
         aij->col->ptr = aij->c_next;
      else
         aij->c_prev->c_next = aij->c_next;
      if (aij->c_next == NULL)
         ;
      else
         aij->c_next->c_prev = aij->c_prev;
      dmp_free_atom(npp->pool, aij, sizeof(NPPAIJ));
      return;
}

void npp_load_prob(NPP *npp, glp_prob *orig, int names, int sol,
      int scaling)
{     /* load original problem into the preprocessor workspace */
      int m = orig->m;
      int n = orig->n;
      NPPROW **link;
      int i, j;
      double dir;
      xassert(names == GLP_OFF || names == GLP_ON);
      xassert(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP);
      xassert(scaling == GLP_OFF || scaling == GLP_ON);
      if (sol == GLP_MIP) xassert(!scaling);
      npp->orig_dir = orig->dir;
      if (npp->orig_dir == GLP_MIN)
         dir = +1.0;
      else if (npp->orig_dir == GLP_MAX)
         dir = -1.0;
      else
         xassert(npp != npp);
      npp->orig_m = m;
      npp->orig_n = n;
      npp->orig_nnz = orig->nnz;
      if (names && orig->name != NULL)
      {  npp->name = dmp_get_atom(npp->pool, strlen(orig->name)+1);
         strcpy(npp->name, orig->name);
      }
      if (names && orig->obj != NULL)
      {  npp->obj = dmp_get_atom(npp->pool, strlen(orig->obj)+1);
         strcpy(npp->obj, orig->obj);
      }
      npp->c0 = dir * orig->c0;
      /* load rows */
      link = xcalloc(1+m, sizeof(NPPROW *));
      for (i = 1; i <= m; i++)
      {  GLPROW *rrr = orig->row[i];
         NPPROW *row;
         link[i] = row = npp_add_row(npp);
         xassert(row->i == i);
         if (names && rrr->name != NULL)
         {  row->name = dmp_get_atom(npp->pool, strlen(rrr->name)+1);
            strcpy(row->name, rrr->name);
         }
         if (!scaling)
         {  if (rrr->type == GLP_FR)
               row->lb = -DBL_MAX, row->ub = +DBL_MAX;
            else if (rrr->type == GLP_LO)
               row->lb = rrr->lb, row->ub = +DBL_MAX;
            else if (rrr->type == GLP_UP)
               row->lb = -DBL_MAX, row->ub = rrr->ub;
            else if (rrr->type == GLP_DB)
               row->lb = rrr->lb, row->ub = rrr->ub;
            else if (rrr->type == GLP_FX)
               row->lb = row->ub = rrr->lb;
            else
               xassert(rrr != rrr);
         }
         else
         {  double rii = rrr->rii;
            if (rrr->type == GLP_FR)
               row->lb = -DBL_MAX, row->ub = +DBL_MAX;
            else if (rrr->type == GLP_LO)
               row->lb = rrr->lb * rii, row->ub = +DBL_MAX;
            else if (rrr->type == GLP_UP)
               row->lb = -DBL_MAX, row->ub = rrr->ub * rii;
            else if (rrr->type == GLP_DB)
               row->lb = rrr->lb * rii, row->ub = rrr->ub * rii;
            else if (rrr->type == GLP_FX)
               row->lb = row->ub = rrr->lb * rii;
            else
               xassert(rrr != rrr);
         }
      }
      /* load columns and constraint coefficients */
      for (j = 1; j <= n; j++)
      {  GLPCOL *ccc = orig->col[j];
         GLPAIJ *aaa;
         NPPCOL *col;
         col = npp_add_col(npp);
         xassert(col->j == j);
         if (names && ccc->name != NULL)
         {  col->name = dmp_get_atom(npp->pool, strlen(ccc->name)+1);
            strcpy(col->name, ccc->name);
         }
         if (sol == GLP_MIP)
#if 0
            col->kind = ccc->kind;
#else
            col->is_int = (char)(ccc->kind == GLP_IV);
#endif
         if (!scaling)
         {  if (ccc->type == GLP_FR)
               col->lb = -DBL_MAX, col->ub = +DBL_MAX;
            else if (ccc->type == GLP_LO)
               col->lb = ccc->lb, col->ub = +DBL_MAX;
            else if (ccc->type == GLP_UP)
               col->lb = -DBL_MAX, col->ub = ccc->ub;
            else if (ccc->type == GLP_DB)
               col->lb = ccc->lb, col->ub = ccc->ub;
            else if (ccc->type == GLP_FX)
               col->lb = col->ub = ccc->lb;
            else
               xassert(ccc != ccc);
            col->coef = dir * ccc->coef;
            for (aaa = ccc->ptr; aaa != NULL; aaa = aaa->c_next)
               npp_add_aij(npp, link[aaa->row->i], col, aaa->val);
         }
         else
         {  double sjj = ccc->sjj;
            if (ccc->type == GLP_FR)
               col->lb = -DBL_MAX, col->ub = +DBL_MAX;
            else if (ccc->type == GLP_LO)
               col->lb = ccc->lb / sjj, col->ub = +DBL_MAX;
            else if (ccc->type == GLP_UP)
               col->lb = -DBL_MAX, col->ub = ccc->ub / sjj;
            else if (ccc->type == GLP_DB)
               col->lb = ccc->lb / sjj, col->ub = ccc->ub / sjj;
            else if (ccc->type == GLP_FX)
               col->lb = col->ub = ccc->lb / sjj;
            else
               xassert(ccc != ccc);
            col->coef = dir * ccc->coef * sjj;
            for (aaa = ccc->ptr; aaa != NULL; aaa = aaa->c_next)
               npp_add_aij(npp, link[aaa->row->i], col,
                  aaa->row->rii * aaa->val * sjj);
         }
      }
      xfree(link);
      /* keep solution indicator and scaling option */
      npp->sol = sol;
      npp->scaling = scaling;
      return;
}

void npp_build_prob(NPP *npp, glp_prob *prob)
{     /* build resultant (preprocessed) problem */
      NPPROW *row;
      NPPCOL *col;
      NPPAIJ *aij;
      int i, j, type, len, *ind;
      double dir, *val;
      glp_erase_prob(prob);
      glp_set_prob_name(prob, npp->name);
      glp_set_obj_name(prob, npp->obj);
      glp_set_obj_dir(prob, npp->orig_dir);
      if (npp->orig_dir == GLP_MIN)
         dir = +1.0;
      else if (npp->orig_dir == GLP_MAX)
         dir = -1.0;
      else
         xassert(npp != npp);
      glp_set_obj_coef(prob, 0, dir * npp->c0);
      /* build rows */
      for (row = npp->r_head; row != NULL; row = row->next)
      {  row->temp = i = glp_add_rows(prob, 1);
         glp_set_row_name(prob, i, row->name);
         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)
            type = GLP_FR;
         else if (row->ub == +DBL_MAX)
            type = GLP_LO;
         else if (row->lb == -DBL_MAX)
            type = GLP_UP;
         else if (row->lb != row->ub)
            type = GLP_DB;
         else
            type = GLP_FX;
         glp_set_row_bnds(prob, i, type, row->lb, row->ub);
      }
      /* build columns and the constraint matrix */
      ind = xcalloc(1+prob->m, sizeof(int));
      val = xcalloc(1+prob->m, sizeof(double));
      for (col = npp->c_head; col != NULL; col = col->next)
      {  j = glp_add_cols(prob, 1);
         glp_set_col_name(prob, j, col->name);
#if 0
         glp_set_col_kind(prob, j, col->kind);
#else
         glp_set_col_kind(prob, j, col->is_int ? GLP_IV : GLP_CV);
#endif
         if (col->lb == -DBL_MAX && col->ub == +DBL_MAX)
            type = GLP_FR;
         else if (col->ub == +DBL_MAX)
            type = GLP_LO;
         else if (col->lb == -DBL_MAX)
            type = GLP_UP;
         else if (col->lb != col->ub)
            type = GLP_DB;
         else
            type = GLP_FX;
         glp_set_col_bnds(prob, j, type, col->lb, col->ub);
         glp_set_obj_coef(prob, j, dir * col->coef);
         len = 0;
         for (aij = col->ptr; aij != NULL; aij = aij->c_next)
         {  len++;
            ind[len] = aij->row->temp;
            val[len] = aij->val;
         }
         glp_set_mat_col(prob, j, len, ind, val);
      }
      xfree(ind);
      xfree(val);
      /* resultant problem has been built */
      npp->m = prob->m;
      npp->n = prob->n;
      npp->nnz = prob->nnz;
      npp->row_ref = xcalloc(1+npp->m, sizeof(int));
      npp->col_ref = xcalloc(1+npp->n, sizeof(int));
      for (row = npp->r_head, i = 0; row != NULL; row = row->next)
         npp->row_ref[++i] = row->i;
      for (col = npp->c_head, j = 0; col != NULL; col = col->next)
         npp->col_ref[++j] = col->j;
      /* transformed problem segment is no longer needed */
      dmp_delete_pool(npp->pool), npp->pool = NULL;
      npp->name = npp->obj = NULL;
      npp->c0 = 0.0;
      npp->r_head = npp->r_tail = NULL;
      npp->c_head = npp->c_tail = NULL;
      return;
}

void npp_postprocess(NPP *npp, glp_prob *prob)
{     /* postprocess solution from the resultant problem */
      GLPROW *row;
      GLPCOL *col;
      NPPTSE *tse;
      int i, j, k;
      double dir;
      xassert(npp->orig_dir == prob->dir);
      if (npp->orig_dir == GLP_MIN)
         dir = +1.0;
      else if (npp->orig_dir == GLP_MAX)
         dir = -1.0;
      else
         xassert(npp != npp);
#if 0 /* 11/VII-2013; due to call from ios_main */
      xassert(npp->m == prob->m);
#else
      if (npp->sol != GLP_MIP)
         xassert(npp->m == prob->m);
#endif
      xassert(npp->n == prob->n);
#if 0 /* 11/VII-2013; due to call from ios_main */
      xassert(npp->nnz == prob->nnz);
#else
      if (npp->sol != GLP_MIP)
         xassert(npp->nnz == prob->nnz);
#endif
      /* copy solution status */
      if (npp->sol == GLP_SOL)
      {  npp->p_stat = prob->pbs_stat;
         npp->d_stat = prob->dbs_stat;
      }
      else if (npp->sol == GLP_IPT)
         npp->t_stat = prob->ipt_stat;
      else if (npp->sol == GLP_MIP)
         npp->i_stat = prob->mip_stat;
      else
         xassert(npp != npp);
      /* allocate solution arrays */
      if (npp->sol == GLP_SOL)
      {  if (npp->r_stat == NULL)
            npp->r_stat = xcalloc(1+npp->nrows, sizeof(char));
         for (i = 1; i <= npp->nrows; i++)
            npp->r_stat[i] = 0;
         if (npp->c_stat == NULL)
            npp->c_stat = xcalloc(1+npp->ncols, sizeof(char));
         for (j = 1; j <= npp->ncols; j++)
            npp->c_stat[j] = 0;
      }
#if 0
      if (npp->r_prim == NULL)
         npp->r_prim = xcalloc(1+npp->nrows, sizeof(double));
      for (i = 1; i <= npp->nrows; i++)
         npp->r_prim[i] = DBL_MAX;
#endif
      if (npp->c_value == NULL)
         npp->c_value = xcalloc(1+npp->ncols, sizeof(double));
      for (j = 1; j <= npp->ncols; j++)
         npp->c_value[j] = DBL_MAX;
      if (npp->sol != GLP_MIP)
      {  if (npp->r_pi == NULL)
            npp->r_pi = xcalloc(1+npp->nrows, sizeof(double));
         for (i = 1; i <= npp->nrows; i++)
            npp->r_pi[i] = DBL_MAX;
#if 0
         if (npp->c_dual == NULL)
            npp->c_dual = xcalloc(1+npp->ncols, sizeof(double));
         for (j = 1; j <= npp->ncols; j++)
            npp->c_dual[j] = DBL_MAX;
#endif
      }
      /* copy solution components from the resultant problem */
      if (npp->sol == GLP_SOL)
      {  for (i = 1; i <= npp->m; i++)
         {  row = prob->row[i];
            k = npp->row_ref[i];
            npp->r_stat[k] = (char)row->stat;
            /*npp->r_prim[k] = row->prim;*/
            npp->r_pi[k] = dir * row->dual;
         }
         for (j = 1; j <= npp->n; j++)
         {  col = prob->col[j];
            k = npp->col_ref[j];
            npp->c_stat[k] = (char)col->stat;
            npp->c_value[k] = col->prim;
            /*npp->c_dual[k] = dir * col->dual;*/
         }
      }
      else if (npp->sol == GLP_IPT)
      {  for (i = 1; i <= npp->m; i++)
         {  row = prob->row[i];
            k = npp->row_ref[i];
            /*npp->r_prim[k] = row->pval;*/
            npp->r_pi[k] = dir * row->dval;
         }
         for (j = 1; j <= npp->n; j++)
         {  col = prob->col[j];
            k = npp->col_ref[j];
            npp->c_value[k] = col->pval;
            /*npp->c_dual[k] = dir * col->dval;*/
         }
      }
      else if (npp->sol == GLP_MIP)
      {
#if 0
         for (i = 1; i <= npp->m; i++)
         {  row = prob->row[i];
            k = npp->row_ref[i];
            /*npp->r_prim[k] = row->mipx;*/
         }
#endif
         for (j = 1; j <= npp->n; j++)
         {  col = prob->col[j];
            k = npp->col_ref[j];
            npp->c_value[k] = col->mipx;
         }
      }
      else
         xassert(npp != npp);
      /* perform postprocessing to construct solution to the original
         problem */
      for (tse = npp->top; tse != NULL; tse = tse->link)
      {  xassert(tse->func != NULL);
         xassert(tse->func(npp, tse->info) == 0);
      }
      return;
}

void npp_unload_sol(NPP *npp, glp_prob *orig)
{     /* store solution to the original problem */
      GLPROW *row;
      GLPCOL *col;
      int i, j;
      double dir;
      xassert(npp->orig_dir == orig->dir);
      if (npp->orig_dir == GLP_MIN)
         dir = +1.0;
      else if (npp->orig_dir == GLP_MAX)
         dir = -1.0;
      else
         xassert(npp != npp);
      xassert(npp->orig_m == orig->m);
      xassert(npp->orig_n == orig->n);
      xassert(npp->orig_nnz == orig->nnz);
      if (npp->sol == GLP_SOL)
      {  /* store basic solution */
         orig->valid = 0;
         orig->pbs_stat = npp->p_stat;
         orig->dbs_stat = npp->d_stat;
         orig->obj_val = orig->c0;
         orig->some = 0;
         for (i = 1; i <= orig->m; i++)
         {  row = orig->row[i];
            row->stat = npp->r_stat[i];
            if (!npp->scaling)
            {  /*row->prim = npp->r_prim[i];*/
               row->dual = dir * npp->r_pi[i];
            }
            else
            {  /*row->prim = npp->r_prim[i] / row->rii;*/
               row->dual = dir * npp->r_pi[i] * row->rii;
            }
            if (row->stat == GLP_BS)
               row->dual = 0.0;
            else if (row->stat == GLP_NL)
            {  xassert(row->type == GLP_LO || row->type == GLP_DB);
               row->prim = row->lb;
            }
            else if (row->stat == GLP_NU)
            {  xassert(row->type == GLP_UP || row->type == GLP_DB);
               row->prim = row->ub;
            }
            else if (row->stat == GLP_NF)
            {  xassert(row->type == GLP_FR);
               row->prim = 0.0;
            }
            else if (row->stat == GLP_NS)
            {  xassert(row->type == GLP_FX);
               row->prim = row->lb;
            }
            else
               xassert(row != row);
         }
         for (j = 1; j <= orig->n; j++)
         {  col = orig->col[j];
            col->stat = npp->c_stat[j];
            if (!npp->scaling)
            {  col->prim = npp->c_value[j];
               /*col->dual = dir * npp->c_dual[j];*/
            }
            else
            {  col->prim = npp->c_value[j] * col->sjj;
               /*col->dual = dir * npp->c_dual[j] / col->sjj;*/
            }
            if (col->stat == GLP_BS)
               col->dual = 0.0;
#if 1
            else if (col->stat == GLP_NL)
            {  xassert(col->type == GLP_LO || col->type == GLP_DB);
               col->prim = col->lb;
            }
            else if (col->stat == GLP_NU)
            {  xassert(col->type == GLP_UP || col->type == GLP_DB);
               col->prim = col->ub;
            }
            else if (col->stat == GLP_NF)
            {  xassert(col->type == GLP_FR);
               col->prim = 0.0;
            }
            else if (col->stat == GLP_NS)
            {  xassert(col->type == GLP_FX);
               col->prim = col->lb;
            }
            else
               xassert(col != col);
#endif
            orig->obj_val += col->coef * col->prim;
         }
#if 1
         /* compute primal values of inactive rows */
         for (i = 1; i <= orig->m; i++)
         {  row = orig->row[i];
            if (row->stat == GLP_BS)
            {  GLPAIJ *aij;
               double temp;
               temp = 0.0;
               for (aij = row->ptr; aij != NULL; aij = aij->r_next)
                  temp += aij->val * aij->col->prim;
               row->prim = temp;
            }
         }
         /* compute reduced costs of active columns */
         for (j = 1; j <= orig->n; j++)
         {  col = orig->col[j];
            if (col->stat != GLP_BS)
            {  GLPAIJ *aij;
               double temp;
               temp = col->coef;
               for (aij = col->ptr; aij != NULL; aij = aij->c_next)
                  temp -= aij->val * aij->row->dual;
               col->dual = temp;
            }
         }
#endif
      }
      else if (npp->sol == GLP_IPT)
      {  /* store interior-point solution */
         orig->ipt_stat = npp->t_stat;
         orig->ipt_obj = orig->c0;
         for (i = 1; i <= orig->m; i++)
         {  row = orig->row[i];
            if (!npp->scaling)
            {  /*row->pval = npp->r_prim[i];*/
               row->dval = dir * npp->r_pi[i];
            }
            else
            {  /*row->pval = npp->r_prim[i] / row->rii;*/
               row->dval = dir * npp->r_pi[i] * row->rii;
            }
         }
         for (j = 1; j <= orig->n; j++)
         {  col = orig->col[j];
            if (!npp->scaling)
            {  col->pval = npp->c_value[j];
               /*col->dval = dir * npp->c_dual[j];*/
            }
            else
            {  col->pval = npp->c_value[j] * col->sjj;
               /*col->dval = dir * npp->c_dual[j] / col->sjj;*/
            }
            orig->ipt_obj += col->coef * col->pval;
         }
#if 1
         /* compute row primal values */
         for (i = 1; i <= orig->m; i++)
         {  row = orig->row[i];
            {  GLPAIJ *aij;
               double temp;
               temp = 0.0;
               for (aij = row->ptr; aij != NULL; aij = aij->r_next)
                  temp += aij->val * aij->col->pval;
               row->pval = temp;
            }
         }
         /* compute column dual values */
         for (j = 1; j <= orig->n; j++)
         {  col = orig->col[j];
            {  GLPAIJ *aij;
               double temp;
               temp = col->coef;
               for (aij = col->ptr; aij != NULL; aij = aij->c_next)
                  temp -= aij->val * aij->row->dval;
               col->dval = temp;
            }
         }
#endif
      }
      else if (npp->sol == GLP_MIP)
      {  /* store MIP solution */
         xassert(!npp->scaling);
         orig->mip_stat = npp->i_stat;
         orig->mip_obj = orig->c0;
#if 0
         for (i = 1; i <= orig->m; i++)
         {  row = orig->row[i];
            /*row->mipx = npp->r_prim[i];*/
         }
#endif
         for (j = 1; j <= orig->n; j++)
         {  col = orig->col[j];
            col->mipx = npp->c_value[j];
            if (col->kind == GLP_IV)
               xassert(col->mipx == floor(col->mipx));
            orig->mip_obj += col->coef * col->mipx;
         }
#if 1
         /* compute row primal values */
         for (i = 1; i <= orig->m; i++)
         {  row = orig->row[i];
            {  GLPAIJ *aij;
               double temp;
               temp = 0.0;
               for (aij = row->ptr; aij != NULL; aij = aij->r_next)
                  temp += aij->val * aij->col->mipx;
               row->mipx = temp;
            }
         }
#endif
      }
      else
         xassert(npp != npp);
      return;
}

void npp_delete_wksp(NPP *npp)
{     /* delete LP/MIP preprocessor workspace */
      if (npp->pool != NULL)
         dmp_delete_pool(npp->pool);
      if (npp->stack != NULL)
         dmp_delete_pool(npp->stack);
      if (npp->row_ref != NULL)
         xfree(npp->row_ref);
      if (npp->col_ref != NULL)
         xfree(npp->col_ref);
      if (npp->r_stat != NULL)
         xfree(npp->r_stat);
#if 0
      if (npp->r_prim != NULL)
         xfree(npp->r_prim);
#endif
      if (npp->r_pi != NULL)
         xfree(npp->r_pi);
      if (npp->c_stat != NULL)
         xfree(npp->c_stat);
      if (npp->c_value != NULL)
         xfree(npp->c_value);
#if 0
      if (npp->c_dual != NULL)
         xfree(npp->c_dual);
#endif
      xfree(npp);
      return;
}





struct free_row
{     /* free (unbounded) row */
      int p;
      /* row reference number */
};

static int rcv_free_row(NPP *npp, void *info);

void npp_free_row(NPP *npp, NPPROW *p)
{     /* process free (unbounded) row */
      struct free_row *info;
      /* the row must be free */
      xassert(p->lb == -DBL_MAX && p->ub == +DBL_MAX);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_free_row, sizeof(struct free_row));
      info->p = p->i;
      /* remove the row from the problem */
      npp_del_row(npp, p);
      return;
}

static int rcv_free_row(NPP *npp, void *_info)
{     /* recover free (unbounded) row */
      struct free_row *info = _info;
      if (npp->sol == GLP_SOL)
         npp->r_stat[info->p] = GLP_BS;
      if (npp->sol != GLP_MIP)
         npp->r_pi[info->p] = 0.0;
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_geq_row - process row of 'not less than' type
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_geq_row(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_geq_row processes row p, which is 'not less than'
*  inequality constraint:
*
*     L[p] <= sum a[p,j] x[j] (<= U[p]),                             (1)
*              j
*
*  where L[p] < U[p], and upper bound may not exist (U[p] = +oo).
*
*  PROBLEM TRANSFORMATION
*
*  Constraint (1) can be replaced by equality constraint:
*
*     sum a[p,j] x[j] - s = L[p],                                    (2)
*      j
*
*  where
*
*     0 <= s (<= U[p] - L[p])                                        (3)
*
*  is a non-negative surplus variable.
*
*  Since in the primal system there appears column s having the only
*  non-zero coefficient in row p, in the dual system there appears a
*  new row:
*
*     (-1) pi[p] + lambda = 0,                                       (4)
*
*  where (-1) is coefficient of column s in row p, pi[p] is multiplier
*  of row p, lambda is multiplier of column q, 0 is coefficient of
*  column s in the objective row.
*
*  RECOVERING BASIC SOLUTION
*
*  Status of row p in solution to the original problem is determined
*  by its status and status of column q in solution to the transformed
*  problem as follows:
*
*     +--------------------------------------+------------------+
*     |         Transformed problem          | Original problem |
*     +-----------------+--------------------+------------------+
*     | Status of row p | Status of column s | Status of row p  |
*     +-----------------+--------------------+------------------+
*     |     GLP_BS      |       GLP_BS       |       N/A        |
*     |     GLP_BS      |       GLP_NL       |      GLP_BS      |
*     |     GLP_BS      |       GLP_NU       |      GLP_BS      |
*     |     GLP_NS      |       GLP_BS       |      GLP_BS      |
*     |     GLP_NS      |       GLP_NL       |      GLP_NL      |
*     |     GLP_NS      |       GLP_NU       |      GLP_NU      |
*     +-----------------+--------------------+------------------+
*
*  Value of row multiplier pi[p] in solution to the original problem
*  is the same as in solution to the transformed problem.
*
*  1. In solution to the transformed problem row p and column q cannot
*     be basic at the same time; otherwise the basis matrix would have
*     two linear dependent columns: unity column of auxiliary variable
*     of row p and unity column of variable s.
*
*  2. Though in the transformed problem row p is equality constraint,
*     it may be basic due to primal degenerate solution.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of row multiplier pi[p] in solution to the original problem
*  is the same as in solution to the transformed problem.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

struct ineq_row
{     /* inequality constraint row */
      int p;
      /* row reference number */
      int s;
      /* column reference number for slack/surplus variable */
};

static int rcv_geq_row(NPP *npp, void *info);

void npp_geq_row(NPP *npp, NPPROW *p)
{     /* process row of 'not less than' type */
      struct ineq_row *info;
      NPPCOL *s;
      /* the row must have lower bound */
      xassert(p->lb != -DBL_MAX);
      xassert(p->lb < p->ub);
      /* create column for surplus variable */
      s = npp_add_col(npp);
      s->lb = 0.0;
      s->ub = (p->ub == +DBL_MAX ? +DBL_MAX : p->ub - p->lb);
      /* and add it to the transformed problem */
      npp_add_aij(npp, p, s, -1.0);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_geq_row, sizeof(struct ineq_row));
      info->p = p->i;
      info->s = s->j;
      /* replace the row by equality constraint */
      p->ub = p->lb;
      return;
}

static int rcv_geq_row(NPP *npp, void *_info)
{     /* recover row of 'not less than' type */
      struct ineq_row *info = _info;
      if (npp->sol == GLP_SOL)
      {  if (npp->r_stat[info->p] == GLP_BS)
         {  if (npp->c_stat[info->s] == GLP_BS)
            {  npp_error();
               return 1;
            }
            else if (npp->c_stat[info->s] == GLP_NL ||
                     npp->c_stat[info->s] == GLP_NU)
               npp->r_stat[info->p] = GLP_BS;
            else
            {  npp_error();
               return 1;
            }
         }
         else if (npp->r_stat[info->p] == GLP_NS)
         {  if (npp->c_stat[info->s] == GLP_BS)
               npp->r_stat[info->p] = GLP_BS;
            else if (npp->c_stat[info->s] == GLP_NL)
               npp->r_stat[info->p] = GLP_NL;
            else if (npp->c_stat[info->s] == GLP_NU)
               npp->r_stat[info->p] = GLP_NU;
            else
            {  npp_error();
               return 1;
            }
         }
         else
         {  npp_error();
            return 1;
         }
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_leq_row - process row of 'not greater than' type
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_leq_row(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_leq_row processes row p, which is 'not greater than'
*  inequality constraint:
*
*     (L[p] <=) sum a[p,j] x[j] <= U[p],                             (1)
*                j
*
*  where L[p] < U[p], and lower bound may not exist (L[p] = +oo).
*
*  PROBLEM TRANSFORMATION
*
*  Constraint (1) can be replaced by equality constraint:
*
*     sum a[p,j] x[j] + s = L[p],                                    (2)
*      j
*
*  where
*
*     0 <= s (<= U[p] - L[p])                                        (3)
*
*  is a non-negative slack variable.
*
*  Since in the primal system there appears column s having the only
*  non-zero coefficient in row p, in the dual system there appears a
*  new row:
*
*     (+1) pi[p] + lambda = 0,                                       (4)
*
*  where (+1) is coefficient of column s in row p, pi[p] is multiplier
*  of row p, lambda is multiplier of column q, 0 is coefficient of
*  column s in the objective row.
*
*  RECOVERING BASIC SOLUTION
*
*  Status of row p in solution to the original problem is determined
*  by its status and status of column q in solution to the transformed
*  problem as follows:
*
*     +--------------------------------------+------------------+
*     |         Transformed problem          | Original problem |
*     +-----------------+--------------------+------------------+
*     | Status of row p | Status of column s | Status of row p  |
*     +-----------------+--------------------+------------------+
*     |     GLP_BS      |       GLP_BS       |       N/A        |
*     |     GLP_BS      |       GLP_NL       |      GLP_BS      |
*     |     GLP_BS      |       GLP_NU       |      GLP_BS      |
*     |     GLP_NS      |       GLP_BS       |      GLP_BS      |
*     |     GLP_NS      |       GLP_NL       |      GLP_NU      |
*     |     GLP_NS      |       GLP_NU       |      GLP_NL      |
*     +-----------------+--------------------+------------------+
*
*  Value of row multiplier pi[p] in solution to the original problem
*  is the same as in solution to the transformed problem.
*
*  1. In solution to the transformed problem row p and column q cannot
*     be basic at the same time; otherwise the basis matrix would have
*     two linear dependent columns: unity column of auxiliary variable
*     of row p and unity column of variable s.
*
*  2. Though in the transformed problem row p is equality constraint,
*     it may be basic due to primal degeneracy.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of row multiplier pi[p] in solution to the original problem
*  is the same as in solution to the transformed problem.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

static int rcv_leq_row(NPP *npp, void *info);

void npp_leq_row(NPP *npp, NPPROW *p)
{     /* process row of 'not greater than' type */
      struct ineq_row *info;
      NPPCOL *s;
      /* the row must have upper bound */
      xassert(p->ub != +DBL_MAX);
      xassert(p->lb < p->ub);
      /* create column for slack variable */
      s = npp_add_col(npp);
      s->lb = 0.0;
      s->ub = (p->lb == -DBL_MAX ? +DBL_MAX : p->ub - p->lb);
      /* and add it to the transformed problem */
      npp_add_aij(npp, p, s, +1.0);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_leq_row, sizeof(struct ineq_row));
      info->p = p->i;
      info->s = s->j;
      /* replace the row by equality constraint */
      p->lb = p->ub;
      return;
}

static int rcv_leq_row(NPP *npp, void *_info)
{     /* recover row of 'not greater than' type */
      struct ineq_row *info = _info;
      if (npp->sol == GLP_SOL)
      {  if (npp->r_stat[info->p] == GLP_BS)
         {  if (npp->c_stat[info->s] == GLP_BS)
            {  npp_error();
               return 1;
            }
            else if (npp->c_stat[info->s] == GLP_NL ||
                     npp->c_stat[info->s] == GLP_NU)
               npp->r_stat[info->p] = GLP_BS;
            else
            {  npp_error();
               return 1;
            }
         }
         else if (npp->r_stat[info->p] == GLP_NS)
         {  if (npp->c_stat[info->s] == GLP_BS)
               npp->r_stat[info->p] = GLP_BS;
            else if (npp->c_stat[info->s] == GLP_NL)
               npp->r_stat[info->p] = GLP_NU;
            else if (npp->c_stat[info->s] == GLP_NU)
               npp->r_stat[info->p] = GLP_NL;
            else
            {  npp_error();
               return 1;
            }
         }
         else
         {  npp_error();
            return 1;
         }
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_free_col - process free (unbounded) column
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_free_col(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_free_col processes column q, which is free (i.e. has
*  no finite bounds):
*
*     -oo < x[q] < +oo.                                              (1)
*
*  PROBLEM TRANSFORMATION
*
*  Free (unbounded) variable can be replaced by the difference of two
*  non-negative variables:
*
*     x[q] = s' - s'',   s', s'' >= 0.                               (2)
*
*  Assuming that in the transformed problem x[q] becomes s',
*  transformation (2) causes new column s'' to appear, which differs
*  from column s' only in the sign of coefficients in constraint and
*  objective rows. Thus, if in the dual system the following row
*  corresponds to column s':
*
*     sum a[i,q] pi[i] + lambda' = c[q],                             (3)
*      i
*
*  the row which corresponds to column s'' is the following:
*
*     sum (-a[i,q]) pi[i] + lambda'' = -c[q].                        (4)
*      i
*
*  Then from (3) and (4) it follows that:
*
*     lambda' + lambda'' = 0   =>   lambda' = lmabda'' = 0,          (5)
*
*  where lambda' and lambda'' are multipliers for columns s' and s'',
*  resp.
*
*  RECOVERING BASIC SOLUTION
*
*  With respect to (5) status of column q in solution to the original
*  problem is determined by statuses of columns s' and s'' in solution
*  to the transformed problem as follows:
*
*     +--------------------------------------+------------------+
*     |         Transformed problem          | Original problem |
*     +------------------+-------------------+------------------+
*     | Status of col s' | Status of col s'' | Status of col q  |
*     +------------------+-------------------+------------------+
*     |      GLP_BS      |      GLP_BS       |       N/A        |
*     |      GLP_BS      |      GLP_NL       |      GLP_BS      |
*     |      GLP_NL      |      GLP_BS       |      GLP_BS      |
*     |      GLP_NL      |      GLP_NL       |      GLP_NF      |
*     +------------------+-------------------+------------------+
*
*  Value of column q is computed with formula (2).
*
*  1. In solution to the transformed problem columns s' and s'' cannot
*     be basic at the same time, because they differ only in the sign,
*     hence, are linear dependent.
*
*  2. Though column q is free, it can be non-basic due to dual
*     degeneracy.
*
*  3. If column q is integral, columns s' and s'' are also integral.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of column q is computed with formula (2).
*
*  RECOVERING MIP SOLUTION
*
*  Value of column q is computed with formula (2). */

struct free_col
{     /* free (unbounded) column */
      int q;
      /* column reference number for variables x[q] and s' */
      int s;
      /* column reference number for variable s'' */
};

static int rcv_free_col(NPP *npp, void *info);

void npp_free_col(NPP *npp, NPPCOL *q)
{     /* process free (unbounded) column */
      struct free_col *info;
      NPPCOL *s;
      NPPAIJ *aij;
      /* the column must be free */
      xassert(q->lb == -DBL_MAX && q->ub == +DBL_MAX);
      /* variable x[q] becomes s' */
      q->lb = 0.0, q->ub = +DBL_MAX;
      /* create variable s'' */
      s = npp_add_col(npp);
      s->is_int = q->is_int;
      s->lb = 0.0, s->ub = +DBL_MAX;
      /* duplicate objective coefficient */
      s->coef = -q->coef;
      /* duplicate column of the constraint matrix */
      for (aij = q->ptr; aij != NULL; aij = aij->c_next)
         npp_add_aij(npp, aij->row, s, -aij->val);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_free_col, sizeof(struct free_col));
      info->q = q->j;
      info->s = s->j;
      return;
}

static int rcv_free_col(NPP *npp, void *_info)
{     /* recover free (unbounded) column */
      struct free_col *info = _info;
      if (npp->sol == GLP_SOL)
      {  if (npp->c_stat[info->q] == GLP_BS)
         {  if (npp->c_stat[info->s] == GLP_BS)
            {  npp_error();
               return 1;
            }
            else if (npp->c_stat[info->s] == GLP_NL)
               npp->c_stat[info->q] = GLP_BS;
            else
            {  npp_error();
               return -1;
            }
         }
         else if (npp->c_stat[info->q] == GLP_NL)
         {  if (npp->c_stat[info->s] == GLP_BS)
               npp->c_stat[info->q] = GLP_BS;
            else if (npp->c_stat[info->s] == GLP_NL)
               npp->c_stat[info->q] = GLP_NF;
            else
            {  npp_error();
               return -1;
            }
         }
         else
         {  npp_error();
            return -1;
         }
      }
      /* compute value of x[q] with formula (2) */
      npp->c_value[info->q] -= npp->c_value[info->s];
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_lbnd_col - process column with (non-zero) lower bound
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_lbnd_col(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_lbnd_col processes column q, which has (non-zero)
*  lower bound:
*
*     l[q] <= x[q] (<= u[q]),                                        (1)
*
*  where l[q] < u[q], and upper bound may not exist (u[q] = +oo).
*
*  PROBLEM TRANSFORMATION
*
*  Column q can be replaced as follows:
*
*     x[q] = l[q] + s,                                               (2)
*
*  where
*
*     0 <= s (<= u[q] - l[q])                                        (3)
*
*  is a non-negative variable.
*
*  Substituting x[q] from (2) into the objective row, we have:
*
*     z = sum c[j] x[j] + c0 =
*          j
*
*       = sum c[j] x[j] + c[q] x[q] + c0 =
*         j!=q
*
*       = sum c[j] x[j] + c[q] (l[q] + s) + c0 =
*         j!=q
*
*       = sum c[j] x[j] + c[q] s + c~0,
*
*  where
*
*     c~0 = c0 + c[q] l[q]                                           (4)
*
*  is the constant term of the objective in the transformed problem.
*  Similarly, substituting x[q] into constraint row i, we have:
*
*     L[i] <= sum a[i,j] x[j] <= U[i]  ==>
*              j
*
*     L[i] <= sum a[i,j] x[j] + a[i,q] x[q] <= U[i]  ==>
*             j!=q
*
*     L[i] <= sum a[i,j] x[j] + a[i,q] (l[q] + s) <= U[i]  ==>
*             j!=q
*
*     L~[i] <= sum a[i,j] x[j] + a[i,q] s <= U~[i],
*              j!=q
*
*  where
*
*     L~[i] = L[i] - a[i,q] l[q],  U~[i] = U[i] - a[i,q] l[q]        (5)
*
*  are lower and upper bounds of row i in the transformed problem,
*  resp.
*
*  Transformation (2) does not affect the dual system.
*
*  RECOVERING BASIC SOLUTION
*
*  Status of column q in solution to the original problem is the same
*  as in solution to the transformed problem (GLP_BS, GLP_NL or GLP_NU).
*  Value of column q is computed with formula (2).
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of column q is computed with formula (2).
*
*  RECOVERING MIP SOLUTION
*
*  Value of column q is computed with formula (2). */

struct bnd_col
{     /* bounded column */
      int q;
      /* column reference number for variables x[q] and s */
      double bnd;
      /* lower/upper bound l[q] or u[q] */
};

static int rcv_lbnd_col(NPP *npp, void *info);

void npp_lbnd_col(NPP *npp, NPPCOL *q)
{     /* process column with (non-zero) lower bound */
      struct bnd_col *info;
      NPPROW *i;
      NPPAIJ *aij;
      /* the column must have non-zero lower bound */
      xassert(q->lb != 0.0);
      xassert(q->lb != -DBL_MAX);
      xassert(q->lb < q->ub);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_lbnd_col, sizeof(struct bnd_col));
      info->q = q->j;
      info->bnd = q->lb;
      /* substitute x[q] into objective row */
      npp->c0 += q->coef * q->lb;
      /* substitute x[q] into constraint rows */
      for (aij = q->ptr; aij != NULL; aij = aij->c_next)
      {  i = aij->row;
         if (i->lb == i->ub)
            i->ub = (i->lb -= aij->val * q->lb);
         else
         {  if (i->lb != -DBL_MAX)
               i->lb -= aij->val * q->lb;
            if (i->ub != +DBL_MAX)
               i->ub -= aij->val * q->lb;
         }
      }
      /* column x[q] becomes column s */
      if (q->ub != +DBL_MAX)
         q->ub -= q->lb;
      q->lb = 0.0;
      return;
}

static int rcv_lbnd_col(NPP *npp, void *_info)
{     /* recover column with (non-zero) lower bound */
      struct bnd_col *info = _info;
      if (npp->sol == GLP_SOL)
      {  if (npp->c_stat[info->q] == GLP_BS ||
             npp->c_stat[info->q] == GLP_NL ||
             npp->c_stat[info->q] == GLP_NU)
            npp->c_stat[info->q] = npp->c_stat[info->q];
         else
         {  npp_error();
            return 1;
         }
      }
      /* compute value of x[q] with formula (2) */
      npp->c_value[info->q] = info->bnd + npp->c_value[info->q];
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_ubnd_col - process column with upper bound
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_ubnd_col(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_ubnd_col processes column q, which has upper bound:
*
*     (l[q] <=) x[q] <= u[q],                                        (1)
*
*  where l[q] < u[q], and lower bound may not exist (l[q] = -oo).
*
*  PROBLEM TRANSFORMATION
*
*  Column q can be replaced as follows:
*
*     x[q] = u[q] - s,                                               (2)
*
*  where
*
*     0 <= s (<= u[q] - l[q])                                        (3)
*
*  is a non-negative variable.
*
*  Substituting x[q] from (2) into the objective row, we have:
*
*     z = sum c[j] x[j] + c0 =
*          j
*
*       = sum c[j] x[j] + c[q] x[q] + c0 =
*         j!=q
*
*       = sum c[j] x[j] + c[q] (u[q] - s) + c0 =
*         j!=q
*
*       = sum c[j] x[j] - c[q] s + c~0,
*
*  where
*
*     c~0 = c0 + c[q] u[q]                                           (4)
*
*  is the constant term of the objective in the transformed problem.
*  Similarly, substituting x[q] into constraint row i, we have:
*
*     L[i] <= sum a[i,j] x[j] <= U[i]  ==>
*              j
*
*     L[i] <= sum a[i,j] x[j] + a[i,q] x[q] <= U[i]  ==>
*             j!=q
*
*     L[i] <= sum a[i,j] x[j] + a[i,q] (u[q] - s) <= U[i]  ==>
*             j!=q
*
*     L~[i] <= sum a[i,j] x[j] - a[i,q] s <= U~[i],
*              j!=q
*
*  where
*
*     L~[i] = L[i] - a[i,q] u[q],  U~[i] = U[i] - a[i,q] u[q]        (5)
*
*  are lower and upper bounds of row i in the transformed problem,
*  resp.
*
*  Note that in the transformed problem coefficients c[q] and a[i,q]
*  change their sign. Thus, the row of the dual system corresponding to
*  column q:
*
*     sum a[i,q] pi[i] + lambda[q] = c[q]                            (6)
*      i
*
*  in the transformed problem becomes the following:
*
*     sum (-a[i,q]) pi[i] + lambda[s] = -c[q].                       (7)
*      i
*
*  Therefore:
*
*     lambda[q] = - lambda[s],                                       (8)
*
*  where lambda[q] is multiplier for column q, lambda[s] is multiplier
*  for column s.
*
*  RECOVERING BASIC SOLUTION
*
*  With respect to (8) status of column q in solution to the original
*  problem is determined by status of column s in solution to the
*  transformed problem as follows:
*
*     +-----------------------+--------------------+
*     |  Status of column s   | Status of column q |
*     | (transformed problem) | (original problem) |
*     +-----------------------+--------------------+
*     |        GLP_BS         |       GLP_BS       |
*     |        GLP_NL         |       GLP_NU       |
*     |        GLP_NU         |       GLP_NL       |
*     +-----------------------+--------------------+
*
*  Value of column q is computed with formula (2).
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of column q is computed with formula (2).
*
*  RECOVERING MIP SOLUTION
*
*  Value of column q is computed with formula (2). */

static int rcv_ubnd_col(NPP *npp, void *info);

void npp_ubnd_col(NPP *npp, NPPCOL *q)
{     /* process column with upper bound */
      struct bnd_col *info;
      NPPROW *i;
      NPPAIJ *aij;
      /* the column must have upper bound */
      xassert(q->ub != +DBL_MAX);
      xassert(q->lb < q->ub);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_ubnd_col, sizeof(struct bnd_col));
      info->q = q->j;
      info->bnd = q->ub;
      /* substitute x[q] into objective row */
      npp->c0 += q->coef * q->ub;
      q->coef = -q->coef;
      /* substitute x[q] into constraint rows */
      for (aij = q->ptr; aij != NULL; aij = aij->c_next)
      {  i = aij->row;
         if (i->lb == i->ub)
            i->ub = (i->lb -= aij->val * q->ub);
         else
         {  if (i->lb != -DBL_MAX)
               i->lb -= aij->val * q->ub;
            if (i->ub != +DBL_MAX)
               i->ub -= aij->val * q->ub;
         }
         aij->val = -aij->val;
      }
      /* column x[q] becomes column s */
      if (q->lb != -DBL_MAX)
         q->ub -= q->lb;
      else
         q->ub = +DBL_MAX;
      q->lb = 0.0;
      return;
}

static int rcv_ubnd_col(NPP *npp, void *_info)
{     /* recover column with upper bound */
      struct bnd_col *info = _info;
      if (npp->sol == GLP_BS)
      {  if (npp->c_stat[info->q] == GLP_BS)
            npp->c_stat[info->q] = GLP_BS;
         else if (npp->c_stat[info->q] == GLP_NL)
            npp->c_stat[info->q] = GLP_NU;
         else if (npp->c_stat[info->q] == GLP_NU)
            npp->c_stat[info->q] = GLP_NL;
         else
         {  npp_error();
            return 1;
         }
      }
      /* compute value of x[q] with formula (2) */
      npp->c_value[info->q] = info->bnd - npp->c_value[info->q];
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_dbnd_col - process non-negative column with upper bound
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_dbnd_col(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_dbnd_col processes column q, which is non-negative
*  and has upper bound:
*
*     0 <= x[q] <= u[q],                                             (1)
*
*  where u[q] > 0.
*
*  PROBLEM TRANSFORMATION
*
*  Upper bound of column q can be replaced by the following equality
*  constraint:
*
*     x[q] + s = u[q],                                               (2)
*
*  where s >= 0 is a non-negative complement variable.
*
*  Since in the primal system along with new row (2) there appears a
*  new column s having the only non-zero coefficient in this row, in
*  the dual system there appears a new row:
*
*     (+1)pi + lambda[s] = 0,                                        (3)
*
*  where (+1) is coefficient at column s in row (2), pi is multiplier
*  for row (2), lambda[s] is multiplier for column s, 0 is coefficient
*  at column s in the objective row.
*
*  RECOVERING BASIC SOLUTION
*
*  Status of column q in solution to the original problem is determined
*  by its status and status of column s in solution to the transformed
*  problem as follows:
*
*     +-----------------------------------+------------------+
*     |         Transformed problem       | Original problem |
*     +-----------------+-----------------+------------------+
*     | Status of col q | Status of col s | Status of col q  |
*     +-----------------+-----------------+------------------+
*     |     GLP_BS      |     GLP_BS      |      GLP_BS      |
*     |     GLP_BS      |     GLP_NL      |      GLP_NU      |
*     |     GLP_NL      |     GLP_BS      |      GLP_NL      |
*     |     GLP_NL      |     GLP_NL      |      GLP_NL (*)  |
*     +-----------------+-----------------+------------------+
*
*  Value of column q in solution to the original problem is the same as
*  in solution to the transformed problem.
*
*  1. Formally, in solution to the transformed problem columns q and s
*     cannot be non-basic at the same time, since the constraint (2)
*     would be violated. However, if u[q] is close to zero, violation
*     may be less than a working precision even if both columns q and s
*     are non-basic. In this degenerate case row (2) can be only basic,
*     i.e. non-active constraint (otherwise corresponding row of the
*     basis matrix would be zero). This allows to pivot out auxiliary
*     variable and pivot in column s, in which case the row becomes
*     active while column s becomes basic.
*
*  2. If column q is integral, column s is also integral.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of column q in solution to the original problem is the same as
*  in solution to the transformed problem.
*
*  RECOVERING MIP SOLUTION
*
*  Value of column q in solution to the original problem is the same as
*  in solution to the transformed problem. */

struct dbnd_col
{     /* double-bounded column */
      int q;
      /* column reference number for variable x[q] */
      int s;
      /* column reference number for complement variable s */
};

static int rcv_dbnd_col(NPP *npp, void *info);

void npp_dbnd_col(NPP *npp, NPPCOL *q)
{     /* process non-negative column with upper bound */
      struct dbnd_col *info;
      NPPROW *p;
      NPPCOL *s;
      /* the column must be non-negative with upper bound */
      xassert(q->lb == 0.0);
      xassert(q->ub > 0.0);
      xassert(q->ub != +DBL_MAX);
      /* create variable s */
      s = npp_add_col(npp);
      s->is_int = q->is_int;
      s->lb = 0.0, s->ub = +DBL_MAX;
      /* create equality constraint (2) */
      p = npp_add_row(npp);
      p->lb = p->ub = q->ub;
      npp_add_aij(npp, p, q, +1.0);
      npp_add_aij(npp, p, s, +1.0);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_dbnd_col, sizeof(struct dbnd_col));
      info->q = q->j;
      info->s = s->j;
      /* remove upper bound of x[q] */
      q->ub = +DBL_MAX;
      return;
}

static int rcv_dbnd_col(NPP *npp, void *_info)
{     /* recover non-negative column with upper bound */
      struct dbnd_col *info = _info;
      if (npp->sol == GLP_BS)
      {  if (npp->c_stat[info->q] == GLP_BS)
         {  if (npp->c_stat[info->s] == GLP_BS)
               npp->c_stat[info->q] = GLP_BS;
            else if (npp->c_stat[info->s] == GLP_NL)
               npp->c_stat[info->q] = GLP_NU;
            else
            {  npp_error();
               return 1;
            }
         }
         else if (npp->c_stat[info->q] == GLP_NL)
         {  if (npp->c_stat[info->s] == GLP_BS ||
                npp->c_stat[info->s] == GLP_NL)
               npp->c_stat[info->q] = GLP_NL;
            else
            {  npp_error();
               return 1;
            }
         }
         else
         {  npp_error();
            return 1;
         }
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_fixed_col - process fixed column
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_fixed_col(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_fixed_col processes column q, which is fixed:
*
*     x[q] = s[q],                                                   (1)
*
*  where s[q] is a fixed column value.
*
*  PROBLEM TRANSFORMATION
*
*  The value of a fixed column can be substituted into the objective
*  and constraint rows that allows removing the column from the problem.
*
*  Substituting x[q] = s[q] into the objective row, we have:
*
*     z = sum c[j] x[j] + c0 =
*          j
*
*       = sum c[j] x[j] + c[q] x[q] + c0 =
*         j!=q
*
*       = sum c[j] x[j] + c[q] s[q] + c0 =
*         j!=q
*
*       = sum c[j] x[j] + c~0,
*         j!=q
*
*  where
*
*     c~0 = c0 + c[q] s[q]                                           (2)
*
*  is the constant term of the objective in the transformed problem.
*  Similarly, substituting x[q] = s[q] into constraint row i, we have:
*
*     L[i] <= sum a[i,j] x[j] <= U[i]  ==>
*              j
*
*     L[i] <= sum a[i,j] x[j] + a[i,q] x[q] <= U[i]  ==>
*             j!=q
*
*     L[i] <= sum a[i,j] x[j] + a[i,q] s[q] <= U[i]  ==>
*             j!=q
*
*     L~[i] <= sum a[i,j] x[j] + a[i,q] s <= U~[i],
*              j!=q
*
*  where
*
*     L~[i] = L[i] - a[i,q] s[q],  U~[i] = U[i] - a[i,q] s[q]        (3)
*
*  are lower and upper bounds of row i in the transformed problem,
*  resp.
*
*  RECOVERING BASIC SOLUTION
*
*  Column q is assigned status GLP_NS and its value is assigned s[q].
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of column q is assigned s[q].
*
*  RECOVERING MIP SOLUTION
*
*  Value of column q is assigned s[q]. */

struct fixed_col
{     /* fixed column */
      int q;
      /* column reference number for variable x[q] */
      double s;
      /* value, at which x[q] is fixed */
};

static int rcv_fixed_col(NPP *npp, void *info);

void npp_fixed_col(NPP *npp, NPPCOL *q)
{     /* process fixed column */
      struct fixed_col *info;
      NPPROW *i;
      NPPAIJ *aij;
      /* the column must be fixed */
      xassert(q->lb == q->ub);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_fixed_col, sizeof(struct fixed_col));
      info->q = q->j;
      info->s = q->lb;
      /* substitute x[q] = s[q] into objective row */
      npp->c0 += q->coef * q->lb;
      /* substitute x[q] = s[q] into constraint rows */
      for (aij = q->ptr; aij != NULL; aij = aij->c_next)
      {  i = aij->row;
         if (i->lb == i->ub)
            i->ub = (i->lb -= aij->val * q->lb);
         else
         {  if (i->lb != -DBL_MAX)
               i->lb -= aij->val * q->lb;
            if (i->ub != +DBL_MAX)
               i->ub -= aij->val * q->lb;
         }
      }
      /* remove the column from the problem */
      npp_del_col(npp, q);
      return;
}

static int rcv_fixed_col(NPP *npp, void *_info)
{     /* recover fixed column */
      struct fixed_col *info = _info;
      if (npp->sol == GLP_SOL)
         npp->c_stat[info->q] = GLP_NS;
      npp->c_value[info->q] = info->s;
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_make_equality - process row with almost identical bounds
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_make_equality(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_make_equality processes row p:
*
*     L[p] <= sum a[p,j] x[j] <= U[p],                               (1)
*              j
*
*  where -oo < L[p] < U[p] < +oo, i.e. which is double-sided inequality
*  constraint.
*
*  RETURNS
*
*  0 - row bounds have not been changed;
*
*  1 - row has been replaced by equality constraint.
*
*  PROBLEM TRANSFORMATION
*
*  If bounds of row (1) are very close to each other:
*
*     U[p] - L[p] <= eps,                                            (2)
*
*  where eps is an absolute tolerance for row value, the row can be
*  replaced by the following almost equivalent equiality constraint:
*
*     sum a[p,j] x[j] = b,                                           (3)
*      j
*
*  where b = (L[p] + U[p]) / 2. If the right-hand side in (3) happens
*  to be very close to its nearest integer:
*
*     |b - floor(b + 0.5)| <= eps,                                   (4)
*
*  it is reasonable to use this nearest integer as the right-hand side.
*
*  RECOVERING BASIC SOLUTION
*
*  Status of row p in solution to the original problem is determined
*  by its status and the sign of its multiplier pi[p] in solution to
*  the transformed problem as follows:
*
*     +-----------------------+---------+--------------------+
*     |    Status of row p    | Sign of |  Status of row p   |
*     | (transformed problem) |  pi[p]  | (original problem) |
*     +-----------------------+---------+--------------------+
*     |        GLP_BS         |  + / -  |       GLP_BS       |
*     |        GLP_NS         |    +    |       GLP_NL       |
*     |        GLP_NS         |    -    |       GLP_NU       |
*     +-----------------------+---------+--------------------+
*
*  Value of row multiplier pi[p] in solution to the original problem is
*  the same as in solution to the transformed problem.
*
*  RECOVERING INTERIOR POINT SOLUTION
*
*  Value of row multiplier pi[p] in solution to the original problem is
*  the same as in solution to the transformed problem.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

struct make_equality
{     /* row with almost identical bounds */
      int p;
      /* row reference number */
};

static int rcv_make_equality(NPP *npp, void *info);

int npp_make_equality(NPP *npp, NPPROW *p)
{     /* process row with almost identical bounds */
      struct make_equality *info;
      double b, eps, nint;
      /* the row must be double-sided inequality */
      xassert(p->lb != -DBL_MAX);
      xassert(p->ub != +DBL_MAX);
      xassert(p->lb < p->ub);
      /* check row bounds */
      eps = 1e-9 + 1e-12 * fabs(p->lb);
      if (p->ub - p->lb > eps) return 0;
      /* row bounds are very close to each other */
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_make_equality, sizeof(struct make_equality));
      info->p = p->i;
      /* compute right-hand side */
      b = 0.5 * (p->ub + p->lb);
      nint = floor(b + 0.5);
      if (fabs(b - nint) <= eps) b = nint;
      /* replace row p by almost equivalent equality constraint */
      p->lb = p->ub = b;
      return 1;
}

int rcv_make_equality(NPP *npp, void *_info)
{     /* recover row with almost identical bounds */
      struct make_equality *info = _info;
      if (npp->sol == GLP_SOL)
      {  if (npp->r_stat[info->p] == GLP_BS)
            npp->r_stat[info->p] = GLP_BS;
         else if (npp->r_stat[info->p] == GLP_NS)
         {  if (npp->r_pi[info->p] >= 0.0)
               npp->r_stat[info->p] = GLP_NL;
            else
               npp->r_stat[info->p] = GLP_NU;
         }
         else
         {  npp_error();
            return 1;
         }
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_make_fixed - process column with almost identical bounds
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_make_fixed(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_make_fixed processes column q:
*
*     l[q] <= x[q] <= u[q],                                          (1)
*
*  where -oo < l[q] < u[q] < +oo, i.e. which has both lower and upper
*  bounds.
*
*  RETURNS
*
*  0 - column bounds have not been changed;
*
*  1 - column has been fixed.
*
*  PROBLEM TRANSFORMATION
*
*  If bounds of column (1) are very close to each other:
*
*     u[q] - l[q] <= eps,                                            (2)
*
*  where eps is an absolute tolerance for column value, the column can
*  be fixed:
*
*     x[q] = s[q],                                                   (3)
*
*  where s[q] = (l[q] + u[q]) / 2. And if the fixed column value s[q]
*  happens to be very close to its nearest integer:
*
*     |s[q] - floor(s[q] + 0.5)| <= eps,                             (4)
*
*  it is reasonable to use this nearest integer as the fixed value.
*
*  RECOVERING BASIC SOLUTION
*
*  In the dual system of the original (as well as transformed) problem
*  column q corresponds to the following row:
*
*     sum a[i,q] pi[i] + lambda[q] = c[q].                           (5)
*      i
*
*  Since multipliers pi[i] are known for all rows from solution to the
*  transformed problem, formula (5) allows computing value of multiplier
*  (reduced cost) for column q:
*
*     lambda[q] = c[q] - sum a[i,q] pi[i].                           (6)
*                         i
*
*  Status of column q in solution to the original problem is determined
*  by its status and the sign of its multiplier lambda[q] in solution to
*  the transformed problem as follows:
*
*     +-----------------------+-----------+--------------------+
*     |  Status of column q   |  Sign of  | Status of column q |
*     | (transformed problem) | lambda[q] | (original problem) |
*     +-----------------------+-----------+--------------------+
*     |        GLP_BS         |   + / -   |       GLP_BS       |
*     |        GLP_NS         |     +     |       GLP_NL       |
*     |        GLP_NS         |     -     |       GLP_NU       |
*     +-----------------------+-----------+--------------------+
*
*  Value of column q in solution to the original problem is the same as
*  in solution to the transformed problem.
*
*  RECOVERING INTERIOR POINT SOLUTION
*
*  Value of column q in solution to the original problem is the same as
*  in solution to the transformed problem.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

struct make_fixed
{     /* column with almost identical bounds */
      int q;
      /* column reference number */
      double c;
      /* objective coefficient at x[q] */
      NPPLFE *ptr;
      /* list of non-zero coefficients a[i,q] */
};

static int rcv_make_fixed(NPP *npp, void *info);

int npp_make_fixed(NPP *npp, NPPCOL *q)
{     /* process column with almost identical bounds */
      struct make_fixed *info;
      NPPAIJ *aij;
      NPPLFE *lfe;
      double s, eps, nint;
      /* the column must be double-bounded */
      xassert(q->lb != -DBL_MAX);
      xassert(q->ub != +DBL_MAX);
      xassert(q->lb < q->ub);
      /* check column bounds */
      eps = 1e-9 + 1e-12 * fabs(q->lb);
      if (q->ub - q->lb > eps) return 0;
      /* column bounds are very close to each other */
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_make_fixed, sizeof(struct make_fixed));
      info->q = q->j;
      info->c = q->coef;
      info->ptr = NULL;
      /* save column coefficients a[i,q] (needed for basic solution
         only) */
      if (npp->sol == GLP_SOL)
      {  for (aij = q->ptr; aij != NULL; aij = aij->c_next)
         {  lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));
            lfe->ref = aij->row->i;
            lfe->val = aij->val;
            lfe->next = info->ptr;
            info->ptr = lfe;
         }
      }
      /* compute column fixed value */
      s = 0.5 * (q->ub + q->lb);
      nint = floor(s + 0.5);
      if (fabs(s - nint) <= eps) s = nint;
      /* make column q fixed */
      q->lb = q->ub = s;
      return 1;
}

static int rcv_make_fixed(NPP *npp, void *_info)
{     /* recover column with almost identical bounds */
      struct make_fixed *info = _info;
      NPPLFE *lfe;
      double lambda;
      if (npp->sol == GLP_SOL)
      {  if (npp->c_stat[info->q] == GLP_BS)
            npp->c_stat[info->q] = GLP_BS;
         else if (npp->c_stat[info->q] == GLP_NS)
         {  /* compute multiplier for column q with formula (6) */
            lambda = info->c;
            for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)
               lambda -= lfe->val * npp->r_pi[lfe->ref];
            /* assign status to non-basic column */
            if (lambda >= 0.0)
               npp->c_stat[info->q] = GLP_NL;
            else
               npp->c_stat[info->q] = GLP_NU;
         }
         else
         {  npp_error();
            return 1;
         }
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_empty_row - process empty row
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_empty_row(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_empty_row processes row p, which is empty, i.e.
*  coefficients at all columns in this row are zero:
*
*     L[p] <= sum 0 x[j] <= U[p],                                    (1)
*
*  where L[p] <= U[p].
*
*  RETURNS
*
*  0 - success;
*
*  1 - problem has no primal feasible solution.
*
*  PROBLEM TRANSFORMATION
*
*  If the following conditions hold:
*
*     L[p] <= +eps,  U[p] >= -eps,                                   (2)
*
*  where eps is an absolute tolerance for row value, the row p is
*  redundant. In this case it can be replaced by equivalent redundant
*  row, which is free (unbounded), and then removed from the problem.
*  Otherwise, the row p is infeasible and, thus, the problem has no
*  primal feasible solution.
*
*  RECOVERING BASIC SOLUTION
*
*  See the routine npp_free_row.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  See the routine npp_free_row.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

int npp_empty_row(NPP *npp, NPPROW *p)
{     /* process empty row */
      double eps = 1e-3;
      /* the row must be empty */
      xassert(p->ptr == NULL);
      /* check primal feasibility */
      if (p->lb > +eps || p->ub < -eps)
         return 1;
      /* replace the row by equivalent free (unbounded) row */
      p->lb = -DBL_MAX, p->ub = +DBL_MAX;
      /* and process it */
      npp_free_row(npp, p);
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_empty_col - process empty column
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_empty_col(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_empty_col processes column q:
*
*     l[q] <= x[q] <= u[q],                                          (1)
*
*  where l[q] <= u[q], which is empty, i.e. has zero coefficients in
*  all constraint rows.
*
*  RETURNS
*
*  0 - success;
*
*  1 - problem has no dual feasible solution.
*
*  PROBLEM TRANSFORMATION
*
*  The row of the dual system corresponding to the empty column is the
*  following:
*
*     sum 0 pi[i] + lambda[q] = c[q],                                (2)
*      i
*
*  from which it follows that:
*
*     lambda[q] = c[q].                                              (3)
*
*  If the following condition holds:
*
*     c[q] < - eps,                                                  (4)
*
*  where eps is an absolute tolerance for column multiplier, the lower
*  column bound l[q] must be active to provide dual feasibility (note
*  that being preprocessed the problem is always minimization). In this
*  case the column can be fixed on its lower bound and removed from the
*  problem (if the column is integral, its bounds are also assumed to
*  be integral). And if the column has no lower bound (l[q] = -oo), the
*  problem has no dual feasible solution.
*
*  If the following condition holds:
*
*     c[q] > + eps,                                                  (5)
*
*  the upper column bound u[q] must be active to provide dual
*  feasibility. In this case the column can be fixed on its upper bound
*  and removed from the problem. And if the column has no upper bound
*  (u[q] = +oo), the problem has no dual feasible solution.
*
*  Finally, if the following condition holds:
*
*     - eps <= c[q] <= +eps,                                         (6)
*
*  dual feasibility does not depend on a particular value of column q.
*  In this case the column can be fixed either on its lower bound (if
*  l[q] > -oo) or on its upper bound (if u[q] < +oo) or at zero (if the
*  column is unbounded) and then removed from the problem.
*
*  RECOVERING BASIC SOLUTION
*
*  See the routine npp_fixed_col. Having been recovered the column
*  is assigned status GLP_NS. However, if actually it is not fixed
*  (l[q] < u[q]), its status should be changed to GLP_NL, GLP_NU, or
*  GLP_NF depending on which bound it was fixed on transformation stage.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  See the routine npp_fixed_col.
*
*  RECOVERING MIP SOLUTION
*
*  See the routine npp_fixed_col. */

struct empty_col
{     /* empty column */
      int q;
      /* column reference number */
      char stat;
      /* status in basic solution */
};

static int rcv_empty_col(NPP *npp, void *info);

int npp_empty_col(NPP *npp, NPPCOL *q)
{     /* process empty column */
      struct empty_col *info;
      double eps = 1e-3;
      /* the column must be empty */
      xassert(q->ptr == NULL);
      /* check dual feasibility */
      if (q->coef > +eps && q->lb == -DBL_MAX)
         return 1;
      if (q->coef < -eps && q->ub == +DBL_MAX)
         return 1;
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_empty_col, sizeof(struct empty_col));
      info->q = q->j;
      /* fix the column */
      if (q->lb == -DBL_MAX && q->ub == +DBL_MAX)
      {  /* free column */
         info->stat = GLP_NF;
         q->lb = q->ub = 0.0;
      }
      else if (q->ub == +DBL_MAX)
lo:   {  /* column with lower bound */
         info->stat = GLP_NL;
         q->ub = q->lb;
      }
      else if (q->lb == -DBL_MAX)
up:   {  /* column with upper bound */
         info->stat = GLP_NU;
         q->lb = q->ub;
      }
      else if (q->lb != q->ub)
      {  /* double-bounded column */
         if (q->coef >= +DBL_EPSILON) goto lo;
         if (q->coef <= -DBL_EPSILON) goto up;
         if (fabs(q->lb) <= fabs(q->ub)) goto lo; else goto up;
      }
      else
      {  /* fixed column */
         info->stat = GLP_NS;
      }
      /* process fixed column */
      npp_fixed_col(npp, q);
      return 0;
}

static int rcv_empty_col(NPP *npp, void *_info)
{     /* recover empty column */
      struct empty_col *info = _info;
      if (npp->sol == GLP_SOL)
         npp->c_stat[info->q] = info->stat;
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_implied_value - process implied column value
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_implied_value(NPP *npp, NPPCOL *q, double s);
*
*  DESCRIPTION
*
*  For column q:
*
*     l[q] <= x[q] <= u[q],                                          (1)
*
*  where l[q] < u[q], the routine npp_implied_value processes its
*  implied value s[q]. If this implied value satisfies to the current
*  column bounds and integrality condition, the routine fixes column q
*  at the given point. Note that the column is kept in the problem in
*  any case.
*
*  RETURNS
*
*  0 - column has been fixed;
*
*  1 - implied value violates to current column bounds;
*
*  2 - implied value violates integrality condition.
*
*  ALGORITHM
*
*  Implied column value s[q] satisfies to the current column bounds if
*  the following condition holds:
*
*     l[q] - eps <= s[q] <= u[q] + eps,                              (2)
*
*  where eps is an absolute tolerance for column value. If the column
*  is integral, the following condition also must hold:
*
*     |s[q] - floor(s[q]+0.5)| <= eps,                               (3)
*
*  where floor(s[q]+0.5) is the nearest integer to s[q].
*
*  If both condition (2) and (3) are satisfied, the column can be fixed
*  at the value s[q], or, if it is integral, at floor(s[q]+0.5).
*  Otherwise, if s[q] violates (2) or (3), the problem has no feasible
*  solution.
*
*  Note: If s[q] is close to l[q] or u[q], it seems to be reasonable to
*  fix the column at its lower or upper bound, resp. rather than at the
*  implied value. */

int npp_implied_value(NPP *npp, NPPCOL *q, double s)
{     /* process implied column value */
      double eps, nint;
      xassert(npp == npp);
      /* column must not be fixed */
      xassert(q->lb < q->ub);
      /* check integrality */
      if (q->is_int)
      {  nint = floor(s + 0.5);
         if (fabs(s - nint) <= 1e-5)
            s = nint;
         else
            return 2;
      }
      /* check current column lower bound */
      if (q->lb != -DBL_MAX)
      {  eps = (q->is_int ? 1e-5 : 1e-5 + 1e-8 * fabs(q->lb));
         if (s < q->lb - eps) return 1;
         /* if s[q] is close to l[q], fix column at its lower bound
            rather than at the implied value */
         if (s < q->lb + 1e-3 * eps)
         {  q->ub = q->lb;
            return 0;
         }
      }
      /* check current column upper bound */
      if (q->ub != +DBL_MAX)
      {  eps = (q->is_int ? 1e-5 : 1e-5 + 1e-8 * fabs(q->ub));
         if (s > q->ub + eps) return 1;
         /* if s[q] is close to u[q], fix column at its upper bound
            rather than at the implied value */
         if (s > q->ub - 1e-3 * eps)
         {  q->lb = q->ub;
            return 0;
         }
      }
      /* fix column at the implied value */
      q->lb = q->ub = s;
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_eq_singlet - process row singleton (equality constraint)
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_eq_singlet(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_eq_singlet processes row p, which is equiality
*  constraint having the only non-zero coefficient:
*
*     a[p,q] x[q] = b.                                               (1)
*
*  RETURNS
*
*  0 - success;
*
*  1 - problem has no primal feasible solution;
*
*  2 - problem has no integer feasible solution.
*
*  PROBLEM TRANSFORMATION
*
*  The equality constraint defines implied value of column q:
*
*     x[q] = s[q] = b / a[p,q].                                      (2)
*
*  If the implied value s[q] satisfies to the column bounds (see the
*  routine npp_implied_value), the column can be fixed at s[q] and
*  removed from the problem. In this case row p becomes redundant, so
*  it can be replaced by equivalent free row and also removed from the
*  problem.
*
*  Note that the routine removes from the problem only row p. Column q
*  becomes fixed, however, it is kept in the problem.
*
*  RECOVERING BASIC SOLUTION
*
*  In solution to the original problem row p is assigned status GLP_NS
*  (active equality constraint), and column q is assigned status GLP_BS
*  (basic column).
*
*  Multiplier for row p can be computed as follows. In the dual system
*  of the original problem column q corresponds to the following row:
*
*     sum a[i,q] pi[i] + lambda[q] = c[q]  ==>
*      i
*
*     sum a[i,q] pi[i] + a[p,q] pi[p] + lambda[q] = c[q].
*     i!=p
*
*  Therefore:
*
*               1
*     pi[p] = ------ (c[q] - lambda[q] - sum a[i,q] pi[i]),          (3)
*             a[p,q]                     i!=q
*
*  where lambda[q] = 0 (since column[q] is basic), and pi[i] for all
*  i != p are known in solution to the transformed problem.
*
*  Value of column q in solution to the original problem is assigned
*  its implied value s[q].
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Multiplier for row p is computed with formula (3). Value of column
*  q is assigned its implied value s[q].
*
*  RECOVERING MIP SOLUTION
*
*  Value of column q is assigned its implied value s[q]. */

struct eq_singlet
{     /* row singleton (equality constraint) */
      int p;
      /* row reference number */
      int q;
      /* column reference number */
      double apq;
      /* constraint coefficient a[p,q] */
      double c;
      /* objective coefficient at x[q] */
      NPPLFE *ptr;
      /* list of non-zero coefficients a[i,q], i != p */
};

static int rcv_eq_singlet(NPP *npp, void *info);

int npp_eq_singlet(NPP *npp, NPPROW *p)
{     /* process row singleton (equality constraint) */
      struct eq_singlet *info;
      NPPCOL *q;
      NPPAIJ *aij;
      NPPLFE *lfe;
      int ret;
      double s;
      /* the row must be singleton equality constraint */
      xassert(p->lb == p->ub);
      xassert(p->ptr != NULL && p->ptr->r_next == NULL);
      /* compute and process implied column value */
      aij = p->ptr;
      q = aij->col;
      s = p->lb / aij->val;
      ret = npp_implied_value(npp, q, s);
      xassert(0 <= ret && ret <= 2);
      if (ret != 0) return ret;
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_eq_singlet, sizeof(struct eq_singlet));
      info->p = p->i;
      info->q = q->j;
      info->apq = aij->val;
      info->c = q->coef;
      info->ptr = NULL;
      /* save column coefficients a[i,q], i != p (not needed for MIP
         solution) */
      if (npp->sol != GLP_MIP)
      {  for (aij = q->ptr; aij != NULL; aij = aij->c_next)
         {  if (aij->row == p) continue; /* skip a[p,q] */
            lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));
            lfe->ref = aij->row->i;
            lfe->val = aij->val;
            lfe->next = info->ptr;
            info->ptr = lfe;
         }
      }
      /* remove the row from the problem */
      npp_del_row(npp, p);
      return 0;
}

static int rcv_eq_singlet(NPP *npp, void *_info)
{     /* recover row singleton (equality constraint) */
      struct eq_singlet *info = _info;
      NPPLFE *lfe;
      double temp;
      if (npp->sol == GLP_SOL)
      {  /* column q must be already recovered as GLP_NS */
         if (npp->c_stat[info->q] != GLP_NS)
         {  npp_error();
            return 1;
         }
         npp->r_stat[info->p] = GLP_NS;
         npp->c_stat[info->q] = GLP_BS;
      }
      if (npp->sol != GLP_MIP)
      {  /* compute multiplier for row p with formula (3) */
         temp = info->c;
         for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)
            temp -= lfe->val * npp->r_pi[lfe->ref];
         npp->r_pi[info->p] = temp / info->apq;
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_implied_lower - process implied column lower bound
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_implied_lower(NPP *npp, NPPCOL *q, double l);
*
*  DESCRIPTION
*
*  For column q:
*
*     l[q] <= x[q] <= u[q],                                          (1)
*
*  where l[q] < u[q], the routine npp_implied_lower processes its
*  implied lower bound l'[q]. As the result the current column lower
*  bound may increase. Note that the column is kept in the problem in
*  any case.
*
*  RETURNS
*
*  0 - current column lower bound has not changed;
*
*  1 - current column lower bound has changed, but not significantly;
*
*  2 - current column lower bound has significantly changed;
*
*  3 - column has been fixed on its upper bound;
*
*  4 - implied lower bound violates current column upper bound.
*
*  ALGORITHM
*
*  If column q is integral, before processing its implied lower bound
*  should be rounded up:
*
*              ( floor(l'[q]+0.5), if |l'[q] - floor(l'[q]+0.5)| <= eps
*     l'[q] := <                                                     (2)
*              ( ceil(l'[q]),      otherwise
*
*  where floor(l'[q]+0.5) is the nearest integer to l'[q], ceil(l'[q])
*  is smallest integer not less than l'[q], and eps is an absolute
*  tolerance for column value.
*
*  Processing implied column lower bound l'[q] includes the following
*  cases:
*
*  1) if l'[q] < l[q] + eps, implied lower bound is redundant;
*
*  2) if l[q] + eps <= l[q] <= u[q] + eps, current column lower bound
*     l[q] can be strengthened by replacing it with l'[q]. If in this
*     case new column lower bound becomes close to current column upper
*     bound u[q], the column can be fixed on its upper bound;
*
*  3) if l'[q] > u[q] + eps, implied lower bound violates current
*     column upper bound u[q], in which case the problem has no primal
*     feasible solution. */

int npp_implied_lower(NPP *npp, NPPCOL *q, double l)
{     /* process implied column lower bound */
      int ret;
      double eps, nint;
      xassert(npp == npp);
      /* column must not be fixed */
      xassert(q->lb < q->ub);
      /* implied lower bound must be finite */
      xassert(l != -DBL_MAX);
      /* if column is integral, round up l'[q] */
      if (q->is_int)
      {  nint = floor(l + 0.5);
         if (fabs(l - nint) <= 1e-5)
            l = nint;
         else
            l = ceil(l);
      }
      /* check current column lower bound */
      if (q->lb != -DBL_MAX)
      {  eps = (q->is_int ? 1e-3 : 1e-3 + 1e-6 * fabs(q->lb));
         if (l < q->lb + eps)
         {  ret = 0; /* redundant */
            goto done;
         }
      }
      /* check current column upper bound */
      if (q->ub != +DBL_MAX)
      {  eps = (q->is_int ? 1e-5 : 1e-5 + 1e-8 * fabs(q->ub));
         if (l > q->ub + eps)
         {  ret = 4; /* infeasible */
            goto done;
         }
         /* if l'[q] is close to u[q], fix column at its upper bound */
         if (l > q->ub - 1e-3 * eps)
         {  q->lb = q->ub;
            ret = 3; /* fixed */
            goto done;
         }
      }
      /* check if column lower bound changes significantly */
      if (q->lb == -DBL_MAX)
         ret = 2; /* significantly */
      else if (q->is_int && l > q->lb + 0.5)
         ret = 2; /* significantly */
      else if (l > q->lb + 0.30 * (1.0 + fabs(q->lb)))
         ret = 2; /* significantly */
      else
         ret = 1; /* not significantly */
      /* set new column lower bound */
      q->lb = l;
done: return ret;
}

/***********************************************************************
*  NAME
*
*  npp_implied_upper - process implied column upper bound
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_implied_upper(NPP *npp, NPPCOL *q, double u);
*
*  DESCRIPTION
*
*  For column q:
*
*     l[q] <= x[q] <= u[q],                                          (1)
*
*  where l[q] < u[q], the routine npp_implied_upper processes its
*  implied upper bound u'[q]. As the result the current column upper
*  bound may decrease. Note that the column is kept in the problem in
*  any case.
*
*  RETURNS
*
*  0 - current column upper bound has not changed;
*
*  1 - current column upper bound has changed, but not significantly;
*
*  2 - current column upper bound has significantly changed;
*
*  3 - column has been fixed on its lower bound;
*
*  4 - implied upper bound violates current column lower bound.
*
*  ALGORITHM
*
*  If column q is integral, before processing its implied upper bound
*  should be rounded down:
*
*              ( floor(u'[q]+0.5), if |u'[q] - floor(l'[q]+0.5)| <= eps
*     u'[q] := <                                                     (2)
*              ( floor(l'[q]),     otherwise
*
*  where floor(u'[q]+0.5) is the nearest integer to u'[q],
*  floor(u'[q]) is largest integer not greater than u'[q], and eps is
*  an absolute tolerance for column value.
*
*  Processing implied column upper bound u'[q] includes the following
*  cases:
*
*  1) if u'[q] > u[q] - eps, implied upper bound is redundant;
*
*  2) if l[q] - eps <= u[q] <= u[q] - eps, current column upper bound
*     u[q] can be strengthened by replacing it with u'[q]. If in this
*     case new column upper bound becomes close to current column lower
*     bound, the column can be fixed on its lower bound;
*
*  3) if u'[q] < l[q] - eps, implied upper bound violates current
*     column lower bound l[q], in which case the problem has no primal
*     feasible solution. */

int npp_implied_upper(NPP *npp, NPPCOL *q, double u)
{     int ret;
      double eps, nint;
      xassert(npp == npp);
      /* column must not be fixed */
      xassert(q->lb < q->ub);
      /* implied upper bound must be finite */
      xassert(u != +DBL_MAX);
      /* if column is integral, round down u'[q] */
      if (q->is_int)
      {  nint = floor(u + 0.5);
         if (fabs(u - nint) <= 1e-5)
            u = nint;
         else
            u = floor(u);
      }
      /* check current column upper bound */
      if (q->ub != +DBL_MAX)
      {  eps = (q->is_int ? 1e-3 : 1e-3 + 1e-6 * fabs(q->ub));
         if (u > q->ub - eps)
         {  ret = 0; /* redundant */
            goto done;
         }
      }
      /* check current column lower bound */
      if (q->lb != -DBL_MAX)
      {  eps = (q->is_int ? 1e-5 : 1e-5 + 1e-8 * fabs(q->lb));
         if (u < q->lb - eps)
         {  ret = 4; /* infeasible */
            goto done;
         }
         /* if u'[q] is close to l[q], fix column at its lower bound */
         if (u < q->lb + 1e-3 * eps)
         {  q->ub = q->lb;
            ret = 3; /* fixed */
            goto done;
         }
      }
      /* check if column upper bound changes significantly */
      if (q->ub == +DBL_MAX)
         ret = 2; /* significantly */
      else if (q->is_int && u < q->ub - 0.5)
         ret = 2; /* significantly */
      else if (u < q->ub - 0.30 * (1.0 + fabs(q->ub)))
         ret = 2; /* significantly */
      else
         ret = 1; /* not significantly */
      /* set new column upper bound */
      q->ub = u;
done: return ret;
}

/***********************************************************************
*  NAME
*
*  npp_ineq_singlet - process row singleton (inequality constraint)
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_ineq_singlet(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_ineq_singlet processes row p, which is inequality
*  constraint having the only non-zero coefficient:
*
*     L[p] <= a[p,q] * x[q] <= U[p],                                 (1)
*
*  where L[p] < U[p], L[p] > -oo and/or U[p] < +oo.
*
*  RETURNS
*
*  0 - current column bounds have not changed;
*
*  1 - current column bounds have changed, but not significantly;
*
*  2 - current column bounds have significantly changed;
*
*  3 - column has been fixed on its lower or upper bound;
*
*  4 - problem has no primal feasible solution.
*
*  PROBLEM TRANSFORMATION
*
*  Inequality constraint (1) defines implied bounds of column q:
*
*             (  L[p] / a[p,q],  if a[p,q] > 0
*     l'[q] = <                                                      (2)
*             (  U[p] / a[p,q],  if a[p,q] < 0
*
*             (  U[p] / a[p,q],  if a[p,q] > 0
*     u'[q] = <                                                      (3)
*             (  L[p] / a[p,q],  if a[p,q] < 0
*
*  If these implied bounds do not violate current bounds of column q:
*
*     l[q] <= x[q] <= u[q],                                          (4)
*
*  they can be used to strengthen the current column bounds:
*
*     l[q] := max(l[q], l'[q]),                                      (5)
*
*     u[q] := min(u[q], u'[q]).                                      (6)
*
*  (See the routines npp_implied_lower and npp_implied_upper.)
*
*  Once bounds of row p (1) have been carried over column q, the row
*  becomes redundant, so it can be replaced by equivalent free row and
*  removed from the problem.
*
*  Note that the routine removes from the problem only row p. Column q,
*  even it has been fixed, is kept in the problem.
*
*  RECOVERING BASIC SOLUTION
*
*  Note that the row in the dual system corresponding to column q is
*  the following:
*
*     sum a[i,q] pi[i] + lambda[q] = c[q]  ==>
*      i
*                                                                    (7)
*     sum a[i,q] pi[i] + a[p,q] pi[p] + lambda[q] = c[q],
*     i!=p
*
*  where pi[i] for all i != p are known in solution to the transformed
*  problem. Row p does not exist in the transformed problem, so it has
*  zero multiplier there. This allows computing multiplier for column q
*  in solution to the transformed problem:
*
*     lambda~[q] = c[q] - sum a[i,q] pi[i].                          (8)
*                         i!=p
*
*  Let in solution to the transformed problem column q be non-basic
*  with lower bound active (GLP_NL, lambda~[q] >= 0), and this lower
*  bound be implied one l'[q]. From the original problem's standpoint
*  this then means that actually the original column lower bound l[q]
*  is inactive, and active is that row bound L[p] or U[p] that defines
*  the implied bound l'[q] (2). In this case in solution to the
*  original problem column q is assigned status GLP_BS while row p is
*  assigned status GLP_NL (if a[p,q] > 0) or GLP_NU (if a[p,q] < 0).
*  Since now column q is basic, its multiplier lambda[q] is zero. This
*  allows using (7) and (8) to find multiplier for row p in solution to
*  the original problem:
*
*               1
*     pi[p] = ------ (c[q] - sum a[i,q] pi[i]) = lambda~[q] / a[p,q] (9)
*             a[p,q]         i!=p
*
*  Now let in solution to the transformed problem column q be non-basic
*  with upper bound active (GLP_NU, lambda~[q] <= 0), and this upper
*  bound be implied one u'[q]. As in the previous case this then means
*  that from the original problem's standpoint actually the original
*  column upper bound u[q] is inactive, and active is that row bound
*  L[p] or U[p] that defines the implied bound u'[q] (3). In this case
*  in solution to the original problem column q is assigned status
*  GLP_BS, row p is assigned status GLP_NU (if a[p,q] > 0) or GLP_NL
*  (if a[p,q] < 0), and its multiplier is computed with formula (9).
*
*  Strengthening bounds of column q according to (5) and (6) may make
*  it fixed. Thus, if in solution to the transformed problem column q is
*  non-basic and fixed (GLP_NS), we can suppose that if lambda~[q] > 0,
*  column q has active lower bound (GLP_NL), and if lambda~[q] < 0,
*  column q has active upper bound (GLP_NU), reducing this case to two
*  previous ones. If, however, lambda~[q] is close to zero or
*  corresponding bound of row p does not exist (this may happen if
*  lambda~[q] has wrong sign due to round-off errors, in which case it
*  is expected to be close to zero, since solution is assumed to be dual
*  feasible), column q can be assigned status GLP_BS (basic), and row p
*  can be made active on its existing bound. In the latter case row
*  multiplier pi[p] computed with formula (9) will be also close to
*  zero, and dual feasibility will be kept.
*
*  In all other cases, namely, if in solution to the transformed
*  problem column q is basic (GLP_BS), or non-basic with original lower
*  bound l[q] active (GLP_NL), or non-basic with original upper bound
*  u[q] active (GLP_NU), constraint (1) is inactive. So in solution to
*  the original problem status of column q remains unchanged, row p is
*  assigned status GLP_BS, and its multiplier pi[p] is assigned zero
*  value.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  First, value of multiplier for column q in solution to the original
*  problem is computed with formula (8). If lambda~[q] > 0 and column q
*  has implied lower bound, or if lambda~[q] < 0 and column q has
*  implied upper bound, this means that from the original problem's
*  standpoint actually row p has corresponding active bound, in which
*  case its multiplier pi[p] is computed with formula (9). In other
*  cases, when the sign of lambda~[q] corresponds to original bound of
*  column q, or when lambda~[q] =~ 0, value of row multiplier pi[p] is
*  assigned zero value.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

struct ineq_singlet
{     /* row singleton (inequality constraint) */
      int p;
      /* row reference number */
      int q;
      /* column reference number */
      double apq;
      /* constraint coefficient a[p,q] */
      double c;
      /* objective coefficient at x[q] */
      double lb;
      /* row lower bound */
      double ub;
      /* row upper bound */
      char lb_changed;
      /* this flag is set if column lower bound was changed */
      char ub_changed;
      /* this flag is set if column upper bound was changed */
      NPPLFE *ptr;
      /* list of non-zero coefficients a[i,q], i != p */
};

static int rcv_ineq_singlet(NPP *npp, void *info);

int npp_ineq_singlet(NPP *npp, NPPROW *p)
{     /* process row singleton (inequality constraint) */
      struct ineq_singlet *info;
      NPPCOL *q;
      NPPAIJ *apq, *aij;
      NPPLFE *lfe;
      int lb_changed, ub_changed;
      double ll, uu;
      /* the row must be singleton inequality constraint */
      xassert(p->lb != -DBL_MAX || p->ub != +DBL_MAX);
      xassert(p->lb < p->ub);
      xassert(p->ptr != NULL && p->ptr->r_next == NULL);
      /* compute implied column bounds */
      apq = p->ptr;
      q = apq->col;
      xassert(q->lb < q->ub);
      if (apq->val > 0.0)
      {  ll = (p->lb == -DBL_MAX ? -DBL_MAX : p->lb / apq->val);
         uu = (p->ub == +DBL_MAX ? +DBL_MAX : p->ub / apq->val);
      }
      else
      {  ll = (p->ub == +DBL_MAX ? -DBL_MAX : p->ub / apq->val);
         uu = (p->lb == -DBL_MAX ? +DBL_MAX : p->lb / apq->val);
      }
      /* process implied column lower bound */
      if (ll == -DBL_MAX)
         lb_changed = 0;
      else
      {  lb_changed = npp_implied_lower(npp, q, ll);
         xassert(0 <= lb_changed && lb_changed <= 4);
         if (lb_changed == 4) return 4; /* infeasible */
      }
      /* process implied column upper bound */
      if (uu == +DBL_MAX)
         ub_changed = 0;
      else if (lb_changed == 3)
      {  /* column was fixed on its upper bound due to l'[q] = u[q] */
         /* note that L[p] < U[p], so l'[q] = u[q] < u'[q] */
         ub_changed = 0;
      }
      else
      {  ub_changed = npp_implied_upper(npp, q, uu);
         xassert(0 <= ub_changed && ub_changed <= 4);
         if (ub_changed == 4) return 4; /* infeasible */
      }
      /* if neither lower nor upper column bound was changed, the row
         is originally redundant and can be replaced by free row */
      if (!lb_changed && !ub_changed)
      {  p->lb = -DBL_MAX, p->ub = +DBL_MAX;
         npp_free_row(npp, p);
         return 0;
      }
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_ineq_singlet, sizeof(struct ineq_singlet));
      info->p = p->i;
      info->q = q->j;
      info->apq = apq->val;
      info->c = q->coef;
      info->lb = p->lb;
      info->ub = p->ub;
      info->lb_changed = (char)lb_changed;
      info->ub_changed = (char)ub_changed;
      info->ptr = NULL;
      /* save column coefficients a[i,q], i != p (not needed for MIP
         solution) */
      if (npp->sol != GLP_MIP)
      {  for (aij = q->ptr; aij != NULL; aij = aij->c_next)
         {  if (aij == apq) continue; /* skip a[p,q] */
            lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));
            lfe->ref = aij->row->i;
            lfe->val = aij->val;
            lfe->next = info->ptr;
            info->ptr = lfe;
         }
      }
      /* remove the row from the problem */
      npp_del_row(npp, p);
      return lb_changed >= ub_changed ? lb_changed : ub_changed;
}

static int rcv_ineq_singlet(NPP *npp, void *_info)
{     /* recover row singleton (inequality constraint) */
      struct ineq_singlet *info = _info;
      NPPLFE *lfe;
      double lambda;
      if (npp->sol == GLP_MIP) goto done;
      /* compute lambda~[q] in solution to the transformed problem
         with formula (8) */
      lambda = info->c;
      for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)
         lambda -= lfe->val * npp->r_pi[lfe->ref];
      if (npp->sol == GLP_SOL)
      {  /* recover basic solution */
         if (npp->c_stat[info->q] == GLP_BS)
         {  /* column q is basic, so row p is inactive */
            npp->r_stat[info->p] = GLP_BS;
            npp->r_pi[info->p] = 0.0;
         }
         else if (npp->c_stat[info->q] == GLP_NL)
nl:      {  /* column q is non-basic with lower bound active */
            if (info->lb_changed)
            {  /* it is implied bound, so actually row p is active
                  while column q is basic */
               npp->r_stat[info->p] =
                  (char)(info->apq > 0.0 ? GLP_NL : GLP_NU);
               npp->c_stat[info->q] = GLP_BS;
               npp->r_pi[info->p] = lambda / info->apq;
            }
            else
            {  /* it is original bound, so row p is inactive */
               npp->r_stat[info->p] = GLP_BS;
               npp->r_pi[info->p] = 0.0;
            }
         }
         else if (npp->c_stat[info->q] == GLP_NU)
nu:      {  /* column q is non-basic with upper bound active */
            if (info->ub_changed)
            {  /* it is implied bound, so actually row p is active
                  while column q is basic */
               npp->r_stat[info->p] =
                  (char)(info->apq > 0.0 ? GLP_NU : GLP_NL);
               npp->c_stat[info->q] = GLP_BS;
               npp->r_pi[info->p] = lambda / info->apq;
            }
            else
            {  /* it is original bound, so row p is inactive */
               npp->r_stat[info->p] = GLP_BS;
               npp->r_pi[info->p] = 0.0;
            }
         }
         else if (npp->c_stat[info->q] == GLP_NS)
         {  /* column q is non-basic and fixed; note, however, that in
               in the original problem it is non-fixed */
            if (lambda > +1e-7)
            {  if (info->apq > 0.0 && info->lb != -DBL_MAX ||
                   info->apq < 0.0 && info->ub != +DBL_MAX ||
                  !info->lb_changed)
               {  /* either corresponding bound of row p exists or
                     column q remains non-basic with its original lower
                     bound active */
                  npp->c_stat[info->q] = GLP_NL;
                  goto nl;
               }
            }
            if (lambda < -1e-7)
            {  if (info->apq > 0.0 && info->ub != +DBL_MAX ||
                   info->apq < 0.0 && info->lb != -DBL_MAX ||
                  !info->ub_changed)
               {  /* either corresponding bound of row p exists or
                     column q remains non-basic with its original upper
                     bound active */
                  npp->c_stat[info->q] = GLP_NU;
                  goto nu;
               }
            }
            /* either lambda~[q] is close to zero, or corresponding
               bound of row p does not exist, because lambda~[q] has
               wrong sign due to round-off errors; in the latter case
               lambda~[q] is also assumed to be close to zero; so, we
               can make row p active on its existing bound and column q
               basic; pi[p] will have wrong sign, but it also will be
               close to zero (rarus casus of dual degeneracy) */
            if (info->lb != -DBL_MAX && info->ub == +DBL_MAX)
            {  /* row lower bound exists, but upper bound doesn't */
               npp->r_stat[info->p] = GLP_NL;
            }
            else if (info->lb == -DBL_MAX && info->ub != +DBL_MAX)
            {  /* row upper bound exists, but lower bound doesn't */
               npp->r_stat[info->p] = GLP_NU;
            }
            else if (info->lb != -DBL_MAX && info->ub != +DBL_MAX)
            {  /* both row lower and upper bounds exist */
               /* to choose proper active row bound we should not use
                  lambda~[q], because its value being close to zero is
                  unreliable; so we choose that bound which provides
                  primal feasibility for original constraint (1) */
               if (info->apq * npp->c_value[info->q] <=
                   0.5 * (info->lb + info->ub))
                  npp->r_stat[info->p] = GLP_NL;
               else
                  npp->r_stat[info->p] = GLP_NU;
            }
            else
            {  npp_error();
               return 1;
            }
            npp->c_stat[info->q] = GLP_BS;
            npp->r_pi[info->p] = lambda / info->apq;
         }
         else
         {  npp_error();
            return 1;
         }
      }
      if (npp->sol == GLP_IPT)
      {  /* recover interior-point solution */
         if (lambda > +DBL_EPSILON && info->lb_changed ||
             lambda < -DBL_EPSILON && info->ub_changed)
         {  /* actually row p has corresponding active bound */
            npp->r_pi[info->p] = lambda / info->apq;
         }
         else
         {  /* either bounds of column q are both inactive or its
               original bound is active */
            npp->r_pi[info->p] = 0.0;
         }
      }
done: return 0;
}

/***********************************************************************
*  NAME
*
*  npp_implied_slack - process column singleton (implied slack variable)
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_implied_slack(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_implied_slack processes column q:
*
*     l[q] <= x[q] <= u[q],                                          (1)
*
*  where l[q] < u[q], having the only non-zero coefficient in row p,
*  which is equality constraint:
*
*     sum a[p,j] x[j] + a[p,q] x[q] = b.                             (2)
*     j!=q
*
*  PROBLEM TRANSFORMATION
*
*  (If x[q] is integral, this transformation must not be used.)
*
*  The term a[p,q] x[q] in constraint (2) can be considered as a slack
*  variable that allows to carry bounds of column q over row p and then
*  remove column q from the problem.
*
*  Constraint (2) can be written as follows:
*
*     sum a[p,j] x[j] = b - a[p,q] x[q].                             (3)
*     j!=q
*
*  According to (1) constraint (3) is equivalent to the following
*  inequality constraint:
*
*     L[p] <= sum a[p,j] x[j] <= U[p],                               (4)
*             j!=q
*
*  where
*
*            ( b - a[p,q] u[q],  if a[p,q] > 0
*     L[p] = <                                                       (5)
*            ( b - a[p,q] l[q],  if a[p,q] < 0
*
*            ( b - a[p,q] l[q],  if a[p,q] > 0
*     U[p] = <                                                       (6)
*            ( b - a[p,q] u[q],  if a[p,q] < 0
*
*  From (2) it follows that:
*
*              1
*     x[q] = ------ (b - sum a[p,j] x[j]).                           (7)
*            a[p,q]      j!=q
*
*  In order to eliminate x[q] from the objective row we substitute it
*  from (6) to that row:
*
*     z = sum c[j] x[j] + c[q] x[q] + c[0] =
*         j!=q
*                                 1
*       = sum c[j] x[j] + c[q] [------ (b - sum a[p,j] x[j])] + c0 =
*         j!=q                  a[p,q]      j!=q
*
*       = sum c~[j] x[j] + c~[0],
*         j!=q
*                         a[p,j]                     b
*     c~[j] = c[j] - c[q] ------,  c~0 = c0 - c[q] ------            (8)
*                         a[p,q]                   a[p,q]
*
*  are values of objective coefficients and constant term, resp., in
*  the transformed problem.
*
*  Note that column q is column singleton, so in the dual system of the
*  original problem it corresponds to the following row singleton:
*
*     a[p,q] pi[p] + lambda[q] = c[q].                               (9)
*
*  In the transformed problem row (9) would be the following:
*
*     a[p,q] pi~[p] + lambda[q] = c~[q] = 0.                        (10)
*
*  Subtracting (10) from (9) we have:
*
*     a[p,q] (pi[p] - pi~[p]) = c[q]
*
*  that gives the following formula to compute multiplier for row p in
*  solution to the original problem using its value in solution to the
*  transformed problem:
*
*     pi[p] = pi~[p] + c[q] / a[p,q].                               (11)
*
*  RECOVERING BASIC SOLUTION
*
*  Status of column q in solution to the original problem is defined
*  by status of row p in solution to the transformed problem and the
*  sign of coefficient a[p,q] in the original inequality constraint (2)
*  as follows:
*
*     +-----------------------+---------+--------------------+
*     |    Status of row p    | Sign of | Status of column q |
*     | (transformed problem) | a[p,q]  | (original problem) |
*     +-----------------------+---------+--------------------+
*     |        GLP_BS         |  + / -  |       GLP_BS       |
*     |        GLP_NL         |    +    |       GLP_NU       |
*     |        GLP_NL         |    -    |       GLP_NL       |
*     |        GLP_NU         |    +    |       GLP_NL       |
*     |        GLP_NU         |    -    |       GLP_NU       |
*     |        GLP_NF         |  + / -  |       GLP_NF       |
*     +-----------------------+---------+--------------------+
*
*  Value of column q is computed with formula (7). Since originally row
*  p is equality constraint, its status is assigned GLP_NS, and value of
*  its multiplier pi[p] is computed with formula (11).
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of column q is computed with formula (7). Row multiplier value
*  pi[p] is computed with formula (11).
*
*  RECOVERING MIP SOLUTION
*
*  Value of column q is computed with formula (7). */

struct implied_slack
{     /* column singleton (implied slack variable) */
      int p;
      /* row reference number */
      int q;
      /* column reference number */
      double apq;
      /* constraint coefficient a[p,q] */
      double b;
      /* right-hand side of original equality constraint */
      double c;
      /* original objective coefficient at x[q] */
      NPPLFE *ptr;
      /* list of non-zero coefficients a[p,j], j != q */
};

static int rcv_implied_slack(NPP *npp, void *info);

void npp_implied_slack(NPP *npp, NPPCOL *q)
{     /* process column singleton (implied slack variable) */
      struct implied_slack *info;
      NPPROW *p;
      NPPAIJ *aij;
      NPPLFE *lfe;
      /* the column must be non-integral non-fixed singleton */
      xassert(!q->is_int);
      xassert(q->lb < q->ub);
      xassert(q->ptr != NULL && q->ptr->c_next == NULL);
      /* corresponding row must be equality constraint */
      aij = q->ptr;
      p = aij->row;
      xassert(p->lb == p->ub);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_implied_slack, sizeof(struct implied_slack));
      info->p = p->i;
      info->q = q->j;
      info->apq = aij->val;
      info->b = p->lb;
      info->c = q->coef;
      info->ptr = NULL;
      /* save row coefficients a[p,j], j != q, and substitute x[q]
         into the objective row */
      for (aij = p->ptr; aij != NULL; aij = aij->r_next)
      {  if (aij->col == q) continue; /* skip a[p,q] */
         lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));
         lfe->ref = aij->col->j;
         lfe->val = aij->val;
         lfe->next = info->ptr;
         info->ptr = lfe;
         aij->col->coef -= info->c * (aij->val / info->apq);
      }
      npp->c0 += info->c * (info->b / info->apq);
      /* compute new row bounds */
      if (info->apq > 0.0)
      {  p->lb = (q->ub == +DBL_MAX ?
            -DBL_MAX : info->b - info->apq * q->ub);
         p->ub = (q->lb == -DBL_MAX ?
            +DBL_MAX : info->b - info->apq * q->lb);
      }
      else
      {  p->lb = (q->lb == -DBL_MAX ?
            -DBL_MAX : info->b - info->apq * q->lb);
         p->ub = (q->ub == +DBL_MAX ?
            +DBL_MAX : info->b - info->apq * q->ub);
      }
      /* remove the column from the problem */
      npp_del_col(npp, q);
      return;
}

static int rcv_implied_slack(NPP *npp, void *_info)
{     /* recover column singleton (implied slack variable) */
      struct implied_slack *info = _info;
      NPPLFE *lfe;
      double temp;
      if (npp->sol == GLP_SOL)
      {  /* assign statuses to row p and column q */
         if (npp->r_stat[info->p] == GLP_BS ||
             npp->r_stat[info->p] == GLP_NF)
            npp->c_stat[info->q] = npp->r_stat[info->p];
         else if (npp->r_stat[info->p] == GLP_NL)
            npp->c_stat[info->q] =
               (char)(info->apq > 0.0 ? GLP_NU : GLP_NL);
         else if (npp->r_stat[info->p] == GLP_NU)
            npp->c_stat[info->q] =
               (char)(info->apq > 0.0 ? GLP_NL : GLP_NU);
         else
         {  npp_error();
            return 1;
         }
         npp->r_stat[info->p] = GLP_NS;
      }
      if (npp->sol != GLP_MIP)
      {  /* compute multiplier for row p */
         npp->r_pi[info->p] += info->c / info->apq;
      }
      /* compute value of column q */
      temp = info->b;
      for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)
         temp -= lfe->val * npp->c_value[lfe->ref];
      npp->c_value[info->q] = temp / info->apq;
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_implied_free - process column singleton (implied free variable)
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_implied_free(NPP *npp, NPPCOL *q);
*
*  DESCRIPTION
*
*  The routine npp_implied_free processes column q:
*
*     l[q] <= x[q] <= u[q],                                          (1)
*
*  having non-zero coefficient in the only row p, which is inequality
*  constraint:
*
*     L[p] <= sum a[p,j] x[j] + a[p,q] x[q] <= U[p],                 (2)
*             j!=q
*
*  where l[q] < u[q], L[p] < U[p], L[p] > -oo and/or U[p] < +oo.
*
*  RETURNS
*
*  0 - success;
*
*  1 - column lower and/or upper bound(s) can be active;
*
*  2 - problem has no dual feasible solution.
*
*  PROBLEM TRANSFORMATION
*
*  Constraint (2) can be written as follows:
*
*     L[p] - sum a[p,j] x[j] <= a[p,q] x[q] <= U[p] - sum a[p,j] x[j],
*            j!=q                                     j!=q
*
*  from which it follows that:
*
*     alfa <= a[p,q] x[q] <= beta,                                   (3)
*
*  where
*
*     alfa = inf(L[p] - sum a[p,j] x[j]) =
*                       j!=q
*
*          = L[p] - sup sum a[p,j] x[j] =                            (4)
*                       j!=q
*
*          = L[p] -  sum  a[p,j] u[j] -  sum  a[p,j] l[j],
*                  j in Jp             j in Jn
*
*     beta = sup(L[p] - sum a[p,j] x[j]) =
*                       j!=q
*
*          = L[p] - inf sum a[p,j] x[j] =                            (5)
*                       j!=q
*
*          = L[p] -  sum  a[p,j] l[j] -  sum  a[p,j] u[j],
*                  j in Jp             j in Jn
*
*     Jp = {j != q: a[p,j] > 0},  Jn = {j != q: a[p,j] < 0}.         (6)
*
*  Inequality (3) defines implied bounds of variable x[q]:
*
*     l'[q] <= x[q] <= u'[q],                                        (7)
*
*  where
*
*             ( alfa / a[p,q], if a[p,q] > 0
*     l'[q] = <                                                     (8a)
*             ( beta / a[p,q], if a[p,q] < 0
*
*             ( beta / a[p,q], if a[p,q] > 0
*     u'[q] = <                                                     (8b)
*             ( alfa / a[p,q], if a[p,q] < 0
*
*  Thus, if l'[q] > l[q] - eps and u'[q] < u[q] + eps, where eps is
*  an absolute tolerance for column value, column bounds (1) cannot be
*  active, in which case column q can be replaced by equivalent free
*  (unbounded) column.
*
*  Note that column q is column singleton, so in the dual system of the
*  original problem it corresponds to the following row singleton:
*
*     a[p,q] pi[p] + lambda[q] = c[q],                               (9)
*
*  from which it follows that:
*
*     pi[p] = (c[q] - lambda[q]) / a[p,q].                          (10)
*
*  Let x[q] be implied free (unbounded) variable. Then column q can be
*  only basic, so its multiplier lambda[q] is equal to zero, and from
*  (10) we have:
*
*     pi[p] = c[q] / a[p,q].                                        (11)
*
*  There are possible three cases:
*
*  1) pi[p] < -eps, where eps is an absolute tolerance for row
*     multiplier. In this case, to provide dual feasibility of the
*     original problem, row p must be active on its lower bound, and
*     if its lower bound does not exist (L[p] = -oo), the problem has
*     no dual feasible solution;
*
*  2) pi[p] > +eps. In this case row p must be active on its upper
*     bound, and if its upper bound does not exist (U[p] = +oo), the
*     problem has no dual feasible solution;
*
*  3) -eps <= pi[p] <= +eps. In this case any (either lower or upper)
*     bound of row p can be active, because this does not affect dual
*     feasibility.
*
*  Thus, in all three cases original inequality constraint (2) can be
*  replaced by equality constraint, where the right-hand side is either
*  lower or upper bound of row p, and bounds of column q can be removed
*  that makes it free (unbounded). (May note that this transformation
*  can be followed by transformation "Column singleton (implied slack
*  variable)" performed by the routine npp_implied_slack.)
*
*  RECOVERING BASIC SOLUTION
*
*  Status of row p in solution to the original problem is determined
*  by its status in solution to the transformed problem and its bound,
*  which was choosen to be active:
*
*     +-----------------------+--------+--------------------+
*     |    Status of row p    | Active | Status of row p    |
*     | (transformed problem) | bound  | (original problem) |
*     +-----------------------+--------+--------------------+
*     |        GLP_BS         |  L[p]  |       GLP_BS       |
*     |        GLP_BS         |  U[p]  |       GLP_BS       |
*     |        GLP_NS         |  L[p]  |       GLP_NL       |
*     |        GLP_NS         |  U[p]  |       GLP_NU       |
*     +-----------------------+--------+--------------------+
*
*  Value of row multiplier pi[p] (as well as value of column q) in
*  solution to the original problem is the same as in solution to the
*  transformed problem.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of row multiplier pi[p] in solution to the original problem is
*  the same as in solution to the transformed problem.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

struct implied_free
{     /* column singleton (implied free variable) */
      int p;
      /* row reference number */
      char stat;
      /* row status:
         GLP_NL - active constraint on lower bound
         GLP_NU - active constraint on upper bound */
};

static int rcv_implied_free(NPP *npp, void *info);

int npp_implied_free(NPP *npp, NPPCOL *q)
{     /* process column singleton (implied free variable) */
      struct implied_free *info;
      NPPROW *p;
      NPPAIJ *apq, *aij;
      double alfa, beta, l, u, pi, eps;
      /* the column must be non-fixed singleton */
      xassert(q->lb < q->ub);
      xassert(q->ptr != NULL && q->ptr->c_next == NULL);
      /* corresponding row must be inequality constraint */
      apq = q->ptr;
      p = apq->row;
      xassert(p->lb != -DBL_MAX || p->ub != +DBL_MAX);
      xassert(p->lb < p->ub);
      /* compute alfa */
      alfa = p->lb;
      if (alfa != -DBL_MAX)
      {  for (aij = p->ptr; aij != NULL; aij = aij->r_next)
         {  if (aij == apq) continue; /* skip a[p,q] */
            if (aij->val > 0.0)
            {  if (aij->col->ub == +DBL_MAX)
               {  alfa = -DBL_MAX;
                  break;
               }
               alfa -= aij->val * aij->col->ub;
            }
            else /* < 0.0 */
            {  if (aij->col->lb == -DBL_MAX)
               {  alfa = -DBL_MAX;
                  break;
               }
               alfa -= aij->val * aij->col->lb;
            }
         }
      }
      /* compute beta */
      beta = p->ub;
      if (beta != +DBL_MAX)
      {  for (aij = p->ptr; aij != NULL; aij = aij->r_next)
         {  if (aij == apq) continue; /* skip a[p,q] */
            if (aij->val > 0.0)
            {  if (aij->col->lb == -DBL_MAX)
               {  beta = +DBL_MAX;
                  break;
               }
               beta -= aij->val * aij->col->lb;
            }
            else /* < 0.0 */
            {  if (aij->col->ub == +DBL_MAX)
               {  beta = +DBL_MAX;
                  break;
               }
               beta -= aij->val * aij->col->ub;
            }
         }
      }
      /* compute implied column lower bound l'[q] */
      if (apq->val > 0.0)
         l = (alfa == -DBL_MAX ? -DBL_MAX : alfa / apq->val);
      else /* < 0.0 */
         l = (beta == +DBL_MAX ? -DBL_MAX : beta / apq->val);
      /* compute implied column upper bound u'[q] */
      if (apq->val > 0.0)
         u = (beta == +DBL_MAX ? +DBL_MAX : beta / apq->val);
      else
         u = (alfa == -DBL_MAX ? +DBL_MAX : alfa / apq->val);
      /* check if column lower bound l[q] can be active */
      if (q->lb != -DBL_MAX)
      {  eps = 1e-9 + 1e-12 * fabs(q->lb);
         if (l < q->lb - eps) return 1; /* yes, it can */
      }
      /* check if column upper bound u[q] can be active */
      if (q->ub != +DBL_MAX)
      {  eps = 1e-9 + 1e-12 * fabs(q->ub);
         if (u > q->ub + eps) return 1; /* yes, it can */
      }
      /* okay; make column q free (unbounded) */
      q->lb = -DBL_MAX, q->ub = +DBL_MAX;
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_implied_free, sizeof(struct implied_free));
      info->p = p->i;
      info->stat = -1;
      /* compute row multiplier pi[p] */
      pi = q->coef / apq->val;
      /* check dual feasibility for row p */
      if (pi > +DBL_EPSILON)
      {  /* lower bound L[p] must be active */
         if (p->lb != -DBL_MAX)
nl:      {  info->stat = GLP_NL;
            p->ub = p->lb;
         }
         else
         {  if (pi > +1e-5) return 2; /* dual infeasibility */
            /* take a chance on U[p] */
            xassert(p->ub != +DBL_MAX);
            goto nu;
         }
      }
      else if (pi < -DBL_EPSILON)
      {  /* upper bound U[p] must be active */
         if (p->ub != +DBL_MAX)
nu:      {  info->stat = GLP_NU;
            p->lb = p->ub;
         }
         else
         {  if (pi < -1e-5) return 2; /* dual infeasibility */
            /* take a chance on L[p] */
            xassert(p->lb != -DBL_MAX);
            goto nl;
         }
      }
      else
      {  /* any bound (either L[p] or U[p]) can be made active  */
         if (p->ub == +DBL_MAX)
         {  xassert(p->lb != -DBL_MAX);
            goto nl;
         }
         if (p->lb == -DBL_MAX)
         {  xassert(p->ub != +DBL_MAX);
            goto nu;
         }
         if (fabs(p->lb) <= fabs(p->ub)) goto nl; else goto nu;
      }
      return 0;
}

static int rcv_implied_free(NPP *npp, void *_info)
{     /* recover column singleton (implied free variable) */
      struct implied_free *info = _info;
      if (npp->sol == GLP_SOL)
      {  if (npp->r_stat[info->p] == GLP_BS)
            npp->r_stat[info->p] = GLP_BS;
         else if (npp->r_stat[info->p] == GLP_NS)
         {  xassert(info->stat == GLP_NL || info->stat == GLP_NU);
            npp->r_stat[info->p] = info->stat;
         }
         else
         {  npp_error();
            return 1;
         }
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_eq_doublet - process row doubleton (equality constraint)
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  NPPCOL *npp_eq_doublet(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_eq_doublet processes row p, which is equality
*  constraint having exactly two non-zero coefficients:
*
*     a[p,q] x[q] + a[p,r] x[r] = b.                                 (1)
*
*  As the result of processing one of columns q or r is eliminated from
*  all other rows and, thus, becomes column singleton of type "implied
*  slack variable". Row p is not changed and along with column q and r
*  remains in the problem.
*
*  RETURNS
*
*  The routine npp_eq_doublet returns pointer to the descriptor of that
*  column q or r which has been eliminated. If, due to some reason, the
*  elimination was not performed, the routine returns NULL.
*
*  PROBLEM TRANSFORMATION
*
*  First, we decide which column q or r will be eliminated. Let it be
*  column q. Consider i-th constraint row, where column q has non-zero
*  coefficient a[i,q] != 0:
*
*     L[i] <= sum a[i,j] x[j] <= U[i].                               (2)
*              j
*
*  In order to eliminate column q from row (2) we subtract from it row
*  (1) multiplied by gamma[i] = a[i,q] / a[p,q], i.e. we replace in the
*  transformed problem row (2) by its linear combination with row (1).
*  This transformation changes only coefficients in columns q and r,
*  and bounds of row i as follows:
*
*     a~[i,q] = a[i,q] - gamma[i] a[p,q] = 0,                        (3)
*
*     a~[i,r] = a[i,r] - gamma[i] a[p,r],                            (4)
*
*       L~[i] = L[i] - gamma[i] b,                                   (5)
*
*       U~[i] = U[i] - gamma[i] b.                                   (6)
*
*  RECOVERING BASIC SOLUTION
*
*  The transformation of the primal system of the original problem:
*
*     L <= A x <= U                                                  (7)
*
*  is equivalent to multiplying from the left a transformation matrix F
*  by components of this primal system, which in the transformed problem
*  becomes the following:
*
*     F L <= F A x <= F U  ==>  L~ <= A~x <= U~.                     (8)
*
*  The matrix F has the following structure:
*
*         ( 1           -gamma[1]            )
*         (                                  )
*         (    1        -gamma[2]            )
*         (                                  )
*         (      ...       ...               )
*         (                                  )
*     F = (          1  -gamma[p-1]          )                       (9)
*         (                                  )
*         (                 1                )
*         (                                  )
*         (             -gamma[p+1]  1       )
*         (                                  )
*         (                ...          ...  )
*
*  where its column containing elements -gamma[i] corresponds to row p
*  of the primal system.
*
*  From (8) it follows that the dual system of the original problem:
*
*     A'pi + lambda = c,                                            (10)
*
*  in the transformed problem becomes the following:
*
*     A'F'inv(F')pi + lambda = c  ==>  (A~)'pi~ + lambda = c,       (11)
*
*  where:
*
*     pi~ = inv(F')pi                                               (12)
*
*  is the vector of row multipliers in the transformed problem. Thus:
*
*     pi = F'pi~.                                                   (13)
*
*  Therefore, as it follows from (13), value of multiplier for row p in
*  solution to the original problem can be computed as follows:
*
*     pi[p] = pi~[p] - sum gamma[i] pi~[i],                         (14)
*                       i
*
*  where pi~[i] = pi[i] is multiplier for row i (i != p).
*
*  Note that the statuses of all rows and columns are not changed.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Multiplier for row p in solution to the original problem is computed
*  with formula (14).
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

struct eq_doublet
{     /* row doubleton (equality constraint) */
      int p;
      /* row reference number */
      double apq;
      /* constraint coefficient a[p,q] */
      NPPLFE *ptr;
      /* list of non-zero coefficients a[i,q], i != p */
};

static int rcv_eq_doublet(NPP *npp, void *info);

NPPCOL *npp_eq_doublet(NPP *npp, NPPROW *p)
{     /* process row doubleton (equality constraint) */
      struct eq_doublet *info;
      NPPROW *i;
      NPPCOL *q, *r;
      NPPAIJ *apq, *apr, *aiq, *air, *next;
      NPPLFE *lfe;
      double gamma;
      /* the row must be doubleton equality constraint */
      xassert(p->lb == p->ub);
      xassert(p->ptr != NULL && p->ptr->r_next != NULL &&
              p->ptr->r_next->r_next == NULL);
      /* choose column to be eliminated */
      {  NPPAIJ *a1, *a2;
         a1 = p->ptr, a2 = a1->r_next;
         if (fabs(a2->val) < 0.001 * fabs(a1->val))
         {  /* only first column can be eliminated, because second one
               has too small constraint coefficient */
            apq = a1, apr = a2;
         }
         else if (fabs(a1->val) < 0.001 * fabs(a2->val))
         {  /* only second column can be eliminated, because first one
               has too small constraint coefficient */
            apq = a2, apr = a1;
         }
         else
         {  /* both columns are appropriate; choose that one which is
               shorter to minimize fill-in */
            if (npp_col_nnz(npp, a1->col) <= npp_col_nnz(npp, a2->col))
            {  /* first column is shorter */
               apq = a1, apr = a2;
            }
            else
            {  /* second column is shorter */
               apq = a2, apr = a1;
            }
         }
      }
      /* now columns q and r have been chosen */
      q = apq->col, r = apr->col;
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_eq_doublet, sizeof(struct eq_doublet));
      info->p = p->i;
      info->apq = apq->val;
      info->ptr = NULL;
      /* transform each row i (i != p), where a[i,q] != 0, to eliminate
         column q */
      for (aiq = q->ptr; aiq != NULL; aiq = next)
      {  next = aiq->c_next;
         if (aiq == apq) continue; /* skip row p */
         i = aiq->row; /* row i to be transformed */
         /* save constraint coefficient a[i,q] */
         if (npp->sol != GLP_MIP)
         {  lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));
            lfe->ref = i->i;
            lfe->val = aiq->val;
            lfe->next = info->ptr;
            info->ptr = lfe;
         }
         /* find coefficient a[i,r] in row i */
         for (air = i->ptr; air != NULL; air = air->r_next)
            if (air->col == r) break;
         /* if a[i,r] does not exist, create a[i,r] = 0 */
         if (air == NULL)
            air = npp_add_aij(npp, i, r, 0.0);
         /* compute gamma[i] = a[i,q] / a[p,q] */
         gamma = aiq->val / apq->val;
         /* (row i) := (row i) - gamma[i] * (row p); see (3)-(6) */
         /* new a[i,q] is exact zero due to elimnation; remove it from
            row i */
         npp_del_aij(npp, aiq);
         /* compute new a[i,r] */
         air->val -= gamma * apr->val;
         /* if new a[i,r] is close to zero due to numeric cancelation,
            remove it from row i */
         if (fabs(air->val) <= 1e-10)
            npp_del_aij(npp, air);
         /* compute new lower and upper bounds of row i */
         if (i->lb == i->ub)
            i->lb = i->ub = (i->lb - gamma * p->lb);
         else
         {  if (i->lb != -DBL_MAX)
               i->lb -= gamma * p->lb;
            if (i->ub != +DBL_MAX)
               i->ub -= gamma * p->lb;
         }
      }
      return q;
}

static int rcv_eq_doublet(NPP *npp, void *_info)
{     /* recover row doubleton (equality constraint) */
      struct eq_doublet *info = _info;
      NPPLFE *lfe;
      double gamma, temp;
      /* we assume that processing row p is followed by processing
         column q as singleton of type "implied slack variable", in
         which case row p must always be active equality constraint */
      if (npp->sol == GLP_SOL)
      {  if (npp->r_stat[info->p] != GLP_NS)
         {  npp_error();
            return 1;
         }
      }
      if (npp->sol != GLP_MIP)
      {  /* compute value of multiplier for row p; see (14) */
         temp = npp->r_pi[info->p];
         for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)
         {  gamma = lfe->val / info->apq; /* a[i,q] / a[p,q] */
            temp -= gamma * npp->r_pi[lfe->ref];
         }
         npp->r_pi[info->p] = temp;
      }
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_forcing_row - process forcing row
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_forcing_row(NPP *npp, NPPROW *p, int at);
*
*  DESCRIPTION
*
*  The routine npp_forcing row processes row p of general format:
*
*     L[p] <= sum a[p,j] x[j] <= U[p],                               (1)
*              j
*
*     l[j] <= x[j] <= u[j],                                          (2)
*
*  where L[p] <= U[p] and l[j] < u[j] for all a[p,j] != 0. It is also
*  assumed that:
*
*  1) if at = 0 then |L[p] - U'[p]| <= eps, where U'[p] is implied
*     row upper bound (see below), eps is an absolute tolerance for row
*     value;
*
*  2) if at = 1 then |U[p] - L'[p]| <= eps, where L'[p] is implied
*     row lower bound (see below).
*
*  RETURNS
*
*  0 - success;
*
*  1 - cannot fix columns due to too small constraint coefficients.
*
*  PROBLEM TRANSFORMATION
*
*  Implied lower and upper bounds of row (1) are determined by bounds
*  of corresponding columns (variables) as follows:
*
*     L'[p] = inf sum a[p,j] x[j] =
*                  j
*                                                                    (3)
*           =  sum  a[p,j] l[j] +  sum  a[p,j] u[j],
*            j in Jp             j in Jn
*
*     U'[p] = sup sum a[p,j] x[j] =
*                                                                    (4)
*           =  sum  a[p,j] u[j] +  sum  a[p,j] l[j],
*            j in Jp             j in Jn
*
*     Jp = {j: a[p,j] > 0},  Jn = {j: a[p,j] < 0}.                   (5)
*
*  If L[p] =~ U'[p] (at = 0), solution can be primal feasible only when
*  all variables take their boundary values as defined by (4):
*
*            ( u[j], if j in Jp
*     x[j] = <                                                       (6)
*            ( l[j], if j in Jn
*
*  Similarly, if U[p] =~ L'[p] (at = 1), solution can be primal feasible
*  only when all variables take their boundary values as defined by (3):
*
*            ( l[j], if j in Jp
*     x[j] = <                                                       (7)
*            ( u[j], if j in Jn
*
*  Condition (6) or (7) allows fixing all columns (variables x[j])
*  in row (1) on their bounds and then removing them from the problem
*  (see the routine npp_fixed_col). Due to this row p becomes redundant,
*  so it can be replaced by equivalent free (unbounded) row and also
*  removed from the problem (see the routine npp_free_row).
*
*  1. To apply this transformation row (1) should not have coefficients
*     whose magnitude is too small, i.e. all a[p,j] should satisfy to
*     the following condition:
*
*        |a[p,j]| >= eps * max(1, |a[p,k]|),                         (8)
*                           k
*     where eps is a relative tolerance for constraint coefficients.
*     Otherwise, fixing columns may be numerically unreliable and may
*     lead to wrong solution.
*
*  2. The routine fixes columns and remove bounds of row p, however,
*     it does not remove the row and columns from the problem.
*
*  RECOVERING BASIC SOLUTION
*
*  In the transformed problem row p being inactive constraint is
*  assigned status GLP_BS (as the result of transformation of free
*  row), and all columns in this row are assigned status GLP_NS (as the
*  result of transformation of fixed columns).
*
*  Note that in the dual system of the transformed (as well as original)
*  problem every column j in row p corresponds to the following row:
*
*     sum  a[i,j] pi[i] + a[p,j] pi[p] + lambda[j] = c[j],           (9)
*     i!=p
*
*  from which it follows that:
*
*     lambda[j] = c[j] - sum a[i,j] pi[i] - a[p,j] pi[p].           (10)
*                        i!=p
*
*  In the transformed problem values of all multipliers pi[i] are known
*  (including pi[i], whose value is zero, since row p is inactive).
*  Thus, using formula (10) it is possible to compute values of
*  multipliers lambda[j] for all columns in row p.
*
*  Note also that in the original problem all columns in row p are
*  bounded, not fixed. So status GLP_NS assigned to every such column
*  must be changed to GLP_NL or GLP_NU depending on which bound the
*  corresponding column has been fixed. This status change may lead to
*  dual feasibility violation for solution of the original problem,
*  because now column multipliers must satisfy to the following
*  condition:
*
*               ( >= 0, if status of column j is GLP_NL,
*     lambda[j] <                                                   (11)
*               ( <= 0, if status of column j is GLP_NU.
*
*  If this condition holds, solution to the original problem is the
*  same as to the transformed problem. Otherwise, we have to perform
*  one degenerate pivoting step of the primal simplex method to obtain
*  dual feasible (hence, optimal) solution to the original problem as
*  follows. If, on problem transformation, row p was made active on its
*  lower bound (case at = 0), we change its status to GLP_NL (or GLP_NS)
*  and start increasing its multiplier pi[p]. Otherwise, if row p was
*  made active on its upper bound (case at = 1), we change its status
*  to GLP_NU (or GLP_NS) and start decreasing pi[p]. From (10) it
*  follows that:
*
*     delta lambda[j] = - a[p,j] * delta pi[p] = - a[p,j] pi[p].    (12)
*
*  Simple analysis of formulae (3)-(5) shows that changing pi[p] in the
*  specified direction causes increasing lambda[j] for every column j
*  assigned status GLP_NL (delta lambda[j] > 0) and decreasing lambda[j]
*  for every column j assigned status GLP_NU (delta lambda[j] < 0). It
*  is understood that once the last lambda[q], which violates condition
*  (11), has reached zero, multipliers lambda[j] for all columns get
*  valid signs. Such column q can be determined as follows. Let d[j] be
*  initial value of lambda[j] (i.e. reduced cost of column j) in the
*  transformed problem computed with formula (10) when pi[p] = 0. Then
*  lambda[j] = d[j] + delta lambda[j], and from (12) it follows that
*  lambda[j] becomes zero if:
*
*     delta lambda[j] = - a[p,j] pi[p] = - d[j]  ==>
*                                                                   (13)
*     pi[p] = d[j] / a[p,j].
*
*  Therefore, the last column q, for which lambda[q] becomes zero, can
*  be determined from the following condition:
*
*     |d[q] / a[p,q]| = max  |pi[p]| = max  |d[j] / a[p,j]|,        (14)
*                      j in D         j in D
*
*  where D is a set of columns j whose, reduced costs d[j] have invalid
*  signs, i.e. violate condition (11). (Thus, if D is empty, solution
*  to the original problem is the same as solution to the transformed
*  problem, and no correction is needed as was noticed above.) In
*  solution to the original problem column q is assigned status GLP_BS,
*  since it replaces column of auxiliary variable of row p (becoming
*  active) in the basis, and multiplier for row p is assigned its new
*  value, which is pi[p] = d[q] / a[p,q]. Note that due to primal
*  degeneracy values of all columns having non-zero coefficients in row
*  p remain unchanged.
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  Value of multiplier pi[p] in solution to the original problem is
*  corrected in the same way as for basic solution. Values of all
*  columns having non-zero coefficients in row p remain unchanged.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

struct forcing_col
{     /* column fixed on its bound by forcing row */
      int j;
      /* column reference number */
      char stat;
      /* original column status:
         GLP_NL - fixed on lower bound
         GLP_NU - fixed on upper bound */
      double a;
      /* constraint coefficient a[p,j] */
      double c;
      /* objective coefficient c[j] */
      NPPLFE *ptr;
      /* list of non-zero coefficients a[i,j], i != p */
      struct forcing_col *next;
      /* pointer to another column fixed by forcing row */
};

struct forcing_row
{     /* forcing row */
      int p;
      /* row reference number */
      char stat;
      /* status assigned to the row if it becomes active:
         GLP_NS - active equality constraint
         GLP_NL - inequality constraint with lower bound active
         GLP_NU - inequality constraint with upper bound active */
      struct forcing_col *ptr;
      /* list of all columns having non-zero constraint coefficient
         a[p,j] in the forcing row */
};

static int rcv_forcing_row(NPP *npp, void *info);

int npp_forcing_row(NPP *npp, NPPROW *p, int at)
{     /* process forcing row */
      struct forcing_row *info;
      struct forcing_col *col = NULL;
      NPPCOL *j;
      NPPAIJ *apj, *aij;
      NPPLFE *lfe;
      double big;
      xassert(at == 0 || at == 1);
      /* determine maximal magnitude of the row coefficients */
      big = 1.0;
      for (apj = p->ptr; apj != NULL; apj = apj->r_next)
         if (big < fabs(apj->val)) big = fabs(apj->val);
      /* if there are too small coefficients in the row, transformation
         should not be applied */
      for (apj = p->ptr; apj != NULL; apj = apj->r_next)
         if (fabs(apj->val) < 1e-7 * big) return 1;
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_forcing_row, sizeof(struct forcing_row));
      info->p = p->i;
      if (p->lb == p->ub)
      {  /* equality constraint */
         info->stat = GLP_NS;
      }
      else if (at == 0)
      {  /* inequality constraint; case L[p] = U'[p] */
         info->stat = GLP_NL;
         xassert(p->lb != -DBL_MAX);
      }
      else /* at == 1 */
      {  /* inequality constraint; case U[p] = L'[p] */
         info->stat = GLP_NU;
         xassert(p->ub != +DBL_MAX);
      }
      info->ptr = NULL;
      /* scan the forcing row, fix columns at corresponding bounds, and
         save column information (the latter is not needed for MIP) */
      for (apj = p->ptr; apj != NULL; apj = apj->r_next)
      {  /* column j has non-zero coefficient in the forcing row */
         j = apj->col;
         /* it must be non-fixed */
         xassert(j->lb < j->ub);
         /* allocate stack entry to save column information */
         if (npp->sol != GLP_MIP)
         {  col = dmp_get_atom(npp->stack, sizeof(struct forcing_col));
            col->j = j->j;
            col->stat = -1; /* will be set below */
            col->a = apj->val;
            col->c = j->coef;
            col->ptr = NULL;
            col->next = info->ptr;
            info->ptr = col;
         }
         /* fix column j */
         if (at == 0 && apj->val < 0.0 || at != 0 && apj->val > 0.0)
         {  /* at its lower bound */
            if (npp->sol != GLP_MIP)
               col->stat = GLP_NL;
            xassert(j->lb != -DBL_MAX);
            j->ub = j->lb;
         }
         else
         {  /* at its upper bound */
            if (npp->sol != GLP_MIP)
               col->stat = GLP_NU;
            xassert(j->ub != +DBL_MAX);
            j->lb = j->ub;
         }
         /* save column coefficients a[i,j], i != p */
         if (npp->sol != GLP_MIP)
         {  for (aij = j->ptr; aij != NULL; aij = aij->c_next)
            {  if (aij == apj) continue; /* skip a[p,j] */
               lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));
               lfe->ref = aij->row->i;
               lfe->val = aij->val;
               lfe->next = col->ptr;
               col->ptr = lfe;
            }
         }
      }
      /* make the row free (unbounded) */
      p->lb = -DBL_MAX, p->ub = +DBL_MAX;
      return 0;
}

static int rcv_forcing_row(NPP *npp, void *_info)
{     /* recover forcing row */
      struct forcing_row *info = _info;
      struct forcing_col *col, *piv;
      NPPLFE *lfe;
      double d, big, temp;
      if (npp->sol == GLP_MIP) goto done;
      /* initially solution to the original problem is the same as
         to the transformed problem, where row p is inactive constraint
         with pi[p] = 0, and all columns are non-basic */
      if (npp->sol == GLP_SOL)
      {  if (npp->r_stat[info->p] != GLP_BS)
         {  npp_error();
            return 1;
         }
         for (col = info->ptr; col != NULL; col = col->next)
         {  if (npp->c_stat[col->j] != GLP_NS)
            {  npp_error();
               return 1;
            }
            npp->c_stat[col->j] = col->stat; /* original status */
         }
      }
      /* compute reduced costs d[j] for all columns with formula (10)
         and store them in col.c instead objective coefficients */
      for (col = info->ptr; col != NULL; col = col->next)
      {  d = col->c;
         for (lfe = col->ptr; lfe != NULL; lfe = lfe->next)
            d -= lfe->val * npp->r_pi[lfe->ref];
         col->c = d;
      }
      /* consider columns j, whose multipliers lambda[j] has wrong
         sign in solution to the transformed problem (where lambda[j] =
         d[j]), and choose column q, whose multipler lambda[q] reaches
         zero last on changing row multiplier pi[p]; see (14) */
      piv = NULL, big = 0.0;
      for (col = info->ptr; col != NULL; col = col->next)
      {  d = col->c; /* d[j] */
         temp = fabs(d / col->a);
         if (col->stat == GLP_NL)
         {  /* column j has active lower bound */
            if (d < 0.0 && big < temp)
               piv = col, big = temp;
         }
         else if (col->stat == GLP_NU)
         {  /* column j has active upper bound */
            if (d > 0.0 && big < temp)
               piv = col, big = temp;
         }
         else
         {  npp_error();
            return 1;
         }
      }
      /* if column q does not exist, no correction is needed */
      if (piv != NULL)
      {  /* correct solution; row p becomes active constraint while
            column q becomes basic */
         if (npp->sol == GLP_SOL)
         {  npp->r_stat[info->p] = info->stat;
            npp->c_stat[piv->j] = GLP_BS;
         }
         /* assign new value to row multiplier pi[p] = d[p] / a[p,q] */
         npp->r_pi[info->p] = piv->c / piv->a;
      }
done: return 0;
}

/***********************************************************************
*  NAME
*
*  npp_analyze_row - perform general row analysis
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_analyze_row(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_analyze_row performs analysis of row p of general
*  format:
*
*     L[p] <= sum a[p,j] x[j] <= U[p],                               (1)
*              j
*
*     l[j] <= x[j] <= u[j],                                          (2)
*
*  where L[p] <= U[p] and l[j] <= u[j] for all a[p,j] != 0.
*
*  RETURNS
*
*  0x?0 - row lower bound does not exist or is redundant;
*
*  0x?1 - row lower bound can be active;
*
*  0x?2 - row lower bound is a forcing bound;
*
*  0x0? - row upper bound does not exist or is redundant;
*
*  0x1? - row upper bound can be active;
*
*  0x2? - row upper bound is a forcing bound;
*
*  0x33 - row bounds are inconsistent with column bounds.
*
*  ALGORITHM
*
*  Analysis of row (1) is based on analysis of its implied lower and
*  upper bounds, which are determined by bounds of corresponding columns
*  (variables) as follows:
*
*     L'[p] = inf sum a[p,j] x[j] =
*                  j
*                                                                    (3)
*           =  sum  a[p,j] l[j] +  sum  a[p,j] u[j],
*            j in Jp             j in Jn
*
*     U'[p] = sup sum a[p,j] x[j] =
*                                                                    (4)
*           =  sum  a[p,j] u[j] +  sum  a[p,j] l[j],
*            j in Jp             j in Jn
*
*     Jp = {j: a[p,j] > 0},  Jn = {j: a[p,j] < 0}.                   (5)
*
*  (Note that bounds of all columns in row p are assumed to be correct,
*  so L'[p] <= U'[p].)
*
*  Analysis of row lower bound L[p] includes the following cases:
*
*  1) if L[p] > U'[p] + eps, where eps is an absolute tolerance for row
*     value, row lower bound L[p] and implied row upper bound U'[p] are
*     inconsistent, ergo, the problem has no primal feasible solution;
*
*  2) if U'[p] - eps <= L[p] <= U'[p] + eps, i.e. if L[p] =~ U'[p],
*     the row is a forcing row on its lower bound (see description of
*     the routine npp_forcing_row);
*
*  3) if L[p] > L'[p] + eps, row lower bound L[p] can be active (this
*     conclusion does not account other rows in the problem);
*
*  4) if L[p] <= L'[p] + eps, row lower bound L[p] cannot be active, so
*     it is redundant and can be removed (replaced by -oo).
*
*  Analysis of row upper bound U[p] is performed in a similar way and
*  includes the following cases:
*
*  1) if U[p] < L'[p] - eps, row upper bound U[p] and implied row lower
*     bound L'[p] are inconsistent, ergo the problem has no primal
*     feasible solution;
*
*  2) if L'[p] - eps <= U[p] <= L'[p] + eps, i.e. if U[p] =~ L'[p],
*     the row is a forcing row on its upper bound (see description of
*     the routine npp_forcing_row);
*
*  3) if U[p] < U'[p] - eps, row upper bound U[p] can be active (this
*     conclusion does not account other rows in the problem);
*
*  4) if U[p] >= U'[p] - eps, row upper bound U[p] cannot be active, so
*     it is redundant and can be removed (replaced by +oo). */

int npp_analyze_row(NPP *npp, NPPROW *p)
{     /* perform general row analysis */
      NPPAIJ *aij;
      int ret = 0x00;
      double l, u, eps;
      xassert(npp == npp);
      /* compute implied lower bound L'[p]; see (3) */
      l = 0.0;
      for (aij = p->ptr; aij != NULL; aij = aij->r_next)
      {  if (aij->val > 0.0)
         {  if (aij->col->lb == -DBL_MAX)
            {  l = -DBL_MAX;
               break;
            }
            l += aij->val * aij->col->lb;
         }
         else /* aij->val < 0.0 */
         {  if (aij->col->ub == +DBL_MAX)
            {  l = -DBL_MAX;
               break;
            }
            l += aij->val * aij->col->ub;
         }
      }
      /* compute implied upper bound U'[p]; see (4) */
      u = 0.0;
      for (aij = p->ptr; aij != NULL; aij = aij->r_next)
      {  if (aij->val > 0.0)
         {  if (aij->col->ub == +DBL_MAX)
            {  u = +DBL_MAX;
               break;
            }
            u += aij->val * aij->col->ub;
         }
         else /* aij->val < 0.0 */
         {  if (aij->col->lb == -DBL_MAX)
            {  u = +DBL_MAX;
               break;
            }
            u += aij->val * aij->col->lb;
         }
      }
      /* column bounds are assumed correct, so L'[p] <= U'[p] */
      /* check if row lower bound is consistent */
      if (p->lb != -DBL_MAX)
      {  eps = 1e-3 + 1e-6 * fabs(p->lb);
         if (p->lb - eps > u)
         {  ret = 0x33;
            goto done;
         }
      }
      /* check if row upper bound is consistent */
      if (p->ub != +DBL_MAX)
      {  eps = 1e-3 + 1e-6 * fabs(p->ub);
         if (p->ub + eps < l)
         {  ret = 0x33;
            goto done;
         }
      }
      /* check if row lower bound can be active/forcing */
      if (p->lb != -DBL_MAX)
      {  eps = 1e-9 + 1e-12 * fabs(p->lb);
         if (p->lb - eps > l)
         {  if (p->lb + eps <= u)
               ret |= 0x01;
            else
               ret |= 0x02;
         }
      }
      /* check if row upper bound can be active/forcing */
      if (p->ub != +DBL_MAX)
      {  eps = 1e-9 + 1e-12 * fabs(p->ub);
         if (p->ub + eps < u)
         {  /* check if the upper bound is forcing */
            if (p->ub - eps >= l)
               ret |= 0x10;
            else
               ret |= 0x20;
         }
      }
done: return ret;
}

/***********************************************************************
*  NAME
*
*  npp_inactive_bound - remove row lower/upper inactive bound
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_inactive_bound(NPP *npp, NPPROW *p, int which);
*
*  DESCRIPTION
*
*  The routine npp_inactive_bound removes lower (if which = 0) or upper
*  (if which = 1) bound of row p:
*
*     L[p] <= sum a[p,j] x[j] <= U[p],
*
*  which (bound) is assumed to be redundant.
*
*  PROBLEM TRANSFORMATION
*
*  If which = 0, current lower bound L[p] of row p is assigned -oo.
*  If which = 1, current upper bound U[p] of row p is assigned +oo.
*
*  RECOVERING BASIC SOLUTION
*
*  If in solution to the transformed problem row p is inactive
*  constraint (GLP_BS), its status is not changed in solution to the
*  original problem. Otherwise, status of row p in solution to the
*  original problem is defined by its type before transformation and
*  its status in solution to the transformed problem as follows:
*
*     +---------------------+-------+---------------+---------------+
*     |        Row          | Flag  | Row status in | Row status in |
*     |        type         | which | transfmd soln | original soln |
*     +---------------------+-------+---------------+---------------+
*     |     sum >= L[p]     |   0   |    GLP_NF     |    GLP_NL     |
*     |     sum <= U[p]     |   1   |    GLP_NF     |    GLP_NU     |
*     | L[p] <= sum <= U[p] |   0   |    GLP_NU     |    GLP_NU     |
*     | L[p] <= sum <= U[p] |   1   |    GLP_NL     |    GLP_NL     |
*     |  sum = L[p] = U[p]  |   0   |    GLP_NU     |    GLP_NS     |
*     |  sum = L[p] = U[p]  |   1   |    GLP_NL     |    GLP_NS     |
*     +---------------------+-------+---------------+---------------+
*
*  RECOVERING INTERIOR-POINT SOLUTION
*
*  None needed.
*
*  RECOVERING MIP SOLUTION
*
*  None needed. */

struct inactive_bound
{     /* row inactive bound */
      int p;
      /* row reference number */
      char stat;
      /* row status (if active constraint) */
};

static int rcv_inactive_bound(NPP *npp, void *info);

void npp_inactive_bound(NPP *npp, NPPROW *p, int which)
{     /* remove row lower/upper inactive bound */
      struct inactive_bound *info;
      if (npp->sol == GLP_SOL)
      {  /* create transformation stack entry */
         info = npp_push_tse(npp,
            rcv_inactive_bound, sizeof(struct inactive_bound));
         info->p = p->i;
         if (p->ub == +DBL_MAX)
            info->stat = GLP_NL;
         else if (p->lb == -DBL_MAX)
            info->stat = GLP_NU;
         else if (p->lb != p->ub)
            info->stat = (char)(which == 0 ? GLP_NU : GLP_NL);
         else
            info->stat = GLP_NS;
      }
      /* remove row inactive bound */
      if (which == 0)
      {  xassert(p->lb != -DBL_MAX);
         p->lb = -DBL_MAX;
      }
      else if (which == 1)
      {  xassert(p->ub != +DBL_MAX);
         p->ub = +DBL_MAX;
      }
      else
         xassert(which != which);
      return;
}

static int rcv_inactive_bound(NPP *npp, void *_info)
{     /* recover row status */
      struct inactive_bound *info = _info;
      if (npp->sol != GLP_SOL)
      {  npp_error();
         return 1;
      }
      if (npp->r_stat[info->p] == GLP_BS)
         npp->r_stat[info->p] = GLP_BS;
      else
         npp->r_stat[info->p] = info->stat;
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_implied_bounds - determine implied column bounds
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_implied_bounds(NPP *npp, NPPROW *p);
*
*  DESCRIPTION
*
*  The routine npp_implied_bounds inspects general row (constraint) p:
*
*     L[p] <= sum a[p,j] x[j] <= U[p],                               (1)
*
*     l[j] <= x[j] <= u[j],                                          (2)
*
*  where L[p] <= U[p] and l[j] <= u[j] for all a[p,j] != 0, to compute
*  implied bounds of columns (variables x[j]) in this row.
*
*  The routine stores implied column bounds l'[j] and u'[j] in column
*  descriptors (NPPCOL); it does not change current column bounds l[j]
*  and u[j]. (Implied column bounds can be then used to strengthen the
*  current column bounds; see the routines npp_implied_lower and
*  npp_implied_upper).
*
*  ALGORITHM
*
*  Current column bounds (2) define implied lower and upper bounds of
*  row (1) as follows:
*
*     L'[p] = inf sum a[p,j] x[j] =
*                  j
*                                                                    (3)
*           =  sum  a[p,j] l[j] +  sum  a[p,j] u[j],
*            j in Jp             j in Jn
*
*     U'[p] = sup sum a[p,j] x[j] =
*                                                                    (4)
*           =  sum  a[p,j] u[j] +  sum  a[p,j] l[j],
*            j in Jp             j in Jn
*
*     Jp = {j: a[p,j] > 0},  Jn = {j: a[p,j] < 0}.                   (5)
*
*  (Note that bounds of all columns in row p are assumed to be correct,
*  so L'[p] <= U'[p].)
*
*  If L[p] > L'[p] and/or U[p] < U'[p], the lower and/or upper bound of
*  row (1) can be active, in which case such row defines implied bounds
*  of its variables.
*
*  Let x[k] be some variable having in row (1) coefficient a[p,k] != 0.
*  Consider a case when row lower bound can be active (L[p] > L'[p]):
*
*     sum a[p,j] x[j] >= L[p]  ==>
*      j
*
*     sum a[p,j] x[j] + a[p,k] x[k] >= L[p]  ==>
*     j!=k
*                                                                    (6)
*     a[p,k] x[k] >= L[p] - sum a[p,j] x[j]  ==>
*                           j!=k
*
*     a[p,k] x[k] >= L[p,k],
*
*  where
*
*     L[p,k] = inf(L[p] - sum a[p,j] x[j]) =
*                         j!=k
*
*            = L[p] - sup sum a[p,j] x[j] =                          (7)
*                         j!=k
*
*            = L[p] - sum a[p,j] u[j] - sum a[p,j] l[j].
*                    j in Jp\{k}       j in Jn\{k}
*
*  Thus:
*
*     x[k] >= l'[k] = L[p,k] / a[p,k],  if a[p,k] > 0,               (8)
*
*     x[k] <= u'[k] = L[p,k] / a[p,k],  if a[p,k] < 0.               (9)
*
*  where l'[k] and u'[k] are implied lower and upper bounds of variable
*  x[k], resp.
*
*  Now consider a similar case when row upper bound can be active
*  (U[p] < U'[p]):
*
*     sum a[p,j] x[j] <= U[p]  ==>
*      j
*
*     sum a[p,j] x[j] + a[p,k] x[k] <= U[p]  ==>
*     j!=k
*                                                                   (10)
*     a[p,k] x[k] <= U[p] - sum a[p,j] x[j]  ==>
*                           j!=k
*
*     a[p,k] x[k] <= U[p,k],
*
*  where:
*
*     U[p,k] = sup(U[p] - sum a[p,j] x[j]) =
*                         j!=k
*
*            = U[p] - inf sum a[p,j] x[j] =                         (11)
*                         j!=k
*
*            = U[p] - sum a[p,j] l[j] - sum a[p,j] u[j].
*                    j in Jp\{k}       j in Jn\{k}
*
*  Thus:
*
*     x[k] <= u'[k] = U[p,k] / a[p,k],  if a[p,k] > 0,              (12)
*
*     x[k] >= l'[k] = U[p,k] / a[p,k],  if a[p,k] < 0.              (13)
*
*  Note that in formulae (8), (9), (12), and (13) coefficient a[p,k]
*  must not be too small in magnitude relatively to other non-zero
*  coefficients in row (1), i.e. the following condition must hold:
*
*     |a[p,k]| >= eps * max(1, |a[p,j]|),                           (14)
*                        j
*
*  where eps is a relative tolerance for constraint coefficients.
*  Otherwise the implied column bounds can be numerical inreliable. For
*  example, using formula (8) for the following inequality constraint:
*
*     1e-12 x1 - x2 - x3 >= 0,
*
*  where x1 >= -1, x2, x3, >= 0, may lead to numerically unreliable
*  conclusion that x1 >= 0.
*
*  Using formulae (8), (9), (12), and (13) to compute implied bounds
*  for one variable requires |J| operations, where J = {j: a[p,j] != 0},
*  because this needs computing L[p,k] and U[p,k]. Thus, computing
*  implied bounds for all variables in row (1) would require |J|^2
*  operations, that is not a good technique. However, the total number
*  of operations can be reduced to |J| as follows.
*
*  Let a[p,k] > 0. Then from (7) and (11) we have:
*
*     L[p,k] = L[p] - (U'[p] - a[p,k] u[k]) =
*
*            = L[p] - U'[p] + a[p,k] u[k],
*
*     U[p,k] = U[p] - (L'[p] - a[p,k] l[k]) =
*
*            = U[p] - L'[p] + a[p,k] l[k],
*
*  where L'[p] and U'[p] are implied row lower and upper bounds defined
*  by formulae (3) and (4). Substituting these expressions into (8) and
*  (12) gives:
*
*     l'[k] = L[p,k] / a[p,k] = u[k] + (L[p] - U'[p]) / a[p,k],     (15)
*
*     u'[k] = U[p,k] / a[p,k] = l[k] + (U[p] - L'[p]) / a[p,k].     (16)
*
*  Similarly, if a[p,k] < 0, according to (7) and (11) we have:
*
*     L[p,k] = L[p] - (U'[p] - a[p,k] l[k]) =
*
*            = L[p] - U'[p] + a[p,k] l[k],
*
*     U[p,k] = U[p] - (L'[p] - a[p,k] u[k]) =
*
*            = U[p] - L'[p] + a[p,k] u[k],
*
*  and substituting these expressions into (8) and (12) gives:
*
*     l'[k] = U[p,k] / a[p,k] = u[k] + (U[p] - L'[p]) / a[p,k],     (17)
*
*     u'[k] = L[p,k] / a[p,k] = l[k] + (L[p] - U'[p]) / a[p,k].     (18)
*
*  Note that formulae (15)-(18) can be used only if L'[p] and U'[p]
*  exist. However, if for some variable x[j] it happens that l[j] = -oo
*  and/or u[j] = +oo, values of L'[p] (if a[p,j] > 0) and/or U'[p] (if
*  a[p,j] < 0) are undefined. Consider, therefore, the most general
*  situation, when some column bounds (2) may not exist.
*
*  Let:
*
*     J' = {j : (a[p,j] > 0 and l[j] = -oo) or
*                                                                   (19)
*               (a[p,j] < 0 and u[j] = +oo)}.
*
*  Then (assuming that row upper bound U[p] can be active) the following
*  three cases are possible:
*
*  1) |J'| = 0. In this case L'[p] exists, thus, for all variables x[j]
*     in row (1) we can use formulae (16) and (17);
*
*  2) J' = {k}. In this case L'[p] = -oo, however, U[p,k] (11) exists,
*     so for variable x[k] we can use formulae (12) and (13). Note that
*     for all other variables x[j] (j != k) l'[j] = -oo (if a[p,j] < 0)
*     or u'[j] = +oo (if a[p,j] > 0);
*
*  3) |J'| > 1. In this case for all variables x[j] in row [1] we have
*     l'[j] = -oo (if a[p,j] < 0) or u'[j] = +oo (if a[p,j] > 0).
*
*  Similarly, let:
*
*     J'' = {j : (a[p,j] > 0 and u[j] = +oo) or
*                                                                   (20)
*                (a[p,j] < 0 and l[j] = -oo)}.
*
*  Then (assuming that row lower bound L[p] can be active) the following
*  three cases are possible:
*
*  1) |J''| = 0. In this case U'[p] exists, thus, for all variables x[j]
*     in row (1) we can use formulae (15) and (18);
*
*  2) J'' = {k}. In this case U'[p] = +oo, however, L[p,k] (7) exists,
*     so for variable x[k] we can use formulae (8) and (9). Note that
*     for all other variables x[j] (j != k) l'[j] = -oo (if a[p,j] > 0)
*     or u'[j] = +oo (if a[p,j] < 0);
*
*  3) |J''| > 1. In this case for all variables x[j] in row (1) we have
*     l'[j] = -oo (if a[p,j] > 0) or u'[j] = +oo (if a[p,j] < 0). */

void npp_implied_bounds(NPP *npp, NPPROW *p)
{     NPPAIJ *apj, *apk;
      double big, eps, temp;
      xassert(npp == npp);
      /* initialize implied bounds for all variables and determine
         maximal magnitude of row coefficients a[p,j] */
      big = 1.0;
      for (apj = p->ptr; apj != NULL; apj = apj->r_next)
      {  apj->col->ll.ll = -DBL_MAX, apj->col->uu.uu = +DBL_MAX;
         if (big < fabs(apj->val)) big = fabs(apj->val);
      }
      eps = 1e-6 * big;
      /* process row lower bound (assuming that it can be active) */
      if (p->lb != -DBL_MAX)
      {  apk = NULL;
         for (apj = p->ptr; apj != NULL; apj = apj->r_next)
         {  if (apj->val > 0.0 && apj->col->ub == +DBL_MAX ||
                apj->val < 0.0 && apj->col->lb == -DBL_MAX)
            {  if (apk == NULL)
                  apk = apj;
               else
                  goto skip1;
            }
         }
         /* if a[p,k] = NULL then |J'| = 0 else J' = { k } */
         temp = p->lb;
         for (apj = p->ptr; apj != NULL; apj = apj->r_next)
         {  if (apj == apk)
               /* skip a[p,k] */;
            else if (apj->val > 0.0)
               temp -= apj->val * apj->col->ub;
            else /* apj->val < 0.0 */
               temp -= apj->val * apj->col->lb;
         }
         /* compute column implied bounds */
         if (apk == NULL)
         {  /* temp = L[p] - U'[p] */
            for (apj = p->ptr; apj != NULL; apj = apj->r_next)
            {  if (apj->val >= +eps)
               {  /* l'[j] := u[j] + (L[p] - U'[p]) / a[p,j] */
                  apj->col->ll.ll = apj->col->ub + temp / apj->val;
               }
               else if (apj->val <= -eps)
               {  /* u'[j] := l[j] + (L[p] - U'[p]) / a[p,j] */
                  apj->col->uu.uu = apj->col->lb + temp / apj->val;
               }
            }
         }
         else
         {  /* temp = L[p,k] */
            if (apk->val >= +eps)
            {  /* l'[k] := L[p,k] / a[p,k] */
               apk->col->ll.ll = temp / apk->val;
            }
            else if (apk->val <= -eps)
            {  /* u'[k] := L[p,k] / a[p,k] */
               apk->col->uu.uu = temp / apk->val;
            }
         }
skip1:   ;
      }
      /* process row upper bound (assuming that it can be active) */
      if (p->ub != +DBL_MAX)
      {  apk = NULL;
         for (apj = p->ptr; apj != NULL; apj = apj->r_next)
         {  if (apj->val > 0.0 && apj->col->lb == -DBL_MAX ||
                apj->val < 0.0 && apj->col->ub == +DBL_MAX)
            {  if (apk == NULL)
                  apk = apj;
               else
                  goto skip2;
            }
         }
         /* if a[p,k] = NULL then |J''| = 0 else J'' = { k } */
         temp = p->ub;
         for (apj = p->ptr; apj != NULL; apj = apj->r_next)
         {  if (apj == apk)
               /* skip a[p,k] */;
            else if (apj->val > 0.0)
               temp -= apj->val * apj->col->lb;
            else /* apj->val < 0.0 */
               temp -= apj->val * apj->col->ub;
         }
         /* compute column implied bounds */
         if (apk == NULL)
         {  /* temp = U[p] - L'[p] */
            for (apj = p->ptr; apj != NULL; apj = apj->r_next)
            {  if (apj->val >= +eps)
               {  /* u'[j] := l[j] + (U[p] - L'[p]) / a[p,j] */
                  apj->col->uu.uu = apj->col->lb + temp / apj->val;
               }
               else if (apj->val <= -eps)
               {  /* l'[j] := u[j] + (U[p] - L'[p]) / a[p,j] */
                  apj->col->ll.ll = apj->col->ub + temp / apj->val;
               }
            }
         }
         else
         {  /* temp = U[p,k] */
            if (apk->val >= +eps)
            {  /* u'[k] := U[p,k] / a[p,k] */
               apk->col->uu.uu = temp / apk->val;
            }
            else if (apk->val <= -eps)
            {  /* l'[k] := U[p,k] / a[p,k] */
               apk->col->ll.ll = temp / apk->val;
            }
         }
skip2:   ;
      }
      return;
}



struct binarize
{     int q;
      /* column reference number for x[q] = x[0] */
      int j;
      /* column reference number for x[1]; x[2] has reference number
         j+1, x[3] - j+2, etc. */
      int n;
      /* total number of binary variables, n >= 2 */
};

static int rcv_binarize_prob(NPP *npp, void *info);

int npp_binarize_prob(NPP *npp)
{     /* binarize MIP problem */
      struct binarize *info;
      NPPROW *row;
      NPPCOL *col, *bin;
      NPPAIJ *aij;
      int u, n, k, temp, nfails, nvars, nbins, nrows;
      /* new variables will be added to the end of the column list, so
         we go from the end to beginning of the column list */
      nfails = nvars = nbins = nrows = 0;
      for (col = npp->c_tail; col != NULL; col = col->prev)
      {  /* skip continuous variable */
         if (!col->is_int) continue;
         /* skip fixed variable */
         if (col->lb == col->ub) continue;
         /* skip binary variable */
         if (col->lb == 0.0 && col->ub == 1.0) continue;
         /* check if the transformation is applicable */
         if (col->lb < -1e6 || col->ub > +1e6 ||
             col->ub - col->lb > 4095.0)
         {  /* unfortunately, not */
            nfails++;
            continue;
         }
         /* process integer non-binary variable x[q] */
         nvars++;
         /* make x[q] non-negative, if its lower bound is non-zero */
         if (col->lb != 0.0)
            npp_lbnd_col(npp, col);
         /* now 0 <= x[q] <= u[q] */
         xassert(col->lb == 0.0);
         u = (int)col->ub;
         xassert(col->ub == (double)u);
         /* if x[q] is binary, further processing is not needed */
         if (u == 1) continue;
         /* determine smallest n such that u <= 2^n - 1 (thus, n is the
            number of binary variables needed) */
         n = 2, temp = 4;
         while (u >= temp)
            n++, temp += temp;
         nbins += n;
         /* create transformation stack entry */
         info = npp_push_tse(npp,
            rcv_binarize_prob, sizeof(struct binarize));
         info->q = col->j;
         info->j = 0; /* will be set below */
         info->n = n;
         /* if u < 2^n - 1, we need one additional row for (4) */
         if (u < temp - 1)
         {  row = npp_add_row(npp), nrows++;
            row->lb = -DBL_MAX, row->ub = u;
         }
         else
            row = NULL;
         /* in the transformed problem variable x[q] becomes binary
            variable x[0], so its objective and constraint coefficients
            are not changed */
         col->ub = 1.0;
         /* include x[0] into constraint (4) */
         if (row != NULL)
            npp_add_aij(npp, row, col, 1.0);
         /* add other binary variables x[1], ..., x[n-1] */
         for (k = 1, temp = 2; k < n; k++, temp += temp)
         {  /* add new binary variable x[k] */
            bin = npp_add_col(npp);
            bin->is_int = 1;
            bin->lb = 0.0, bin->ub = 1.0;
            bin->coef = (double)temp * col->coef;
            /* store column reference number for x[1] */
            if (info->j == 0)
               info->j = bin->j;
            else
               xassert(info->j + (k-1) == bin->j);
            /* duplicate constraint coefficients for x[k]; this also
               automatically includes x[k] into constraint (4) */
            for (aij = col->ptr; aij != NULL; aij = aij->c_next)
               npp_add_aij(npp, aij->row, bin, (double)temp * aij->val);
         }
      }
      if (nvars > 0)
         xprintf("%d integer variable(s) were replaced by %d binary one"
            "s\n", nvars, nbins);
      if (nrows > 0)
         xprintf("%d row(s) were added due to binarization\n", nrows);
      if (nfails > 0)
         xprintf("Binarization failed for %d integer variable(s)\n",
            nfails);
      return nfails;
}

static int rcv_binarize_prob(NPP *npp, void *_info)
{     /* recovery binarized variable */
      struct binarize *info = _info;
      int k, temp;
      double sum;
      /* compute value of x[q]; see formula (3) */
      sum = npp->c_value[info->q];
      for (k = 1, temp = 2; k < info->n; k++, temp += temp)
         sum += (double)temp * npp->c_value[info->j + (k-1)];
      npp->c_value[info->q] = sum;
      return 0;
}

/**********************************************************************/

struct elem
{     /* linear form element a[j] x[j] */
      double aj;
      /* non-zero coefficient value */
      NPPCOL *xj;
      /* pointer to variable (column) */
      struct elem *next;
      /* pointer to another term */
};

static struct elem *copy_form(NPP *npp, NPPROW *row, double s)
{     /* copy linear form */
      NPPAIJ *aij;
      struct elem *ptr, *e;
      ptr = NULL;
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  e = dmp_get_atom(npp->pool, sizeof(struct elem));
         e->aj = s * aij->val;
         e->xj = aij->col;
         e->next = ptr;
         ptr = e;
      }
      return ptr;
}

static void drop_form(NPP *npp, struct elem *ptr)
{     /* drop linear form */
      struct elem *e;
      while (ptr != NULL)
      {  e = ptr;
         ptr = e->next;
         dmp_free_atom(npp->pool, e, sizeof(struct elem));
      }
      return;
}

/***********************************************************************
*  NAME
*
*  npp_is_packing - test if constraint is packing inequality
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_is_packing(NPP *npp, NPPROW *row);
*
*  RETURNS
*
*  If the specified row (constraint) is packing inequality (see below),
*  the routine npp_is_packing returns non-zero. Otherwise, it returns
*  zero.
*
*  PACKING INEQUALITIES
*
*  In canonical format the packing inequality is the following:
*
*     sum  x[j] <= 1,                                                (1)
*    j in J
*
*  where all variables x[j] are binary. This inequality expresses the
*  condition that in any integer feasible solution at most one variable
*  from set J can take non-zero (unity) value while other variables
*  must be equal to zero. W.l.o.g. it is assumed that |J| >= 2, because
*  if J is empty or |J| = 1, the inequality (1) is redundant.
*
*  In general case the packing inequality may include original variables
*  x[j] as well as their complements x~[j]:
*
*     sum   x[j] + sum   x~[j] <= 1,                                 (2)
*    j in Jp      j in Jn
*
*  where Jp and Jn are not intersected. Therefore, using substitution
*  x~[j] = 1 - x[j] gives the packing inequality in generalized format:
*
*     sum   x[j] - sum   x[j] <= 1 - |Jn|.                           (3)
*    j in Jp      j in Jn */

int npp_is_packing(NPP *npp, NPPROW *row)
{     /* test if constraint is packing inequality */
      NPPCOL *col;
      NPPAIJ *aij;
      int b;
      xassert(npp == npp);
      if (!(row->lb == -DBL_MAX && row->ub != +DBL_MAX))
         return 0;
      b = 1;
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  col = aij->col;
         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))
            return 0;
         if (aij->val == +1.0)
            ;
         else if (aij->val == -1.0)
            b--;
         else
            return 0;
      }
      if (row->ub != (double)b) return 0;
      return 1;
}

/***********************************************************************
*  NAME
*
*  npp_hidden_packing - identify hidden packing inequality
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_hidden_packing(NPP *npp, NPPROW *row);
*
*  DESCRIPTION
*
*  The routine npp_hidden_packing processes specified inequality
*  constraint, which includes only binary variables, and the number of
*  the variables is not less than two. If the original inequality is
*  equivalent to a packing inequality, the routine replaces it by this
*  equivalent inequality. If the original constraint is double-sided
*  inequality, it is replaced by a pair of single-sided inequalities,
*  if necessary.
*
*  RETURNS
*
*  If the original inequality constraint was replaced by equivalent
*  packing inequality, the routine npp_hidden_packing returns non-zero.
*  Otherwise, it returns zero.
*
*  PROBLEM TRANSFORMATION
*
*  Consider an inequality constraint:
*
*     sum  a[j] x[j] <= b,                                           (1)
*    j in J
*
*  where all variables x[j] are binary, and |J| >= 2. (In case of '>='
*  inequality it can be transformed to '<=' format by multiplying both
*  its sides by -1.)
*
*  Let Jp = {j: a[j] > 0}, Jn = {j: a[j] < 0}. Performing substitution
*  x[j] = 1 - x~[j] for all j in Jn, we have:
*
*     sum   a[j] x[j] <= b  ==>
*    j in J
*
*     sum   a[j] x[j] + sum   a[j] x[j] <= b  ==>
*    j in Jp           j in Jn
*
*     sum   a[j] x[j] + sum   a[j] (1 - x~[j]) <= b  ==>
*    j in Jp           j in Jn
*
*     sum   a[j] x[j] - sum   a[j] x~[j] <= b - sum   a[j].
*    j in Jp           j in Jn                 j in Jn
*
*  Thus, meaning the transformation above, we can assume that in
*  inequality (1) all coefficients a[j] are positive. Moreover, we can
*  assume that a[j] <= b. In fact, let a[j] > b; then the following
*  three cases are possible:
*
*  1) b < 0. In this case inequality (1) is infeasible, so the problem
*     has no feasible solution (see the routine npp_analyze_row);
*
*  2) b = 0. In this case inequality (1) is a forcing inequality on its
*     upper bound (see the routine npp_forcing row), from which it
*     follows that all variables x[j] should be fixed at zero;
*
*  3) b > 0. In this case inequality (1) defines an implied zero upper
*     bound for variable x[j] (see the routine npp_implied_bounds), from
*     which it follows that x[j] should be fixed at zero.
*
*  It is assumed that all three cases listed above have been recognized
*  by the routine npp_process_prob, which performs basic MIP processing
*  prior to a call the routine npp_hidden_packing. So, if one of these
*  cases occurs, we should just skip processing such constraint.
*
*  Thus, let 0 < a[j] <= b. Then it is obvious that constraint (1) is
*  equivalent to packing inquality only if:
*
*     a[j] + a[k] > b + eps                                          (2)
*
*  for all j, k in J, j != k, where eps is an absolute tolerance for
*  row (linear form) value. Checking the condition (2) for all j and k,
*  j != k, requires time O(|J|^2). However, this time can be reduced to
*  O(|J|), if use minimal a[j] and a[k], in which case it is sufficient
*  to check the condition (2) only once.
*
*  Once the original inequality (1) is replaced by equivalent packing
*  inequality, we need to perform back substitution x~[j] = 1 - x[j] for
*  all j in Jn (see above).
*
*  RECOVERING SOLUTION
*
*  None needed. */

static int hidden_packing(NPP *npp, struct elem *ptr, double *_b)
{     /* process inequality constraint: sum a[j] x[j] <= b;
         0 - specified row is NOT hidden packing inequality;
         1 - specified row is packing inequality;
         2 - specified row is hidden packing inequality. */
      struct elem *e, *ej, *ek;
      int neg;
      double b = *_b, eps;
      xassert(npp == npp);
      /* a[j] must be non-zero, x[j] must be binary, for all j in J */
      for (e = ptr; e != NULL; e = e->next)
      {  xassert(e->aj != 0.0);
         xassert(e->xj->is_int);
         xassert(e->xj->lb == 0.0 && e->xj->ub == 1.0);
      }
      /* check if the specified inequality constraint already has the
         form of packing inequality */
      neg = 0; /* neg is |Jn| */
      for (e = ptr; e != NULL; e = e->next)
      {  if (e->aj == +1.0)
            ;
         else if (e->aj == -1.0)
            neg++;
         else
            break;
      }
      if (e == NULL)
      {  /* all coefficients a[j] are +1 or -1; check rhs b */
         if (b == (double)(1 - neg))
         {  /* it is packing inequality; no processing is needed */
            return 1;
         }
      }
      /* substitute x[j] = 1 - x~[j] for all j in Jn to make all a[j]
         positive; the result is a~[j] = |a[j]| and new rhs b */
      for (e = ptr; e != NULL; e = e->next)
         if (e->aj < 0) b -= e->aj;
      /* now a[j] > 0 for all j in J (actually |a[j]| are used) */
      /* if a[j] > b, skip processing--this case must not appear */
      for (e = ptr; e != NULL; e = e->next)
         if (fabs(e->aj) > b) return 0;
      /* now 0 < a[j] <= b for all j in J */
      /* find two minimal coefficients a[j] and a[k], j != k */
      ej = NULL;
      for (e = ptr; e != NULL; e = e->next)
         if (ej == NULL || fabs(ej->aj) > fabs(e->aj)) ej = e;
      xassert(ej != NULL);
      ek = NULL;
      for (e = ptr; e != NULL; e = e->next)
         if (e != ej)
            if (ek == NULL || fabs(ek->aj) > fabs(e->aj)) ek = e;
      xassert(ek != NULL);
      /* the specified constraint is equivalent to packing inequality
         iff a[j] + a[k] > b + eps */
      eps = 1e-3 + 1e-6 * fabs(b);
      if (fabs(ej->aj) + fabs(ek->aj) <= b + eps) return 0;
      /* perform back substitution x~[j] = 1 - x[j] and construct the
         final equivalent packing inequality in generalized format */
      b = 1.0;
      for (e = ptr; e != NULL; e = e->next)
      {  if (e->aj > 0.0)
            e->aj = +1.0;
         else /* e->aj < 0.0 */
            e->aj = -1.0, b -= 1.0;
      }
      *_b = b;
      return 2;
}

int npp_hidden_packing(NPP *npp, NPPROW *row)
{     /* identify hidden packing inequality */
      NPPROW *copy;
      NPPAIJ *aij;
      struct elem *ptr, *e;
      int kase, ret, count = 0;
      double b;
      /* the row must be inequality constraint */
      xassert(row->lb < row->ub);
      for (kase = 0; kase <= 1; kase++)
      {  if (kase == 0)
         {  /* process row upper bound */
            if (row->ub == +DBL_MAX) continue;
            ptr = copy_form(npp, row, +1.0);
            b = + row->ub;
         }
         else
         {  /* process row lower bound */
            if (row->lb == -DBL_MAX) continue;
            ptr = copy_form(npp, row, -1.0);
            b = - row->lb;
         }
         /* now the inequality has the form "sum a[j] x[j] <= b" */
         ret = hidden_packing(npp, ptr, &b);
         xassert(0 <= ret && ret <= 2);
         if (kase == 1 && ret == 1 || ret == 2)
         {  /* the original inequality has been identified as hidden
               packing inequality */
            count++;
#ifdef GLP_DEBUG
            xprintf("Original constraint:\n");
            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
               xprintf(" %+g x%d", aij->val, aij->col->j);
            if (row->lb != -DBL_MAX) xprintf(", >= %g", row->lb);
            if (row->ub != +DBL_MAX) xprintf(", <= %g", row->ub);
            xprintf("\n");
            xprintf("Equivalent packing inequality:\n");
            for (e = ptr; e != NULL; e = e->next)
               xprintf(" %sx%d", e->aj > 0.0 ? "+" : "-", e->xj->j);
            xprintf(", <= %g\n", b);
#endif
            if (row->lb == -DBL_MAX || row->ub == +DBL_MAX)
            {  /* the original row is single-sided inequality; no copy
                  is needed */
               copy = NULL;
            }
            else
            {  /* the original row is double-sided inequality; we need
                  to create its copy for other bound before replacing it
                  with the equivalent inequality */
               copy = npp_add_row(npp);
               if (kase == 0)
               {  /* the copy is for lower bound */
                  copy->lb = row->lb, copy->ub = +DBL_MAX;
               }
               else
               {  /* the copy is for upper bound */
                  copy->lb = -DBL_MAX, copy->ub = row->ub;
               }
               /* copy original row coefficients */
               for (aij = row->ptr; aij != NULL; aij = aij->r_next)
                  npp_add_aij(npp, copy, aij->col, aij->val);
            }
            /* replace the original inequality by equivalent one */
            npp_erase_row(npp, row);
            row->lb = -DBL_MAX, row->ub = b;
            for (e = ptr; e != NULL; e = e->next)
               npp_add_aij(npp, row, e->xj, e->aj);
            /* continue processing lower bound for the copy */
            if (copy != NULL) row = copy;
         }
         drop_form(npp, ptr);
      }
      return count;
}

/***********************************************************************
*  NAME
*
*  npp_implied_packing - identify implied packing inequality
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_implied_packing(NPP *npp, NPPROW *row, int which,
*     NPPCOL *var[], char set[]);
*
*  DESCRIPTION
*
*  The routine npp_implied_packing processes specified row (constraint)
*  of general format:
*
*     L <= sum a[j] x[j] <= U.                                       (1)
*           j
*
*  If which = 0, only lower bound L, which must exist, is considered,
*  while upper bound U is ignored. Similarly, if which = 1, only upper
*  bound U, which must exist, is considered, while lower bound L is
*  ignored. Thus, if the specified row is a double-sided inequality or
*  equality constraint, this routine should be called twice for both
*  lower and upper bounds.
*
*  The routine npp_implied_packing attempts to find a non-trivial (i.e.
*  having not less than two binary variables) packing inequality:
*
*     sum   x[j] - sum   x[j] <= 1 - |Jn|,                           (2)
*    j in Jp      j in Jn
*
*  which is relaxation of the constraint (1) in the sense that any
*  solution satisfying to that constraint also satisfies to the packing
*  inequality (2). If such relaxation exists, the routine stores
*  pointers to descriptors of corresponding binary variables and their
*  flags, resp., to locations var[1], var[2], ..., var[len] and set[1],
*  set[2], ..., set[len], where set[j] = 0 means that j in Jp and
*  set[j] = 1 means that j in Jn.
*
*  RETURNS
*
*  The routine npp_implied_packing returns len, which is the total
*  number of binary variables in the packing inequality found, len >= 2.
*  However, if the relaxation does not exist, the routine returns zero.
*
*  ALGORITHM
*
*  If which = 0, the constraint coefficients (1) are multiplied by -1
*  and b is assigned -L; if which = 1, the constraint coefficients (1)
*  are not changed and b is assigned +U. In both cases the specified
*  constraint gets the following format:
*
*     sum a[j] x[j] <= b.                                            (3)
*      j
*
*  (Note that (3) is a relaxation of (1), because one of bounds L or U
*  is ignored.)
*
*  Let J be set of binary variables, Kp be set of non-binary (integer
*  or continuous) variables with a[j] > 0, and Kn be set of non-binary
*  variables with a[j] < 0. Then the inequality (3) can be written as
*  follows:
*
*     sum  a[j] x[j] <= b - sum   a[j] x[j] - sum   a[j] x[j].       (4)
*    j in J                j in Kp           j in Kn
*
*  To get rid of non-binary variables we can replace the inequality (4)
*  by the following relaxed inequality:
*
*     sum  a[j] x[j] <= b~,                                          (5)
*    j in J
*
*  where:
*
*     b~ = sup(b - sum   a[j] x[j] - sum   a[j] x[j]) =
*                 j in Kp           j in Kn
*
*        = b - inf sum   a[j] x[j] - inf sum   a[j] x[j] =           (6)
*                 j in Kp               j in Kn
*
*        = b - sum   a[j] l[j] - sum   a[j] u[j].
*             j in Kp           j in Kn
*
*  Note that if lower bound l[j] (if j in Kp) or upper bound u[j]
*  (if j in Kn) of some non-binary variable x[j] does not exist, then
*  formally b = +oo, in which case further analysis is not performed.
*
*  Let Bp = {j in J: a[j] > 0}, Bn = {j in J: a[j] < 0}. To make all
*  the inequality coefficients in (5) positive, we replace all x[j] in
*  Bn by their complementaries, substituting x[j] = 1 - x~[j] for all
*  j in Bn, that gives:
*
*     sum   a[j] x[j] - sum   a[j] x~[j] <= b~ - sum   a[j].         (7)
*    j in Bp           j in Bn                  j in Bn
*
*  This inequality is a relaxation of the original constraint (1), and
*  it is a binary knapsack inequality. Writing it in the standard format
*  we have:
*
*     sum  alfa[j] z[j] <= beta,                                     (8)
*    j in J
*
*  where:
*               ( + a[j],   if j in Bp,
*     alfa[j] = <                                                    (9)
*               ( - a[j],   if j in Bn,
*
*               ( x[j],     if j in Bp,
*        z[j] = <                                                   (10)
*               ( 1 - x[j], if j in Bn,
*
*        beta = b~ - sum   a[j].                                    (11)
*                   j in Bn
*
*  In the inequality (8) all coefficients are positive, therefore, the
*  packing relaxation to be found for this inequality is the following:
*
*     sum  z[j] <= 1.                                               (12)
*    j in P
*
*  It is obvious that set P within J, which we would like to find, must
*  satisfy to the following condition:
*
*     alfa[j] + alfa[k] > beta + eps  for all j, k in P, j != k,    (13)
*
*  where eps is an absolute tolerance for value of the linear form.
*  Thus, it is natural to take P = {j: alpha[j] > (beta + eps) / 2}.
*  Moreover, if in the equality (8) there exist coefficients alfa[k],
*  for which alfa[k] <= (beta + eps) / 2, but which, nevertheless,
*  satisfies to the condition (13) for all j in P, *one* corresponding
*  variable z[k] (having, for example, maximal coefficient alfa[k]) can
*  be included in set P, that allows increasing the number of binary
*  variables in (12) by one.
*
*  Once the set P has been built, for the inequality (12) we need to
*  perform back substitution according to (10) in order to express it
*  through the original binary variables. As the result of such back
*  substitution the relaxed packing inequality get its final format (2),
*  where Jp = J intersect Bp, and Jn = J intersect Bn. */

int npp_implied_packing(NPP *npp, NPPROW *row, int which,
      NPPCOL *var[], char set[])
{     struct elem *ptr, *e, *i, *k;
      int len = 0;
      double b, eps;
      /* build inequality (3) */
      if (which == 0)
      {  ptr = copy_form(npp, row, -1.0);
         xassert(row->lb != -DBL_MAX);
         b = - row->lb;
      }
      else if (which == 1)
      {  ptr = copy_form(npp, row, +1.0);
         xassert(row->ub != +DBL_MAX);
         b = + row->ub;
      }
      /* remove non-binary variables to build relaxed inequality (5);
         compute its right-hand side b~ with formula (6) */
      for (e = ptr; e != NULL; e = e->next)
      {  if (!(e->xj->is_int && e->xj->lb == 0.0 && e->xj->ub == 1.0))
         {  /* x[j] is non-binary variable */
            if (e->aj > 0.0)
            {  if (e->xj->lb == -DBL_MAX) goto done;
               b -= e->aj * e->xj->lb;
            }
            else /* e->aj < 0.0 */
            {  if (e->xj->ub == +DBL_MAX) goto done;
               b -= e->aj * e->xj->ub;
            }
            /* a[j] = 0 means that variable x[j] is removed */
            e->aj = 0.0;
         }
      }
      /* substitute x[j] = 1 - x~[j] to build knapsack inequality (8);
         compute its right-hand side beta with formula (11) */
      for (e = ptr; e != NULL; e = e->next)
         if (e->aj < 0.0) b -= e->aj;
      /* if beta is close to zero, the knapsack inequality is either
         infeasible or forcing inequality; this must never happen, so
         we skip further analysis */
      if (b < 1e-3) goto done;
      /* build set P as well as sets Jp and Jn, and determine x[k] as
         explained above in comments to the routine */
      eps = 1e-3 + 1e-6 * b;
      i = k = NULL;
      for (e = ptr; e != NULL; e = e->next)
      {  /* note that alfa[j] = |a[j]| */
         if (fabs(e->aj) > 0.5 * (b + eps))
         {  /* alfa[j] > (b + eps) / 2; include x[j] in set P, i.e. in
               set Jp or Jn */
            var[++len] = e->xj;
            set[len] = (char)(e->aj > 0.0 ? 0 : 1);
            /* alfa[i] = min alfa[j] over all j included in set P */
            if (i == NULL || fabs(i->aj) > fabs(e->aj)) i = e;
         }
         else if (fabs(e->aj) >= 1e-3)
         {  /* alfa[k] = max alfa[j] over all j not included in set P;
               we skip coefficient a[j] if it is close to zero to avoid
               numerically unreliable results */
            if (k == NULL || fabs(k->aj) < fabs(e->aj)) k = e;
         }
      }
      /* if alfa[k] satisfies to condition (13) for all j in P, include
         x[k] in P */
      if (i != NULL && k != NULL && fabs(i->aj) + fabs(k->aj) > b + eps)
      {  var[++len] = k->xj;
         set[len] = (char)(k->aj > 0.0 ? 0 : 1);
      }
      /* trivial packing inequality being redundant must never appear,
         so we just ignore it */
      if (len < 2) len = 0;
done: drop_form(npp, ptr);
      return len;
}

/***********************************************************************
*  NAME
*
*  npp_is_covering - test if constraint is covering inequality
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_is_covering(NPP *npp, NPPROW *row);
*
*  RETURNS
*
*  If the specified row (constraint) is covering inequality (see below),
*  the routine npp_is_covering returns non-zero. Otherwise, it returns
*  zero.
*
*  COVERING INEQUALITIES
*
*  In canonical format the covering inequality is the following:
*
*     sum  x[j] >= 1,                                                (1)
*    j in J
*
*  where all variables x[j] are binary. This inequality expresses the
*  condition that in any integer feasible solution variables in set J
*  cannot be all equal to zero at the same time, i.e. at least one
*  variable must take non-zero (unity) value. W.l.o.g. it is assumed
*  that |J| >= 2, because if J is empty, the inequality (1) is
*  infeasible, and if |J| = 1, the inequality (1) is a forcing row.
*
*  In general case the covering inequality may include original
*  variables x[j] as well as their complements x~[j]:
*
*     sum   x[j] + sum   x~[j] >= 1,                                 (2)
*    j in Jp      j in Jn
*
*  where Jp and Jn are not intersected. Therefore, using substitution
*  x~[j] = 1 - x[j] gives the packing inequality in generalized format:
*
*     sum   x[j] - sum   x[j] >= 1 - |Jn|.                           (3)
*    j in Jp      j in Jn
*
*  (May note that the inequality (3) cuts off infeasible solutions,
*  where x[j] = 0 for all j in Jp and x[j] = 1 for all j in Jn.)
*
*  NOTE: If |J| = 2, the inequality (3) is equivalent to packing
*        inequality (see the routine npp_is_packing). */

int npp_is_covering(NPP *npp, NPPROW *row)
{     /* test if constraint is covering inequality */
      NPPCOL *col;
      NPPAIJ *aij;
      int b;
      xassert(npp == npp);
      if (!(row->lb != -DBL_MAX && row->ub == +DBL_MAX))
         return 0;
      b = 1;
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  col = aij->col;
         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))
            return 0;
         if (aij->val == +1.0)
            ;
         else if (aij->val == -1.0)
            b--;
         else
            return 0;
      }
      if (row->lb != (double)b) return 0;
      return 1;
}

/***********************************************************************
*  NAME
*
*  npp_hidden_covering - identify hidden covering inequality
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_hidden_covering(NPP *npp, NPPROW *row);
*
*  DESCRIPTION
*
*  The routine npp_hidden_covering processes specified inequality
*  constraint, which includes only binary variables, and the number of
*  the variables is not less than three. If the original inequality is
*  equivalent to a covering inequality (see below), the routine
*  replaces it by the equivalent inequality. If the original constraint
*  is double-sided inequality, it is replaced by a pair of single-sided
*  inequalities, if necessary.
*
*  RETURNS
*
*  If the original inequality constraint was replaced by equivalent
*  covering inequality, the routine npp_hidden_covering returns
*  non-zero. Otherwise, it returns zero.
*
*  PROBLEM TRANSFORMATION
*
*  Consider an inequality constraint:
*
*     sum  a[j] x[j] >= b,                                           (1)
*    j in J
*
*  where all variables x[j] are binary, and |J| >= 3. (In case of '<='
*  inequality it can be transformed to '>=' format by multiplying both
*  its sides by -1.)
*
*  Let Jp = {j: a[j] > 0}, Jn = {j: a[j] < 0}. Performing substitution
*  x[j] = 1 - x~[j] for all j in Jn, we have:
*
*     sum   a[j] x[j] >= b  ==>
*    j in J
*
*     sum   a[j] x[j] + sum   a[j] x[j] >= b  ==>
*    j in Jp           j in Jn
*
*     sum   a[j] x[j] + sum   a[j] (1 - x~[j]) >= b  ==>
*    j in Jp           j in Jn
*
*     sum  m   a[j] x[j] - sum   a[j] x~[j] >= b - sum   a[j].
*    j in Jp              j in Jn                 j in Jn
*
*  Thus, meaning the transformation above, we can assume that in
*  inequality (1) all coefficients a[j] are positive. Moreover, we can
*  assume that b > 0, because otherwise the inequality (1) would be
*  redundant (see the routine npp_analyze_row). It is then obvious that
*  constraint (1) is equivalent to covering inequality only if:
*
*     a[j] >= b,                                                     (2)
*
*  for all j in J.
*
*  Once the original inequality (1) is replaced by equivalent covering
*  inequality, we need to perform back substitution x~[j] = 1 - x[j] for
*  all j in Jn (see above).
*
*  RECOVERING SOLUTION
*
*  None needed. */

static int hidden_covering(NPP *npp, struct elem *ptr, double *_b)
{     /* process inequality constraint: sum a[j] x[j] >= b;
         0 - specified row is NOT hidden covering inequality;
         1 - specified row is covering inequality;
         2 - specified row is hidden covering inequality. */
      struct elem *e;
      int neg;
      double b = *_b, eps;
      xassert(npp == npp);
      /* a[j] must be non-zero, x[j] must be binary, for all j in J */
      for (e = ptr; e != NULL; e = e->next)
      {  xassert(e->aj != 0.0);
         xassert(e->xj->is_int);
         xassert(e->xj->lb == 0.0 && e->xj->ub == 1.0);
      }
      /* check if the specified inequality constraint already has the
         form of covering inequality */
      neg = 0; /* neg is |Jn| */
      for (e = ptr; e != NULL; e = e->next)
      {  if (e->aj == +1.0)
            ;
         else if (e->aj == -1.0)
            neg++;
         else
            break;
      }
      if (e == NULL)
      {  /* all coefficients a[j] are +1 or -1; check rhs b */
         if (b == (double)(1 - neg))
         {  /* it is covering inequality; no processing is needed */
            return 1;
         }
      }
      /* substitute x[j] = 1 - x~[j] for all j in Jn to make all a[j]
         positive; the result is a~[j] = |a[j]| and new rhs b */
      for (e = ptr; e != NULL; e = e->next)
         if (e->aj < 0) b -= e->aj;
      /* now a[j] > 0 for all j in J (actually |a[j]| are used) */
      /* if b <= 0, skip processing--this case must not appear */
      if (b < 1e-3) return 0;
      /* now a[j] > 0 for all j in J, and b > 0 */
      /* the specified constraint is equivalent to covering inequality
         iff a[j] >= b for all j in J */
      eps = 1e-9 + 1e-12 * fabs(b);
      for (e = ptr; e != NULL; e = e->next)
         if (fabs(e->aj) < b - eps) return 0;
      /* perform back substitution x~[j] = 1 - x[j] and construct the
         final equivalent covering inequality in generalized format */
      b = 1.0;
      for (e = ptr; e != NULL; e = e->next)
      {  if (e->aj > 0.0)
            e->aj = +1.0;
         else /* e->aj < 0.0 */
            e->aj = -1.0, b -= 1.0;
      }
      *_b = b;
      return 2;
}

int npp_hidden_covering(NPP *npp, NPPROW *row)
{     /* identify hidden covering inequality */
      NPPROW *copy;
      NPPAIJ *aij;
      struct elem *ptr, *e;
      int kase, ret, count = 0;
      double b;
      /* the row must be inequality constraint */
      xassert(row->lb < row->ub);
      for (kase = 0; kase <= 1; kase++)
      {  if (kase == 0)
         {  /* process row lower bound */
            if (row->lb == -DBL_MAX) continue;
            ptr = copy_form(npp, row, +1.0);
            b = + row->lb;
         }
         else
         {  /* process row upper bound */
            if (row->ub == +DBL_MAX) continue;
            ptr = copy_form(npp, row, -1.0);
            b = - row->ub;
         }
         /* now the inequality has the form "sum a[j] x[j] >= b" */
         ret = hidden_covering(npp, ptr, &b);
         xassert(0 <= ret && ret <= 2);
         if (kase == 1 && ret == 1 || ret == 2)
         {  /* the original inequality has been identified as hidden
               covering inequality */
            count++;
#ifdef GLP_DEBUG
            xprintf("Original constraint:\n");
            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
               xprintf(" %+g x%d", aij->val, aij->col->j);
            if (row->lb != -DBL_MAX) xprintf(", >= %g", row->lb);
            if (row->ub != +DBL_MAX) xprintf(", <= %g", row->ub);
            xprintf("\n");
            xprintf("Equivalent covering inequality:\n");
            for (e = ptr; e != NULL; e = e->next)
               xprintf(" %sx%d", e->aj > 0.0 ? "+" : "-", e->xj->j);
            xprintf(", >= %g\n", b);
#endif
            if (row->lb == -DBL_MAX || row->ub == +DBL_MAX)
            {  /* the original row is single-sided inequality; no copy
                  is needed */
               copy = NULL;
            }
            else
            {  /* the original row is double-sided inequality; we need
                  to create its copy for other bound before replacing it
                  with the equivalent inequality */
               copy = npp_add_row(npp);
               if (kase == 0)
               {  /* the copy is for upper bound */
                  copy->lb = -DBL_MAX, copy->ub = row->ub;
               }
               else
               {  /* the copy is for lower bound */
                  copy->lb = row->lb, copy->ub = +DBL_MAX;
               }
               /* copy original row coefficients */
               for (aij = row->ptr; aij != NULL; aij = aij->r_next)
                  npp_add_aij(npp, copy, aij->col, aij->val);
            }
            /* replace the original inequality by equivalent one */
            npp_erase_row(npp, row);
            row->lb = b, row->ub = +DBL_MAX;
            for (e = ptr; e != NULL; e = e->next)
               npp_add_aij(npp, row, e->xj, e->aj);
            /* continue processing upper bound for the copy */
            if (copy != NULL) row = copy;
         }
         drop_form(npp, ptr);
      }
      return count;
}

/***********************************************************************
*  NAME
*
*  npp_is_partitioning - test if constraint is partitioning equality
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_is_partitioning(NPP *npp, NPPROW *row);
*
*  RETURNS
*
*  If the specified row (constraint) is partitioning equality (see
*  below), the routine npp_is_partitioning returns non-zero. Otherwise,
*  it returns zero.
*
*  PARTITIONING EQUALITIES
*
*  In canonical format the partitioning equality is the following:
*
*     sum  x[j] = 1,                                                 (1)
*    j in J
*
*  where all variables x[j] are binary. This equality expresses the
*  condition that in any integer feasible solution exactly one variable
*  in set J must take non-zero (unity) value while other variables must
*  be equal to zero. W.l.o.g. it is assumed that |J| >= 2, because if
*  J is empty, the inequality (1) is infeasible, and if |J| = 1, the
*  inequality (1) is a fixing row.
*
*  In general case the partitioning equality may include original
*  variables x[j] as well as their complements x~[j]:
*
*     sum   x[j] + sum   x~[j] = 1,                                  (2)
*    j in Jp      j in Jn
*
*  where Jp and Jn are not intersected. Therefore, using substitution
*  x~[j] = 1 - x[j] leads to the partitioning equality in generalized
*  format:
*
*     sum   x[j] - sum   x[j] = 1 - |Jn|.                            (3)
*    j in Jp      j in Jn */

int npp_is_partitioning(NPP *npp, NPPROW *row)
{     /* test if constraint is partitioning equality */
      NPPCOL *col;
      NPPAIJ *aij;
      int b;
      xassert(npp == npp);
      if (row->lb != row->ub) return 0;
      b = 1;
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  col = aij->col;
         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))
            return 0;
         if (aij->val == +1.0)
            ;
         else if (aij->val == -1.0)
            b--;
         else
            return 0;
      }
      if (row->lb != (double)b) return 0;
      return 1;
}

/***********************************************************************
*  NAME
*
*  npp_reduce_ineq_coef - reduce inequality constraint coefficients
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_reduce_ineq_coef(NPP *npp, NPPROW *row);
*
*  DESCRIPTION
*
*  The routine npp_reduce_ineq_coef processes specified inequality
*  constraint attempting to replace it by an equivalent constraint,
*  where magnitude of coefficients at binary variables is smaller than
*  in the original constraint. If the inequality is double-sided, it is
*  replaced by a pair of single-sided inequalities, if necessary.
*
*  RETURNS
*
*  The routine npp_reduce_ineq_coef returns the number of coefficients
*  reduced.
*
*  BACKGROUND
*
*  Consider an inequality constraint:
*
*     sum  a[j] x[j] >= b.                                           (1)
*    j in J
*
*  (In case of '<=' inequality it can be transformed to '>=' format by
*  multiplying both its sides by -1.) Let x[k] be a binary variable;
*  other variables can be integer as well as continuous. We can write
*  constraint (1) as follows:
*
*     a[k] x[k] + t[k] >= b,                                         (2)
*
*  where:
*
*     t[k] = sum      a[j] x[j].                                     (3)
*           j in J\{k}
*
*  Since x[k] is binary, constraint (2) is equivalent to disjunction of
*  the following two constraints:
*
*     x[k] = 0,  t[k] >= b                                           (4)
*
*        OR
*
*     x[k] = 1,  t[k] >= b - a[k].                                   (5)
*
*  Let also that for the partial sum t[k] be known some its implied
*  lower bound inf t[k].
*
*  Case a[k] > 0. Let inf t[k] < b, since otherwise both constraints
*  (4) and (5) and therefore constraint (2) are redundant.
*  If inf t[k] > b - a[k], only constraint (5) is redundant, in which
*  case it can be replaced with the following redundant and therefore
*  equivalent constraint:
*
*     t[k] >= b - a'[k] = inf t[k],                                  (6)
*
*  where:
*
*     a'[k] = b - inf t[k].                                          (7)
*
*  Thus, the original constraint (2) is equivalent to the following
*  constraint with coefficient at variable x[k] changed:
*
*     a'[k] x[k] + t[k] >= b.                                        (8)
*
*  From inf t[k] < b it follows that a'[k] > 0, i.e. the coefficient
*  at x[k] keeps its sign. And from inf t[k] > b - a[k] it follows that
*  a'[k] < a[k], i.e. the coefficient reduces in magnitude.
*
*  Case a[k] < 0. Let inf t[k] < b - a[k], since otherwise both
*  constraints (4) and (5) and therefore constraint (2) are redundant.
*  If inf t[k] > b, only constraint (4) is redundant, in which case it
*  can be replaced with the following redundant and therefore equivalent
*  constraint:
*
*     t[k] >= b' = inf t[k].                                         (9)
*
*  Rewriting constraint (5) as follows:
*
*     t[k] >= b - a[k] = b' - a'[k],                                (10)
*
*  where:
*
*     a'[k] = a[k] + b' - b = a[k] + inf t[k] - b,                  (11)
*
*  we can see that disjunction of constraint (9) and (10) is equivalent
*  to disjunction of constraint (4) and (5), from which it follows that
*  the original constraint (2) is equivalent to the following constraint
*  with both coefficient at variable x[k] and right-hand side changed:
*
*     a'[k] x[k] + t[k] >= b'.                                      (12)
*
*  From inf t[k] < b - a[k] it follows that a'[k] < 0, i.e. the
*  coefficient at x[k] keeps its sign. And from inf t[k] > b it follows
*  that a'[k] > a[k], i.e. the coefficient reduces in magnitude.
*
*  PROBLEM TRANSFORMATION
*
*  In the routine npp_reduce_ineq_coef the following implied lower
*  bound of the partial sum (3) is used:
*
*     inf t[k] = sum       a[j] l[j] + sum       a[j] u[j],         (13)
*               j in Jp\{k}           k in Jn\{k}
*
*  where Jp = {j : a[j] > 0}, Jn = {j : a[j] < 0}, l[j] and u[j] are
*  lower and upper bounds, resp., of variable x[j].
*
*  In order to compute inf t[k] more efficiently, the following formula,
*  which is equivalent to (13), is actually used:
*
*                ( h - a[k] l[k] = h,        if a[k] > 0,
*     inf t[k] = <                                                  (14)
*                ( h - a[k] u[k] = h - a[k], if a[k] < 0,
*
*  where:
*
*     h = sum   a[j] l[j] + sum   a[j] u[j]                         (15)
*        j in Jp           j in Jn
*
*  is the implied lower bound of row (1).
*
*  Reduction of positive coefficient (a[k] > 0) does not change value
*  of h, since l[k] = 0. In case of reduction of negative coefficient
*  (a[k] < 0) from (11) it follows that:
*
*     delta a[k] = a'[k] - a[k] = inf t[k] - b  (> 0),              (16)
*
*  so new value of h (accounting that u[k] = 1) can be computed as
*  follows:
*
*     h := h + delta a[k] = h + (inf t[k] - b).                     (17)
*
*  RECOVERING SOLUTION
*
*  None needed. */

static int reduce_ineq_coef(NPP *npp, struct elem *ptr, double *_b)
{     /* process inequality constraint: sum a[j] x[j] >= b */
      /* returns: the number of coefficients reduced */
      struct elem *e;
      int count = 0;
      double h, inf_t, new_a, b = *_b;
      xassert(npp == npp);
      /* compute h; see (15) */
      h = 0.0;
      for (e = ptr; e != NULL; e = e->next)
      {  if (e->aj > 0.0)
         {  if (e->xj->lb == -DBL_MAX) goto done;
            h += e->aj * e->xj->lb;
         }
         else /* e->aj < 0.0 */
         {  if (e->xj->ub == +DBL_MAX) goto done;
            h += e->aj * e->xj->ub;
         }
      }
      /* perform reduction of coefficients at binary variables */
      for (e = ptr; e != NULL; e = e->next)
      {  /* skip non-binary variable */
         if (!(e->xj->is_int && e->xj->lb == 0.0 && e->xj->ub == 1.0))
            continue;
         if (e->aj > 0.0)
         {  /* compute inf t[k]; see (14) */
            inf_t = h;
            if (b - e->aj < inf_t && inf_t < b)
            {  /* compute reduced coefficient a'[k]; see (7) */
               new_a = b - inf_t;
               if (new_a >= +1e-3 &&
                   e->aj - new_a >= 0.01 * (1.0 + e->aj))
               {  /* accept a'[k] */
#ifdef GLP_DEBUG
                  xprintf("+");
#endif
                  e->aj = new_a;
                  count++;
               }
            }
         }
         else /* e->aj < 0.0 */
         {  /* compute inf t[k]; see (14) */
            inf_t = h - e->aj;
            if (b < inf_t && inf_t < b - e->aj)
            {  /* compute reduced coefficient a'[k]; see (11) */
               new_a = e->aj + (inf_t - b);
               if (new_a <= -1e-3 &&
                   new_a - e->aj >= 0.01 * (1.0 - e->aj))
               {  /* accept a'[k] */
#ifdef GLP_DEBUG
                  xprintf("-");
#endif
                  e->aj = new_a;
                  /* update h; see (17) */
                  h += (inf_t - b);
                  /* compute b'; see (9) */
                  b = inf_t;
                  count++;
               }
            }
         }
      }
      *_b = b;
done: return count;
}

int npp_reduce_ineq_coef(NPP *npp, NPPROW *row)
{     /* reduce inequality constraint coefficients */
      NPPROW *copy;
      NPPAIJ *aij;
      struct elem *ptr, *e;
      int kase, count[2];
      double b;
      /* the row must be inequality constraint */
      xassert(row->lb < row->ub);
      count[0] = count[1] = 0;
      for (kase = 0; kase <= 1; kase++)
      {  if (kase == 0)
         {  /* process row lower bound */
            if (row->lb == -DBL_MAX) continue;
#ifdef GLP_DEBUG
            xprintf("L");
#endif
            ptr = copy_form(npp, row, +1.0);
            b = + row->lb;
         }
         else
         {  /* process row upper bound */
            if (row->ub == +DBL_MAX) continue;
#ifdef GLP_DEBUG
            xprintf("U");
#endif
            ptr = copy_form(npp, row, -1.0);
            b = - row->ub;
         }
         /* now the inequality has the form "sum a[j] x[j] >= b" */
         count[kase] = reduce_ineq_coef(npp, ptr, &b);
         if (count[kase] > 0)
         {  /* the original inequality has been replaced by equivalent
               one with coefficients reduced */
            if (row->lb == -DBL_MAX || row->ub == +DBL_MAX)
            {  /* the original row is single-sided inequality; no copy
                  is needed */
               copy = NULL;
            }
            else
            {  /* the original row is double-sided inequality; we need
                  to create its copy for other bound before replacing it
                  with the equivalent inequality */
#ifdef GLP_DEBUG
               xprintf("*");
#endif
               copy = npp_add_row(npp);
               if (kase == 0)
               {  /* the copy is for upper bound */
                  copy->lb = -DBL_MAX, copy->ub = row->ub;
               }
               else
               {  /* the copy is for lower bound */
                  copy->lb = row->lb, copy->ub = +DBL_MAX;
               }
               /* copy original row coefficients */
               for (aij = row->ptr; aij != NULL; aij = aij->r_next)
                  npp_add_aij(npp, copy, aij->col, aij->val);
            }
            /* replace the original inequality by equivalent one */
            npp_erase_row(npp, row);
            row->lb = b, row->ub = +DBL_MAX;
            for (e = ptr; e != NULL; e = e->next)
               npp_add_aij(npp, row, e->xj, e->aj);
            /* continue processing upper bound for the copy */
            if (copy != NULL) row = copy;
         }
         drop_form(npp, ptr);
      }
      return count[0] + count[1];
}



/***********************************************************************
*  NAME
*
*  npp_clean_prob - perform initial LP/MIP processing
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  void npp_clean_prob(NPP *npp);
*
*  DESCRIPTION
*
*  The routine npp_clean_prob performs initial LP/MIP processing that
*  currently includes:
*
*  1) removing free rows;
*
*  2) replacing double-sided constraint rows with almost identical
*     bounds, by equality constraint rows;
*
*  3) removing fixed columns;
*
*  4) replacing double-bounded columns with almost identical bounds by
*     fixed columns and removing those columns;
*
*  5) initial processing constraint coefficients (not implemented);
*
*  6) initial processing objective coefficients (not implemented). */

void npp_clean_prob(NPP *npp)
{     /* perform initial LP/MIP processing */
      NPPROW *row, *next_row;
      NPPCOL *col, *next_col;
      int ret;
      xassert(npp == npp);
      /* process rows which originally are free */
      for (row = npp->r_head; row != NULL; row = next_row)
      {  next_row = row->next;
         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)
         {  /* process free row */
#ifdef GLP_DEBUG
            xprintf("1");
#endif
            npp_free_row(npp, row);
            /* row was deleted */
         }
      }
      /* process rows which originally are double-sided inequalities */
      for (row = npp->r_head; row != NULL; row = next_row)
      {  next_row = row->next;
         if (row->lb != -DBL_MAX && row->ub != +DBL_MAX &&
             row->lb < row->ub)
         {  ret = npp_make_equality(npp, row);
            if (ret == 0)
               ;
            else if (ret == 1)
            {  /* row was replaced by equality constraint */
#ifdef GLP_DEBUG
               xprintf("2");
#endif
            }
            else
               xassert(ret != ret);
         }
      }
      /* process columns which are originally fixed */
      for (col = npp->c_head; col != NULL; col = next_col)
      {  next_col = col->next;
         if (col->lb == col->ub)
         {  /* process fixed column */
#ifdef GLP_DEBUG
            xprintf("3");
#endif
            npp_fixed_col(npp, col);
            /* column was deleted */
         }
      }
      /* process columns which are originally double-bounded */
      for (col = npp->c_head; col != NULL; col = next_col)
      {  next_col = col->next;
         if (col->lb != -DBL_MAX && col->ub != +DBL_MAX &&
             col->lb < col->ub)
         {  ret = npp_make_fixed(npp, col);
            if (ret == 0)
               ;
            else if (ret == 1)
            {  /* column was replaced by fixed column; process it */
#ifdef GLP_DEBUG
               xprintf("4");
#endif
               npp_fixed_col(npp, col);
               /* column was deleted */
            }
         }
      }
      return;
}

/***********************************************************************
*  NAME
*
*  npp_process_row - perform basic row processing
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_process_row(NPP *npp, NPPROW *row, int hard);
*
*  DESCRIPTION
*
*  The routine npp_process_row performs basic row processing that
*  currently includes:
*
*  1) removing empty row;
*
*  2) removing equality constraint row singleton and corresponding
*     column;
*
*  3) removing inequality constraint row singleton and corresponding
*     column if it was fixed;
*
*  4) performing general row analysis;
*
*  5) removing redundant row bounds;
*
*  6) removing forcing row and corresponding columns;
*
*  7) removing row which becomes free due to redundant bounds;
*
*  8) computing implied bounds for all columns in the row and using
*     them to strengthen current column bounds (MIP only, optional,
*     performed if the flag hard is on).
*
*  Additionally the routine may activate affected rows and/or columns
*  for further processing.
*
*  RETURNS
*
*  0           success;
*
*  GLP_ENOPFS  primal/integer infeasibility detected;
*
*  GLP_ENODFS  dual infeasibility detected. */

int npp_process_row(NPP *npp, NPPROW *row, int hard)
{     /* perform basic row processing */
      NPPCOL *col;
      NPPAIJ *aij, *next_aij, *aaa;
      int ret;
      /* row must not be free */
      xassert(!(row->lb == -DBL_MAX && row->ub == +DBL_MAX));
      /* start processing row */
      if (row->ptr == NULL)
      {  /* empty row */
         ret = npp_empty_row(npp, row);
         if (ret == 0)
         {  /* row was deleted */
#ifdef GLP_DEBUG
            xprintf("A");
#endif
            return 0;
         }
         else if (ret == 1)
         {  /* primal infeasibility */
            return GLP_ENOPFS;
         }
         else
            xassert(ret != ret);
      }
      if (row->ptr->r_next == NULL)
      {  /* row singleton */
         col = row->ptr->col;
         if (row->lb == row->ub)
         {  /* equality constraint */
            ret = npp_eq_singlet(npp, row);
            if (ret == 0)
            {  /* column was fixed, row was deleted */
#ifdef GLP_DEBUG
               xprintf("B");
#endif
               /* activate rows affected by column */
               for (aij = col->ptr; aij != NULL; aij = aij->c_next)
                  npp_activate_row(npp, aij->row);
               /* process fixed column */
               npp_fixed_col(npp, col);
               /* column was deleted */
               return 0;
            }
            else if (ret == 1 || ret == 2)
            {  /* primal/integer infeasibility */
               return GLP_ENOPFS;
            }
            else
               xassert(ret != ret);
         }
         else
         {  /* inequality constraint */
            ret = npp_ineq_singlet(npp, row);
            if (0 <= ret && ret <= 3)
            {  /* row was deleted */
#ifdef GLP_DEBUG
               xprintf("C");
#endif
               /* activate column, since its length was changed due to
                  row deletion */
               npp_activate_col(npp, col);
               if (ret >= 2)
               {  /* column bounds changed significantly or column was
                     fixed */
                  /* activate rows affected by column */
                  for (aij = col->ptr; aij != NULL; aij = aij->c_next)
                     npp_activate_row(npp, aij->row);
               }
               if (ret == 3)
               {  /* column was fixed; process it */
#ifdef GLP_DEBUG
                  xprintf("D");
#endif
                  npp_fixed_col(npp, col);
                  /* column was deleted */
               }
               return 0;
            }
            else if (ret == 4)
            {  /* primal infeasibility */
               return GLP_ENOPFS;
            }
            else
               xassert(ret != ret);
         }
      }
#if 0
      /* sometimes this causes too large round-off errors; probably
         pivot coefficient should be chosen more carefully */
      if (row->ptr->r_next->r_next == NULL)
      {  /* row doubleton */
         if (row->lb == row->ub)
         {  /* equality constraint */
            if (!(row->ptr->col->is_int ||
                  row->ptr->r_next->col->is_int))
            {  /* both columns are continuous */
               NPPCOL *q;
               q = npp_eq_doublet(npp, row);
               if (q != NULL)
               {  /* column q was eliminated */
#ifdef GLP_DEBUG
                  xprintf("E");
#endif
                  /* now column q is singleton of type "implied slack
                     variable"; we process it here to make sure that on
                     recovering basic solution the row is always active
                     equality constraint (as required by the routine
                     rcv_eq_doublet) */
                  xassert(npp_process_col(npp, q) == 0);
                  /* column q was deleted; note that row p also may be
                     deleted */
                  return 0;
               }
            }
         }
      }
#endif
      /* general row analysis */
      ret = npp_analyze_row(npp, row);
      xassert(0x00 <= ret && ret <= 0xFF);
      if (ret == 0x33)
      {  /* row bounds are inconsistent with column bounds */
         return GLP_ENOPFS;
      }
      if ((ret & 0x0F) == 0x00)
      {  /* row lower bound does not exist or redundant */
         if (row->lb != -DBL_MAX)
         {  /* remove redundant row lower bound */
#ifdef GLP_DEBUG
            xprintf("F");
#endif
            npp_inactive_bound(npp, row, 0);
         }
      }
      else if ((ret & 0x0F) == 0x01)
      {  /* row lower bound can be active */
         /* see below */
      }
      else if ((ret & 0x0F) == 0x02)
      {  /* row lower bound is a forcing bound */
#ifdef GLP_DEBUG
         xprintf("G");
#endif
         /* process forcing row */
         if (npp_forcing_row(npp, row, 0) == 0)
fixup:   {  /* columns were fixed, row was made free */
            for (aij = row->ptr; aij != NULL; aij = next_aij)
            {  /* process column fixed by forcing row */
#ifdef GLP_DEBUG
               xprintf("H");
#endif
               col = aij->col;
               next_aij = aij->r_next;
               /* activate rows affected by column */
               for (aaa = col->ptr; aaa != NULL; aaa = aaa->c_next)
                  npp_activate_row(npp, aaa->row);
               /* process fixed column */
               npp_fixed_col(npp, col);
               /* column was deleted */
            }
            /* process free row (which now is empty due to deletion of
               all its columns) */
            npp_free_row(npp, row);
            /* row was deleted */
            return 0;
         }
      }
      else
         xassert(ret != ret);
      if ((ret & 0xF0) == 0x00)
      {  /* row upper bound does not exist or redundant */
         if (row->ub != +DBL_MAX)
         {  /* remove redundant row upper bound */
#ifdef GLP_DEBUG
            xprintf("I");
#endif
            npp_inactive_bound(npp, row, 1);
         }
      }
      else if ((ret & 0xF0) == 0x10)
      {  /* row upper bound can be active */
         /* see below */
      }
      else if ((ret & 0xF0) == 0x20)
      {  /* row upper bound is a forcing bound */
#ifdef GLP_DEBUG
         xprintf("J");
#endif
         /* process forcing row */
         if (npp_forcing_row(npp, row, 1) == 0) goto fixup;
      }
      else
         xassert(ret != ret);
      if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)
      {  /* row became free due to redundant bounds removal */
#ifdef GLP_DEBUG
         xprintf("K");
#endif
         /* activate its columns, since their length will change due
            to row deletion */
         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
            npp_activate_col(npp, aij->col);
         /* process free row */
         npp_free_row(npp, row);
         /* row was deleted */
         return 0;
      }
#if 1 /* 23/XII-2009 */
      /* row lower and/or upper bounds can be active */
      if (npp->sol == GLP_MIP && hard)
      {  /* improve current column bounds (optional) */
         if (npp_improve_bounds(npp, row, 1) < 0)
            return GLP_ENOPFS;
      }
#endif
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_improve_bounds - improve current column bounds
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_improve_bounds(NPP *npp, NPPROW *row, int flag);
*
*  DESCRIPTION
*
*  The routine npp_improve_bounds analyzes specified row (inequality
*  or equality constraint) to determine implied column bounds and then
*  uses these bounds to improve (strengthen) current column bounds.
*
*  If the flag is on and current column bounds changed significantly
*  or the column was fixed, the routine activate rows affected by the
*  column for further processing. (This feature is intended to be used
*  in the main loop of the routine npp_process_row.)
*
*  NOTE: This operation can be used for MIP problem only.
*
*  RETURNS
*
*  The routine npp_improve_bounds returns the number of significantly
*  changed bounds plus the number of column having been fixed due to
*  bound improvements. However, if the routine detects primal/integer
*  infeasibility, it returns a negative value. */

int npp_improve_bounds(NPP *npp, NPPROW *row, int flag)
{     /* improve current column bounds */
      NPPCOL *col;
      NPPAIJ *aij, *next_aij, *aaa;
      int kase, ret, count = 0;
      double lb, ub;
      xassert(npp->sol == GLP_MIP);
      /* row must not be free */
      xassert(!(row->lb == -DBL_MAX && row->ub == +DBL_MAX));
      /* determine implied column bounds */
      npp_implied_bounds(npp, row);
      /* and use these bounds to strengthen current column bounds */
      for (aij = row->ptr; aij != NULL; aij = next_aij)
      {  col = aij->col;
         next_aij = aij->r_next;
         for (kase = 0; kase <= 1; kase++)
         {  /* save current column bounds */
            lb = col->lb, ub = col->ub;
            if (kase == 0)
            {  /* process implied column lower bound */
               if (col->ll.ll == -DBL_MAX) continue;
               ret = npp_implied_lower(npp, col, col->ll.ll);
            }
            else
            {  /* process implied column upper bound */
               if (col->uu.uu == +DBL_MAX) continue;
               ret = npp_implied_upper(npp, col, col->uu.uu);
            }
            if (ret == 0 || ret == 1)
            {  /* current column bounds did not change or changed, but
                  not significantly; restore current column bounds */
               col->lb = lb, col->ub = ub;
            }
            else if (ret == 2 || ret == 3)
            {  /* current column bounds changed significantly or column
                  was fixed */
#ifdef GLP_DEBUG
               xprintf("L");
#endif
               count++;
               /* activate other rows affected by column, if required */
               if (flag)
               {  for (aaa = col->ptr; aaa != NULL; aaa = aaa->c_next)
                  {  if (aaa->row != row)
                        npp_activate_row(npp, aaa->row);
                  }
               }
               if (ret == 3)
               {  /* process fixed column */
#ifdef GLP_DEBUG
                  xprintf("M");
#endif
                  npp_fixed_col(npp, col);
                  /* column was deleted */
                  break; /* for kase */
               }
            }
            else if (ret == 4)
            {  /* primal/integer infeasibility */
               return -1;
            }
            else
               xassert(ret != ret);
         }
      }
      return count;
}

/***********************************************************************
*  NAME
*
*  npp_process_col - perform basic column processing
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_process_col(NPP *npp, NPPCOL *col);
*
*  DESCRIPTION
*
*  The routine npp_process_col performs basic column processing that
*  currently includes:
*
*  1) fixing and removing empty column;
*
*  2) removing column singleton, which is implied slack variable, and
*     corresponding row if it becomes free;
*
*  3) removing bounds of column, which is implied free variable, and
*     replacing corresponding row by equality constraint.
*
*  Additionally the routine may activate affected rows and/or columns
*  for further processing.
*
*  RETURNS
*
*  0           success;
*
*  GLP_ENOPFS  primal/integer infeasibility detected;
*
*  GLP_ENODFS  dual infeasibility detected. */

int npp_process_col(NPP *npp, NPPCOL *col)
{     /* perform basic column processing */
      NPPROW *row;
      NPPAIJ *aij;
      int ret;
      /* column must not be fixed */
      xassert(col->lb < col->ub);
      /* start processing column */
      if (col->ptr == NULL)
      {  /* empty column */
         ret = npp_empty_col(npp, col);
         if (ret == 0)
         {  /* column was fixed and deleted */
#ifdef GLP_DEBUG
            xprintf("N");
#endif
            return 0;
         }
         else if (ret == 1)
         {  /* dual infeasibility */
            return GLP_ENODFS;
         }
         else
            xassert(ret != ret);
      }
      if (col->ptr->c_next == NULL)
      {  /* column singleton */
         row = col->ptr->row;
         if (row->lb == row->ub)
         {  /* equality constraint */
            if (!col->is_int)
slack:      {  /* implied slack variable */
#ifdef GLP_DEBUG
               xprintf("O");
#endif
               npp_implied_slack(npp, col);
               /* column was deleted */
               if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)
               {  /* row became free due to implied slack variable */
#ifdef GLP_DEBUG
                  xprintf("P");
#endif
                  /* activate columns affected by row */
                  for (aij = row->ptr; aij != NULL; aij = aij->r_next)
                     npp_activate_col(npp, aij->col);
                  /* process free row */
                  npp_free_row(npp, row);
                  /* row was deleted */
               }
               else
               {  /* row became inequality constraint; activate it
                     since its length changed due to column deletion */
                  npp_activate_row(npp, row);
               }
               return 0;
            }
         }
         else
         {  /* inequality constraint */
            if (!col->is_int)
            {  ret = npp_implied_free(npp, col);
               if (ret == 0)
               {  /* implied free variable */
#ifdef GLP_DEBUG
                  xprintf("Q");
#endif
                  /* column bounds were removed, row was replaced by
                     equality constraint */
                  goto slack;
               }
               else if (ret == 1)
               {  /* column is not implied free variable, because its
                     lower and/or upper bounds can be active */
               }
               else if (ret == 2)
               {  /* dual infeasibility */
                  return GLP_ENODFS;
               }
            }
         }
      }
      /* column still exists */
      return 0;
}

/***********************************************************************
*  NAME
*
*  npp_process_prob - perform basic LP/MIP processing
*
*  SYNOPSIS
*
*  #include "glpnpp.h"
*  int npp_process_prob(NPP *npp, int hard);
*
*  DESCRIPTION
*
*  The routine npp_process_prob performs basic LP/MIP processing that
*  currently includes:
*
*  1) initial LP/MIP processing (see the routine npp_clean_prob),
*
*  2) basic row processing (see the routine npp_process_row), and
*
*  3) basic column processing (see the routine npp_process_col).
*
*  If the flag hard is on, the routine attempts to improve current
*  column bounds multiple times within the main processing loop, in
*  which case this feature may take a time. Otherwise, if the flag hard
*  is off, improving column bounds is performed only once at the end of
*  the main loop. (Note that this feature is used for MIP only.)
*
*  The routine uses two sets: the set of active rows and the set of
*  active columns. Rows/columns are marked by a flag (the field temp in
*  NPPROW/NPPCOL). If the flag is non-zero, the row/column is active,
*  in which case it is placed in the beginning of the row/column list;
*  otherwise, if the flag is zero, the row/column is inactive, in which
*  case it is placed in the end of the row/column list. If a row/column
*  being currently processed may affect other rows/columns, the latters
*  are activated for further processing.
*
*  RETURNS
*
*  0           success;
*
*  GLP_ENOPFS  primal/integer infeasibility detected;
*
*  GLP_ENODFS  dual infeasibility detected. */

int npp_process_prob(NPP *npp, int hard)
{     /* perform basic LP/MIP processing */
      NPPROW *row;
      NPPCOL *col;
      int processing, ret;
      /* perform initial LP/MIP processing */
      npp_clean_prob(npp);
      /* activate all remaining rows and columns */
      for (row = npp->r_head; row != NULL; row = row->next)
         row->temp = 1;
      for (col = npp->c_head; col != NULL; col = col->next)
         col->temp = 1;
      /* main processing loop */
      processing = 1;
      while (processing)
      {  processing = 0;
         /* process all active rows */
         for (;;)
         {  row = npp->r_head;
            if (row == NULL || !row->temp) break;
            npp_deactivate_row(npp, row);
            ret = npp_process_row(npp, row, hard);
            if (ret != 0) goto done;
            processing = 1;
         }
         /* process all active columns */
         for (;;)
         {  col = npp->c_head;
            if (col == NULL || !col->temp) break;
            npp_deactivate_col(npp, col);
            ret = npp_process_col(npp, col);
            if (ret != 0) goto done;
            processing = 1;
         }
      }
#if 1 /* 23/XII-2009 */
      if (npp->sol == GLP_MIP && !hard)
      {  /* improve current column bounds (optional) */
         for (row = npp->r_head; row != NULL; row = row->next)
         {  if (npp_improve_bounds(npp, row, 0) < 0)
            {  ret = GLP_ENOPFS;
               goto done;
            }
         }
      }
#endif
      /* all seems ok */
      ret = 0;
done: xassert(ret == 0 || ret == GLP_ENOPFS || ret == GLP_ENODFS);
#ifdef GLP_DEBUG
      xprintf("\n");
#endif
      return ret;
}

/**********************************************************************/

int npp_simplex(NPP *npp, const glp_smcp *parm)
{     /* process LP prior to applying primal/dual simplex method */
      int ret;
      xassert(npp->sol == GLP_SOL);
      xassert(parm == parm);
      ret = npp_process_prob(npp, 0);
      return ret;
}

/**********************************************************************/

int npp_integer(NPP *npp, const glp_iocp *parm)
{     /* process MIP prior to applying branch-and-bound method */
      NPPROW *row, *prev_row;
      NPPCOL *col;
      NPPAIJ *aij;
      int count, ret;
      xassert(npp->sol == GLP_MIP);
      xassert(parm == parm);
      /*==============================================================*/
      /* perform basic MIP processing */
      ret = npp_process_prob(npp, 1);
      if (ret != 0) goto done;
      /*==============================================================*/
      /* binarize problem, if required */
      if (parm->binarize)
         npp_binarize_prob(npp);
      /*==============================================================*/
      /* identify hidden packing inequalities */
      count = 0;
      /* new rows will be added to the end of the row list, so we go
         from the end to beginning of the row list */
      for (row = npp->r_tail; row != NULL; row = prev_row)
      {  prev_row = row->prev;
         /* skip free row */
         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX) continue;
         /* skip equality constraint */
         if (row->lb == row->ub) continue;
         /* skip row having less than two variables */
         if (row->ptr == NULL || row->ptr->r_next == NULL) continue;
         /* skip row having non-binary variables */
         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
         {  col = aij->col;
            if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))
               break;
         }
         if (aij != NULL) continue;
         count += npp_hidden_packing(npp, row);
      }
      if (count > 0)
         xprintf("%d hidden packing inequaliti(es) were detected\n",
            count);
      /*==============================================================*/
      /* identify hidden covering inequalities */
      count = 0;
      /* new rows will be added to the end of the row list, so we go
         from the end to beginning of the row list */
      for (row = npp->r_tail; row != NULL; row = prev_row)
      {  prev_row = row->prev;
         /* skip free row */
         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX) continue;
         /* skip equality constraint */
         if (row->lb == row->ub) continue;
         /* skip row having less than three variables */
         if (row->ptr == NULL || row->ptr->r_next == NULL ||
             row->ptr->r_next->r_next == NULL) continue;
         /* skip row having non-binary variables */
         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
         {  col = aij->col;
            if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))
               break;
         }
         if (aij != NULL) continue;
         count += npp_hidden_covering(npp, row);
      }
      if (count > 0)
         xprintf("%d hidden covering inequaliti(es) were detected\n",
            count);
      /*==============================================================*/
      /* reduce inequality constraint coefficients */
      count = 0;
      /* new rows will be added to the end of the row list, so we go
         from the end to beginning of the row list */
      for (row = npp->r_tail; row != NULL; row = prev_row)
      {  prev_row = row->prev;
         /* skip equality constraint */
         if (row->lb == row->ub) continue;
         count += npp_reduce_ineq_coef(npp, row);
      }
      if (count > 0)
         xprintf("%d constraint coefficient(s) were reduced\n", count);
      /*==============================================================*/
#ifdef GLP_DEBUG
      routine(npp);
#endif
      /*==============================================================*/
      /* all seems ok */
      ret = 0;
done: return ret;
}
/***********************************************************************
*  npp_sat_free_row - process free (unbounded) row
*
*  This routine processes row p, which is free (i.e. has no finite
*  bounds):
*
*     -inf < sum a[p,j] x[j] < +inf.                                 (1)
*
*  The constraint (1) cannot be active and therefore it is redundant,
*  so the routine simply removes it from the original problem. */

void npp_sat_free_row(NPP *npp, NPPROW *p)
{     /* the row should be free */
      xassert(p->lb == -DBL_MAX && p->ub == +DBL_MAX);
      /* remove the row from the problem */
      npp_del_row(npp, p);
      return;
}

/***********************************************************************
*  npp_sat_fixed_col - process fixed column
*
*  This routine processes column q, which is fixed:
*
*     x[q] = s[q],                                                   (1)
*
*  where s[q] is a fixed column value.
*
*  The routine substitutes fixed value s[q] into constraint rows and
*  then removes column x[q] from the original problem.
*
*  Substitution of x[q] = s[q] into row i gives:
*
*     L[i] <= sum a[i,j] x[j] <= U[i]   ==>
*              j
*
*     L[i] <= sum a[i,j] x[j] + a[i,q] x[q] <= U[i]   ==>
*            j!=q
*
*     L[i] <= sum a[i,j] x[j] + a[i,q] s[q] <= U[i]   ==>
*            j!=q
*
*     L~[i] <= sum a[i,j] x[j] <= U~[i],
*             j!=q
*
*  where
*
*     L~[i] = L[i] - a[i,q] s[q],                                    (2)
*
*     U~[i] = U[i] - a[i,q] s[q]                                     (3)
*
*  are, respectively, lower and upper bound of row i in the transformed
*  problem.
*
*  On recovering solution x[q] is assigned the value of s[q]. */

struct sat_fixed_col
{     /* fixed column */
      int q;
      /* column reference number for variable x[q] */
      int s;
      /* value, at which x[q] is fixed */
};

static int rcv_sat_fixed_col(NPP *, void *);

int npp_sat_fixed_col(NPP *npp, NPPCOL *q)
{     struct sat_fixed_col *info;
      NPPROW *i;
      NPPAIJ *aij;
      int temp;
      /* the column should be fixed */
      xassert(q->lb == q->ub);
      /* create transformation stack entry */
      info = npp_push_tse(npp,
         rcv_sat_fixed_col, sizeof(struct sat_fixed_col));
      info->q = q->j;
      info->s = (int)q->lb;
      xassert((double)info->s == q->lb);
      /* substitute x[q] = s[q] into constraint rows */
      if (info->s == 0)
         goto skip;
      for (aij = q->ptr; aij != NULL; aij = aij->c_next)
      {  i = aij->row;
         if (i->lb != -DBL_MAX)
         {  i->lb -= aij->val * (double)info->s;
            temp = (int)i->lb;
            if ((double)temp != i->lb)
               return 1; /* integer arithmetic error */
         }
         if (i->ub != +DBL_MAX)
         {  i->ub -= aij->val * (double)info->s;
            temp = (int)i->ub;
            if ((double)temp != i->ub)
               return 2; /* integer arithmetic error */
         }
      }
skip: /* remove the column from the problem */
      npp_del_col(npp, q);
      return 0;
}

static int rcv_sat_fixed_col(NPP *npp, void *info_)
{     struct sat_fixed_col *info = info_;
      npp->c_value[info->q] = (double)info->s;
      return 0;
}

/***********************************************************************
*  npp_sat_is_bin_comb - test if row is binary combination
*
*  This routine tests if the specified row is a binary combination,
*  i.e. all its constraint coefficients are +1 and -1 and all variables
*  are binary. If the test was passed, the routine returns non-zero,
*  otherwise zero. */

int npp_sat_is_bin_comb(NPP *npp, NPPROW *row)
{     NPPCOL *col;
      NPPAIJ *aij;
      xassert(npp == npp);
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  if (!(aij->val == +1.0 || aij->val == -1.0))
            return 0; /* non-unity coefficient */
         col = aij->col;
         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))
            return 0; /* non-binary column */
      }
      return 1; /* test was passed */
}

/***********************************************************************
*  npp_sat_num_pos_coef - determine number of positive coefficients
*
*  This routine returns the number of positive coefficients in the
*  specified row. */

int npp_sat_num_pos_coef(NPP *npp, NPPROW *row)
{     NPPAIJ *aij;
      int num = 0;
      xassert(npp == npp);
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  if (aij->val > 0.0)
            num++;
      }
      return num;
}

/***********************************************************************
*  npp_sat_num_neg_coef - determine number of negative coefficients
*
*  This routine returns the number of negative coefficients in the
*  specified row. */

int npp_sat_num_neg_coef(NPP *npp, NPPROW *row)
{     NPPAIJ *aij;
      int num = 0;
      xassert(npp == npp);
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  if (aij->val < 0.0)
            num++;
      }
      return num;
}

/***********************************************************************
*  npp_sat_is_cover_ineq - test if row is covering inequality
*
*  The canonical form of a covering inequality is the following:
*
*     sum x[j] >= 1,                                                 (1)
*   j in J
*
*  where all x[j] are binary variables.
*
*  In general case a covering inequality may have one of the following
*  two forms:
*
*     sum  x[j] -  sum  x[j] >= 1 - |J-|,                            (2)
*   j in J+      j in J-
*
*
*     sum  x[j] -  sum  x[j] <= |J+| - 1.                            (3)
*   j in J+      j in J-
*
*  Obviously, the inequality (2) can be transformed to the form (1) by
*  substitution x[j] = 1 - x'[j] for all j in J-, where x'[j] is the
*  negation of variable x[j]. And the inequality (3) can be transformed
*  to (2) by multiplying both left- and right-hand sides by -1.
*
*  This routine returns one of the following codes:
*
*  0, if the specified row is not a covering inequality;
*
*  1, if the specified row has the form (2);
*
*  2, if the specified row has the form (3). */

int npp_sat_is_cover_ineq(NPP *npp, NPPROW *row)
{     xassert(npp == npp);
      if (row->lb != -DBL_MAX && row->ub == +DBL_MAX)
      {  /* row is inequality of '>=' type */
         if (npp_sat_is_bin_comb(npp, row))
         {  /* row is a binary combination */
            if (row->lb == 1.0 - npp_sat_num_neg_coef(npp, row))
            {  /* row has the form (2) */
               return 1;
            }
         }
      }
      else if (row->lb == -DBL_MAX && row->ub != +DBL_MAX)
      {  /* row is inequality of '<=' type */
         if (npp_sat_is_bin_comb(npp, row))
         {  /* row is a binary combination */
            if (row->ub == npp_sat_num_pos_coef(npp, row) - 1.0)
            {  /* row has the form (3) */
               return 2;
            }
         }
      }
      /* row is not a covering inequality */
      return 0;
}

/***********************************************************************
*  npp_sat_is_pack_ineq - test if row is packing inequality
*
*  The canonical form of a packing inequality is the following:
*
*     sum x[j] <= 1,                                                 (1)
*   j in J
*
*  where all x[j] are binary variables.
*
*  In general case a packing inequality may have one of the following
*  two forms:
*
*     sum  x[j] -  sum  x[j] <= 1 - |J-|,                            (2)
*   j in J+      j in J-
*
*
*     sum  x[j] -  sum  x[j] >= |J+| - 1.                            (3)
*   j in J+      j in J-
*
*  Obviously, the inequality (2) can be transformed to the form (1) by
*  substitution x[j] = 1 - x'[j] for all j in J-, where x'[j] is the
*  negation of variable x[j]. And the inequality (3) can be transformed
*  to (2) by multiplying both left- and right-hand sides by -1.
*
*  This routine returns one of the following codes:
*
*  0, if the specified row is not a packing inequality;
*
*  1, if the specified row has the form (2);
*
*  2, if the specified row has the form (3). */

int npp_sat_is_pack_ineq(NPP *npp, NPPROW *row)
{     xassert(npp == npp);
      if (row->lb == -DBL_MAX && row->ub != +DBL_MAX)
      {  /* row is inequality of '<=' type */
         if (npp_sat_is_bin_comb(npp, row))
         {  /* row is a binary combination */
            if (row->ub == 1.0 - npp_sat_num_neg_coef(npp, row))
            {  /* row has the form (2) */
               return 1;
            }
         }
      }
      else if (row->lb != -DBL_MAX && row->ub == +DBL_MAX)
      {  /* row is inequality of '>=' type */
         if (npp_sat_is_bin_comb(npp, row))
         {  /* row is a binary combination */
            if (row->lb == npp_sat_num_pos_coef(npp, row) - 1.0)
            {  /* row has the form (3) */
               return 2;
            }
         }
      }
      /* row is not a packing inequality */
      return 0;
}

/***********************************************************************
*  npp_sat_is_partn_eq - test if row is partitioning equality
*
*  The canonical form of a partitioning equality is the following:
*
*     sum x[j] = 1,                                                  (1)
*   j in J
*
*  where all x[j] are binary variables.
*
*  In general case a partitioning equality may have one of the following
*  two forms:
*
*     sum  x[j] -  sum  x[j] = 1 - |J-|,                             (2)
*   j in J+      j in J-
*
*
*     sum  x[j] -  sum  x[j] = |J+| - 1.                             (3)
*   j in J+      j in J-
*
*  Obviously, the equality (2) can be transformed to the form (1) by
*  substitution x[j] = 1 - x'[j] for all j in J-, where x'[j] is the
*  negation of variable x[j]. And the equality (3) can be transformed
*  to (2) by multiplying both left- and right-hand sides by -1.
*
*  This routine returns one of the following codes:
*
*  0, if the specified row is not a partitioning equality;
*
*  1, if the specified row has the form (2);
*
*  2, if the specified row has the form (3). */

int npp_sat_is_partn_eq(NPP *npp, NPPROW *row)
{     xassert(npp == npp);
      if (row->lb == row->ub)
      {  /* row is equality constraint */
         if (npp_sat_is_bin_comb(npp, row))
         {  /* row is a binary combination */
            if (row->lb == 1.0 - npp_sat_num_neg_coef(npp, row))
            {  /* row has the form (2) */
               return 1;
            }
            if (row->ub == npp_sat_num_pos_coef(npp, row) - 1.0)
            {  /* row has the form (3) */
               return 2;
            }
         }
      }
      /* row is not a partitioning equality */
      return 0;
}

/***********************************************************************
*  npp_sat_reverse_row - multiply both sides of row by -1
*
*  This routines multiplies by -1 both left- and right-hand sides of
*  the specified row:
*
*     L <= sum x[j] <= U,
*
*  that results in the following row:
*
*     -U <= sum (-x[j]) <= -L.
*
*  If no integer overflow occured, the routine returns zero, otherwise
*  non-zero. */

int npp_sat_reverse_row(NPP *npp, NPPROW *row)
{     NPPAIJ *aij;
      int temp, ret = 0;
      double old_lb, old_ub;
      xassert(npp == npp);
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  aij->val = -aij->val;
         temp = (int)aij->val;
         if ((double)temp != aij->val)
            ret = 1;
      }
      old_lb = row->lb, old_ub = row->ub;
      if (old_ub == +DBL_MAX)
         row->lb = -DBL_MAX;
      else
      {  row->lb = -old_ub;
         temp = (int)row->lb;
         if ((double)temp != row->lb)
            ret = 2;
      }
      if (old_lb == -DBL_MAX)
         row->ub = +DBL_MAX;
      else
      {  row->ub = -old_lb;
         temp = (int)row->ub;
         if ((double)temp != row->ub)
            ret = 3;
      }
      return ret;
}

/***********************************************************************
*  npp_sat_split_pack - split packing inequality
*
*  Let there be given a packing inequality in canonical form:
*
*     sum  t[j] <= 1,                                                (1)
*   j in J
*
*  where t[j] = x[j] or t[j] = 1 - x[j], x[j] is a binary variable.
*  And let J = J1 U J2 is a partition of the set of literals. Then the
*  inequality (1) is obviously equivalent to the following two packing
*  inequalities:
*
*     sum  t[j] <= y       <-->   sum  t[j] + (1 - y) <= 1,          (2)
*   j in J1                     j in J1
*
*     sum  t[j] <= 1 - y   <-->   sum  t[j] + y       <= 1,          (3)
*   j in J2                     j in J2
*
*  where y is a new binary variable added to the transformed problem.
*
*  Assuming that the specified row is a packing inequality (1), this
*  routine constructs the set J1 by including there first nlit literals
*  (terms) from the specified row, and the set J2 = J \ J1. Then the
*  routine creates a new row, which corresponds to inequality (2), and
*  replaces the specified row with inequality (3). */

NPPROW *npp_sat_split_pack(NPP *npp, NPPROW *row, int nlit)
{     NPPROW *rrr;
      NPPCOL *col;
      NPPAIJ *aij;
      int k;
      /* original row should be packing inequality (1) */
      xassert(npp_sat_is_pack_ineq(npp, row) == 1);
      /* and nlit should be less than the number of literals (terms)
         in the original row */
      xassert(0 < nlit && nlit < npp_row_nnz(npp, row));
      /* create new row corresponding to inequality (2) */
      rrr = npp_add_row(npp);
      rrr->lb = -DBL_MAX, rrr->ub = 1.0;
      /* move first nlit literals (terms) from the original row to the
         new row; the original row becomes inequality (3) */
      for (k = 1; k <= nlit; k++)
      {  aij = row->ptr;
         xassert(aij != NULL);
         /* add literal to the new row */
         npp_add_aij(npp, rrr, aij->col, aij->val);
         /* correct rhs */
         if (aij->val < 0.0)
            rrr->ub -= 1.0, row->ub += 1.0;
         /* remove literal from the original row */
         npp_del_aij(npp, aij);
      }
      /* create new binary variable y */
      col = npp_add_col(npp);
      col->is_int = 1, col->lb = 0.0, col->ub = 1.0;
      /* include literal (1 - y) in the new row */
      npp_add_aij(npp, rrr, col, -1.0);
      rrr->ub -= 1.0;
      /* include literal y in the original row */
      npp_add_aij(npp, row, col, +1.0);
      return rrr;
}

/***********************************************************************
*  npp_sat_encode_pack - encode packing inequality
*
*  Given a packing inequality in canonical form:
*
*     sum  t[j] <= 1,                                                (1)
*   j in J
*
*  where t[j] = x[j] or t[j] = 1 - x[j], x[j] is a binary variable,
*  this routine translates it to CNF by replacing it with the following
*  equivalent set of edge packing inequalities:
*
*     t[j] + t[k] <= 1   for all j, k in J, j != k.                  (2)
*
*  Then the routine transforms each edge packing inequality (2) to
*  corresponding covering inequality (that encodes two-literal clause)
*  by multiplying both its part by -1:
*
*     - t[j] - t[k] >= -1   <-->   (1 - t[j]) + (1 - t[k]) >= 1.     (3)
*
*  On exit the routine removes the original row from the problem. */

void npp_sat_encode_pack(NPP *npp, NPPROW *row)
{     NPPROW *rrr;
      NPPAIJ *aij, *aik;
      /* original row should be packing inequality (1) */
      xassert(npp_sat_is_pack_ineq(npp, row) == 1);
      /* create equivalent system of covering inequalities (3) */
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  /* due to symmetry only one of inequalities t[j] + t[k] <= 1
            and t[k] <= t[j] <= 1 can be considered */
         for (aik = aij->r_next; aik != NULL; aik = aik->r_next)
         {  /* create edge packing inequality (2) */
            rrr = npp_add_row(npp);
            rrr->lb = -DBL_MAX, rrr->ub = 1.0;
            npp_add_aij(npp, rrr, aij->col, aij->val);
            if (aij->val < 0.0)
               rrr->ub -= 1.0;
            npp_add_aij(npp, rrr, aik->col, aik->val);
            if (aik->val < 0.0)
               rrr->ub -= 1.0;
            /* and transform it to covering inequality (3) */
            npp_sat_reverse_row(npp, rrr);
            xassert(npp_sat_is_cover_ineq(npp, rrr) == 1);
         }
      }
      /* remove the original row from the problem */
      npp_del_row(npp, row);
      return;
}

/***********************************************************************
*  npp_sat_encode_sum2 - encode 2-bit summation
*
*  Given a set containing two literals x and y this routine encodes
*  the equality
*
*     x + y = s + 2 * c,                                             (1)
*
*  where
*
*     s = (x + y) % 2                                                (2)
*
*  is a binary variable modeling the low sum bit, and
*
*     c = (x + y) / 2                                                (3)
*
*  is a binary variable modeling the high (carry) sum bit. */

void npp_sat_encode_sum2(NPP *npp, NPPLSE *set, NPPSED *sed)
{     NPPROW *row;
      int x, y, s, c;
      /* the set should contain exactly two literals */
      xassert(set != NULL);
      xassert(set->next != NULL);
      xassert(set->next->next == NULL);
      sed->x = set->lit;
      xassert(sed->x.neg == 0 || sed->x.neg == 1);
      sed->y = set->next->lit;
      xassert(sed->y.neg == 0 || sed->y.neg == 1);
      sed->z.col = NULL, sed->z.neg = 0;
      /* perform encoding s = (x + y) % 2 */
      sed->s = npp_add_col(npp);
      sed->s->is_int = 1, sed->s->lb = 0.0, sed->s->ub = 1.0;
      for (x = 0; x <= 1; x++)
      {  for (y = 0; y <= 1; y++)
         {  for (s = 0; s <= 1; s++)
            {  if ((x + y) % 2 != s)
               {  /* generate CNF clause to disable infeasible
                     combination */
                  row = npp_add_row(npp);
                  row->lb = 1.0, row->ub = +DBL_MAX;
                  if (x == sed->x.neg)
                     npp_add_aij(npp, row, sed->x.col, +1.0);
                  else
                  {  npp_add_aij(npp, row, sed->x.col, -1.0);
                     row->lb -= 1.0;
                  }
                  if (y == sed->y.neg)
                     npp_add_aij(npp, row, sed->y.col, +1.0);
                  else
                  {  npp_add_aij(npp, row, sed->y.col, -1.0);
                     row->lb -= 1.0;
                  }
                  if (s == 0)
                     npp_add_aij(npp, row, sed->s, +1.0);
                  else
                  {  npp_add_aij(npp, row, sed->s, -1.0);
                     row->lb -= 1.0;
                  }
               }
            }
         }
      }
      /* perform encoding c = (x + y) / 2 */
      sed->c = npp_add_col(npp);
      sed->c->is_int = 1, sed->c->lb = 0.0, sed->c->ub = 1.0;
      for (x = 0; x <= 1; x++)
      {  for (y = 0; y <= 1; y++)
         {  for (c = 0; c <= 1; c++)
            {  if ((x + y) / 2 != c)
               {  /* generate CNF clause to disable infeasible
                     combination */
                  row = npp_add_row(npp);
                  row->lb = 1.0, row->ub = +DBL_MAX;
                  if (x == sed->x.neg)
                     npp_add_aij(npp, row, sed->x.col, +1.0);
                  else
                  {  npp_add_aij(npp, row, sed->x.col, -1.0);
                     row->lb -= 1.0;
                  }
                  if (y == sed->y.neg)
                     npp_add_aij(npp, row, sed->y.col, +1.0);
                  else
                  {  npp_add_aij(npp, row, sed->y.col, -1.0);
                     row->lb -= 1.0;
                  }
                  if (c == 0)
                     npp_add_aij(npp, row, sed->c, +1.0);
                  else
                  {  npp_add_aij(npp, row, sed->c, -1.0);
                     row->lb -= 1.0;
                  }
               }
            }
         }
      }
      return;
}

/***********************************************************************
*  npp_sat_encode_sum3 - encode 3-bit summation
*
*  Given a set containing at least three literals this routine chooses
*  some literals x, y, z from that set and encodes the equality
*
*     x + y + z = s + 2 * c,                                         (1)
*
*  where
*
*     s = (x + y + z) % 2                                            (2)
*
*  is a binary variable modeling the low sum bit, and
*
*     c = (x + y + z) / 2                                            (3)
*
*  is a binary variable modeling the high (carry) sum bit. */

void npp_sat_encode_sum3(NPP *npp, NPPLSE *set, NPPSED *sed)
{     NPPROW *row;
      int x, y, z, s, c;
      /* the set should contain at least three literals */
      xassert(set != NULL);
      xassert(set->next != NULL);
      xassert(set->next->next != NULL);
      sed->x = set->lit;
      xassert(sed->x.neg == 0 || sed->x.neg == 1);
      sed->y = set->next->lit;
      xassert(sed->y.neg == 0 || sed->y.neg == 1);
      sed->z = set->next->next->lit;
      xassert(sed->z.neg == 0 || sed->z.neg == 1);
      /* perform encoding s = (x + y + z) % 2 */
      sed->s = npp_add_col(npp);
      sed->s->is_int = 1, sed->s->lb = 0.0, sed->s->ub = 1.0;
      for (x = 0; x <= 1; x++)
      {  for (y = 0; y <= 1; y++)
         {  for (z = 0; z <= 1; z++)
            {  for (s = 0; s <= 1; s++)
               {  if ((x + y + z) % 2 != s)
                  {  /* generate CNF clause to disable infeasible
                        combination */
                     row = npp_add_row(npp);
                     row->lb = 1.0, row->ub = +DBL_MAX;
                     if (x == sed->x.neg)
                        npp_add_aij(npp, row, sed->x.col, +1.0);
                     else
                     {  npp_add_aij(npp, row, sed->x.col, -1.0);
                        row->lb -= 1.0;
                     }
                     if (y == sed->y.neg)
                        npp_add_aij(npp, row, sed->y.col, +1.0);
                     else
                     {  npp_add_aij(npp, row, sed->y.col, -1.0);
                        row->lb -= 1.0;
                     }
                     if (z == sed->z.neg)
                        npp_add_aij(npp, row, sed->z.col, +1.0);
                     else
                     {  npp_add_aij(npp, row, sed->z.col, -1.0);
                        row->lb -= 1.0;
                     }
                     if (s == 0)
                        npp_add_aij(npp, row, sed->s, +1.0);
                     else
                     {  npp_add_aij(npp, row, sed->s, -1.0);
                        row->lb -= 1.0;
                     }
                  }
               }
            }
         }
      }
      /* perform encoding c = (x + y + z) / 2 */
      sed->c = npp_add_col(npp);
      sed->c->is_int = 1, sed->c->lb = 0.0, sed->c->ub = 1.0;
      for (x = 0; x <= 1; x++)
      {  for (y = 0; y <= 1; y++)
         {  for (z = 0; z <= 1; z++)
            {  for (c = 0; c <= 1; c++)
               {  if ((x + y + z) / 2 != c)
                  {  /* generate CNF clause to disable infeasible
                        combination */
                     row = npp_add_row(npp);
                     row->lb = 1.0, row->ub = +DBL_MAX;
                     if (x == sed->x.neg)
                        npp_add_aij(npp, row, sed->x.col, +1.0);
                     else
                     {  npp_add_aij(npp, row, sed->x.col, -1.0);
                        row->lb -= 1.0;
                     }
                     if (y == sed->y.neg)
                        npp_add_aij(npp, row, sed->y.col, +1.0);
                     else
                     {  npp_add_aij(npp, row, sed->y.col, -1.0);
                        row->lb -= 1.0;
                     }
                     if (z == sed->z.neg)
                        npp_add_aij(npp, row, sed->z.col, +1.0);
                     else
                     {  npp_add_aij(npp, row, sed->z.col, -1.0);
                        row->lb -= 1.0;
                     }
                     if (c == 0)
                        npp_add_aij(npp, row, sed->c, +1.0);
                     else
                     {  npp_add_aij(npp, row, sed->c, -1.0);
                        row->lb -= 1.0;
                     }
                  }
               }
            }
         }
      }
      return;
}

/***********************************************************************
*  npp_sat_encode_sum_ax - encode linear combination of 0-1 variables
*
*  PURPOSE
*
*  Given a linear combination of binary variables:
*
*     sum a[j] x[j],                                                 (1)
*      j
*
*  which is the linear form of the specified row, this routine encodes
*  (i.e. translates to CNF) the following equality:
*
*                        n
*     sum |a[j]| t[j] = sum 2**(k-1) * y[k],                         (2)
*      j                k=1
*
*  where t[j] = x[j] (if a[j] > 0) or t[j] = 1 - x[j] (if a[j] < 0),
*  and y[k] is either t[j] or a new literal created by the routine or
*  a constant zero. Note that the sum in the right-hand side of (2) can
*  be thought as a n-bit representation of the sum in the left-hand
*  side, which is a non-negative integer number.
*
*  ALGORITHM
*
*  First, the number of bits, n, sufficient to represent any value in
*  the left-hand side of (2) is determined. Obviously, n is the number
*  of bits sufficient to represent the sum (sum |a[j]|).
*
*  Let
*
*               n
*     |a[j]| = sum 2**(k-1) b[j,k],                                  (3)
*              k=1
*
*  where b[j,k] is k-th bit in a n-bit representation of |a[j]|. Then
*
*                          m            n
*     sum |a[j]| * t[j] = sum 2**(k-1) sum b[j,k] * t[j].            (4)
*      j                  k=1          j=1
*
*  Introducing the set
*
*     J[k] = { j : b[j,k] = 1 }                                      (5)
*
*  allows rewriting (4) as follows:
*
*                          n
*     sum |a[j]| * t[j] = sum 2**(k-1)  sum    t[j].                 (6)
*      j                  k=1         j in J[k]
*
*  Thus, our goal is to provide |J[k]| <= 1 for all k, in which case
*  we will have the representation (1).
*
*  Let |J[k]| = 2, i.e. J[k] has exactly two literals u and v. In this
*  case we can apply the following transformation:
*
*     u + v = s + 2 * c,                                             (7)
*
*  where s and c are, respectively, low (sum) and high (carry) bits of
*  the sum of two bits. This allows to replace two literals u and v in
*  J[k] by one literal s, and carry out literal c to J[k+1].
*
*  If |J[k]| >= 3, i.e. J[k] has at least three literals u, v, and w,
*  we can apply the following transformation:
*
*     u + v + w = s + 2 * c.                                         (8)
*
*  Again, literal s replaces literals u, v, and w in J[k], and literal
*  c goes into J[k+1].
*
*  On exit the routine stores each literal from J[k] in element y[k],
*  1 <= k <= n. If J[k] is empty, y[k] is set to constant false.
*
*  RETURNS
*
*  The routine returns n, the number of literals in the right-hand side
*  of (2), 0 <= n <= NBIT_MAX. If the sum (sum |a[j]|) is too large, so
*  more than NBIT_MAX (= 31) literals are needed to encode the original
*  linear combination, the routine returns a negative value. */

#define NBIT_MAX 31
/* maximal number of literals in the right hand-side of (2) */

static NPPLSE *remove_lse(NPP *npp, NPPLSE *set, NPPCOL *col)
{     /* remove specified literal from specified literal set */
      NPPLSE *lse, *prev = NULL;
      for (lse = set; lse != NULL; prev = lse, lse = lse->next)
         if (lse->lit.col == col) break;
      xassert(lse != NULL);
      if (prev == NULL)
         set = lse->next;
      else
         prev->next = lse->next;
      dmp_free_atom(npp->pool, lse, sizeof(NPPLSE));
      return set;
}

int npp_sat_encode_sum_ax(NPP *npp, NPPROW *row, NPPLIT y[])
{     NPPAIJ *aij;
      NPPLSE *set[1+NBIT_MAX], *lse;
      NPPSED sed;
      int k, n, temp;
      double sum;
      /* compute the sum (sum |a[j]|) */
      sum = 0.0;
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
         sum += fabs(aij->val);
      /* determine n, the number of bits in the sum */
      temp = (int)sum;
      if ((double)temp != sum)
         return -1; /* integer arithmetic error */
      for (n = 0; temp > 0; n++, temp >>= 1);
      xassert(0 <= n && n <= NBIT_MAX);
      /* build initial sets J[k], 1 <= k <= n; see (5) */
      /* set[k] is a pointer to the list of literals in J[k] */
      for (k = 1; k <= n; k++)
         set[k] = NULL;
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  temp = (int)fabs(aij->val);
         xassert((int)temp == fabs(aij->val));
         for (k = 1; temp > 0; k++, temp >>= 1)
         {  if (temp & 1)
            {  xassert(k <= n);
               lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));
               lse->lit.col = aij->col;
               lse->lit.neg = (aij->val > 0.0 ? 0 : 1);
               lse->next = set[k];
               set[k] = lse;
            }
         }
      }
      /* main transformation loop */
      for (k = 1; k <= n; k++)
      {  /* reduce J[k] and set y[k] */
         for (;;)
         {  if (set[k] == NULL)
            {  /* J[k] is empty */
               /* set y[k] to constant false */
               y[k].col = NULL, y[k].neg = 0;
               break;
            }
            if (set[k]->next == NULL)
            {  /* J[k] contains one literal */
               /* set y[k] to that literal */
               y[k] = set[k]->lit;
               dmp_free_atom(npp->pool, set[k], sizeof(NPPLSE));
               break;
            }
            if (set[k]->next->next == NULL)
            {  /* J[k] contains two literals */
               /* apply transformation (7) */
               npp_sat_encode_sum2(npp, set[k], &sed);
            }
            else
            {  /* J[k] contains at least three literals */
               /* apply transformation (8) */
               npp_sat_encode_sum3(npp, set[k], &sed);
               /* remove third literal from set[k] */
               set[k] = remove_lse(npp, set[k], sed.z.col);
            }
            /* remove second literal from set[k] */
            set[k] = remove_lse(npp, set[k], sed.y.col);
            /* remove first literal from set[k] */
            set[k] = remove_lse(npp, set[k], sed.x.col);
            /* include new literal s to set[k] */
            lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));
            lse->lit.col = sed.s, lse->lit.neg = 0;
            lse->next = set[k];
            set[k] = lse;
            /* include new literal c to set[k+1] */
            xassert(k < n); /* FIXME: can "overflow" happen? */
            lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));
            lse->lit.col = sed.c, lse->lit.neg = 0;
            lse->next = set[k+1];
            set[k+1] = lse;
         }
      }
      return n;
}

/***********************************************************************
*  npp_sat_normalize_clause - normalize clause
*
*  This routine normalizes the specified clause, which is a disjunction
*  of literals, by replacing multiple literals, which refer to the same
*  binary variable, with a single literal.
*
*  On exit the routine returns the number of literals in the resulting
*  clause. However, if the specified clause includes both a literal and
*  its negation, the routine returns a negative value meaning that the
*  clause is equivalent to the value true. */

int npp_sat_normalize_clause(NPP *npp, int size, NPPLIT lit[])
{     int j, k, new_size;
      xassert(npp == npp);
      xassert(size >= 0);
      new_size = 0;
      for (k = 1; k <= size; k++)
      {  for (j = 1; j <= new_size; j++)
         {  if (lit[k].col == lit[j].col)
            {  /* lit[k] refers to the same variable as lit[j], which
                  is already included in the resulting clause */
               if (lit[k].neg == lit[j].neg)
               {  /* ignore lit[k] due to the idempotent law */
                  goto skip;
               }
               else
               {  /* lit[k] is NOT lit[j]; the clause is equivalent to
                     the value true */
                  return -1;
               }
            }
         }
         /* include lit[k] in the resulting clause */
         lit[++new_size] = lit[k];
skip:    ;
      }
      return new_size;
}

/***********************************************************************
*  npp_sat_encode_clause - translate clause to cover inequality
*
*  Given a clause
*
*     OR  t[j],                                                      (1)
*   j in J
*
*  where t[j] is a literal, i.e. t[j] = x[j] or t[j] = NOT x[j], this
*  routine translates it to the following equivalent cover inequality,
*  which is added to the transformed problem:
*
*     sum t[j] >= 1,                                                 (2)
*   j in J
*
*  where t[j] = x[j] or t[j] = 1 - x[j].
*
*  If necessary, the clause should be normalized before a call to this
*  routine. */

NPPROW *npp_sat_encode_clause(NPP *npp, int size, NPPLIT lit[])
{     NPPROW *row;
      int k;
      xassert(size >= 1);
      row = npp_add_row(npp);
      row->lb = 1.0, row->ub = +DBL_MAX;
      for (k = 1; k <= size; k++)
      {  xassert(lit[k].col != NULL);
         if (lit[k].neg == 0)
            npp_add_aij(npp, row, lit[k].col, +1.0);
         else if (lit[k].neg == 1)
         {  npp_add_aij(npp, row, lit[k].col, -1.0);
            row->lb -= 1.0;
         }
         else
            xassert(lit != lit);
      }
      return row;
}

/***********************************************************************
*  npp_sat_encode_geq - encode "not less than" constraint
*
*  PURPOSE
*
*  This routine translates to CNF the following constraint:
*
*      n
*     sum 2**(k-1) * y[k] >= b,                                      (1)
*     k=1
*
*  where y[k] is either a literal (i.e. y[k] = x[k] or y[k] = 1 - x[k])
*  or constant false (zero), b is a given lower bound.
*
*  ALGORITHM
*
*  If b < 0, the constraint is redundant, so assume that b >= 0. Let
*
*          n
*     b = sum 2**(k-1) b[k],                                         (2)
*         k=1
*
*  where b[k] is k-th binary digit of b. (Note that if b >= 2**n and
*  therefore cannot be represented in the form (2), the constraint (1)
*  is infeasible.) In this case the condition (1) is equivalent to the
*  following condition:
*
*     y[n] y[n-1] ... y[2] y[1] >= b[n] b[n-1] ... b[2] b[1],        (3)
*
*  where ">=" is understood lexicographically.
*
*  Algorithmically the condition (3) can be tested as follows:
*
*     for (k = n; k >= 1; k--)
*     {  if (y[k] < b[k])
*           y is less than b;
*        if (y[k] > b[k])
*           y is greater than b;
*     }
*     y is equal to b;
*
*  Thus, y is less than b iff there exists k, 1 <= k <= n, for which
*  the following condition is satisfied:
*
*     y[n] = b[n] AND ... AND y[k+1] = b[k+1] AND y[k] < b[k].       (4)
*
*  Negating the condition (4) we have that y is not less than b iff for
*  all k, 1 <= k <= n, the following condition is satisfied:
*
*     y[n] != b[n] OR ... OR y[k+1] != b[k+1] OR y[k] >= b[k].       (5)
*
*  Note that if b[k] = 0, the literal y[k] >= b[k] is always true, in
*  which case the entire clause (5) is true and can be omitted.
*
*  RETURNS
*
*  Normally the routine returns zero. However, if the constraint (1) is
*  infeasible, the routine returns non-zero. */

int npp_sat_encode_geq(NPP *npp, int n, NPPLIT y[], int rhs)
{     NPPLIT lit[1+NBIT_MAX];
      int j, k, size, temp, b[1+NBIT_MAX];
      xassert(0 <= n && n <= NBIT_MAX);
      /* if the constraint (1) is redundant, do nothing */
      if (rhs < 0)
         return 0;
      /* determine binary digits of b according to (2) */
      for (k = 1, temp = rhs; k <= n; k++, temp >>= 1)
         b[k] = temp & 1;
      if (temp != 0)
      {  /* b >= 2**n; the constraint (1) is infeasible */
         return 1;
      }
      /* main transformation loop */
      for (k = 1; k <= n; k++)
      {  /* build the clause (5) for current k */
         size = 0; /* clause size = number of literals */
         /* add literal y[k] >= b[k] */
         if (b[k] == 0)
         {  /* b[k] = 0 -> the literal is true */
            goto skip;
         }
         else if (y[k].col == NULL)
         {  /* y[k] = 0, b[k] = 1 -> the literal is false */
            xassert(y[k].neg == 0);
         }
         else
         {  /* add literal y[k] = 1 */
            lit[++size] = y[k];
         }
         for (j = k+1; j <= n; j++)
         {  /* add literal y[j] != b[j] */
            if (y[j].col == NULL)
            {  xassert(y[j].neg == 0);
               if (b[j] == 0)
               {  /* y[j] = 0, b[j] = 0 -> the literal is false */
                  continue;
               }
               else
               {  /* y[j] = 0, b[j] = 1 -> the literal is true */
                  goto skip;
               }
            }
            else
            {  lit[++size] = y[j];
               if (b[j] != 0)
                  lit[size].neg = 1 - lit[size].neg;
            }
         }
         /* normalize the clause */
         size = npp_sat_normalize_clause(npp, size, lit);
         if (size < 0)
         {  /* the clause is equivalent to the value true */
            goto skip;
         }
         if (size == 0)
         {  /* the clause is equivalent to the value false; this means
               that the constraint (1) is infeasible */
            return 2;
         }
         /* translate the clause to corresponding cover inequality */
         npp_sat_encode_clause(npp, size, lit);
skip:    ;
      }
      return 0;
}

/***********************************************************************
*  npp_sat_encode_leq - encode "not greater than" constraint
*
*  PURPOSE
*
*  This routine translates to CNF the following constraint:
*
*      n
*     sum 2**(k-1) * y[k] <= b,                                      (1)
*     k=1
*
*  where y[k] is either a literal (i.e. y[k] = x[k] or y[k] = 1 - x[k])
*  or constant false (zero), b is a given upper bound.
*
*  ALGORITHM
*
*  If b < 0, the constraint is infeasible, so assume that b >= 0. Let
*
*          n
*     b = sum 2**(k-1) b[k],                                         (2)
*         k=1
*
*  where b[k] is k-th binary digit of b. (Note that if b >= 2**n and
*  therefore cannot be represented in the form (2), the constraint (1)
*  is redundant.) In this case the condition (1) is equivalent to the
*  following condition:
*
*     y[n] y[n-1] ... y[2] y[1] <= b[n] b[n-1] ... b[2] b[1],        (3)
*
*  where "<=" is understood lexicographically.
*
*  Algorithmically the condition (3) can be tested as follows:
*
*     for (k = n; k >= 1; k--)
*     {  if (y[k] < b[k])
*           y is less than b;
*        if (y[k] > b[k])
*           y is greater than b;
*     }
*     y is equal to b;
*
*  Thus, y is greater than b iff there exists k, 1 <= k <= n, for which
*  the following condition is satisfied:
*
*     y[n] = b[n] AND ... AND y[k+1] = b[k+1] AND y[k] > b[k].       (4)
*
*  Negating the condition (4) we have that y is not greater than b iff
*  for all k, 1 <= k <= n, the following condition is satisfied:
*
*     y[n] != b[n] OR ... OR y[k+1] != b[k+1] OR y[k] <= b[k].       (5)
*
*  Note that if b[k] = 1, the literal y[k] <= b[k] is always true, in
*  which case the entire clause (5) is true and can be omitted.
*
*  RETURNS
*
*  Normally the routine returns zero. However, if the constraint (1) is
*  infeasible, the routine returns non-zero. */

int npp_sat_encode_leq(NPP *npp, int n, NPPLIT y[], int rhs)
{     NPPLIT lit[1+NBIT_MAX];
      int j, k, size, temp, b[1+NBIT_MAX];
      xassert(0 <= n && n <= NBIT_MAX);
      /* check if the constraint (1) is infeasible */
      if (rhs < 0)
         return 1;
      /* determine binary digits of b according to (2) */
      for (k = 1, temp = rhs; k <= n; k++, temp >>= 1)
         b[k] = temp & 1;
      if (temp != 0)
      {  /* b >= 2**n; the constraint (1) is redundant */
         return 0;
      }
      /* main transformation loop */
      for (k = 1; k <= n; k++)
      {  /* build the clause (5) for current k */
         size = 0; /* clause size = number of literals */
         /* add literal y[k] <= b[k] */
         if (b[k] == 1)
         {  /* b[k] = 1 -> the literal is true */
            goto skip;
         }
         else if (y[k].col == NULL)
         {  /* y[k] = 0, b[k] = 0 -> the literal is true */
            xassert(y[k].neg == 0);
            goto skip;
         }
         else
         {  /* add literal y[k] = 0 */
            lit[++size] = y[k];
            lit[size].neg = 1 - lit[size].neg;
         }
         for (j = k+1; j <= n; j++)
         {  /* add literal y[j] != b[j] */
            if (y[j].col == NULL)
            {  xassert(y[j].neg == 0);
               if (b[j] == 0)
               {  /* y[j] = 0, b[j] = 0 -> the literal is false */
                  continue;
               }
               else
               {  /* y[j] = 0, b[j] = 1 -> the literal is true */
                  goto skip;
               }
            }
            else
            {  lit[++size] = y[j];
               if (b[j] != 0)
                  lit[size].neg = 1 - lit[size].neg;
            }
         }
         /* normalize the clause */
         size = npp_sat_normalize_clause(npp, size, lit);
         if (size < 0)
         {  /* the clause is equivalent to the value true */
            goto skip;
         }
         if (size == 0)
         {  /* the clause is equivalent to the value false; this means
               that the constraint (1) is infeasible */
            return 2;
         }
         /* translate the clause to corresponding cover inequality */
         npp_sat_encode_clause(npp, size, lit);
skip:    ;
      }
      return 0;
}

/***********************************************************************
*  npp_sat_encode_row - encode constraint (row) of general type
*
*  PURPOSE
*
*  This routine translates to CNF the following constraint (row):
*
*     L <= sum a[j] x[j] <= U,                                       (1)
*           j
*
*  where all x[j] are binary variables.
*
*  ALGORITHM
*
*  First, the routine performs substitution x[j] = t[j] for j in J+
*  and x[j] = 1 - t[j] for j in J-, where J+ = { j : a[j] > 0 } and
*  J- = { j : a[j] < 0 }. This gives:
*
*     L <=  sum  a[j] t[j] +   sum  a[j] (1 - t[j]) <= U  ==>
*         j in J+            j in J-
*
*     L' <= sum |a[j]| t[j] <= U',                                   (2)
*            j
*
*  where
*
*     L' = L -   sum  a[j],   U' = U -   sum  a[j].                  (3)
*              j in J-                 j in J-
*
*  (Actually only new bounds L' and U' are computed.)
*
*  Then the routine translates to CNF the following equality:
*
*                        n
*     sum |a[j]| t[j] = sum 2**(k-1) * y[k],                         (4)
*      j                k=1
*
*  where y[k] is either some t[j] or a new literal or a constant zero
*  (see the routine npp_sat_encode_sum_ax).
*
*  Finally, the routine translates to CNF the following conditions:
*
*      n
*     sum 2**(k-1) * y[k] >= L'                                      (5)
*     k=1
*
*  and
*
*      n
*     sum 2**(k-1) * y[k] <= U'                                      (6)
*     k=1
*
*  (see the routines npp_sat_encode_geq and npp_sat_encode_leq).
*
*  All resulting clauses are encoded as cover inequalities and included
*  into the transformed problem.
*
*  Note that on exit the routine removes the specified constraint (row)
*  from the original problem.
*
*  RETURNS
*
*  The routine returns one of the following codes:
*
*  0 - translation was successful;
*  1 - constraint (1) was found infeasible;
*  2 - integer arithmetic error occured. */

int npp_sat_encode_row(NPP *npp, NPPROW *row)
{     NPPAIJ *aij;
      NPPLIT y[1+NBIT_MAX];
      int n, rhs;
      double lb, ub;
      /* the row should not be free */
      xassert(!(row->lb == -DBL_MAX && row->ub == +DBL_MAX));
      /* compute new bounds L' and U' (3) */
      lb = row->lb;
      ub = row->ub;
      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
      {  if (aij->val < 0.0)
         {  if (lb != -DBL_MAX)
               lb -= aij->val;
            if (ub != -DBL_MAX)
               ub -= aij->val;
         }
      }
      /* encode the equality (4) */
      n = npp_sat_encode_sum_ax(npp, row, y);
      if (n < 0)
         return 2; /* integer arithmetic error */
      /* encode the condition (5) */
      if (lb != -DBL_MAX)
      {  rhs = (int)lb;
         if ((double)rhs != lb)
            return 2; /* integer arithmetic error */
         if (npp_sat_encode_geq(npp, n, y, rhs) != 0)
            return 1; /* original constraint is infeasible */
      }
      /* encode the condition (6) */
      if (ub != +DBL_MAX)
      {  rhs = (int)ub;
         if ((double)rhs != ub)
            return 2; /* integer arithmetic error */
         if (npp_sat_encode_leq(npp, n, y, rhs) != 0)
            return 1; /* original constraint is infeasible */
      }
      /* remove the specified row from the problem */
      npp_del_row(npp, row);
      return 0;
}

/***********************************************************************
*  npp_sat_encode_prob - encode 0-1 feasibility problem
*
*  This routine translates the specified 0-1 feasibility problem to an
*  equivalent SAT-CNF problem.
*
*  N.B. Currently this is a very crude implementation.
*
*  RETURNS
*
*  0           success;
*
*  GLP_ENOPFS  primal/integer infeasibility detected;
*
*  GLP_ERANGE  integer overflow occured. */

int npp_sat_encode_prob(NPP *npp)
{     NPPROW *row, *next_row, *prev_row;
      NPPCOL *col, *next_col;
      int cover = 0, pack = 0, partn = 0, ret;
      /* process and remove free rows */
      for (row = npp->r_head; row != NULL; row = next_row)
      {  next_row = row->next;
         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)
            npp_sat_free_row(npp, row);
      }
      /* process and remove fixed columns */
      for (col = npp->c_head; col != NULL; col = next_col)
      {  next_col = col->next;
         if (col->lb == col->ub)
            xassert(npp_sat_fixed_col(npp, col) == 0);
      }
      /* only binary variables should remain */
      for (col = npp->c_head; col != NULL; col = col->next)
         xassert(col->is_int && col->lb == 0.0 && col->ub == 1.0);
      /* new rows may be added to the end of the row list, so we walk
         from the end to beginning of the list */
      for (row = npp->r_tail; row != NULL; row = prev_row)
      {  prev_row = row->prev;
         /* process special cases */
         ret = npp_sat_is_cover_ineq(npp, row);
         if (ret != 0)
         {  /* row is covering inequality */
            cover++;
            /* since it already encodes a clause, just transform it to
               canonical form */
            if (ret == 2)
            {  xassert(npp_sat_reverse_row(npp, row) == 0);
               ret = npp_sat_is_cover_ineq(npp, row);
            }
            xassert(ret == 1);
            continue;
         }
         ret = npp_sat_is_partn_eq(npp, row);
         if (ret != 0)
         {  /* row is partitioning equality */
            NPPROW *cov;
            NPPAIJ *aij;
            partn++;
            /* transform it to canonical form */
            if (ret == 2)
            {  xassert(npp_sat_reverse_row(npp, row) == 0);
               ret = npp_sat_is_partn_eq(npp, row);
            }
            xassert(ret == 1);
            /* and split it into covering and packing inequalities,
               both in canonical forms */
            cov = npp_add_row(npp);
            cov->lb = row->lb, cov->ub = +DBL_MAX;
            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
               npp_add_aij(npp, cov, aij->col, aij->val);
            xassert(npp_sat_is_cover_ineq(npp, cov) == 1);
            /* the cover inequality already encodes a clause and do
               not need any further processing */
            row->lb = -DBL_MAX;
            xassert(npp_sat_is_pack_ineq(npp, row) == 1);
            /* the packing inequality will be processed below */
            pack--;
         }
         ret = npp_sat_is_pack_ineq(npp, row);
         if (ret != 0)
         {  /* row is packing inequality */
            NPPROW *rrr;
            int nlit, desired_nlit = 4;
            pack++;
            /* transform it to canonical form */
            if (ret == 2)
            {  xassert(npp_sat_reverse_row(npp, row) == 0);
               ret = npp_sat_is_pack_ineq(npp, row);
            }
            xassert(ret == 1);
            /* process the packing inequality */
            for (;;)
            {  /* determine the number of literals in the remaining
                  inequality */
               nlit = npp_row_nnz(npp, row);
               if (nlit <= desired_nlit)
                  break;
               /* split the current inequality into one having not more
                  than desired_nlit literals and remaining one */
               rrr = npp_sat_split_pack(npp, row, desired_nlit-1);
               /* translate the former inequality to CNF and remove it
                  from the original problem */
               npp_sat_encode_pack(npp, rrr);
            }
            /* translate the remaining inequality to CNF and remove it
               from the original problem */
            npp_sat_encode_pack(npp, row);
            continue;
         }
         /* translate row of general type to CNF and remove it from the
            original problem */
         ret = npp_sat_encode_row(npp, row);
         if (ret == 0)
            ;
         else if (ret == 1)
            ret = GLP_ENOPFS;
         else if (ret == 2)
            ret = GLP_ERANGE;
         else
            xassert(ret != ret);
         if (ret != 0)
            goto done;
      }
      ret = 0;
      if (cover != 0)
         xprintf("%d covering inequalities\n", cover);
      if (pack != 0)
         xprintf("%d packing inequalities\n", pack);
      if (partn != 0)
         xprintf("%d partitioning equalities\n", partn);
done: return ret;
}











































#define spx_dual spy_dual
/***********************************************************************
*  NAME
*
*  glp_simplex - solve LP problem with the simplex method
*
*  SYNOPSIS
*
*  int glp_simplex(glp_prob *P, const glp_smcp *parm);
*
*  DESCRIPTION
*
*  The routine glp_simplex is a driver to the LP solver based on the
*  simplex method. This routine retrieves problem data from the
*  specified problem object, calls the solver to solve the problem
*  instance, and stores results of computations back into the problem
*  object.
*
*  The simplex solver has a set of control parameters. Values of the
*  control parameters can be passed in a structure glp_smcp, which the
*  parameter parm points to.
*
*  The parameter parm can be specified as NULL, in which case the LP
*  solver uses default settings.
*
*  RETURNS
*
*  0  The LP problem instance has been successfully solved. This code
*     does not necessarily mean that the solver has found optimal
*     solution. It only means that the solution process was successful.
*
*  GLP_EBADB
*     Unable to start the search, because the initial basis specified
*     in the problem object is invalid--the number of basic (auxiliary
*     and structural) variables is not the same as the number of rows in
*     the problem object.
*
*  GLP_ESING
*     Unable to start the search, because the basis matrix correspodning
*     to the initial basis is singular within the working precision.
*
*  GLP_ECOND
*     Unable to start the search, because the basis matrix correspodning
*     to the initial basis is ill-conditioned, i.e. its condition number
*     is too large.
*
*  GLP_EBOUND
*     Unable to start the search, because some double-bounded variables
*     have incorrect bounds.
*
*  GLP_EFAIL
*     The search was prematurely terminated due to the solver failure.
*
*  GLP_EOBJLL
*     The search was prematurely terminated, because the objective
*     function being maximized has reached its lower limit and continues
*     decreasing (dual simplex only).
*
*  GLP_EOBJUL
*     The search was prematurely terminated, because the objective
*     function being minimized has reached its upper limit and continues
*     increasing (dual simplex only).
*
*  GLP_EITLIM
*     The search was prematurely terminated, because the simplex
*     iteration limit has been exceeded.
*
*  GLP_ETMLIM
*     The search was prematurely terminated, because the time limit has
*     been exceeded.
*
*  GLP_ENOPFS
*     The LP problem instance has no primal feasible solution (only if
*     the LP presolver is used).
*
*  GLP_ENODFS
*     The LP problem instance has no dual feasible solution (only if the
*     LP presolver is used). */

static void trivial_lp(glp_prob *P, const glp_smcp *parm)
{     /* solve trivial LP which has empty constraint matrix */
      GLPROW *row;
      GLPCOL *col;
      int i, j;
      double p_infeas, d_infeas, zeta;
      P->valid = 0;
      P->pbs_stat = P->dbs_stat = GLP_FEAS;
      P->obj_val = P->c0;
      P->some = 0;
      p_infeas = d_infeas = 0.0;
      /* make all auxiliary variables basic */
      for (i = 1; i <= P->m; i++)
      {  row = P->row[i];
         row->stat = GLP_BS;
         row->prim = row->dual = 0.0;
         /* check primal feasibility */
         if (row->type == GLP_LO || row->type == GLP_DB ||
             row->type == GLP_FX)
         {  /* row has lower bound */
            if (row->lb > + parm->tol_bnd)
            {  P->pbs_stat = GLP_NOFEAS;
               if (P->some == 0 && parm->meth != GLP_PRIMAL)
                  P->some = i;
            }
            if (p_infeas < + row->lb)
               p_infeas = + row->lb;
         }
         if (row->type == GLP_UP || row->type == GLP_DB ||
             row->type == GLP_FX)
         {  /* row has upper bound */
            if (row->ub < - parm->tol_bnd)
            {  P->pbs_stat = GLP_NOFEAS;
               if (P->some == 0 && parm->meth != GLP_PRIMAL)
                  P->some = i;
            }
            if (p_infeas < - row->ub)
               p_infeas = - row->ub;
         }
      }
      /* determine scale factor for the objective row */
      zeta = 1.0;
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         if (zeta < fabs(col->coef)) zeta = fabs(col->coef);
      }
      zeta = (P->dir == GLP_MIN ? +1.0 : -1.0) / zeta;
      /* make all structural variables non-basic */
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         if (col->type == GLP_FR)
            col->stat = GLP_NF, col->prim = 0.0;
         else if (col->type == GLP_LO)
lo:         col->stat = GLP_NL, col->prim = col->lb;
         else if (col->type == GLP_UP)
up:         col->stat = GLP_NU, col->prim = col->ub;
         else if (col->type == GLP_DB)
         {  if (zeta * col->coef > 0.0)
               goto lo;
            else if (zeta * col->coef < 0.0)
               goto up;
            else if (fabs(col->lb) <= fabs(col->ub))
               goto lo;
            else
               goto up;
         }
         else if (col->type == GLP_FX)
            col->stat = GLP_NS, col->prim = col->lb;
         col->dual = col->coef;
         P->obj_val += col->coef * col->prim;
         /* check dual feasibility */
         if (col->type == GLP_FR || col->type == GLP_LO)
         {  /* column has no upper bound */
            if (zeta * col->dual < - parm->tol_dj)
            {  P->dbs_stat = GLP_NOFEAS;
               if (P->some == 0 && parm->meth == GLP_PRIMAL)
                  P->some = P->m + j;
            }
            if (d_infeas < - zeta * col->dual)
               d_infeas = - zeta * col->dual;
         }
         if (col->type == GLP_FR || col->type == GLP_UP)
         {  /* column has no lower bound */
            if (zeta * col->dual > + parm->tol_dj)
            {  P->dbs_stat = GLP_NOFEAS;
               if (P->some == 0 && parm->meth == GLP_PRIMAL)
                  P->some = P->m + j;
            }
            if (d_infeas < + zeta * col->dual)
               d_infeas = + zeta * col->dual;
         }
      }
      /* simulate the simplex solver output */
      if (parm->msg_lev >= GLP_MSG_ON && parm->out_dly == 0)
      {  xprintf("~%6d: obj = %17.9e  infeas = %10.3e\n", P->it_cnt,
            P->obj_val, parm->meth == GLP_PRIMAL ? p_infeas : d_infeas);
      }
      if (parm->msg_lev >= GLP_MSG_ALL && parm->out_dly == 0)
      {  if (P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS)
            xprintf("OPTIMAL SOLUTION FOUND\n");
         else if (P->pbs_stat == GLP_NOFEAS)
            xprintf("PROBLEM HAS NO FEASIBLE SOLUTION\n");
         else if (parm->meth == GLP_PRIMAL)
            xprintf("PROBLEM HAS UNBOUNDED SOLUTION\n");
         else
            xprintf("PROBLEM HAS NO DUAL FEASIBLE SOLUTION\n");
      }
      return;
}

static int solve_lp(glp_prob *P, const glp_smcp *parm)
{     /* solve LP directly without using the preprocessor */
      int ret;
      if (!glp_bf_exists(P))
      {  ret = glp_factorize(P);
         if (ret == 0)
            ;
         else if (ret == GLP_EBADB)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf("glp_simplex: initial basis is invalid\n");
         }
         else if (ret == GLP_ESING)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf("glp_simplex: initial basis is singular\n");
         }
         else if (ret == GLP_ECOND)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf(
                  "glp_simplex: initial basis is ill-conditioned\n");
         }
         else
            xassert(ret != ret);
         if (ret != 0) goto done;
      }
      if (parm->meth == GLP_PRIMAL)
         ret = spx_primal(P, parm);
      else if (parm->meth == GLP_DUALP)
      {  ret = spx_dual(P, parm);
         if (ret == GLP_EFAIL && P->valid)
            ret = spx_primal(P, parm);
      }
      else if (parm->meth == GLP_DUAL)
         ret = spx_dual(P, parm);
      else
         xassert(parm != parm);
done: return ret;
}

static int preprocess_and_solve_lp(glp_prob *P, const glp_smcp *parm)
{     /* solve LP using the preprocessor */
      NPP *npp;
      glp_prob *lp = NULL;
      glp_bfcp bfcp;
      int ret;
      if (parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Preprocessing...\n");
      /* create preprocessor workspace */
      npp = npp_create_wksp();
      /* load original problem into the preprocessor workspace */
      npp_load_prob(npp, P, GLP_OFF, GLP_SOL, GLP_OFF);
      /* process LP prior to applying primal/dual simplex method */
      ret = npp_simplex(npp, parm);
      if (ret == 0)
         ;
      else if (ret == GLP_ENOPFS)
      {  if (parm->msg_lev >= GLP_MSG_ALL)
            xprintf("PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\n");
      }
      else if (ret == GLP_ENODFS)
      {  if (parm->msg_lev >= GLP_MSG_ALL)
            xprintf("PROBLEM HAS NO DUAL FEASIBLE SOLUTION\n");
      }
      else
         xassert(ret != ret);
      if (ret != 0) goto done;
      /* build transformed LP */
      lp = glp_create_prob();
      npp_build_prob(npp, lp);
      /* if the transformed LP is empty, it has empty solution, which
         is optimal */
      if (lp->m == 0 && lp->n == 0)
      {  lp->pbs_stat = lp->dbs_stat = GLP_FEAS;
         lp->obj_val = lp->c0;
         if (parm->msg_lev >= GLP_MSG_ON && parm->out_dly == 0)
         {  xprintf("~%6d: obj = %17.9e  infeas = %10.3e\n", P->it_cnt,
               lp->obj_val, 0.0);
         }
         if (parm->msg_lev >= GLP_MSG_ALL)
            xprintf("OPTIMAL SOLUTION FOUND BY LP PREPROCESSOR\n");
         goto post;
      }
      if (parm->msg_lev >= GLP_MSG_ALL)
      {  xprintf("%d row%s, %d column%s, %d non-zero%s\n",
            lp->m, lp->m == 1 ? "" : "s", lp->n, lp->n == 1 ? "" : "s",
            lp->nnz, lp->nnz == 1 ? "" : "s");
      }
      /* inherit basis factorization control parameters */
      glp_get_bfcp(P, &bfcp);
      glp_set_bfcp(lp, &bfcp);
      /* scale the transformed problem */
      {  ENV *env = get_env_ptr();
         int term_out = env->term_out;
         if (!term_out || parm->msg_lev < GLP_MSG_ALL)
            env->term_out = GLP_OFF;
         else
            env->term_out = GLP_ON;
         glp_scale_prob(lp, GLP_SF_AUTO);
         env->term_out = term_out;
      }
      /* build advanced initial basis */
      {  ENV *env = get_env_ptr();
         int term_out = env->term_out;
         if (!term_out || parm->msg_lev < GLP_MSG_ALL)
            env->term_out = GLP_OFF;
         else
            env->term_out = GLP_ON;
         glp_adv_basis(lp, 0);
         env->term_out = term_out;
      }
      /* solve the transformed LP */
      lp->it_cnt = P->it_cnt;
      ret = solve_lp(lp, parm);
      P->it_cnt = lp->it_cnt;
      /* only optimal solution can be postprocessed */
      if (!(ret == 0 && lp->pbs_stat == GLP_FEAS && lp->dbs_stat ==
            GLP_FEAS))
      {  if (parm->msg_lev >= GLP_MSG_ERR)
            xprintf("glp_simplex: unable to recover undefined or non-op"
               "timal solution\n");
         if (ret == 0)
         {  if (lp->pbs_stat == GLP_NOFEAS)
               ret = GLP_ENOPFS;
            else if (lp->dbs_stat == GLP_NOFEAS)
               ret = GLP_ENODFS;
            else
               xassert(lp != lp);
         }
         goto done;
      }
post: /* postprocess solution from the transformed LP */
      npp_postprocess(npp, lp);
      /* the transformed LP is no longer needed */
      glp_delete_prob(lp), lp = NULL;
      /* store solution to the original problem */
      npp_unload_sol(npp, P);
      /* the original LP has been successfully solved */
      ret = 0;
done: /* delete the transformed LP, if it exists */
      if (lp != NULL) glp_delete_prob(lp);
      /* delete preprocessor workspace */
      npp_delete_wksp(npp);
      return ret;
}

int glp_simplex(glp_prob *P, const glp_smcp *parm)
{     /* solve LP problem with the simplex method */
      glp_smcp _parm;
      int i, j, ret;
      /* check problem object */
      if (P == NULL || P->magic != GLP_PROB_MAGIC)
         xerror("glp_simplex: P = %p; invalid problem object\n", P);
      if (P->tree != NULL && P->tree->reason != 0)
         xerror("glp_simplex: operation not allowed\n");
      /* check control parameters */
      if (parm == NULL)
         parm = &_parm, glp_init_smcp((glp_smcp *)parm);
      if (!(parm->msg_lev == GLP_MSG_OFF ||
            parm->msg_lev == GLP_MSG_ERR ||
            parm->msg_lev == GLP_MSG_ON  ||
            parm->msg_lev == GLP_MSG_ALL ||
            parm->msg_lev == GLP_MSG_DBG))
         xerror("glp_simplex: msg_lev = %d; invalid parameter\n",
            parm->msg_lev);
      if (!(parm->meth == GLP_PRIMAL ||
            parm->meth == GLP_DUALP  ||
            parm->meth == GLP_DUAL))
         xerror("glp_simplex: meth = %d; invalid parameter\n",
            parm->meth);
      if (!(parm->pricing == GLP_PT_STD ||
            parm->pricing == GLP_PT_PSE))
         xerror("glp_simplex: pricing = %d; invalid parameter\n",
            parm->pricing);
      if (!(parm->r_test == GLP_RT_STD ||
#if 1 /* 16/III-2016 */
            parm->r_test == GLP_RT_FLIP ||
#endif
            parm->r_test == GLP_RT_HAR))
         xerror("glp_simplex: r_test = %d; invalid parameter\n",
            parm->r_test);
      if (!(0.0 < parm->tol_bnd && parm->tol_bnd < 1.0))
         xerror("glp_simplex: tol_bnd = %g; invalid parameter\n",
            parm->tol_bnd);
      if (!(0.0 < parm->tol_dj && parm->tol_dj < 1.0))
         xerror("glp_simplex: tol_dj = %g; invalid parameter\n",
            parm->tol_dj);
      if (!(0.0 < parm->tol_piv && parm->tol_piv < 1.0))
         xerror("glp_simplex: tol_piv = %g; invalid parameter\n",
            parm->tol_piv);
      if (parm->it_lim < 0)
         xerror("glp_simplex: it_lim = %d; invalid parameter\n",
            parm->it_lim);
      if (parm->tm_lim < 0)
         xerror("glp_simplex: tm_lim = %d; invalid parameter\n",
            parm->tm_lim);
      if (parm->out_frq < 1)
         xerror("glp_simplex: out_frq = %d; invalid parameter\n",
            parm->out_frq);
      if (parm->out_dly < 0)
         xerror("glp_simplex: out_dly = %d; invalid parameter\n",
            parm->out_dly);
      if (!(parm->presolve == GLP_ON || parm->presolve == GLP_OFF))
         xerror("glp_simplex: presolve = %d; invalid parameter\n",
            parm->presolve);
      /* basic solution is currently undefined */
      P->pbs_stat = P->dbs_stat = GLP_UNDEF;
      P->obj_val = 0.0;
      P->some = 0;
      /* check bounds of double-bounded variables */
      for (i = 1; i <= P->m; i++)
      {  GLPROW *row = P->row[i];
         if (row->type == GLP_DB && row->lb >= row->ub)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf("glp_simplex: row %d: lb = %g, ub = %g; incorrec"
                  "t bounds\n", i, row->lb, row->ub);
            ret = GLP_EBOUND;
            goto done;
         }
      }
      for (j = 1; j <= P->n; j++)
      {  GLPCOL *col = P->col[j];
         if (col->type == GLP_DB && col->lb >= col->ub)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf("glp_simplex: column %d: lb = %g, ub = %g; incor"
                  "rect bounds\n", j, col->lb, col->ub);
            ret = GLP_EBOUND;
            goto done;
         }
      }
      /* solve LP problem */
      if (parm->msg_lev >= GLP_MSG_ALL)
      {  xprintf("GLPK Simplex Optimizer, v%s\n", glp_version());
         xprintf("%d row%s, %d column%s, %d non-zero%s\n",
            P->m, P->m == 1 ? "" : "s", P->n, P->n == 1 ? "" : "s",
            P->nnz, P->nnz == 1 ? "" : "s");
      }
      if (P->nnz == 0)
         trivial_lp(P, parm), ret = 0;
      else if (!parm->presolve)
         ret = solve_lp(P, parm);
      else
         ret = preprocess_and_solve_lp(P, parm);
done: /* return to the application program */
      return ret;
}

/***********************************************************************
*  NAME
*
*  glp_init_smcp - initialize simplex method control parameters
*
*  SYNOPSIS
*
*  void glp_init_smcp(glp_smcp *parm);
*
*  DESCRIPTION
*
*  The routine glp_init_smcp initializes control parameters, which are
*  used by the simplex solver, with default values.
*
*  Default values of the control parameters are stored in a glp_smcp
*  structure, which the parameter parm points to. */

void glp_init_smcp(glp_smcp *parm)
{     parm->msg_lev = GLP_MSG_ALL;
      parm->meth = GLP_PRIMAL;
      parm->pricing = GLP_PT_PSE;
      parm->r_test = GLP_RT_HAR;
      parm->tol_bnd = 1e-7;
      parm->tol_dj = 1e-7;
#if 0 /* 07/XI-2015 */
      parm->tol_piv = 1e-10;
#else
      parm->tol_piv = 1e-9;
#endif
      parm->obj_ll = -DBL_MAX;
      parm->obj_ul = +DBL_MAX;
      parm->it_lim = INT_MAX;
      parm->tm_lim = INT_MAX;
      parm->out_frq = 500;
      parm->out_dly = 0;
      parm->presolve = GLP_OFF;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_get_status - retrieve generic status of basic solution
*
*  SYNOPSIS
*
*  int glp_get_status(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_status reports the generic status of the basic
*  solution for the specified problem object as follows:
*
*  GLP_OPT    - solution is optimal;
*  GLP_FEAS   - solution is feasible;
*  GLP_INFEAS - solution is infeasible;
*  GLP_NOFEAS - problem has no feasible solution;
*  GLP_UNBND  - problem has unbounded solution;
*  GLP_UNDEF  - solution is undefined. */

int glp_get_status(glp_prob *lp)
{     int status;
      status = glp_get_prim_stat(lp);
      switch (status)
      {  case GLP_FEAS:
            switch (glp_get_dual_stat(lp))
            {  case GLP_FEAS:
                  status = GLP_OPT;
                  break;
               case GLP_NOFEAS:
                  status = GLP_UNBND;
                  break;
               case GLP_UNDEF:
               case GLP_INFEAS:
                  status = status;
                  break;
               default:
                  xassert(lp != lp);
            }
            break;
         case GLP_UNDEF:
         case GLP_INFEAS:
         case GLP_NOFEAS:
            status = status;
            break;
         default:
            xassert(lp != lp);
      }
      return status;
}

/***********************************************************************
*  NAME
*
*  glp_get_prim_stat - retrieve status of primal basic solution
*
*  SYNOPSIS
*
*  int glp_get_prim_stat(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_prim_stat reports the status of the primal basic
*  solution for the specified problem object as follows:
*
*  GLP_UNDEF  - primal solution is undefined;
*  GLP_FEAS   - primal solution is feasible;
*  GLP_INFEAS - primal solution is infeasible;
*  GLP_NOFEAS - no primal feasible solution exists. */

int glp_get_prim_stat(glp_prob *lp)
{     int pbs_stat = lp->pbs_stat;
      return pbs_stat;
}

/***********************************************************************
*  NAME
*
*  glp_get_dual_stat - retrieve status of dual basic solution
*
*  SYNOPSIS
*
*  int glp_get_dual_stat(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_dual_stat reports the status of the dual basic
*  solution for the specified problem object as follows:
*
*  GLP_UNDEF  - dual solution is undefined;
*  GLP_FEAS   - dual solution is feasible;
*  GLP_INFEAS - dual solution is infeasible;
*  GLP_NOFEAS - no dual feasible solution exists. */

int glp_get_dual_stat(glp_prob *lp)
{     int dbs_stat = lp->dbs_stat;
      return dbs_stat;
}

/***********************************************************************
*  NAME
*
*  glp_get_obj_val - retrieve objective value (basic solution)
*
*  SYNOPSIS
*
*  double glp_get_obj_val(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_obj_val returns value of the objective function
*  for basic solution. */

double glp_get_obj_val(glp_prob *lp)
{     /*struct LPXCPS *cps = lp->cps;*/
      double z;
      z = lp->obj_val;
      /*if (cps->round && fabs(z) < 1e-9) z = 0.0;*/
      return z;
}

/***********************************************************************
*  NAME
*
*  glp_get_row_stat - retrieve row status
*
*  SYNOPSIS
*
*  int glp_get_row_stat(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_row_stat returns current status assigned to the
*  auxiliary variable associated with i-th row as follows:
*
*  GLP_BS - basic variable;
*  GLP_NL - non-basic variable on its lower bound;
*  GLP_NU - non-basic variable on its upper bound;
*  GLP_NF - non-basic free (unbounded) variable;
*  GLP_NS - non-basic fixed variable. */

int glp_get_row_stat(glp_prob *lp, int i)
{     if (!(1 <= i && i <= lp->m))
         xerror("glp_get_row_stat: i = %d; row number out of range\n",
            i);
      return lp->row[i]->stat;
}

/***********************************************************************
*  NAME
*
*  glp_get_row_prim - retrieve row primal value (basic solution)
*
*  SYNOPSIS
*
*  double glp_get_row_prim(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_row_prim returns primal value of the auxiliary
*  variable associated with i-th row. */

double glp_get_row_prim(glp_prob *lp, int i)
{     /*struct LPXCPS *cps = lp->cps;*/
      double prim;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_get_row_prim: i = %d; row number out of range\n",
            i);
      prim = lp->row[i]->prim;
      /*if (cps->round && fabs(prim) < 1e-9) prim = 0.0;*/
      return prim;
}

/***********************************************************************
*  NAME
*
*  glp_get_row_dual - retrieve row dual value (basic solution)
*
*  SYNOPSIS
*
*  double glp_get_row_dual(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_row_dual returns dual value (i.e. reduced cost)
*  of the auxiliary variable associated with i-th row. */

double glp_get_row_dual(glp_prob *lp, int i)
{     /*struct LPXCPS *cps = lp->cps;*/
      double dual;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_get_row_dual: i = %d; row number out of range\n",
            i);
      dual = lp->row[i]->dual;
      /*if (cps->round && fabs(dual) < 1e-9) dual = 0.0;*/
      return dual;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_stat - retrieve column status
*
*  SYNOPSIS
*
*  int glp_get_col_stat(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_col_stat returns current status assigned to the
*  structural variable associated with j-th column as follows:
*
*  GLP_BS - basic variable;
*  GLP_NL - non-basic variable on its lower bound;
*  GLP_NU - non-basic variable on its upper bound;
*  GLP_NF - non-basic free (unbounded) variable;
*  GLP_NS - non-basic fixed variable. */

int glp_get_col_stat(glp_prob *lp, int j)
{     if (!(1 <= j && j <= lp->n))
         xerror("glp_get_col_stat: j = %d; column number out of range\n"
            , j);
      return lp->col[j]->stat;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_prim - retrieve column primal value (basic solution)
*
*  SYNOPSIS
*
*  double glp_get_col_prim(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_col_prim returns primal value of the structural
*  variable associated with j-th column. */

double glp_get_col_prim(glp_prob *lp, int j)
{     /*struct LPXCPS *cps = lp->cps;*/
      double prim;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_get_col_prim: j = %d; column number out of range\n"
            , j);
      prim = lp->col[j]->prim;
      /*if (cps->round && fabs(prim) < 1e-9) prim = 0.0;*/
      return prim;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_dual - retrieve column dual value (basic solution)
*
*  SYNOPSIS
*
*  double glp_get_col_dual(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_col_dual returns dual value (i.e. reduced cost)
*  of the structural variable associated with j-th column. */

double glp_get_col_dual(glp_prob *lp, int j)
{     /*struct LPXCPS *cps = lp->cps;*/
      double dual;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_get_col_dual: j = %d; column number out of range\n"
            , j);
      dual = lp->col[j]->dual;
      /*if (cps->round && fabs(dual) < 1e-9) dual = 0.0;*/
      return dual;
}

/***********************************************************************
*  NAME
*
*  glp_get_unbnd_ray - determine variable causing unboundedness
*
*  SYNOPSIS
*
*  int glp_get_unbnd_ray(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_get_unbnd_ray returns the number k of a variable,
*  which causes primal or dual unboundedness. If 1 <= k <= m, it is
*  k-th auxiliary variable, and if m+1 <= k <= m+n, it is (k-m)-th
*  structural variable, where m is the number of rows, n is the number
*  of columns in the problem object. If such variable is not defined,
*  the routine returns 0.
*
*  COMMENTS
*
*  If it is not exactly known which version of the simplex solver
*  detected unboundedness, i.e. whether the unboundedness is primal or
*  dual, it is sufficient to check the status of the variable reported
*  with the routine glp_get_row_stat or glp_get_col_stat. If the
*  variable is non-basic, the unboundedness is primal, otherwise, if
*  the variable is basic, the unboundedness is dual (the latter case
*  means that the problem has no primal feasible dolution). */

int glp_get_unbnd_ray(glp_prob *lp)
{     int k;
      k = lp->some;
      xassert(k >= 0);
      if (k > lp->m + lp->n) k = 0;
      return k;
}

#if 1 /* 08/VIII-2013 */
int glp_get_it_cnt(glp_prob *P)
{     /* get simplex solver iteration count */
      return P->it_cnt;
}
#endif

#if 1 /* 08/VIII-2013 */
void glp_set_it_cnt(glp_prob *P, int it_cnt)
{     /* set simplex solver iteration count */
      P->it_cnt = it_cnt;
      return;
}
#endif


/***********************************************************************
*  NAME
*
*  glp_create_index - create the name index
*
*  SYNOPSIS
*
*  void glp_create_index(glp_prob *lp);
*
*  DESCRIPTION
*
*  The routine glp_create_index creates the name index for the
*  specified problem object. The name index is an auxiliary data
*  structure, which is intended to quickly (i.e. for logarithmic time)
*  find rows and columns by their names.
*
*  This routine can be called at any time. If the name index already
*  exists, the routine does nothing. */

void glp_create_index(glp_prob *lp)
{     GLPROW *row;
      GLPCOL *col;
      int i, j;
      /* create row name index */
      if (lp->r_tree == NULL)
      {  lp->r_tree = avl_create_tree(avl_strcmp, NULL);
         for (i = 1; i <= lp->m; i++)
         {  row = lp->row[i];
            xassert(row->node == NULL);
            if (row->name != NULL)
            {  row->node = avl_insert_node(lp->r_tree, row->name);
               avl_set_node_link(row->node, row);
            }
         }
      }
      /* create column name index */
      if (lp->c_tree == NULL)
      {  lp->c_tree = avl_create_tree(avl_strcmp, NULL);
         for (j = 1; j <= lp->n; j++)
         {  col = lp->col[j];
            xassert(col->node == NULL);
            if (col->name != NULL)
            {  col->node = avl_insert_node(lp->c_tree, col->name);
               avl_set_node_link(col->node, col);
            }
         }
      }
      return;
}

/***********************************************************************
*  NAME
*
*  glp_find_row - find row by its name
*
*  SYNOPSIS
*
*  int glp_find_row(glp_prob *lp, const char *name);
*
*  RETURNS
*
*  The routine glp_find_row returns the ordinal number of a row,
*  which is assigned (by the routine glp_set_row_name) the specified
*  symbolic name. If no such row exists, the routine returns 0. */

int glp_find_row(glp_prob *lp, const char *name)
{     AVLNODE *node;
      int i = 0;
      if (lp->r_tree == NULL)
         xerror("glp_find_row: row name index does not exist\n");
      if (!(name == NULL || name[0] == '\0' || strlen(name) > 255))
      {  node = avl_find_node(lp->r_tree, name);
         if (node != NULL)
            i = ((GLPROW *)avl_get_node_link(node))->i;
      }
      return i;
}

/***********************************************************************
*  NAME
*
*  glp_find_col - find column by its name
*
*  SYNOPSIS
*
*  int glp_find_col(glp_prob *lp, const char *name);
*
*  RETURNS
*
*  The routine glp_find_col returns the ordinal number of a column,
*  which is assigned (by the routine glp_set_col_name) the specified
*  symbolic name. If no such column exists, the routine returns 0. */

int glp_find_col(glp_prob *lp, const char *name)
{     AVLNODE *node;
      int j = 0;
      if (lp->c_tree == NULL)
         xerror("glp_find_col: column name index does not exist\n");
      if (!(name == NULL || name[0] == '\0' || strlen(name) > 255))
      {  node = avl_find_node(lp->c_tree, name);
         if (node != NULL)
            j = ((GLPCOL *)avl_get_node_link(node))->j;
      }
      return j;
}

/***********************************************************************
*  NAME
*
*  glp_delete_index - delete the name index
*
*  SYNOPSIS
*
*  void glp_delete_index(glp_prob *lp);
*
*  DESCRIPTION
*
*  The routine glp_delete_index deletes the name index previously
*  created by the routine glp_create_index and frees the memory
*  allocated to this auxiliary data structure.
*
*  This routine can be called at any time. If the name index does not
*  exist, the routine does nothing. */

void glp_delete_index(glp_prob *lp)
{     int i, j;
      /* delete row name index */
      if (lp->r_tree != NULL)
      {  for (i = 1; i <= lp->m; i++) lp->row[i]->node = NULL;
         avl_delete_tree(lp->r_tree), lp->r_tree = NULL;
      }
      /* delete column name index */
      if (lp->c_tree != NULL)
      {  for (j = 1; j <= lp->n; j++) lp->col[j]->node = NULL;
         avl_delete_tree(lp->c_tree), lp->c_tree = NULL;
      }
      return;
}




/***********************************************************************
*  NAME
*
*  glp_set_rii - set (change) row scale factor
*
*  SYNOPSIS
*
*  void glp_set_rii(glp_prob *lp, int i, double rii);
*
*  DESCRIPTION
*
*  The routine glp_set_rii sets (changes) the scale factor r[i,i] for
*  i-th row of the specified problem object. */

void glp_set_rii(glp_prob *lp, int i, double rii)
{     if (!(1 <= i && i <= lp->m))
         xerror("glp_set_rii: i = %d; row number out of range\n", i);
      if (rii <= 0.0)
         xerror("glp_set_rii: i = %d; rii = %g; invalid scale factor\n",
            i, rii);
      if (lp->valid && lp->row[i]->rii != rii)
      {  GLPAIJ *aij;
         for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)
         {  if (aij->col->stat == GLP_BS)
            {  /* invalidate the basis factorization */
               lp->valid = 0;
               break;
            }
         }
      }
      lp->row[i]->rii = rii;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_set sjj - set (change) column scale factor
*
*  SYNOPSIS
*
*  void glp_set_sjj(glp_prob *lp, int j, double sjj);
*
*  DESCRIPTION
*
*  The routine glp_set_sjj sets (changes) the scale factor s[j,j] for
*  j-th column of the specified problem object. */

void glp_set_sjj(glp_prob *lp, int j, double sjj)
{     if (!(1 <= j && j <= lp->n))
         xerror("glp_set_sjj: j = %d; column number out of range\n", j);
      if (sjj <= 0.0)
         xerror("glp_set_sjj: j = %d; sjj = %g; invalid scale factor\n",
            j, sjj);
      if (lp->valid && lp->col[j]->sjj != sjj && lp->col[j]->stat ==
         GLP_BS)
      {  /* invalidate the basis factorization */
         lp->valid = 0;
      }
      lp->col[j]->sjj = sjj;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_get_rii - retrieve row scale factor
*
*  SYNOPSIS
*
*  double glp_get_rii(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_get_rii returns current scale factor r[i,i] for i-th
*  row of the specified problem object. */

double glp_get_rii(glp_prob *lp, int i)
{     if (!(1 <= i && i <= lp->m))
         xerror("glp_get_rii: i = %d; row number out of range\n", i);
      return lp->row[i]->rii;
}

/***********************************************************************
*  NAME
*
*  glp_get_sjj - retrieve column scale factor
*
*  SYNOPSIS
*
*  double glp_get_sjj(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_get_sjj returns current scale factor s[j,j] for j-th
*  column of the specified problem object. */

double glp_get_sjj(glp_prob *lp, int j)
{     if (!(1 <= j && j <= lp->n))
         xerror("glp_get_sjj: j = %d; column number out of range\n", j);
      return lp->col[j]->sjj;
}

/***********************************************************************
*  NAME
*
*  glp_unscale_prob - unscale problem data
*
*  SYNOPSIS
*
*  void glp_unscale_prob(glp_prob *lp);
*
*  DESCRIPTION
*
*  The routine glp_unscale_prob performs unscaling of problem data for
*  the specified problem object.
*
*  "Unscaling" means replacing the current scaling matrices R and S by
*  unity matrices that cancels the scaling effect. */

void glp_unscale_prob(glp_prob *lp)
{     int m = glp_get_num_rows(lp);
      int n = glp_get_num_cols(lp);
      int i, j;
      for (i = 1; i <= m; i++) glp_set_rii(lp, i, 1.0);
      for (j = 1; j <= n; j++) glp_set_sjj(lp, j, 1.0);
      return;
}








/***********************************************************************
*  NAME
*
*  glp_set_row_stat - set (change) row status
*
*  SYNOPSIS
*
*  void glp_set_row_stat(glp_prob *lp, int i, int stat);
*
*  DESCRIPTION
*
*  The routine glp_set_row_stat sets (changes) status of the auxiliary
*  variable associated with i-th row.
*
*  The new status of the auxiliary variable should be specified by the
*  parameter stat as follows:
*
*  GLP_BS - basic variable;
*  GLP_NL - non-basic variable;
*  GLP_NU - non-basic variable on its upper bound; if the variable is
*           not double-bounded, this means the same as GLP_NL (only in
*           case of this routine);
*  GLP_NF - the same as GLP_NL (only in case of this routine);
*  GLP_NS - the same as GLP_NL (only in case of this routine). */

void glp_set_row_stat(glp_prob *lp, int i, int stat)
{     GLPROW *row;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_set_row_stat: i = %d; row number out of range\n",
            i);
      if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU ||
            stat == GLP_NF || stat == GLP_NS))
         xerror("glp_set_row_stat: i = %d; stat = %d; invalid status\n",
            i, stat);
      row = lp->row[i];
      if (stat != GLP_BS)
      {  switch (row->type)
         {  case GLP_FR: stat = GLP_NF; break;
            case GLP_LO: stat = GLP_NL; break;
            case GLP_UP: stat = GLP_NU; break;
            case GLP_DB: if (stat != GLP_NU) stat = GLP_NL; break;
            case GLP_FX: stat = GLP_NS; break;
            default: xassert(row != row);
         }
      }
      if (row->stat == GLP_BS && stat != GLP_BS ||
          row->stat != GLP_BS && stat == GLP_BS)
      {  /* invalidate the basis factorization */
         lp->valid = 0;
      }
      row->stat = stat;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_set_col_stat - set (change) column status
*
*  SYNOPSIS
*
*  void glp_set_col_stat(glp_prob *lp, int j, int stat);
*
*  DESCRIPTION
*
*  The routine glp_set_col_stat sets (changes) status of the structural
*  variable associated with j-th column.
*
*  The new status of the structural variable should be specified by the
*  parameter stat as follows:
*
*  GLP_BS - basic variable;
*  GLP_NL - non-basic variable;
*  GLP_NU - non-basic variable on its upper bound; if the variable is
*           not double-bounded, this means the same as GLP_NL (only in
*           case of this routine);
*  GLP_NF - the same as GLP_NL (only in case of this routine);
*  GLP_NS - the same as GLP_NL (only in case of this routine). */

void glp_set_col_stat(glp_prob *lp, int j, int stat)
{     GLPCOL *col;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_set_col_stat: j = %d; column number out of range\n"
            , j);
      if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU ||
            stat == GLP_NF || stat == GLP_NS))
         xerror("glp_set_col_stat: j = %d; stat = %d; invalid status\n",
            j, stat);
      col = lp->col[j];
      if (stat != GLP_BS)
      {  switch (col->type)
         {  case GLP_FR: stat = GLP_NF; break;
            case GLP_LO: stat = GLP_NL; break;
            case GLP_UP: stat = GLP_NU; break;
            case GLP_DB: if (stat != GLP_NU) stat = GLP_NL; break;
            case GLP_FX: stat = GLP_NS; break;
            default: xassert(col != col);
         }
      }
      if (col->stat == GLP_BS && stat != GLP_BS ||
          col->stat != GLP_BS && stat == GLP_BS)
      {  /* invalidate the basis factorization */
         lp->valid = 0;
      }
      col->stat = stat;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_std_basis - construct standard initial LP basis
*
*  SYNOPSIS
*
*  void glp_std_basis(glp_prob *lp);
*
*  DESCRIPTION
*
*  The routine glp_std_basis builds the "standard" (trivial) initial
*  basis for the specified problem object.
*
*  In the "standard" basis all auxiliary variables are basic, and all
*  structural variables are non-basic. */

void glp_std_basis(glp_prob *lp)
{     int i, j;
      /* make all auxiliary variables basic */
      for (i = 1; i <= lp->m; i++)
         glp_set_row_stat(lp, i, GLP_BS);
      /* make all structural variables non-basic */
      for (j = 1; j <= lp->n; j++)
      {  GLPCOL *col = lp->col[j];
         if (col->type == GLP_DB && fabs(col->lb) > fabs(col->ub))
            glp_set_col_stat(lp, j, GLP_NU);
         else
            glp_set_col_stat(lp, j, GLP_NL);
      }
      return;
}







#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef HAVE_GMP               /* use GNU MP library */

#include <gmp.h>

#define gmp_pool_count() 0

#define gmp_free_mem() ((void)0)

#else                         /* use GLPK MP module */

/***********************************************************************
*  INTEGER NUMBERS
*  ---------------
*  Depending on its magnitude an integer number of arbitrary precision
*  is represented either in short format or in long format.
*
*  Short format corresponds to the int type and allows representing
*  integer numbers in the range [-(2^31-1), +(2^31-1)]. Note that for
*  the most negative number of int type the short format is not used.
*
*  In long format integer numbers are represented using the positional
*  system with the base (radix) 2^16 = 65536:
*
*     x = (-1)^s sum{j in 0..n-1} d[j] * 65536^j,
*
*  where x is the integer to be represented, s is its sign (+1 or -1),
*  d[j] are its digits (0 <= d[j] <= 65535).
*
*  RATIONAL NUMBERS
*  ----------------
*  A rational number is represented as an irreducible fraction:
*
*     p / q,
*
*  where p (numerator) and q (denominator) are integer numbers (q > 0)
*  having no common divisors. */

struct mpz
{     /* integer number */
      int val;
      /* if ptr is a null pointer, the number is in short format, and
         val is its value; otherwise, the number is in long format, and
         val is its sign (+1 or -1) */
      struct mpz_seg *ptr;
      /* pointer to the linked list of the number segments ordered in
         ascending of powers of the base */
};

struct mpz_seg
{     /* integer number segment */
      unsigned short d[6];
      /* six digits of the number ordered in ascending of powers of the
         base */
      struct mpz_seg *next;
      /* pointer to the next number segment */
};

struct mpq
{     /* rational number (p / q) */
      struct mpz p;
      /* numerator */
      struct mpz q;
      /* denominator */
};

typedef struct mpz *mpz_t;
typedef struct mpq *mpq_t;

#define gmp_get_atom _glp_gmp_get_atom
void *gmp_get_atom(int size);

#define gmp_free_atom _glp_gmp_free_atom
void gmp_free_atom(void *ptr, int size);

#define gmp_pool_count _glp_gmp_pool_count
int gmp_pool_count(void);

#define gmp_get_work _glp_gmp_get_work
unsigned short *gmp_get_work(int size);

#define gmp_free_mem _glp_gmp_free_mem
void gmp_free_mem(void);

#define mpz_init(x) (void)((x) = _mpz_init())

#define _mpz_init _glp_mpz_init
mpz_t _mpz_init(void);
/* initialize x and set its value to 0 */

#define mpz_clear _glp_mpz_clear
void mpz_clear(mpz_t x);
/* free the space occupied by x */

#define mpz_set _glp_mpz_set
void mpz_set(mpz_t z, mpz_t x);
/* set the value of z from x */

#define mpz_set_si _glp_mpz_set_si
void mpz_set_si(mpz_t x, int val);
/* set the value of x to val */

#define mpz_get_d _glp_mpz_get_d
double mpz_get_d(mpz_t x);
/* convert x to a double, truncating if necessary */

#define mpz_get_d_2exp _glp_mpz_get_d_2exp
double mpz_get_d_2exp(int *exp, mpz_t x);
/* convert x to a double, returning the exponent separately */

#define mpz_swap _glp_mpz_swap
void mpz_swap(mpz_t x, mpz_t y);
/* swap the values x and y efficiently */

#define mpz_add _glp_mpz_add
void mpz_add(mpz_t, mpz_t, mpz_t);
/* set z to x + y */

#define mpz_sub _glp_mpz_sub
void mpz_sub(mpz_t, mpz_t, mpz_t);
/* set z to x - y */

#define mpz_mul _glp_mpz_mul
void mpz_mul(mpz_t, mpz_t, mpz_t);
/* set z to x * y */

#define mpz_neg _glp_mpz_neg
void mpz_neg(mpz_t z, mpz_t x);
/* set z to 0 - x */

#define mpz_abs _glp_mpz_abs
void mpz_abs(mpz_t z, mpz_t x);
/* set z to the absolute value of x */

#define mpz_div _glp_mpz_div
void mpz_div(mpz_t q, mpz_t r, mpz_t x, mpz_t y);
/* divide x by y, forming quotient q and/or remainder r */

#define mpz_gcd _glp_mpz_gcd
void mpz_gcd(mpz_t z, mpz_t x, mpz_t y);
/* set z to the greatest common divisor of x and y */

#define mpz_cmp _glp_mpz_cmp
int mpz_cmp(mpz_t x, mpz_t y);
/* compare x and y */

#define mpz_sgn _glp_mpz_sgn
int mpz_sgn(mpz_t x);
/* return +1 if x > 0, 0 if x = 0, and -1 if x < 0 */

#define mpz_out_str _glp_mpz_out_str
int mpz_out_str(void *fp, int base, mpz_t x);
/* output x on stream fp, as a string in given base */

#define mpq_init(x) (void)((x) = _mpq_init())

#define _mpq_init _glp_mpq_init
mpq_t _mpq_init(void);
/* initialize x, and set its value to 0/1 */

#define mpq_clear _glp_mpq_clear
void mpq_clear(mpq_t x);
/* free the space occupied by x */

#define mpq_canonicalize _glp_mpq_canonicalize
void mpq_canonicalize(mpq_t x);
/* canonicalize x */

#define mpq_set _glp_mpq_set
void mpq_set(mpq_t z, mpq_t x);
/* set the value of z from x */

#define mpq_set_si _glp_mpq_set_si
void mpq_set_si(mpq_t x, int p, unsigned int q);
/* set the value of x to p/q */

#define mpq_get_d _glp_mpq_get_d
double mpq_get_d(mpq_t x);
/* convert x to a double, truncating if necessary */

#define mpq_set_d _glp_mpq_set_d
void mpq_set_d(mpq_t x, double val);
/* set x to val; there is no rounding, the conversion is exact */

#define mpq_add _glp_mpq_add
void mpq_add(mpq_t z, mpq_t x, mpq_t y);
/* set z to x + y */

#define mpq_sub _glp_mpq_sub
void mpq_sub(mpq_t z, mpq_t x, mpq_t y);
/* set z to x - y */

#define mpq_mul _glp_mpq_mul
void mpq_mul(mpq_t z, mpq_t x, mpq_t y);
/* set z to x * y */

#define mpq_div _glp_mpq_div
void mpq_div(mpq_t z, mpq_t x, mpq_t y);
/* set z to x / y */

#define mpq_neg _glp_mpq_neg
void mpq_neg(mpq_t z, mpq_t x);
/* set z to 0 - x */

#define mpq_abs _glp_mpq_abs
void mpq_abs(mpq_t z, mpq_t x);
/* set z to the absolute value of x */

#define mpq_cmp _glp_mpq_cmp
int mpq_cmp(mpq_t x, mpq_t y);
/* compare x and y */

#define mpq_sgn _glp_mpq_sgn
int mpq_sgn(mpq_t x);
/* return +1 if x > 0, 0 if x = 0, and -1 if x < 0 */

#define mpq_out_str _glp_mpq_out_str
int mpq_out_str(void *fp, int base, mpq_t x);
/* output x on stream fp, as a string in given base */

#endif

#ifdef HAVE_GMP               /* use GNU MP library */

/* nothing is needed */

#else                         /* use GLPK MP module */

#define bigmul _glp_bigmul
void bigmul(int n, int m, unsigned short x[], unsigned short y[]);
/* multiply unsigned integer numbers of arbitrary precision */

#define bigdiv _glp_bigdiv
void bigdiv(int n, int m, unsigned short x[], unsigned short y[]);
/* divide unsigned integer numbers of arbitrary precision */


/***********************************************************************
*  Two routines below are intended to multiply and divide unsigned
*  integer numbers of arbitrary precision.
*
*  The routines assume that an unsigned integer number is represented in
*  the positional numeral system with the base 2^16 = 65536, i.e. each
*  "digit" of the number is in the range [0, 65535] and represented as
*  a 16-bit value of the unsigned short type. In other words, a number x
*  has the following representation:
*
*         n-1
*     x = sum d[j] * 65536^j,
*         j=0
*
*  where n is the number of places (positions), and d[j] is j-th "digit"
*  of x, 0 <= d[j] <= 65535.
***********************************************************************/

/***********************************************************************
*  NAME
*
*  bigmul - multiply unsigned integer numbers of arbitrary precision
*
*  SYNOPSIS
*
*  #include "bignum.h"
*  void bigmul(int n, int m, unsigned short x[], unsigned short y[]);
*
*  DESCRIPTION
*
*  The routine bigmul multiplies unsigned integer numbers of arbitrary
*  precision.
*
*  n is the number of digits of multiplicand, n >= 1;
*
*  m is the number of digits of multiplier, m >= 1;
*
*  x is an array containing digits of the multiplicand in elements
*  x[m], x[m+1], ..., x[n+m-1]. Contents of x[0], x[1], ..., x[m-1] are
*  ignored on entry.
*
*  y is an array containing digits of the multiplier in elements y[0],
*  y[1], ..., y[m-1].
*
*  On exit digits of the product are stored in elements x[0], x[1], ...,
*  x[n+m-1]. The array y is not changed. */

void bigmul(int n, int m, unsigned short x[], unsigned short y[])
{     int i, j;
      unsigned int t;
      xassert(n >= 1);
      xassert(m >= 1);
      for (j = 0; j < m; j++) x[j] = 0;
      for (i = 0; i < n; i++)
      {  if (x[i+m])
         {  t = 0;
            for (j = 0; j < m; j++)
            {  t += (unsigned int)x[i+m] * (unsigned int)y[j] +
                    (unsigned int)x[i+j];
               x[i+j] = (unsigned short)t;
               t >>= 16;
            }
            x[i+m] = (unsigned short)t;
         }
      }
      return;
}

/***********************************************************************
*  NAME
*
*  bigdiv - divide unsigned integer numbers of arbitrary precision
*
*  SYNOPSIS
*
*  #include "bignum.h"
*  void bigdiv(int n, int m, unsigned short x[], unsigned short y[]);
*
*  DESCRIPTION
*
*  The routine bigdiv divides one unsigned integer number of arbitrary
*  precision by another with the algorithm described in [1].
*
*  n is the difference between the number of digits of dividend and the
*  number of digits of divisor, n >= 0.
*
*  m is the number of digits of divisor, m >= 1.
*
*  x is an array containing digits of the dividend in elements x[0],
*  x[1], ..., x[n+m-1].
*
*  y is an array containing digits of the divisor in elements y[0],
*  y[1], ..., y[m-1]. The highest digit y[m-1] must be non-zero.
*
*  On exit n+1 digits of the quotient are stored in elements x[m],
*  x[m+1], ..., x[n+m], and m digits of the remainder are stored in
*  elements x[0], x[1], ..., x[m-1]. The array y is changed but then
*  restored.
*
*  REFERENCES
*
*  1. D. Knuth. The Art of Computer Programming. Vol. 2: Seminumerical
*  Algorithms. Stanford University, 1969. */

void bigdiv(int n, int m, unsigned short x[], unsigned short y[])
{     int i, j;
      unsigned int t;
      unsigned short d, q, r;
      xassert(n >= 0);
      xassert(m >= 1);
      xassert(y[m-1] != 0);
      /* special case when divisor has the only digit */
      if (m == 1)
      {  d = 0;
         for (i = n; i >= 0; i--)
         {  t = ((unsigned int)d << 16) + (unsigned int)x[i];
            x[i+1] = (unsigned short)(t / y[0]);
            d = (unsigned short)(t % y[0]);
         }
         x[0] = d;
         goto done;
      }
      /* multiply dividend and divisor by a normalizing coefficient in
       * order to provide the condition y[m-1] >= base / 2 */
      d = (unsigned short)(0x10000 / ((unsigned int)y[m-1] + 1));
      if (d == 1)
         x[n+m] = 0;
      else
      {  t = 0;
         for (i = 0; i < n+m; i++)
         {  t += (unsigned int)x[i] * (unsigned int)d;
            x[i] = (unsigned short)t;
            t >>= 16;
         }
         x[n+m] = (unsigned short)t;
         t = 0;
         for (j = 0; j < m; j++)
         {  t += (unsigned int)y[j] * (unsigned int)d;
            y[j] = (unsigned short)t;
            t >>= 16;
         }
      }
      /* main loop */
      for (i = n; i >= 0; i--)
      {  /* estimate and correct the current digit of quotient */
         if (x[i+m] < y[m-1])
         {  t = ((unsigned int)x[i+m] << 16) + (unsigned int)x[i+m-1];
            q = (unsigned short)(t / (unsigned int)y[m-1]);
            r = (unsigned short)(t % (unsigned int)y[m-1]);
            if (q == 0) goto putq; else goto test;
         }
         q = 0;
         r = x[i+m-1];
decr:    q--; /* if q = 0 then q-- = 0xFFFF */
         t = (unsigned int)r + (unsigned int)y[m-1];
         r = (unsigned short)t;
         if (t > 0xFFFF) goto msub;
test:    t = (unsigned int)y[m-2] * (unsigned int)q;
         if ((unsigned short)(t >> 16) > r) goto decr;
         if ((unsigned short)(t >> 16) < r) goto msub;
         if ((unsigned short)t > x[i+m-2]) goto decr;
msub:    /* now subtract divisor multiplied by the current digit of
          * quotient from the current dividend */
         if (q == 0) goto putq;
         t = 0;
         for (j = 0; j < m; j++)
         {  t += (unsigned int)y[j] * (unsigned int)q;
            if (x[i+j] < (unsigned short)t) t += 0x10000;
            x[i+j] -= (unsigned short)t;
            t >>= 16;
         }
         if (x[i+m] >= (unsigned short)t) goto putq;
         /* perform correcting addition, because the current digit of
          * quotient is greater by one than its correct value */
         q--;
         t = 0;
         for (j = 0; j < m; j++)
         {  t += (unsigned int)x[i+j] + (unsigned int)y[j];
            x[i+j] = (unsigned short)t;
            t >>= 16;
         }
putq:    /* store the current digit of quotient */
         x[i+m] = q;
      }
      /* divide divisor and remainder by the normalizing coefficient in
       * order to restore their original values */
      if (d > 1)
      {  t = 0;
         for (i = m-1; i >= 0; i--)
         {  t = (t << 16) + (unsigned int)x[i];
            x[i] = (unsigned short)(t / (unsigned int)d);
            t %= (unsigned int)d;
         }
         t = 0;
         for (j = m-1; j >= 0; j--)
         {  t = (t << 16) + (unsigned int)y[j];
            y[j] = (unsigned short)(t / (unsigned int)d);
            t %= (unsigned int)d;
         }
      }
done: return;
}

/**********************************************************************/

#ifdef GLP_TEST
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "rng.h"

#define N_MAX 7
/* maximal number of digits in multiplicand */

#define M_MAX 5
/* maximal number of digits in multiplier */

#define N_TEST 1000000
/* number of tests */

int main(void)
{     RNG *rand;
      int d, j, n, m, test;
      unsigned short x[N_MAX], y[M_MAX], z[N_MAX+M_MAX];
      rand = rng_create_rand();
      for (test = 1; test <= N_TEST; test++)
      {  /* x[0,...,n-1] := multiplicand */
         n = 1 + rng_unif_rand(rand, N_MAX-1);
         assert(1 <= n && n <= N_MAX);
         for (j = 0; j < n; j++)
         {  d = rng_unif_rand(rand, 65536);
            assert(0 <= d && d <= 65535);
            x[j] = (unsigned short)d;
         }
         /* y[0,...,m-1] := multiplier */
         m = 1 + rng_unif_rand(rand, M_MAX-1);
         assert(1 <= m && m <= M_MAX);
         for (j = 0; j < m; j++)
         {  d = rng_unif_rand(rand, 65536);
            assert(0 <= d && d <= 65535);
            y[j] = (unsigned short)d;
         }
         if (y[m-1] == 0) y[m-1] = 1;
         /* z[0,...,n+m-1] := x * y */
         for (j = 0; j < n; j++) z[m+j] = x[j];
         bigmul(n, m, z, y);
         /* z[0,...,m-1] := z mod y, z[m,...,n+m-1] := z div y */
         bigdiv(n, m, z, y);
         /* z mod y must be 0 */
         for (j = 0; j < m; j++) assert(z[j] == 0);
         /* z div y must be x */
         for (j = 0; j < n; j++) assert(z[m+j] == x[j]);
      }
      fprintf(stderr, "%d tests successfully passed\n", N_TEST);
      rng_delete_rand(rand);
      return 0;
}
#endif



#define gmp_pool env->gmp_pool
#define gmp_size env->gmp_size
#define gmp_work env->gmp_work

void *gmp_get_atom(int size)
{     ENV *env = get_env_ptr();
      if (gmp_pool == NULL)
         gmp_pool = dmp_create_pool();
      return dmp_get_atom(gmp_pool, size);
}

void gmp_free_atom(void *ptr, int size)
{     ENV *env = get_env_ptr();
      xassert(gmp_pool != NULL);
      dmp_free_atom(gmp_pool, ptr, size);
      return;
}

int gmp_pool_count(void)
{     ENV *env = get_env_ptr();
      if (gmp_pool == NULL)
         return 0;
      else
         return dmp_in_use(gmp_pool);
}

unsigned short *gmp_get_work(int size)
{     ENV *env = get_env_ptr();
      xassert(size > 0);
      if (gmp_size < size)
      {  if (gmp_size == 0)
         {  xassert(gmp_work == NULL);
            gmp_size = 100;
         }
         else
         {  xassert(gmp_work != NULL);
            xfree(gmp_work);
         }
         while (gmp_size < size)
            gmp_size += gmp_size;
         gmp_work = xcalloc(gmp_size, sizeof(unsigned short));
      }
      return gmp_work;
}

void gmp_free_mem(void)
{     ENV *env = get_env_ptr();
      if (gmp_pool != NULL)
         dmp_delete_pool(gmp_pool);
      if (gmp_work != NULL)
         xfree(gmp_work);
      gmp_pool = NULL;
      gmp_size = 0;
      gmp_work = NULL;
      return;
}

/*--------------------------------------------------------------------*/

mpz_t _mpz_init(void)
{     /* initialize x and set its value to 0 */
      mpz_t x;
      x = gmp_get_atom(sizeof(struct mpz));
      x->val = 0;
      x->ptr = NULL;
      return x;
}

void mpz_clear(mpz_t x)
{     /* free the space occupied by x */
      mpz_set_si(x, 0);
      xassert(x->ptr == NULL);
      /* free the number descriptor */
      gmp_free_atom(x, sizeof(struct mpz));
      return;
}

void mpz_set(mpz_t z, mpz_t x)
{     /* set the value of z from x */
      struct mpz_seg *e, *ee, *es;
      if (z != x)
      {  mpz_set_si(z, 0);
         z->val = x->val;
         xassert(z->ptr == NULL);
         for (e = x->ptr, es = NULL; e != NULL; e = e->next)
         {  ee = gmp_get_atom(sizeof(struct mpz_seg));
            memcpy(ee->d, e->d, 12);
            ee->next = NULL;
            if (z->ptr == NULL)
               z->ptr = ee;
            else
               es->next = ee;
            es = ee;
         }
      }
      return;
}

void mpz_set_si(mpz_t x, int val)
{     /* set the value of x to val */
      struct mpz_seg *e;
      /* free existing segments, if any */
      while (x->ptr != NULL)
      {  e = x->ptr;
         x->ptr = e->next;
         gmp_free_atom(e, sizeof(struct mpz_seg));
      }
      /* assign new value */
      if (val == 0x80000000)
      {  /* long format is needed */
         x->val = -1;
         x->ptr = e = gmp_get_atom(sizeof(struct mpz_seg));
         memset(e->d, 0, 12);
         e->d[1] = 0x8000;
         e->next = NULL;
      }
      else
      {  /* short format is enough */
         x->val = val;
      }
      return;
}

double mpz_get_d(mpz_t x)
{     /* convert x to a double, truncating if necessary */
      struct mpz_seg *e;
      int j;
      double val, deg;
      if (x->ptr == NULL)
         val = (double)x->val;
      else
      {  xassert(x->val != 0);
         val = 0.0;
         deg = 1.0;
         for (e = x->ptr; e != NULL; e = e->next)
         {  for (j = 0; j <= 5; j++)
            {  val += deg * (double)((int)e->d[j]);
               deg *= 65536.0;
            }
         }
         if (x->val < 0)
            val = - val;
      }
      return val;
}

double mpz_get_d_2exp(int *exp, mpz_t x)
{     /* convert x to a double, truncating if necessary (i.e. rounding
       * towards zero), and returning the exponent separately;
       * the return value is in the range 0.5 <= |d| < 1 and the
       * exponent is stored to *exp; d*2^exp is the (truncated) x value;
       * if x is zero, the return is 0.0 and 0 is stored to *exp;
       * this is similar to the standard C frexp function */
      struct mpz_seg *e;
      int j, n, n1;
      double val;
      if (x->ptr == NULL)
         val = (double)x->val, n = 0;
      else
      {  xassert(x->val != 0);
         val = 0.0, n = 0;
         for (e = x->ptr; e != NULL; e = e->next)
         {  for (j = 0; j <= 5; j++)
            {  val += (double)((int)e->d[j]);
               val /= 65536.0, n += 16;
            }
         }
         if (x->val < 0)
            val = - val;
      }
      val = frexp(val, &n1);
      *exp = n + n1;
      return val;
}

void mpz_swap(mpz_t x, mpz_t y)
{     /* swap the values x and y efficiently */
      int val;
      void *ptr;
      val = x->val, ptr = x->ptr;
      x->val = y->val, x->ptr = y->ptr;
      y->val = val, y->ptr = ptr;
      return;
}

static void normalize(mpz_t x)
{     /* normalize integer x that includes removing non-significant
       * (leading) zeros and converting to short format, if possible */
      struct mpz_seg *es, *e;
      /* if the integer is in short format, it remains unchanged */
      if (x->ptr == NULL)
      {  xassert(x->val != 0x80000000);
         goto done;
      }
      xassert(x->val == +1 || x->val == -1);
      /* find the last (most significant) non-zero segment */
      es = NULL;
      for (e = x->ptr; e != NULL; e = e->next)
      {  if (e->d[0] || e->d[1] || e->d[2] ||
             e->d[3] || e->d[4] || e->d[5])
            es = e;
      }
      /* if all segments contain zeros, the integer is zero */
      if (es == NULL)
      {  mpz_set_si(x, 0);
         goto done;
      }
      /* remove non-significant (leading) zero segments */
      while (es->next != NULL)
      {  e = es->next;
         es->next = e->next;
         gmp_free_atom(e, sizeof(struct mpz_seg));
      }
      /* convert the integer to short format, if possible */
      e = x->ptr;
      if (e->next == NULL && e->d[1] <= 0x7FFF &&
         !e->d[2] && !e->d[3] && !e->d[4] && !e->d[5])
      {  int val;
         val = (int)e->d[0] + ((int)e->d[1] << 16);
         if (x->val < 0)
            val = - val;
         mpz_set_si(x, val);
      }
done: return;
}

void mpz_add(mpz_t z, mpz_t x, mpz_t y)
{     /* set z to x + y */
      static struct mpz_seg zero = { { 0, 0, 0, 0, 0, 0 }, NULL };
      struct mpz_seg dumx, dumy, *ex, *ey, *ez, *es, *ee;
      int k, sx, sy, sz;
      unsigned int t;
      /* if [x] = 0 then [z] = [y] */
      if (x->val == 0)
      {  xassert(x->ptr == NULL);
         mpz_set(z, y);
         goto done;
      }
      /* if [y] = 0 then [z] = [x] */
      if (y->val == 0)
      {  xassert(y->ptr == NULL);
         mpz_set(z, x);
         goto done;
      }
      /* special case when both [x] and [y] are in short format */
      if (x->ptr == NULL && y->ptr == NULL)
      {  int xval = x->val, yval = y->val, zval = x->val + y->val;
         xassert(xval != 0x80000000 && yval != 0x80000000);
         if (!(xval > 0 && yval > 0 && zval <= 0 ||
               xval < 0 && yval < 0 && zval >= 0))
         {  mpz_set_si(z, zval);
            goto done;
         }
      }
      /* convert [x] to long format, if necessary */
      if (x->ptr == NULL)
      {  xassert(x->val != 0x80000000);
         if (x->val >= 0)
         {  sx = +1;
            t = (unsigned int)(+ x->val);
         }
         else
         {  sx = -1;
            t = (unsigned int)(- x->val);
         }
         ex = &dumx;
         ex->d[0] = (unsigned short)t;
         ex->d[1] = (unsigned short)(t >> 16);
         ex->d[2] = ex->d[3] = ex->d[4] = ex->d[5] = 0;
         ex->next = NULL;
      }
      else
      {  sx = x->val;
         xassert(sx == +1 || sx == -1);
         ex = x->ptr;
      }
      /* convert [y] to long format, if necessary */
      if (y->ptr == NULL)
      {  xassert(y->val != 0x80000000);
         if (y->val >= 0)
         {  sy = +1;
            t = (unsigned int)(+ y->val);
         }
         else
         {  sy = -1;
            t = (unsigned int)(- y->val);
         }
         ey = &dumy;
         ey->d[0] = (unsigned short)t;
         ey->d[1] = (unsigned short)(t >> 16);
         ey->d[2] = ey->d[3] = ey->d[4] = ey->d[5] = 0;
         ey->next = NULL;
      }
      else
      {  sy = y->val;
         xassert(sy == +1 || sy == -1);
         ey = y->ptr;
      }
      /* main fragment */
      sz = sx;
      ez = es = NULL;
      if (sx > 0 && sy > 0 || sx < 0 && sy < 0)
      {  /* [x] and [y] have identical signs -- addition */
         t = 0;
         for (; ex || ey; ex = ex->next, ey = ey->next)
         {  if (ex == NULL)
               ex = &zero;
            if (ey == NULL)
               ey = &zero;
            ee = gmp_get_atom(sizeof(struct mpz_seg));
            for (k = 0; k <= 5; k++)
            {  t += (unsigned int)ex->d[k];
               t += (unsigned int)ey->d[k];
               ee->d[k] = (unsigned short)t;
               t >>= 16;
            }
            ee->next = NULL;
            if (ez == NULL)
               ez = ee;
            else
               es->next = ee;
            es = ee;
         }
         if (t)
         {  /* overflow -- one extra digit is needed */
            ee = gmp_get_atom(sizeof(struct mpz_seg));
            ee->d[0] = 1;
            ee->d[1] = ee->d[2] = ee->d[3] = ee->d[4] = ee->d[5] = 0;
            ee->next = NULL;
            xassert(es != NULL);
            es->next = ee;
         }
      }
      else
      {  /* [x] and [y] have different signs -- subtraction */
         t = 1;
         for (; ex || ey; ex = ex->next, ey = ey->next)
         {  if (ex == NULL)
               ex = &zero;
            if (ey == NULL)
               ey = &zero;
            ee = gmp_get_atom(sizeof(struct mpz_seg));
            for (k = 0; k <= 5; k++)
            {  t += (unsigned int)ex->d[k];
               t += (0xFFFF - (unsigned int)ey->d[k]);
               ee->d[k] = (unsigned short)t;
               t >>= 16;
            }
            ee->next = NULL;
            if (ez == NULL)
               ez = ee;
            else
               es->next = ee;
            es = ee;
         }
         if (!t)
         {  /* |[x]| < |[y]| -- result in complement coding */
            sz = - sz;
            t = 1;
            for (ee = ez; ee != NULL; ee = ee->next)
            {  for (k = 0; k <= 5; k++)
               {  t += (0xFFFF - (unsigned int)ee->d[k]);
                  ee->d[k] = (unsigned short)t;
                  t >>= 16;
               }
            }
         }
      }
      /* contruct and normalize result */
      mpz_set_si(z, 0);
      z->val = sz;
      z->ptr = ez;
      normalize(z);
done: return;
}

void mpz_sub(mpz_t z, mpz_t x, mpz_t y)
{     /* set z to x - y */
      if (x == y)
         mpz_set_si(z, 0);
      else
      {  y->val = - y->val;
         mpz_add(z, x, y);
         if (y != z)
            y->val = - y->val;
      }
      return;
}

void mpz_mul(mpz_t z, mpz_t x, mpz_t y)
{     /* set z to x * y */
      struct mpz_seg dumx, dumy, *ex, *ey, *es, *e;
      int sx, sy, k, nx, ny, n;
      unsigned int t;
      unsigned short *work, *wx, *wy;
      /* if [x] = 0 then [z] = 0 */
      if (x->val == 0)
      {  xassert(x->ptr == NULL);
         mpz_set_si(z, 0);
         goto done;
      }
      /* if [y] = 0 then [z] = 0 */
      if (y->val == 0)
      {  xassert(y->ptr == NULL);
         mpz_set_si(z, 0);
         goto done;
      }
      /* special case when both [x] and [y] are in short format */
      if (x->ptr == NULL && y->ptr == NULL)
      {  int xval = x->val, yval = y->val, sz = +1;
         xassert(xval != 0x80000000 && yval != 0x80000000);
         if (xval < 0)
            xval = - xval, sz = - sz;
         if (yval < 0)
            yval = - yval, sz = - sz;
         if (xval <= 0x7FFFFFFF / yval)
         {  mpz_set_si(z, sz * (xval * yval));
            goto done;
         }
      }
      /* convert [x] to long format, if necessary */
      if (x->ptr == NULL)
      {  xassert(x->val != 0x80000000);
         if (x->val >= 0)
         {  sx = +1;
            t = (unsigned int)(+ x->val);
         }
         else
         {  sx = -1;
            t = (unsigned int)(- x->val);
         }
         ex = &dumx;
         ex->d[0] = (unsigned short)t;
         ex->d[1] = (unsigned short)(t >> 16);
         ex->d[2] = ex->d[3] = ex->d[4] = ex->d[5] = 0;
         ex->next = NULL;
      }
      else
      {  sx = x->val;
         xassert(sx == +1 || sx == -1);
         ex = x->ptr;
      }
      /* convert [y] to long format, if necessary */
      if (y->ptr == NULL)
      {  xassert(y->val != 0x80000000);
         if (y->val >= 0)
         {  sy = +1;
            t = (unsigned int)(+ y->val);
         }
         else
         {  sy = -1;
            t = (unsigned int)(- y->val);
         }
         ey = &dumy;
         ey->d[0] = (unsigned short)t;
         ey->d[1] = (unsigned short)(t >> 16);
         ey->d[2] = ey->d[3] = ey->d[4] = ey->d[5] = 0;
         ey->next = NULL;
      }
      else
      {  sy = y->val;
         xassert(sy == +1 || sy == -1);
         ey = y->ptr;
      }
      /* determine the number of digits of [x] */
      nx = n = 0;
      for (e = ex; e != NULL; e = e->next)
      {  for (k = 0; k <= 5; k++)
         {  n++;
            if (e->d[k])
               nx = n;
         }
      }
      xassert(nx > 0);
      /* determine the number of digits of [y] */
      ny = n = 0;
      for (e = ey; e != NULL; e = e->next)
      {  for (k = 0; k <= 5; k++)
         {  n++;
            if (e->d[k])
               ny = n;
         }
      }
      xassert(ny > 0);
      /* we need working array containing at least nx+ny+ny places */
      work = gmp_get_work(nx+ny+ny);
      /* load digits of [x] */
      wx = &work[0];
      for (n = 0; n < nx; n++)
         wx[ny+n] = 0;
      for (n = 0, e = ex; e != NULL; e = e->next)
      {  for (k = 0; k <= 5; k++, n++)
         {  if (e->d[k])
               wx[ny+n] = e->d[k];
         }
      }
      /* load digits of [y] */
      wy = &work[nx+ny];
      for (n = 0; n < ny; n++) wy[n] = 0;
      for (n = 0, e = ey; e != NULL; e = e->next)
      {  for (k = 0; k <= 5; k++, n++)
         {  if (e->d[k])
               wy[n] = e->d[k];
         }
      }
      /* compute [x] * [y] */
      bigmul(nx, ny, wx, wy);
      /* construct and normalize result */
      mpz_set_si(z, 0);
      z->val = sx * sy;
      es = NULL;
      k = 6;
      for (n = 0; n < nx+ny; n++)
      {  if (k > 5)
         {  e = gmp_get_atom(sizeof(struct mpz_seg));
            e->d[0] = e->d[1] = e->d[2] = 0;
            e->d[3] = e->d[4] = e->d[5] = 0;
            e->next = NULL;
            if (z->ptr == NULL)
               z->ptr = e;
            else
               es->next = e;
            es = e;
            k = 0;
         }
         es->d[k++] = wx[n];
      }
      normalize(z);
done: return;
}

void mpz_neg(mpz_t z, mpz_t x)
{     /* set z to 0 - x */
      mpz_set(z, x);
      z->val = - z->val;
      return;
}

void mpz_abs(mpz_t z, mpz_t x)
{     /* set z to the absolute value of x */
      mpz_set(z, x);
      if (z->val < 0)
         z->val = - z->val;
      return;
}

void mpz_div(mpz_t q, mpz_t r, mpz_t x, mpz_t y)
{     /* divide x by y, forming quotient q and/or remainder r
       * if q = NULL then quotient is not stored; if r = NULL then
       * remainder is not stored
       * the sign of quotient is determined as in algebra while the
       * sign of remainder is the same as the sign of dividend:
       * +26 : +7 = +3, remainder is +5
       * -26 : +7 = -3, remainder is -5
       * +26 : -7 = -3, remainder is +5
       * -26 : -7 = +3, remainder is -5 */
      struct mpz_seg dumx, dumy, *ex, *ey, *es, *e;
      int sx, sy, k, nx, ny, n;
      unsigned int t;
      unsigned short *work, *wx, *wy;
      /* divide by zero is not allowed */
      if (y->val == 0)
      {  xassert(y->ptr == NULL);
         xerror("mpz_div: divide by zero not allowed\n");
      }
      /* if [x] = 0 then [q] = [r] = 0 */
      if (x->val == 0)
      {  xassert(x->ptr == NULL);
         if (q != NULL)
            mpz_set_si(q, 0);
         if (r != NULL)
            mpz_set_si(r, 0);
         goto done;
      }
      /* special case when both [x] and [y] are in short format */
      if (x->ptr == NULL && y->ptr == NULL)
      {  int xval = x->val, yval = y->val;
         xassert(xval != 0x80000000 && yval != 0x80000000);
         /* FIXME: use div function */
         if (q != NULL)
            mpz_set_si(q, xval / yval);
         if (r != NULL)
            mpz_set_si(r, xval % yval);
         goto done;
      }
      /* convert [x] to long format, if necessary */
      if (x->ptr == NULL)
      {  xassert(x->val != 0x80000000);
         if (x->val >= 0)
         {  sx = +1;
            t = (unsigned int)(+ x->val);
         }
         else
         {  sx = -1;
            t = (unsigned int)(- x->val);
         }
         ex = &dumx;
         ex->d[0] = (unsigned short)t;
         ex->d[1] = (unsigned short)(t >> 16);
         ex->d[2] = ex->d[3] = ex->d[4] = ex->d[5] = 0;
         ex->next = NULL;
      }
      else
      {  sx = x->val;
         xassert(sx == +1 || sx == -1);
         ex = x->ptr;
      }
      /* convert [y] to long format, if necessary */
      if (y->ptr == NULL)
      {  xassert(y->val != 0x80000000);
         if (y->val >= 0)
         {  sy = +1;
            t = (unsigned int)(+ y->val);
         }
         else
         {  sy = -1;
            t = (unsigned int)(- y->val);
         }
         ey = &dumy;
         ey->d[0] = (unsigned short)t;
         ey->d[1] = (unsigned short)(t >> 16);
         ey->d[2] = ey->d[3] = ey->d[4] = ey->d[5] = 0;
         ey->next = NULL;
      }
      else
      {  sy = y->val;
         xassert(sy == +1 || sy == -1);
         ey = y->ptr;
      }
      /* determine the number of digits of [x] */
      nx = n = 0;
      for (e = ex; e != NULL; e = e->next)
      {  for (k = 0; k <= 5; k++)
         {  n++;
            if (e->d[k])
               nx = n;
         }
      }
      xassert(nx > 0);
      /* determine the number of digits of [y] */
      ny = n = 0;
      for (e = ey; e != NULL; e = e->next)
      {  for (k = 0; k <= 5; k++)
         {  n++;
            if (e->d[k])
               ny = n;
         }
      }
      xassert(ny > 0);
      /* if nx < ny then [q] = 0 and [r] = [x] */
      if (nx < ny)
      {  if (r != NULL)
            mpz_set(r, x);
         if (q != NULL)
            mpz_set_si(q, 0);
         goto done;
      }
      /* we need working array containing at least nx+ny+1 places */
      work = gmp_get_work(nx+ny+1);
      /* load digits of [x] */
      wx = &work[0];
      for (n = 0; n < nx; n++)
         wx[n] = 0;
      for (n = 0, e = ex; e != NULL; e = e->next)
      {  for (k = 0; k <= 5; k++, n++)
            if (e->d[k]) wx[n] = e->d[k];
      }
      /* load digits of [y] */
      wy = &work[nx+1];
      for (n = 0; n < ny; n++)
         wy[n] = 0;
      for (n = 0, e = ey; e != NULL; e = e->next)
      {  for (k = 0; k <= 5; k++, n++)
            if (e->d[k]) wy[n] = e->d[k];
      }
      /* compute quotient and remainder */
      xassert(wy[ny-1] != 0);
      bigdiv(nx-ny, ny, wx, wy);
      /* construct and normalize quotient */
      if (q != NULL)
      {  mpz_set_si(q, 0);
         q->val = sx * sy;
         es = NULL;
         k = 6;
         for (n = ny; n <= nx; n++)
         {  if (k > 5)
            {  e = gmp_get_atom(sizeof(struct mpz_seg));
               e->d[0] = e->d[1] = e->d[2] = 0;
               e->d[3] = e->d[4] = e->d[5] = 0;
               e->next = NULL;
               if (q->ptr == NULL)
                  q->ptr = e;
               else
                  es->next = e;
               es = e;
               k = 0;
            }
            es->d[k++] = wx[n];
         }
         normalize(q);
      }
      /* construct and normalize remainder */
      if (r != NULL)
      {  mpz_set_si(r, 0);
         r->val = sx;
         es = NULL;
         k = 6;
         for (n = 0; n < ny; n++)
         {  if (k > 5)
            {  e = gmp_get_atom(sizeof(struct mpz_seg));
               e->d[0] = e->d[1] = e->d[2] = 0;
               e->d[3] = e->d[4] = e->d[5] = 0;
               e->next = NULL;
               if (r->ptr == NULL)
                  r->ptr = e;
               else
                  es->next = e;
               es = e;
               k = 0;
            }
            es->d[k++] = wx[n];
         }
         normalize(r);
      }
done: return;
}

void mpz_gcd(mpz_t z, mpz_t x, mpz_t y)
{     /* set z to the greatest common divisor of x and y */
      /* in case of arbitrary integers GCD(x, y) = GCD(|x|, |y|), and,
       * in particular, GCD(0, 0) = 0 */
      mpz_t u, v, r;
      mpz_init(u);
      mpz_init(v);
      mpz_init(r);
      mpz_abs(u, x);
      mpz_abs(v, y);
      while (mpz_sgn(v))
      {  mpz_div(NULL, r, u, v);
         mpz_set(u, v);
         mpz_set(v, r);
      }
      mpz_set(z, u);
      mpz_clear(u);
      mpz_clear(v);
      mpz_clear(r);
      return;
}

int mpz_cmp(mpz_t x, mpz_t y)
{     /* compare x and y; return a positive value if x > y, zero if
       * x = y, or a nefative value if x < y */
      static struct mpz_seg zero = { { 0, 0, 0, 0, 0, 0 }, NULL };
      struct mpz_seg dumx, dumy, *ex, *ey;
      int cc, sx, sy, k;
      unsigned int t;
      if (x == y)
      {  cc = 0;
         goto done;
      }
      /* special case when both [x] and [y] are in short format */
      if (x->ptr == NULL && y->ptr == NULL)
      {  int xval = x->val, yval = y->val;
         xassert(xval != 0x80000000 && yval != 0x80000000);
         cc = (xval > yval ? +1 : xval < yval ? -1 : 0);
         goto done;
      }
      /* special case when [x] and [y] have different signs */
      if (x->val > 0 && y->val <= 0 || x->val == 0 && y->val < 0)
      {  cc = +1;
         goto done;
      }
      if (x->val < 0 && y->val >= 0 || x->val == 0 && y->val > 0)
      {  cc = -1;
         goto done;
      }
      /* convert [x] to long format, if necessary */
      if (x->ptr == NULL)
      {  xassert(x->val != 0x80000000);
         if (x->val >= 0)
         {  sx = +1;
            t = (unsigned int)(+ x->val);
         }
         else
         {  sx = -1;
            t = (unsigned int)(- x->val);
         }
         ex = &dumx;
         ex->d[0] = (unsigned short)t;
         ex->d[1] = (unsigned short)(t >> 16);
         ex->d[2] = ex->d[3] = ex->d[4] = ex->d[5] = 0;
         ex->next = NULL;
      }
      else
      {  sx = x->val;
         xassert(sx == +1 || sx == -1);
         ex = x->ptr;
      }
      /* convert [y] to long format, if necessary */
      if (y->ptr == NULL)
      {  xassert(y->val != 0x80000000);
         if (y->val >= 0)
         {  sy = +1;
            t = (unsigned int)(+ y->val);
         }
         else
         {  sy = -1;
            t = (unsigned int)(- y->val);
         }
         ey = &dumy;
         ey->d[0] = (unsigned short)t;
         ey->d[1] = (unsigned short)(t >> 16);
         ey->d[2] = ey->d[3] = ey->d[4] = ey->d[5] = 0;
         ey->next = NULL;
      }
      else
      {  sy = y->val;
         xassert(sy == +1 || sy == -1);
         ey = y->ptr;
      }
      /* main fragment */
      xassert(sx > 0 && sy > 0 || sx < 0 && sy < 0);
      cc = 0;
      for (; ex || ey; ex = ex->next, ey = ey->next)
      {  if (ex == NULL)
            ex = &zero;
         if (ey == NULL)
            ey = &zero;
         for (k = 0; k <= 5; k++)
         {  if (ex->d[k] > ey->d[k])
               cc = +1;
            if (ex->d[k] < ey->d[k])
               cc = -1;
         }
      }
      if (sx < 0) cc = - cc;
done: return cc;
}

int mpz_sgn(mpz_t x)
{     /* return +1 if x > 0, 0 if x = 0, and -1 if x < 0 */
      int s;
      s = (x->val > 0 ? +1 : x->val < 0 ? -1 : 0);
      return s;
}

int mpz_out_str(void *_fp, int base, mpz_t x)
{     /* output x on stream fp, as a string in given base; the base
       * may vary from 2 to 36;
       * return the number of bytes written, or if an error occurred,
       * return 0 */
      FILE *fp = _fp;
      mpz_t b, y, r;
      int n, j, nwr = 0;
      unsigned char *d;
      static char *set = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      if (!(2 <= base && base <= 36))
         xerror("mpz_out_str: base = %d; invalid base\n", base);
      mpz_init(b);
      mpz_set_si(b, base);
      mpz_init(y);
      mpz_init(r);
      /* determine the number of digits */
      mpz_abs(y, x);
      for (n = 0; mpz_sgn(y) != 0; n++)
         mpz_div(y, NULL, y, b);
      if (n == 0) n = 1;
      /* compute the digits */
      d = xmalloc(n);
      mpz_abs(y, x);
      for (j = 0; j < n; j++)
      {  mpz_div(y, r, y, b);
         xassert(0 <= r->val && r->val < base && r->ptr == NULL);
         d[j] = (unsigned char)r->val;
      }
      /* output the integer to the stream */
      if (fp == NULL)
         fp = stdout;
      if (mpz_sgn(x) < 0)
         fputc('-', fp), nwr++;
      for (j = n-1; j >= 0; j--)
         fputc(set[d[j]], fp), nwr++;
      if (ferror(fp))
         nwr = 0;
      mpz_clear(b);
      mpz_clear(y);
      mpz_clear(r);
      xfree(d);
      return nwr;
}

/*--------------------------------------------------------------------*/

mpq_t _mpq_init(void)
{     /* initialize x, and set its value to 0/1 */
      mpq_t x;
      x = gmp_get_atom(sizeof(struct mpq));
      x->p.val = 0;
      x->p.ptr = NULL;
      x->q.val = 1;
      x->q.ptr = NULL;
      return x;
}

void mpq_clear(mpq_t x)
{     /* free the space occupied by x */
      mpz_set_si(&x->p, 0);
      xassert(x->p.ptr == NULL);
      mpz_set_si(&x->q, 0);
      xassert(x->q.ptr == NULL);
      /* free the number descriptor */
      gmp_free_atom(x, sizeof(struct mpq));
      return;
}

void mpq_canonicalize(mpq_t x)
{     /* remove any factors that are common to the numerator and
       * denominator of x, and make the denominator positive */
      mpz_t f;
      xassert(x->q.val != 0);
      if (x->q.val < 0)
      {  mpz_neg(&x->p, &x->p);
         mpz_neg(&x->q, &x->q);
      }
      mpz_init(f);
      mpz_gcd(f, &x->p, &x->q);
      if (!(f->val == 1 && f->ptr == NULL))
      {  mpz_div(&x->p, NULL, &x->p, f);
         mpz_div(&x->q, NULL, &x->q, f);
      }
      mpz_clear(f);
      return;
}

void mpq_set(mpq_t z, mpq_t x)
{     /* set the value of z from x */
      if (z != x)
      {  mpz_set(&z->p, &x->p);
         mpz_set(&z->q, &x->q);
      }
      return;
}

void mpq_set_si(mpq_t x, int p, unsigned int q)
{     /* set the value of x to p/q */
      if (q == 0)
         xerror("mpq_set_si: zero denominator not allowed\n");
      mpz_set_si(&x->p, p);
      xassert(q <= 0x7FFFFFFF);
      mpz_set_si(&x->q, q);
      return;
}

double mpq_get_d(mpq_t x)
{     /* convert x to a double, truncating if necessary */
      int np, nq;
      double p, q;
      p = mpz_get_d_2exp(&np, &x->p);
      q = mpz_get_d_2exp(&nq, &x->q);
      return ldexp(p / q, np - nq);
}

void mpq_set_d(mpq_t x, double val)
{     /* set x to val; there is no rounding, the conversion is exact */
      int s, n, d, j;
      double f;
      mpz_t temp;
      xassert(-DBL_MAX <= val && val <= +DBL_MAX);
      mpq_set_si(x, 0, 1);
      if (val > 0.0)
         s = +1;
      else if (val < 0.0)
         s = -1;
      else
         goto done;
      f = frexp(fabs(val), &n);
      /* |val| = f * 2^n, where 0.5 <= f < 1.0 */
      mpz_init(temp);
      while (f != 0.0)
      {  f *= 16.0, n -= 4;
         d = (int)f;
         xassert(0 <= d && d <= 15);
         f -= (double)d;
         /* x := 16 * x + d */
         mpz_set_si(temp, 16);
         mpz_mul(&x->p, &x->p, temp);
         mpz_set_si(temp, d);
         mpz_add(&x->p, &x->p, temp);
      }
      mpz_clear(temp);
      /* x := x * 2^n */
      if (n > 0)
      {  for (j = 1; j <= n; j++)
            mpz_add(&x->p, &x->p, &x->p);
      }
      else if (n < 0)
      {  for (j = 1; j <= -n; j++)
            mpz_add(&x->q, &x->q, &x->q);
         mpq_canonicalize(x);
      }
      if (s < 0)
         mpq_neg(x, x);
done: return;
}

void mpq_add(mpq_t z, mpq_t x, mpq_t y)
{     /* set z to x + y */
      mpz_t p, q;
      mpz_init(p);
      mpz_init(q);
      mpz_mul(p, &x->p, &y->q);
      mpz_mul(q, &x->q, &y->p);
      mpz_add(p, p, q);
      mpz_mul(q, &x->q, &y->q);
      mpz_set(&z->p, p);
      mpz_set(&z->q, q);
      mpz_clear(p);
      mpz_clear(q);
      mpq_canonicalize(z);
      return;
}

void mpq_sub(mpq_t z, mpq_t x, mpq_t y)
{     /* set z to x - y */
      mpz_t p, q;
      mpz_init(p);
      mpz_init(q);
      mpz_mul(p, &x->p, &y->q);
      mpz_mul(q, &x->q, &y->p);
      mpz_sub(p, p, q);
      mpz_mul(q, &x->q, &y->q);
      mpz_set(&z->p, p);
      mpz_set(&z->q, q);
      mpz_clear(p);
      mpz_clear(q);
      mpq_canonicalize(z);
      return;
}

void mpq_mul(mpq_t z, mpq_t x, mpq_t y)
{     /* set z to x * y */
      mpz_mul(&z->p, &x->p, &y->p);
      mpz_mul(&z->q, &x->q, &y->q);
      mpq_canonicalize(z);
      return;
}

void mpq_div(mpq_t z, mpq_t x, mpq_t y)
{     /* set z to x / y */
      mpz_t p, q;
      if (mpq_sgn(y) == 0)
         xerror("mpq_div: zero divisor not allowed\n");
      mpz_init(p);
      mpz_init(q);
      mpz_mul(p, &x->p, &y->q);
      mpz_mul(q, &x->q, &y->p);
      mpz_set(&z->p, p);
      mpz_set(&z->q, q);
      mpz_clear(p);
      mpz_clear(q);
      mpq_canonicalize(z);
      return;
}

void mpq_neg(mpq_t z, mpq_t x)
{     /* set z to 0 - x */
      mpq_set(z, x);
      mpz_neg(&z->p, &z->p);
      return;
}

void mpq_abs(mpq_t z, mpq_t x)
{     /* set z to the absolute value of x */
      mpq_set(z, x);
      mpz_abs(&z->p, &z->p);
      xassert(mpz_sgn(&x->q) > 0);
      return;
}

int mpq_cmp(mpq_t x, mpq_t y)
{     /* compare x and y; return a positive value if x > y, zero if
       * x = y, or a negative value if x < y */
      mpq_t temp;
      int s;
      mpq_init(temp);
      mpq_sub(temp, x, y);
      s = mpq_sgn(temp);
      mpq_clear(temp);
      return s;
}

int mpq_sgn(mpq_t x)
{     /* return +1 if x > 0, 0 if x = 0, and -1 if x < 0 */
      int s;
      s = mpz_sgn(&x->p);
      xassert(mpz_sgn(&x->q) > 0);
      return s;
}

int mpq_out_str(void *_fp, int base, mpq_t x)
{     /* output x on stream fp, as a string in given base; the base
       * may vary from 2 to 36; output is in the form 'num/den' or if
       * the denominator is 1 then just 'num';
       * if the parameter fp is a null pointer, stdout is assumed;
       * return the number of bytes written, or if an error occurred,
       * return 0 */
      FILE *fp = _fp;
      int nwr;
      if (!(2 <= base && base <= 36))
         xerror("mpq_out_str: base = %d; invalid base\n", base);
      if (fp == NULL)
         fp = stdout;
      nwr = mpz_out_str(fp, base, &x->p);
      if (x->q.val == 1 && x->q.ptr == NULL)
         ;
      else
      {  fputc('/', fp), nwr++;
         nwr += mpz_out_str(fp, base, &x->q);
      }
      if (ferror(fp))
         nwr = 0;
      return nwr;
}

#endif








/***********************************************************************
*  The structure LUX defines LU-factorization of a square matrix A,
*  which is the following quartet:
*
*     [A] = (F, V, P, Q),                                            (1)
*
*  where F and V are such matrices that
*
*     A = F * V,                                                     (2)
*
*  and P and Q are such permutation matrices that the matrix
*
*     L = P * F * inv(P)                                             (3)
*
*  is lower triangular with unity diagonal, and the matrix
*
*     U = P * V * Q                                                  (4)
*
*  is upper triangular. All the matrices have the order n.
*
*  The matrices F and V are stored in row/column-wise sparse format as
*  row and column linked lists of non-zero elements. Unity elements on
*  the main diagonal of the matrix F are not stored. Pivot elements of
*  the matrix V (that correspond to diagonal elements of the matrix U)
*  are also missing from the row and column lists and stored separately
*  in an ordinary array.
*
*  The permutation matrices P and Q are stored as ordinary arrays using
*  both row- and column-like formats.
*
*  The matrices L and U being completely defined by the matrices F, V,
*  P, and Q are not stored explicitly.
*
*  It is easy to show that the factorization (1)-(3) is some version of
*  LU-factorization. Indeed, from (3) and (4) it follows that:
*
*     F = inv(P) * L * P,
*
*     V = inv(P) * U * inv(Q),
*
*  and substitution into (2) gives:
*
*     A = F * V = inv(P) * L * U * inv(Q).
*
*  For more details see the program documentation. */

typedef struct LUX LUX;
typedef struct LUXELM LUXELM;
typedef struct LUXWKA LUXWKA;

struct LUX
{     /* LU-factorization of a square matrix */
      int n;
      /* the order of matrices A, F, V, P, Q */
      DMP *pool;
      /* memory pool for elements of matrices F and V */
      LUXELM **F_row; /* LUXELM *F_row[1+n]; */
      /* F_row[0] is not used;
         F_row[i], 1 <= i <= n, is a pointer to the list of elements in
         i-th row of matrix F (diagonal elements are not stored) */
      LUXELM **F_col; /* LUXELM *F_col[1+n]; */
      /* F_col[0] is not used;
         F_col[j], 1 <= j <= n, is a pointer to the list of elements in
         j-th column of matrix F (diagonal elements are not stored) */
      mpq_t *V_piv; /* mpq_t V_piv[1+n]; */
      /* V_piv[0] is not used;
         V_piv[p], 1 <= p <= n, is a pivot element v[p,q] corresponding
         to a diagonal element u[k,k] of matrix U = P*V*Q (used on k-th
         elimination step, k = 1, 2, ..., n) */
      LUXELM **V_row; /* LUXELM *V_row[1+n]; */
      /* V_row[0] is not used;
         V_row[i], 1 <= i <= n, is a pointer to the list of elements in
         i-th row of matrix V (except pivot elements) */
      LUXELM **V_col; /* LUXELM *V_col[1+n]; */
      /* V_col[0] is not used;
         V_col[j], 1 <= j <= n, is a pointer to the list of elements in
         j-th column of matrix V (except pivot elements) */
      int *P_row; /* int P_row[1+n]; */
      /* P_row[0] is not used;
         P_row[i] = j means that p[i,j] = 1, where p[i,j] is an element
         of permutation matrix P */
      int *P_col; /* int P_col[1+n]; */
      /* P_col[0] is not used;
         P_col[j] = i means that p[i,j] = 1, where p[i,j] is an element
         of permutation matrix P */
      /* if i-th row or column of matrix F is i'-th row or column of
         matrix L = P*F*inv(P), or if i-th row of matrix V is i'-th row
         of matrix U = P*V*Q, then P_row[i'] = i and P_col[i] = i' */
      int *Q_row; /* int Q_row[1+n]; */
      /* Q_row[0] is not used;
         Q_row[i] = j means that q[i,j] = 1, where q[i,j] is an element
         of permutation matrix Q */
      int *Q_col; /* int Q_col[1+n]; */
      /* Q_col[0] is not used;
         Q_col[j] = i means that q[i,j] = 1, where q[i,j] is an element
         of permutation matrix Q */
      /* if j-th column of matrix V is j'-th column of matrix U = P*V*Q,
         then Q_row[j] = j' and Q_col[j'] = j */
      int rank;
      /* the (exact) rank of matrices A and V */
};

struct LUXELM
{     /* element of matrix F or V */
      int i;
      /* row index, 1 <= i <= m */
      int j;
      /* column index, 1 <= j <= n */
      mpq_t val;
      /* numeric (non-zero) element value */
      LUXELM *r_prev;
      /* pointer to previous element in the same row */
      LUXELM *r_next;
      /* pointer to next element in the same row */
      LUXELM *c_prev;
      /* pointer to previous element in the same column */
      LUXELM *c_next;
      /* pointer to next element in the same column */
};

struct LUXWKA
{     /* working area (used only during factorization) */
      /* in order to efficiently implement Markowitz strategy and Duff
         search technique there are two families {R[0], R[1], ..., R[n]}
         and {C[0], C[1], ..., C[n]}; member R[k] is a set of active
         rows of matrix V having k non-zeros, and member C[k] is a set
         of active columns of matrix V having k non-zeros (in the active
         submatrix); each set R[k] and C[k] is implemented as a separate
         doubly linked list */
      int *R_len; /* int R_len[1+n]; */
      /* R_len[0] is not used;
         R_len[i], 1 <= i <= n, is the number of non-zero elements in
         i-th row of matrix V (that is the length of i-th row) */
      int *R_head; /* int R_head[1+n]; */
      /* R_head[k], 0 <= k <= n, is the number of a first row, which is
         active and whose length is k */
      int *R_prev; /* int R_prev[1+n]; */
      /* R_prev[0] is not used;
         R_prev[i], 1 <= i <= n, is the number of a previous row, which
         is active and has the same length as i-th row */
      int *R_next; /* int R_next[1+n]; */
      /* R_prev[0] is not used;
         R_prev[i], 1 <= i <= n, is the number of a next row, which is
         active and has the same length as i-th row */
      int *C_len; /* int C_len[1+n]; */
      /* C_len[0] is not used;
         C_len[j], 1 <= j <= n, is the number of non-zero elements in
         j-th column of the active submatrix of matrix V (that is the
         length of j-th column in the active submatrix) */
      int *C_head; /* int C_head[1+n]; */
      /* C_head[k], 0 <= k <= n, is the number of a first column, which
         is active and whose length is k */
      int *C_prev; /* int C_prev[1+n]; */
      /* C_prev[0] is not used;
         C_prev[j], 1 <= j <= n, is the number of a previous column,
         which is active and has the same length as j-th column */
      int *C_next; /* int C_next[1+n]; */
      /* C_next[0] is not used;
         C_next[j], 1 <= j <= n, is the number of a next column, which
         is active and has the same length as j-th column */
};

#define lux_create _glp_lux_create
LUX *lux_create(int n);
/* create LU-factorization */

#define lux_decomp _glp_lux_decomp
int lux_decomp(LUX *lux, int (*col)(void *info, int j, int ind[],
      mpq_t val[]), void *info);
/* compute LU-factorization */

#define lux_f_solve _glp_lux_f_solve
void lux_f_solve(LUX *lux, int tr, mpq_t x[]);
/* solve system F*x = b or F'*x = b */

#define lux_v_solve _glp_lux_v_solve
void lux_v_solve(LUX *lux, int tr, mpq_t x[]);
/* solve system V*x = b or V'*x = b */

#define lux_solve _glp_lux_solve
void lux_solve(LUX *lux, int tr, mpq_t x[]);
/* solve system A*x = b or A'*x = b */

#define lux_delete _glp_lux_delete
void lux_delete(LUX *lux);
/* delete LU-factorization */


#define xfault xerror
#define dmp_create_poolx(size) dmp_create_pool()

/***********************************************************************
*  lux_create - create LU-factorization
*
*  SYNOPSIS
*
*  #include "lux.h"
*  LUX *lux_create(int n);
*
*  DESCRIPTION
*
*  The routine lux_create creates LU-factorization data structure for
*  a matrix of the order n. Initially the factorization corresponds to
*  the unity matrix (F = V = P = Q = I, so A = I).
*
*  RETURNS
*
*  The routine returns a pointer to the created LU-factorization data
*  structure, which represents the unity matrix of the order n. */

LUX *lux_create(int n)
{     LUX *lux;
      int k;
      if (n < 1)
         xfault("lux_create: n = %d; invalid parameter\n", n);
      lux = xmalloc(sizeof(LUX));
      lux->n = n;
      lux->pool = dmp_create_poolx(sizeof(LUXELM));
      lux->F_row = xcalloc(1+n, sizeof(LUXELM *));
      lux->F_col = xcalloc(1+n, sizeof(LUXELM *));
      lux->V_piv = xcalloc(1+n, sizeof(mpq_t));
      lux->V_row = xcalloc(1+n, sizeof(LUXELM *));
      lux->V_col = xcalloc(1+n, sizeof(LUXELM *));
      lux->P_row = xcalloc(1+n, sizeof(int));
      lux->P_col = xcalloc(1+n, sizeof(int));
      lux->Q_row = xcalloc(1+n, sizeof(int));
      lux->Q_col = xcalloc(1+n, sizeof(int));
      for (k = 1; k <= n; k++)
      {  lux->F_row[k] = lux->F_col[k] = NULL;
         mpq_init(lux->V_piv[k]);
         mpq_set_si(lux->V_piv[k], 1, 1);
         lux->V_row[k] = lux->V_col[k] = NULL;
         lux->P_row[k] = lux->P_col[k] = k;
         lux->Q_row[k] = lux->Q_col[k] = k;
      }
      lux->rank = n;
      return lux;
}

/***********************************************************************
*  initialize - initialize LU-factorization data structures
*
*  This routine initializes data structures for subsequent computing
*  the LU-factorization of a given matrix A, which is specified by the
*  formal routine col. On exit V = A and F = P = Q = I, where I is the
*  unity matrix. */

static void initialize(LUX *lux, int (*col)(void *info, int j,
      int ind[], mpq_t val[]), void *info, LUXWKA *wka)
{     int n = lux->n;
      DMP *pool = lux->pool;
      LUXELM **F_row = lux->F_row;
      LUXELM **F_col = lux->F_col;
      mpq_t *V_piv = lux->V_piv;
      LUXELM **V_row = lux->V_row;
      LUXELM **V_col = lux->V_col;
      int *P_row = lux->P_row;
      int *P_col = lux->P_col;
      int *Q_row = lux->Q_row;
      int *Q_col = lux->Q_col;
      int *R_len = wka->R_len;
      int *R_head = wka->R_head;
      int *R_prev = wka->R_prev;
      int *R_next = wka->R_next;
      int *C_len = wka->C_len;
      int *C_head = wka->C_head;
      int *C_prev = wka->C_prev;
      int *C_next = wka->C_next;
      LUXELM *fij, *vij;
      int i, j, k, len, *ind;
      mpq_t *val;
      /* F := I */
      for (i = 1; i <= n; i++)
      {  while (F_row[i] != NULL)
         {  fij = F_row[i], F_row[i] = fij->r_next;
            mpq_clear(fij->val);
            dmp_free_atom(pool, fij, sizeof(LUXELM));
         }
      }
      for (j = 1; j <= n; j++) F_col[j] = NULL;
      /* V := 0 */
      for (k = 1; k <= n; k++) mpq_set_si(V_piv[k], 0, 1);
      for (i = 1; i <= n; i++)
      {  while (V_row[i] != NULL)
         {  vij = V_row[i], V_row[i] = vij->r_next;
            mpq_clear(vij->val);
            dmp_free_atom(pool, vij, sizeof(LUXELM));
         }
      }
      for (j = 1; j <= n; j++) V_col[j] = NULL;
      /* V := A */
      ind = xcalloc(1+n, sizeof(int));
      val = xcalloc(1+n, sizeof(mpq_t));
      for (k = 1; k <= n; k++) mpq_init(val[k]);
      for (j = 1; j <= n; j++)
      {  /* obtain j-th column of matrix A */
         len = col(info, j, ind, val);
         if (!(0 <= len && len <= n))
            xfault("lux_decomp: j = %d: len = %d; invalid column length"
               "\n", j, len);
         /* copy elements of j-th column to matrix V */
         for (k = 1; k <= len; k++)
         {  /* get row index of a[i,j] */
            i = ind[k];
            if (!(1 <= i && i <= n))
               xfault("lux_decomp: j = %d: i = %d; row index out of ran"
                  "ge\n", j, i);
            /* check for duplicate indices */
            if (V_row[i] != NULL && V_row[i]->j == j)
               xfault("lux_decomp: j = %d: i = %d; duplicate row indice"
                  "s not allowed\n", j, i);
            /* check for zero value */
            if (mpq_sgn(val[k]) == 0)
               xfault("lux_decomp: j = %d: i = %d; zero elements not al"
                  "lowed\n", j, i);
            /* add new element v[i,j] = a[i,j] to V */
            vij = dmp_get_atom(pool, sizeof(LUXELM));
            vij->i = i, vij->j = j;
            mpq_init(vij->val);
            mpq_set(vij->val, val[k]);
            vij->r_prev = NULL;
            vij->r_next = V_row[i];
            vij->c_prev = NULL;
            vij->c_next = V_col[j];
            if (vij->r_next != NULL) vij->r_next->r_prev = vij;
            if (vij->c_next != NULL) vij->c_next->c_prev = vij;
            V_row[i] = V_col[j] = vij;
         }
      }
      xfree(ind);
      for (k = 1; k <= n; k++) mpq_clear(val[k]);
      xfree(val);
      /* P := Q := I */
      for (k = 1; k <= n; k++)
         P_row[k] = P_col[k] = Q_row[k] = Q_col[k] = k;
      /* the rank of A and V is not determined yet */
      lux->rank = -1;
      /* initially the entire matrix V is active */
      /* determine its row lengths */
      for (i = 1; i <= n; i++)
      {  len = 0;
         for (vij = V_row[i]; vij != NULL; vij = vij->r_next) len++;
         R_len[i] = len;
      }
      /* build linked lists of active rows */
      for (len = 0; len <= n; len++) R_head[len] = 0;
      for (i = 1; i <= n; i++)
      {  len = R_len[i];
         R_prev[i] = 0;
         R_next[i] = R_head[len];
         if (R_next[i] != 0) R_prev[R_next[i]] = i;
         R_head[len] = i;
      }
      /* determine its column lengths */
      for (j = 1; j <= n; j++)
      {  len = 0;
         for (vij = V_col[j]; vij != NULL; vij = vij->c_next) len++;
         C_len[j] = len;
      }
      /* build linked lists of active columns */
      for (len = 0; len <= n; len++) C_head[len] = 0;
      for (j = 1; j <= n; j++)
      {  len = C_len[j];
         C_prev[j] = 0;
         C_next[j] = C_head[len];
         if (C_next[j] != 0) C_prev[C_next[j]] = j;
         C_head[len] = j;
      }
      return;
}

/***********************************************************************
*  find_pivot - choose a pivot element
*
*  This routine chooses a pivot element v[p,q] in the active submatrix
*  of matrix U = P*V*Q.
*
*  It is assumed that on entry the matrix U has the following partially
*  triangularized form:
*
*        1       k         n
*     1  x x x x x x x x x x
*        . x x x x x x x x x
*        . . x x x x x x x x
*        . . . x x x x x x x
*     k  . . . . * * * * * *
*        . . . . * * * * * *
*        . . . . * * * * * *
*        . . . . * * * * * *
*        . . . . * * * * * *
*     n  . . . . * * * * * *
*
*  where rows and columns k, k+1, ..., n belong to the active submatrix
*  (elements of the active submatrix are marked by '*').
*
*  Since the matrix U = P*V*Q is not stored, the routine works with the
*  matrix V. It is assumed that the row-wise representation corresponds
*  to the matrix V, but the column-wise representation corresponds to
*  the active submatrix of the matrix V, i.e. elements of the matrix V,
*  which does not belong to the active submatrix, are missing from the
*  column linked lists. It is also assumed that each active row of the
*  matrix V is in the set R[len], where len is number of non-zeros in
*  the row, and each active column of the matrix V is in the set C[len],
*  where len is number of non-zeros in the column (in the latter case
*  only elements of the active submatrix are counted; such elements are
*  marked by '*' on the figure above).
*
*  Due to exact arithmetic any non-zero element of the active submatrix
*  can be chosen as a pivot. However, to keep sparsity of the matrix V
*  the routine uses Markowitz strategy, trying to choose such element
*  v[p,q], which has smallest Markowitz cost (nr[p]-1) * (nc[q]-1),
*  where nr[p] and nc[q] are the number of non-zero elements, resp., in
*  p-th row and in q-th column of the active submatrix.
*
*  In order to reduce the search, i.e. not to walk through all elements
*  of the active submatrix, the routine exploits a technique proposed by
*  I.Duff. This technique is based on using the sets R[len] and C[len]
*  of active rows and columns.
*
*  On exit the routine returns a pointer to a pivot v[p,q] chosen, or
*  NULL, if the active submatrix is empty. */

static LUXELM *find_pivot(LUX *lux, LUXWKA *wka)
{     int n = lux->n;
      LUXELM **V_row = lux->V_row;
      LUXELM **V_col = lux->V_col;
      int *R_len = wka->R_len;
      int *R_head = wka->R_head;
      int *R_next = wka->R_next;
      int *C_len = wka->C_len;
      int *C_head = wka->C_head;
      int *C_next = wka->C_next;
      LUXELM *piv, *some, *vij;
      int i, j, len, min_len, ncand, piv_lim = 5;
      double best, cost;
      /* nothing is chosen so far */
      piv = NULL, best = DBL_MAX, ncand = 0;
      /* if in the active submatrix there is a column that has the only
         non-zero (column singleton), choose it as a pivot */
      j = C_head[1];
      if (j != 0)
      {  xassert(C_len[j] == 1);
         piv = V_col[j];
         xassert(piv != NULL && piv->c_next == NULL);
         goto done;
      }
      /* if in the active submatrix there is a row that has the only
         non-zero (row singleton), choose it as a pivot */
      i = R_head[1];
      if (i != 0)
      {  xassert(R_len[i] == 1);
         piv = V_row[i];
         xassert(piv != NULL && piv->r_next == NULL);
         goto done;
      }
      /* there are no singletons in the active submatrix; walk through
         other non-empty rows and columns */
      for (len = 2; len <= n; len++)
      {  /* consider active columns having len non-zeros */
         for (j = C_head[len]; j != 0; j = C_next[j])
         {  /* j-th column has len non-zeros */
            /* find an element in the row of minimal length */
            some = NULL, min_len = INT_MAX;
            for (vij = V_col[j]; vij != NULL; vij = vij->c_next)
            {  if (min_len > R_len[vij->i])
                  some = vij, min_len = R_len[vij->i];
               /* if Markowitz cost of this element is not greater than
                  (len-1)**2, it can be chosen right now; this heuristic
                  reduces the search and works well in many cases */
               if (min_len <= len)
               {  piv = some;
                  goto done;
               }
            }
            /* j-th column has been scanned */
            /* the minimal element found is a next pivot candidate */
            xassert(some != NULL);
            ncand++;
            /* compute its Markowitz cost */
            cost = (double)(min_len - 1) * (double)(len - 1);
            /* choose between the current candidate and this element */
            if (cost < best) piv = some, best = cost;
            /* if piv_lim candidates have been considered, there is a
               doubt that a much better candidate exists; therefore it
               is the time to terminate the search */
            if (ncand == piv_lim) goto done;
         }
         /* now consider active rows having len non-zeros */
         for (i = R_head[len]; i != 0; i = R_next[i])
         {  /* i-th row has len non-zeros */
            /* find an element in the column of minimal length */
            some = NULL, min_len = INT_MAX;
            for (vij = V_row[i]; vij != NULL; vij = vij->r_next)
            {  if (min_len > C_len[vij->j])
                  some = vij, min_len = C_len[vij->j];
               /* if Markowitz cost of this element is not greater than
                  (len-1)**2, it can be chosen right now; this heuristic
                  reduces the search and works well in many cases */
               if (min_len <= len)
               {  piv = some;
                  goto done;
               }
            }
            /* i-th row has been scanned */
            /* the minimal element found is a next pivot candidate */
            xassert(some != NULL);
            ncand++;
            /* compute its Markowitz cost */
            cost = (double)(len - 1) * (double)(min_len - 1);
            /* choose between the current candidate and this element */
            if (cost < best) piv = some, best = cost;
            /* if piv_lim candidates have been considered, there is a
               doubt that a much better candidate exists; therefore it
               is the time to terminate the search */
            if (ncand == piv_lim) goto done;
         }
      }
done: /* bring the pivot v[p,q] to the factorizing routine */
      return piv;
}

/***********************************************************************
*  eliminate - perform gaussian elimination
*
*  This routine performs elementary gaussian transformations in order
*  to eliminate subdiagonal elements in the k-th column of the matrix
*  U = P*V*Q using the pivot element u[k,k], where k is the number of
*  the current elimination step.
*
*  The parameter piv specifies the pivot element v[p,q] = u[k,k].
*
*  Each time when the routine applies the elementary transformation to
*  a non-pivot row of the matrix V, it stores the corresponding element
*  to the matrix F in order to keep the main equality A = F*V.
*
*  The routine assumes that on entry the matrices L = P*F*inv(P) and
*  U = P*V*Q are the following:
*
*        1       k                  1       k         n
*     1  1 . . . . . . . . .     1  x x x x x x x x x x
*        x 1 . . . . . . . .        . x x x x x x x x x
*        x x 1 . . . . . . .        . . x x x x x x x x
*        x x x 1 . . . . . .        . . . x x x x x x x
*     k  x x x x 1 . . . . .     k  . . . . * * * * * *
*        x x x x _ 1 . . . .        . . . . # * * * * *
*        x x x x _ . 1 . . .        . . . . # * * * * *
*        x x x x _ . . 1 . .        . . . . # * * * * *
*        x x x x _ . . . 1 .        . . . . # * * * * *
*     n  x x x x _ . . . . 1     n  . . . . # * * * * *
*
*             matrix L                   matrix U
*
*  where rows and columns of the matrix U with numbers k, k+1, ..., n
*  form the active submatrix (eliminated elements are marked by '#' and
*  other elements of the active submatrix are marked by '*'). Note that
*  each eliminated non-zero element u[i,k] of the matrix U gives the
*  corresponding element l[i,k] of the matrix L (marked by '_').
*
*  Actually all operations are performed on the matrix V. Should note
*  that the row-wise representation corresponds to the matrix V, but the
*  column-wise representation corresponds to the active submatrix of the
*  matrix V, i.e. elements of the matrix V, which doesn't belong to the
*  active submatrix, are missing from the column linked lists.
*
*  Let u[k,k] = v[p,q] be the pivot. In order to eliminate subdiagonal
*  elements u[i',k] = v[i,q], i' = k+1, k+2, ..., n, the routine applies
*  the following elementary gaussian transformations:
*
*     (i-th row of V) := (i-th row of V) - f[i,p] * (p-th row of V),
*
*  where f[i,p] = v[i,q] / v[p,q] is a gaussian multiplier.
*
*  Additionally, in order to keep the main equality A = F*V, each time
*  when the routine applies the transformation to i-th row of the matrix
*  V, it also adds f[i,p] as a new element to the matrix F.
*
*  IMPORTANT: On entry the working arrays flag and work should contain
*  zeros. This status is provided by the routine on exit. */

static void eliminate(LUX *lux, LUXWKA *wka, LUXELM *piv, int flag[],
      mpq_t work[])
{     DMP *pool = lux->pool;
      LUXELM **F_row = lux->F_row;
      LUXELM **F_col = lux->F_col;
      mpq_t *V_piv = lux->V_piv;
      LUXELM **V_row = lux->V_row;
      LUXELM **V_col = lux->V_col;
      int *R_len = wka->R_len;
      int *R_head = wka->R_head;
      int *R_prev = wka->R_prev;
      int *R_next = wka->R_next;
      int *C_len = wka->C_len;
      int *C_head = wka->C_head;
      int *C_prev = wka->C_prev;
      int *C_next = wka->C_next;
      LUXELM *fip, *vij, *vpj, *viq, *next;
      mpq_t temp;
      int i, j, p, q;
      mpq_init(temp);
      /* determine row and column indices of the pivot v[p,q] */
      xassert(piv != NULL);
      p = piv->i, q = piv->j;
      /* remove p-th (pivot) row from the active set; it will never
         return there */
      if (R_prev[p] == 0)
         R_head[R_len[p]] = R_next[p];
      else
         R_next[R_prev[p]] = R_next[p];
      if (R_next[p] == 0)
         ;
      else
         R_prev[R_next[p]] = R_prev[p];
      /* remove q-th (pivot) column from the active set; it will never
         return there */
      if (C_prev[q] == 0)
         C_head[C_len[q]] = C_next[q];
      else
         C_next[C_prev[q]] = C_next[q];
      if (C_next[q] == 0)
         ;
      else
         C_prev[C_next[q]] = C_prev[q];
      /* store the pivot value in a separate array */
      mpq_set(V_piv[p], piv->val);
      /* remove the pivot from p-th row */
      if (piv->r_prev == NULL)
         V_row[p] = piv->r_next;
      else
         piv->r_prev->r_next = piv->r_next;
      if (piv->r_next == NULL)
         ;
      else
         piv->r_next->r_prev = piv->r_prev;
      R_len[p]--;
      /* remove the pivot from q-th column */
      if (piv->c_prev == NULL)
         V_col[q] = piv->c_next;
      else
         piv->c_prev->c_next = piv->c_next;
      if (piv->c_next == NULL)
         ;
      else
         piv->c_next->c_prev = piv->c_prev;
      C_len[q]--;
      /* free the space occupied by the pivot */
      mpq_clear(piv->val);
      dmp_free_atom(pool, piv, sizeof(LUXELM));
      /* walk through p-th (pivot) row, which already does not contain
         the pivot v[p,q], and do the following... */
      for (vpj = V_row[p]; vpj != NULL; vpj = vpj->r_next)
      {  /* get column index of v[p,j] */
         j = vpj->j;
         /* store v[p,j] in the working array */
         flag[j] = 1;
         mpq_set(work[j], vpj->val);
         /* remove j-th column from the active set; it will return there
            later with a new length */
         if (C_prev[j] == 0)
            C_head[C_len[j]] = C_next[j];
         else
            C_next[C_prev[j]] = C_next[j];
         if (C_next[j] == 0)
            ;
         else
            C_prev[C_next[j]] = C_prev[j];
         /* v[p,j] leaves the active submatrix, so remove it from j-th
            column; however, v[p,j] is kept in p-th row */
         if (vpj->c_prev == NULL)
            V_col[j] = vpj->c_next;
         else
            vpj->c_prev->c_next = vpj->c_next;
         if (vpj->c_next == NULL)
            ;
         else
            vpj->c_next->c_prev = vpj->c_prev;
         C_len[j]--;
      }
      /* now walk through q-th (pivot) column, which already does not
         contain the pivot v[p,q], and perform gaussian elimination */
      while (V_col[q] != NULL)
      {  /* element v[i,q] has to be eliminated */
         viq = V_col[q];
         /* get row index of v[i,q] */
         i = viq->i;
         /* remove i-th row from the active set; later it will return
            there with a new length */
         if (R_prev[i] == 0)
            R_head[R_len[i]] = R_next[i];
         else
            R_next[R_prev[i]] = R_next[i];
         if (R_next[i] == 0)
            ;
         else
            R_prev[R_next[i]] = R_prev[i];
         /* compute gaussian multiplier f[i,p] = v[i,q] / v[p,q] and
            store it in the matrix F */
         fip = dmp_get_atom(pool, sizeof(LUXELM));
         fip->i = i, fip->j = p;
         mpq_init(fip->val);
         mpq_div(fip->val, viq->val, V_piv[p]);
         fip->r_prev = NULL;
         fip->r_next = F_row[i];
         fip->c_prev = NULL;
         fip->c_next = F_col[p];
         if (fip->r_next != NULL) fip->r_next->r_prev = fip;
         if (fip->c_next != NULL) fip->c_next->c_prev = fip;
         F_row[i] = F_col[p] = fip;
         /* v[i,q] has to be eliminated, so remove it from i-th row */
         if (viq->r_prev == NULL)
            V_row[i] = viq->r_next;
         else
            viq->r_prev->r_next = viq->r_next;
         if (viq->r_next == NULL)
            ;
         else
            viq->r_next->r_prev = viq->r_prev;
         R_len[i]--;
         /* and also from q-th column */
         V_col[q] = viq->c_next;
         C_len[q]--;
         /* free the space occupied by v[i,q] */
         mpq_clear(viq->val);
         dmp_free_atom(pool, viq, sizeof(LUXELM));
         /* perform gaussian transformation:
            (i-th row) := (i-th row) - f[i,p] * (p-th row)
            note that now p-th row, which is in the working array,
            does not contain the pivot v[p,q], and i-th row does not
            contain the element v[i,q] to be eliminated */
         /* walk through i-th row and transform existing non-zero
            elements */
         for (vij = V_row[i]; vij != NULL; vij = next)
         {  next = vij->r_next;
            /* get column index of v[i,j] */
            j = vij->j;
            /* v[i,j] := v[i,j] - f[i,p] * v[p,j] */
            if (flag[j])
            {  /* v[p,j] != 0 */
               flag[j] = 0;
               mpq_mul(temp, fip->val, work[j]);
               mpq_sub(vij->val, vij->val, temp);
               if (mpq_sgn(vij->val) == 0)
               {  /* new v[i,j] is zero, so remove it from the active
                     submatrix */
                  /* remove v[i,j] from i-th row */
                  if (vij->r_prev == NULL)
                     V_row[i] = vij->r_next;
                  else
                     vij->r_prev->r_next = vij->r_next;
                  if (vij->r_next == NULL)
                     ;
                  else
                     vij->r_next->r_prev = vij->r_prev;
                  R_len[i]--;
                  /* remove v[i,j] from j-th column */
                  if (vij->c_prev == NULL)
                     V_col[j] = vij->c_next;
                  else
                     vij->c_prev->c_next = vij->c_next;
                  if (vij->c_next == NULL)
                     ;
                  else
                     vij->c_next->c_prev = vij->c_prev;
                  C_len[j]--;
                  /* free the space occupied by v[i,j] */
                  mpq_clear(vij->val);
                  dmp_free_atom(pool, vij, sizeof(LUXELM));
               }
            }
         }
         /* now flag is the pattern of the set v[p,*] \ v[i,*] */
         /* walk through p-th (pivot) row and create new elements in
            i-th row, which appear due to fill-in */
         for (vpj = V_row[p]; vpj != NULL; vpj = vpj->r_next)
         {  j = vpj->j;
            if (flag[j])
            {  /* create new non-zero v[i,j] = 0 - f[i,p] * v[p,j] and
                  add it to i-th row and j-th column */
               vij = dmp_get_atom(pool, sizeof(LUXELM));
               vij->i = i, vij->j = j;
               mpq_init(vij->val);
               mpq_mul(vij->val, fip->val, work[j]);
               mpq_neg(vij->val, vij->val);
               vij->r_prev = NULL;
               vij->r_next = V_row[i];
               vij->c_prev = NULL;
               vij->c_next = V_col[j];
               if (vij->r_next != NULL) vij->r_next->r_prev = vij;
               if (vij->c_next != NULL) vij->c_next->c_prev = vij;
               V_row[i] = V_col[j] = vij;
               R_len[i]++, C_len[j]++;
            }
            else
            {  /* there is no fill-in, because v[i,j] already exists in
                  i-th row; restore the flag, which was reset before */
               flag[j] = 1;
            }
         }
         /* now i-th row has been completely transformed and can return
            to the active set with a new length */
         R_prev[i] = 0;
         R_next[i] = R_head[R_len[i]];
         if (R_next[i] != 0) R_prev[R_next[i]] = i;
         R_head[R_len[i]] = i;
      }
      /* at this point q-th (pivot) column must be empty */
      xassert(C_len[q] == 0);
      /* walk through p-th (pivot) row again and do the following... */
      for (vpj = V_row[p]; vpj != NULL; vpj = vpj->r_next)
      {  /* get column index of v[p,j] */
         j = vpj->j;
         /* erase v[p,j] from the working array */
         flag[j] = 0;
         mpq_set_si(work[j], 0, 1);
         /* now j-th column has been completely transformed, so it can
            return to the active list with a new length */
         C_prev[j] = 0;
         C_next[j] = C_head[C_len[j]];
         if (C_next[j] != 0) C_prev[C_next[j]] = j;
         C_head[C_len[j]] = j;
      }
      mpq_clear(temp);
      /* return to the factorizing routine */
      return;
}

/***********************************************************************
*  lux_decomp - compute LU-factorization
*
*  SYNOPSIS
*
*  #include "lux.h"
*  int lux_decomp(LUX *lux, int (*col)(void *info, int j, int ind[],
*     mpq_t val[]), void *info);
*
*  DESCRIPTION
*
*  The routine lux_decomp computes LU-factorization of a given square
*  matrix A.
*
*  The parameter lux specifies LU-factorization data structure built by
*  means of the routine lux_create.
*
*  The formal routine col specifies the original matrix A. In order to
*  obtain j-th column of the matrix A the routine lux_decomp calls the
*  routine col with the parameter j (1 <= j <= n, where n is the order
*  of A). In response the routine col should store row indices and
*  numerical values of non-zero elements of j-th column of A to the
*  locations ind[1], ..., ind[len] and val[1], ..., val[len], resp.,
*  where len is the number of non-zeros in j-th column, which should be
*  returned on exit. Neiter zero nor duplicate elements are allowed.
*
*  The parameter info is a transit pointer passed to the formal routine
*  col; it can be used for various purposes.
*
*  RETURNS
*
*  The routine lux_decomp returns the singularity flag. Zero flag means
*  that the original matrix A is non-singular while non-zero flag means
*  that A is (exactly!) singular.
*
*  Note that LU-factorization is valid in both cases, however, in case
*  of singularity some rows of the matrix V (including pivot elements)
*  will be empty.
*
*  REPAIRING SINGULAR MATRIX
*
*  If the routine lux_decomp returns non-zero flag, it provides all
*  necessary information that can be used for "repairing" the matrix A,
*  where "repairing" means replacing linearly dependent columns of the
*  matrix A by appropriate columns of the unity matrix. This feature is
*  needed when the routine lux_decomp is used for reinverting the basis
*  matrix within the simplex method procedure.
*
*  On exit linearly dependent columns of the matrix U have the numbers
*  rank+1, rank+2, ..., n, where rank is the exact rank of the matrix A
*  stored by the routine to the member lux->rank. The correspondence
*  between columns of A and U is the same as between columns of V and U.
*  Thus, linearly dependent columns of the matrix A have the numbers
*  Q_col[rank+1], Q_col[rank+2], ..., Q_col[n], where Q_col is an array
*  representing the permutation matrix Q in column-like format. It is
*  understood that each j-th linearly dependent column of the matrix U
*  should be replaced by the unity vector, where all elements are zero
*  except the unity diagonal element u[j,j]. On the other hand j-th row
*  of the matrix U corresponds to the row of the matrix V (and therefore
*  of the matrix A) with the number P_row[j], where P_row is an array
*  representing the permutation matrix P in row-like format. Thus, each
*  j-th linearly dependent column of the matrix U should be replaced by
*  a column of the unity matrix with the number P_row[j].
*
*  The code that repairs the matrix A may look like follows:
*
*     for (j = rank+1; j <= n; j++)
*     {  replace column Q_col[j] of the matrix A by column P_row[j] of
*        the unity matrix;
*     }
*
*  where rank, P_row, and Q_col are members of the structure LUX. */

int lux_decomp(LUX *lux, int (*col)(void *info, int j, int ind[],
      mpq_t val[]), void *info)
{     int n = lux->n;
      LUXELM **V_row = lux->V_row;
      LUXELM **V_col = lux->V_col;
      int *P_row = lux->P_row;
      int *P_col = lux->P_col;
      int *Q_row = lux->Q_row;
      int *Q_col = lux->Q_col;
      LUXELM *piv, *vij;
      LUXWKA *wka;
      int i, j, k, p, q, t, *flag;
      mpq_t *work;
      /* allocate working area */
      wka = xmalloc(sizeof(LUXWKA));
      wka->R_len = xcalloc(1+n, sizeof(int));
      wka->R_head = xcalloc(1+n, sizeof(int));
      wka->R_prev = xcalloc(1+n, sizeof(int));
      wka->R_next = xcalloc(1+n, sizeof(int));
      wka->C_len = xcalloc(1+n, sizeof(int));
      wka->C_head = xcalloc(1+n, sizeof(int));
      wka->C_prev = xcalloc(1+n, sizeof(int));
      wka->C_next = xcalloc(1+n, sizeof(int));
      /* initialize LU-factorization data structures */
      initialize(lux, col, info, wka);
      /* allocate working arrays */
      flag = xcalloc(1+n, sizeof(int));
      work = xcalloc(1+n, sizeof(mpq_t));
      for (k = 1; k <= n; k++)
      {  flag[k] = 0;
         mpq_init(work[k]);
      }
      /* main elimination loop */
      for (k = 1; k <= n; k++)
      {  /* choose a pivot element v[p,q] */
         piv = find_pivot(lux, wka);
         if (piv == NULL)
         {  /* no pivot can be chosen, because the active submatrix is
               empty */
            break;
         }
         /* determine row and column indices of the pivot element */
         p = piv->i, q = piv->j;
         /* let v[p,q] correspond to u[i',j']; permute k-th and i'-th
            rows and k-th and j'-th columns of the matrix U = P*V*Q to
            move the element u[i',j'] to the position u[k,k] */
         i = P_col[p], j = Q_row[q];
         xassert(k <= i && i <= n && k <= j && j <= n);
         /* permute k-th and i-th rows of the matrix U */
         t = P_row[k];
         P_row[i] = t, P_col[t] = i;
         P_row[k] = p, P_col[p] = k;
         /* permute k-th and j-th columns of the matrix U */
         t = Q_col[k];
         Q_col[j] = t, Q_row[t] = j;
         Q_col[k] = q, Q_row[q] = k;
         /* eliminate subdiagonal elements of k-th column of the matrix
            U = P*V*Q using the pivot element u[k,k] = v[p,q] */
         eliminate(lux, wka, piv, flag, work);
      }
      /* determine the rank of A (and V) */
      lux->rank = k - 1;
      /* free working arrays */
      xfree(flag);
      for (k = 1; k <= n; k++) mpq_clear(work[k]);
      xfree(work);
      /* build column lists of the matrix V using its row lists */
      for (j = 1; j <= n; j++)
         xassert(V_col[j] == NULL);
      for (i = 1; i <= n; i++)
      {  for (vij = V_row[i]; vij != NULL; vij = vij->r_next)
         {  j = vij->j;
            vij->c_prev = NULL;
            vij->c_next = V_col[j];
            if (vij->c_next != NULL) vij->c_next->c_prev = vij;
            V_col[j] = vij;
         }
      }
      /* free working area */
      xfree(wka->R_len);
      xfree(wka->R_head);
      xfree(wka->R_prev);
      xfree(wka->R_next);
      xfree(wka->C_len);
      xfree(wka->C_head);
      xfree(wka->C_prev);
      xfree(wka->C_next);
      xfree(wka);
      /* return to the calling program */
      return (lux->rank < n);
}

/***********************************************************************
*  lux_f_solve - solve system F*x = b or F'*x = b
*
*  SYNOPSIS
*
*  #include "lux.h"
*  void lux_f_solve(LUX *lux, int tr, mpq_t x[]);
*
*  DESCRIPTION
*
*  The routine lux_f_solve solves either the system F*x = b (if the
*  flag tr is zero) or the system F'*x = b (if the flag tr is non-zero),
*  where the matrix F is a component of LU-factorization specified by
*  the parameter lux, F' is a matrix transposed to F.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix F. On exit this array will contain elements of the solution
*  vector x in the same locations. */

void lux_f_solve(LUX *lux, int tr, mpq_t x[])
{     int n = lux->n;
      LUXELM **F_row = lux->F_row;
      LUXELM **F_col = lux->F_col;
      int *P_row = lux->P_row;
      LUXELM *fik, *fkj;
      int i, j, k;
      mpq_t temp;
      mpq_init(temp);
      if (!tr)
      {  /* solve the system F*x = b */
         for (j = 1; j <= n; j++)
         {  k = P_row[j];
            if (mpq_sgn(x[k]) != 0)
            {  for (fik = F_col[k]; fik != NULL; fik = fik->c_next)
               {  mpq_mul(temp, fik->val, x[k]);
                  mpq_sub(x[fik->i], x[fik->i], temp);
               }
            }
         }
      }
      else
      {  /* solve the system F'*x = b */
         for (i = n; i >= 1; i--)
         {  k = P_row[i];
            if (mpq_sgn(x[k]) != 0)
            {  for (fkj = F_row[k]; fkj != NULL; fkj = fkj->r_next)
               {  mpq_mul(temp, fkj->val, x[k]);
                  mpq_sub(x[fkj->j], x[fkj->j], temp);
               }
            }
         }
      }
      mpq_clear(temp);
      return;
}

/***********************************************************************
*  lux_v_solve - solve system V*x = b or V'*x = b
*
*  SYNOPSIS
*
*  #include "lux.h"
*  void lux_v_solve(LUX *lux, int tr, double x[]);
*
*  DESCRIPTION
*
*  The routine lux_v_solve solves either the system V*x = b (if the
*  flag tr is zero) or the system V'*x = b (if the flag tr is non-zero),
*  where the matrix V is a component of LU-factorization specified by
*  the parameter lux, V' is a matrix transposed to V.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix V. On exit this array will contain elements of the solution
*  vector x in the same locations. */

void lux_v_solve(LUX *lux, int tr, mpq_t x[])
{     int n = lux->n;
      mpq_t *V_piv = lux->V_piv;
      LUXELM **V_row = lux->V_row;
      LUXELM **V_col = lux->V_col;
      int *P_row = lux->P_row;
      int *Q_col = lux->Q_col;
      LUXELM *vij;
      int i, j, k;
      mpq_t *b, temp;
      b = xcalloc(1+n, sizeof(mpq_t));
      for (k = 1; k <= n; k++)
         mpq_init(b[k]), mpq_set(b[k], x[k]), mpq_set_si(x[k], 0, 1);
      mpq_init(temp);
      if (!tr)
      {  /* solve the system V*x = b */
         for (k = n; k >= 1; k--)
         {  i = P_row[k], j = Q_col[k];
            if (mpq_sgn(b[i]) != 0)
            {  mpq_set(x[j], b[i]);
               mpq_div(x[j], x[j], V_piv[i]);
               for (vij = V_col[j]; vij != NULL; vij = vij->c_next)
               {  mpq_mul(temp, vij->val, x[j]);
                  mpq_sub(b[vij->i], b[vij->i], temp);
               }
            }
         }
      }
      else
      {  /* solve the system V'*x = b */
         for (k = 1; k <= n; k++)
         {  i = P_row[k], j = Q_col[k];
            if (mpq_sgn(b[j]) != 0)
            {  mpq_set(x[i], b[j]);
               mpq_div(x[i], x[i], V_piv[i]);
               for (vij = V_row[i]; vij != NULL; vij = vij->r_next)
               {  mpq_mul(temp, vij->val, x[i]);
                  mpq_sub(b[vij->j], b[vij->j], temp);
               }
            }
         }
      }
      for (k = 1; k <= n; k++) mpq_clear(b[k]);
      mpq_clear(temp);
      xfree(b);
      return;
}

/***********************************************************************
*  lux_solve - solve system A*x = b or A'*x = b
*
*  SYNOPSIS
*
*  #include "lux.h"
*  void lux_solve(LUX *lux, int tr, mpq_t x[]);
*
*  DESCRIPTION
*
*  The routine lux_solve solves either the system A*x = b (if the flag
*  tr is zero) or the system A'*x = b (if the flag tr is non-zero),
*  where the parameter lux specifies LU-factorization of the matrix A,
*  A' is a matrix transposed to A.
*
*  On entry the array x should contain elements of the right-hand side
*  vector b in locations x[1], ..., x[n], where n is the order of the
*  matrix A. On exit this array will contain elements of the solution
*  vector x in the same locations. */

void lux_solve(LUX *lux, int tr, mpq_t x[])
{     if (lux->rank < lux->n)
         xfault("lux_solve: LU-factorization has incomplete rank\n");
      if (!tr)
      {  /* A = F*V, therefore inv(A) = inv(V)*inv(F) */
         lux_f_solve(lux, 0, x);
         lux_v_solve(lux, 0, x);
      }
      else
      {  /* A' = V'*F', therefore inv(A') = inv(F')*inv(V') */
         lux_v_solve(lux, 1, x);
         lux_f_solve(lux, 1, x);
      }
      return;
}

/***********************************************************************
*  lux_delete - delete LU-factorization
*
*  SYNOPSIS
*
*  #include "lux.h"
*  void lux_delete(LUX *lux);
*
*  DESCRIPTION
*
*  The routine lux_delete deletes LU-factorization data structure,
*  which the parameter lux points to, freeing all the memory allocated
*  to this object. */

void lux_delete(LUX *lux)
{     int n = lux->n;
      LUXELM *fij, *vij;
      int i;
      for (i = 1; i <= n; i++)
      {  for (fij = lux->F_row[i]; fij != NULL; fij = fij->r_next)
            mpq_clear(fij->val);
         mpq_clear(lux->V_piv[i]);
         for (vij = lux->V_row[i]; vij != NULL; vij = vij->r_next)
            mpq_clear(vij->val);
      }
      dmp_delete_pool(lux->pool);
      xfree(lux->F_row);
      xfree(lux->F_col);
      xfree(lux->V_piv);
      xfree(lux->V_row);
      xfree(lux->V_col);
      xfree(lux->P_row);
      xfree(lux->P_col);
      xfree(lux->Q_row);
      xfree(lux->Q_col);
      xfree(lux);
      return;
}











typedef struct BFX BFX;

#define bfx_create_binv _glp_bfx_create_binv
BFX *bfx_create_binv(void);
/* create factorization of the basis matrix */

#define bfx_is_valid _glp_bfx_is_valid
int bfx_is_valid(BFX *binv);
/* check if factorization is valid */

#define bfx_invalidate _glp_bfx_invalidate
void bfx_invalidate(BFX *binv);
/* invalidate factorization of the basis matrix */

#define bfx_factorize _glp_bfx_factorize
int bfx_factorize(BFX *binv, int m, int (*col)(void *info, int j,
      int ind[], mpq_t val[]), void *info);
/* compute factorization of the basis matrix */

#define bfx_ftran _glp_bfx_ftran
void bfx_ftran(BFX *binv, mpq_t x[], int save);
/* perform forward transformation (FTRAN) */

#define bfx_btran _glp_bfx_btran
void bfx_btran(BFX *binv, mpq_t x[]);
/* perform backward transformation (BTRAN) */

#define bfx_update _glp_bfx_update
int bfx_update(BFX *binv, int j);
/* update factorization of the basis matrix */

#define bfx_delete_binv _glp_bfx_delete_binv
void bfx_delete_binv(BFX *binv);
/* delete factorization of the basis matrix */

struct BFX
{     int valid;
      LUX *lux;
};

BFX *bfx_create_binv(void)
{     /* create factorization of the basis matrix */
      BFX *bfx;
      bfx = xmalloc(sizeof(BFX));
      bfx->valid = 0;
      bfx->lux = NULL;
      return bfx;
}

int bfx_factorize(BFX *binv, int m, int (*col)(void *info, int j,
      int ind[], mpq_t val[]), void *info)
{     /* compute factorization of the basis matrix */
      int ret;
      xassert(m > 0);
      if (binv->lux != NULL && binv->lux->n != m)
      {  lux_delete(binv->lux);
         binv->lux = NULL;
      }
      if (binv->lux == NULL)
         binv->lux = lux_create(m);
      ret = lux_decomp(binv->lux, col, info);
      binv->valid = (ret == 0);
      return ret;
}

void bfx_ftran(BFX *binv, mpq_t x[], int save)
{     /* perform forward transformation (FTRAN) */
      xassert(binv->valid);
      lux_solve(binv->lux, 0, x);
      xassert(save == save);
      return;
}

void bfx_btran(BFX *binv, mpq_t x[])
{     /* perform backward transformation (BTRAN) */
      xassert(binv->valid);
      lux_solve(binv->lux, 1, x);
      return;
}

int bfx_update(BFX *binv, int j)
{     /* update factorization of the basis matrix */
      xassert(binv->valid);
      xassert(1 <= j && j <= binv->lux->n);
      return 1;
}

void bfx_delete_binv(BFX *binv)
{     /* delete factorization of the basis matrix */
      if (binv->lux != NULL)
         lux_delete(binv->lux);
      xfree(binv);
      return;
}



typedef struct SSX SSX;

struct SSX
{     /* simplex solver workspace */
/*----------------------------------------------------------------------
// LP PROBLEM DATA
//
// It is assumed that LP problem has the following statement:
//
//    minimize (or maximize)
//
//       z = c[1]*x[1] + ... + c[m+n]*x[m+n] + c[0]                  (1)
//
//    subject to equality constraints
//
//       x[1] - a[1,1]*x[m+1] - ... - a[1,n]*x[m+n] = 0
//
//          .  .  .  .  .  .  .                                      (2)
//
//       x[m] - a[m,1]*x[m+1] + ... - a[m,n]*x[m+n] = 0
//
//    and bounds of variables
//
//         l[1] <= x[1]   <= u[1]
//
//          .  .  .  .  .  .  .                                      (3)
//
//       l[m+n] <= x[m+n] <= u[m+n]
//
// where:
// x[1], ..., x[m]      - auxiliary variables;
// x[m+1], ..., x[m+n]  - structural variables;
// z                    - objective function;
// c[1], ..., c[m+n]    - coefficients of the objective function;
// c[0]                 - constant term of the objective function;
// a[1,1], ..., a[m,n]  - constraint coefficients;
// l[1], ..., l[m+n]    - lower bounds of variables;
// u[1], ..., u[m+n]    - upper bounds of variables.
//
// Bounds of variables can be finite as well as inifinite. Besides,
// lower and upper bounds can be equal to each other. So the following
// five types of variables are possible:
//
//    Bounds of variable      Type of variable
//    -------------------------------------------------
//    -inf <  x[k] <  +inf    Free (unbounded) variable
//    l[k] <= x[k] <  +inf    Variable with lower bound
//    -inf <  x[k] <= u[k]    Variable with upper bound
//    l[k] <= x[k] <= u[k]    Double-bounded variable
//    l[k] =  x[k] =  u[k]    Fixed variable
//
// Using vector-matrix notations the LP problem (1)-(3) can be written
// as follows:
//
//    minimize (or maximize)
//
//       z = c * x + c[0]                                            (4)
//
//    subject to equality constraints
//
//       xR - A * xS = 0                                             (5)
//
//    and bounds of variables
//
//       l <= x <= u                                                 (6)
//
// where:
// xR                   - vector of auxiliary variables;
// xS                   - vector of structural variables;
// x = (xR, xS)         - vector of all variables;
// z                    - objective function;
// c                    - vector of objective coefficients;
// c[0]                 - constant term of the objective function;
// A                    - matrix of constraint coefficients (has m rows
//                        and n columns);
// l                    - vector of lower bounds of variables;
// u                    - vector of upper bounds of variables.
//
// The simplex method makes no difference between auxiliary and
// structural variables, so it is convenient to think the system of
// equality constraints (5) written in a homogeneous form:
//
//    (I | -A) * x = 0,                                              (7)
//
// where (I | -A) is an augmented (m+n)xm constraint matrix, I is mxm
// unity matrix whose columns correspond to auxiliary variables, and A
// is the original mxn constraint matrix whose columns correspond to
// structural variables. Note that only the matrix A is stored.
----------------------------------------------------------------------*/
      int m;
      /* number of rows (auxiliary variables), m > 0 */
      int n;
      /* number of columns (structural variables), n > 0 */
      int *type; /* int type[1+m+n]; */
      /* type[0] is not used;
         type[k], 1 <= k <= m+n, is the type of variable x[k]: */
#define SSX_FR          0     /* free (unbounded) variable */
#define SSX_LO          1     /* variable with lower bound */
#define SSX_UP          2     /* variable with upper bound */
#define SSX_DB          3     /* double-bounded variable */
#define SSX_FX          4     /* fixed variable */
      mpq_t *lb; /* mpq_t lb[1+m+n]; alias: l */
      /* lb[0] is not used;
         lb[k], 1 <= k <= m+n, is an lower bound of variable x[k];
         if x[k] has no lower bound, lb[k] is zero */
      mpq_t *ub; /* mpq_t ub[1+m+n]; alias: u */
      /* ub[0] is not used;
         ub[k], 1 <= k <= m+n, is an upper bound of variable x[k];
         if x[k] has no upper bound, ub[k] is zero;
         if x[k] is of fixed type, ub[k] is equal to lb[k] */
      int dir;
      /* optimization direction (sense of the objective function): */
#define SSX_MIN         0     /* minimization */
#define SSX_MAX         1     /* maximization */
      mpq_t *coef; /* mpq_t coef[1+m+n]; alias: c */
      /* coef[0] is a constant term of the objective function;
         coef[k], 1 <= k <= m+n, is a coefficient of the objective
         function at variable x[k];
         note that auxiliary variables also may have non-zero objective
         coefficients */
      int *A_ptr; /* int A_ptr[1+n+1]; */
      int *A_ind; /* int A_ind[A_ptr[n+1]]; */
      mpq_t *A_val; /* mpq_t A_val[A_ptr[n+1]]; */
      /* constraint matrix A (see (5)) in storage-by-columns format */
/*----------------------------------------------------------------------
// LP BASIS AND CURRENT BASIC SOLUTION
//
// The LP basis is defined by the following partition of the augmented
// constraint matrix (7):
//
//    (B | N) = (I | -A) * Q,                                        (8)
//
// where B is a mxm non-singular basis matrix whose columns correspond
// to basic variables xB, N is a mxn matrix whose columns correspond to
// non-basic variables xN, and Q is a permutation (m+n)x(m+n) matrix.
//
// From (7) and (8) it follows that
//
//    (I | -A) * x = (I | -A) * Q * Q' * x = (B | N) * (xB, xN),
//
// therefore
//
//    (xB, xN) = Q' * x,                                             (9)
//
// where x is the vector of all variables in the original order, xB is
// a vector of basic variables, xN is a vector of non-basic variables,
// Q' = inv(Q) is a matrix transposed to Q.
//
// Current values of non-basic variables xN[j], j = 1, ..., n, are not
// stored; they are defined implicitly by their statuses as follows:
//
//    0,             if xN[j] is free variable
//    lN[j],         if xN[j] is on its lower bound                 (10)
//    uN[j],         if xN[j] is on its upper bound
//    lN[j] = uN[j], if xN[j] is fixed variable
//
// where lN[j] and uN[j] are lower and upper bounds of xN[j].
//
// Current values of basic variables xB[i], i = 1, ..., m, are computed
// as follows:
//
//    beta = - inv(B) * N * xN,                                     (11)
//
// where current values of xN are defined by (10).
//
// Current values of simplex multipliers pi[i], i = 1, ..., m (which
// are values of Lagrange multipliers for equality constraints (7) also
// called shadow prices) are computed as follows:
//
//    pi = inv(B') * cB,                                            (12)
//
// where B' is a matrix transposed to B, cB is a vector of objective
// coefficients at basic variables xB.
//
// Current values of reduced costs d[j], j = 1, ..., n, (which are
// values of Langrange multipliers for active inequality constraints
// corresponding to non-basic variables) are computed as follows:
//
//    d = cN - N' * pi,                                             (13)
//
// where N' is a matrix transposed to N, cN is a vector of objective
// coefficients at non-basic variables xN.
----------------------------------------------------------------------*/
      int *stat; /* int stat[1+m+n]; */
      /* stat[0] is not used;
         stat[k], 1 <= k <= m+n, is the status of variable x[k]: */
#define SSX_BS          0     /* basic variable */
#define SSX_NL          1     /* non-basic variable on lower bound */
#define SSX_NU          2     /* non-basic variable on upper bound */
#define SSX_NF          3     /* non-basic free variable */
#define SSX_NS          4     /* non-basic fixed variable */
      int *Q_row; /* int Q_row[1+m+n]; */
      /* matrix Q in row-like format;
         Q_row[0] is not used;
         Q_row[i] = j means that q[i,j] = 1 */
      int *Q_col; /* int Q_col[1+m+n]; */
      /* matrix Q in column-like format;
         Q_col[0] is not used;
         Q_col[j] = i means that q[i,j] = 1 */
      /* if k-th column of the matrix (I | A) is k'-th column of the
         matrix (B | N), then Q_row[k] = k' and Q_col[k'] = k;
         if x[k] is xB[i], then Q_row[k] = i and Q_col[i] = k;
         if x[k] is xN[j], then Q_row[k] = m+j and Q_col[m+j] = k */
      BFX *binv;
      /* invertable form of the basis matrix B */
      mpq_t *bbar; /* mpq_t bbar[1+m]; alias: beta */
      /* bbar[0] is a value of the objective function;
         bbar[i], 1 <= i <= m, is a value of basic variable xB[i] */
      mpq_t *pi; /* mpq_t pi[1+m]; */
      /* pi[0] is not used;
         pi[i], 1 <= i <= m, is a simplex multiplier corresponding to
         i-th row (equality constraint) */
      mpq_t *cbar; /* mpq_t cbar[1+n]; alias: d */
      /* cbar[0] is not used;
         cbar[j], 1 <= j <= n, is a reduced cost of non-basic variable
         xN[j] */
/*----------------------------------------------------------------------
// SIMPLEX TABLE
//
// Due to (8) and (9) the system of equality constraints (7) for the
// current basis can be written as follows:
//
//    xB = A~ * xN,                                                 (14)
//
// where
//
//    A~ = - inv(B) * N                                             (15)
//
// is a mxn matrix called the simplex table.
//
// The revised simplex method uses only two components of A~, namely,
// pivot column corresponding to non-basic variable xN[q] chosen to
// enter the basis, and pivot row corresponding to basic variable xB[p]
// chosen to leave the basis.
//
// Pivot column alfa_q is q-th column of A~, so
//
//    alfa_q = A~ * e[q] = - inv(B) * N * e[q] = - inv(B) * N[q],   (16)
//
// where N[q] is q-th column of the matrix N.
//
// Pivot row alfa_p is p-th row of A~ or, equivalently, p-th column of
// A~', a matrix transposed to A~, so
//
//    alfa_p = A~' * e[p] = - N' * inv(B') * e[p] = - N' * rho_p,   (17)
//
// where (*)' means transposition, and
//
//    rho_p = inv(B') * e[p],                                       (18)
//
// is p-th column of inv(B') or, that is the same, p-th row of inv(B).
----------------------------------------------------------------------*/
      int p;
      /* number of basic variable xB[p], 1 <= p <= m, chosen to leave
         the basis */
      mpq_t *rho; /* mpq_t rho[1+m]; */
      /* p-th row of the inverse inv(B); see (18) */
      mpq_t *ap; /* mpq_t ap[1+n]; */
      /* p-th row of the simplex table; see (17) */
      int q;
      /* number of non-basic variable xN[q], 1 <= q <= n, chosen to
         enter the basis */
      mpq_t *aq; /* mpq_t aq[1+m]; */
      /* q-th column of the simplex table; see (16) */
/*--------------------------------------------------------------------*/
      int q_dir;
      /* direction in which non-basic variable xN[q] should change on
         moving to the adjacent vertex of the polyhedron:
         +1 means that xN[q] increases
         -1 means that xN[q] decreases */
      int p_stat;
      /* non-basic status which should be assigned to basic variable
         xB[p] when it has left the basis and become xN[q] */
      mpq_t delta;
      /* actual change of xN[q] in the adjacent basis (it has the same
         sign as q_dir) */
/*--------------------------------------------------------------------*/
      int it_lim;
      /* simplex iterations limit; if this value is positive, it is
         decreased by one each time when one simplex iteration has been
         performed, and reaching zero value signals the solver to stop
         the search; negative value means no iterations limit */
      int it_cnt;
      /* simplex iterations count; this count is increased by one each
         time when one simplex iteration has been performed */
      double tm_lim;
      /* searching time limit, in seconds; if this value is positive,
         it is decreased each time when one simplex iteration has been
         performed by the amount of time spent for the iteration, and
         reaching zero value signals the solver to stop the search;
         negative value means no time limit */
      double out_frq;
      /* output frequency, in seconds; this parameter specifies how
         frequently the solver sends information about the progress of
         the search to the standard output */
#if 0 /* 10/VI-2013 */
      glp_long tm_beg;
#else
      double tm_beg;
#endif
      /* starting time of the search, in seconds; the total time of the
         search is the difference between xtime() and tm_beg */
#if 0 /* 10/VI-2013 */
      glp_long tm_lag;
#else
      double tm_lag;
#endif
      /* the most recent time, in seconds, at which the progress of the
         the search was displayed */
};

#define ssx_create            _glp_ssx_create
#define ssx_factorize         _glp_ssx_factorize
#define ssx_get_xNj           _glp_ssx_get_xNj
#define ssx_eval_bbar         _glp_ssx_eval_bbar
#define ssx_eval_pi           _glp_ssx_eval_pi
#define ssx_eval_dj           _glp_ssx_eval_dj
#define ssx_eval_cbar         _glp_ssx_eval_cbar
#define ssx_eval_rho          _glp_ssx_eval_rho
#define ssx_eval_row          _glp_ssx_eval_row
#define ssx_eval_col          _glp_ssx_eval_col
#define ssx_chuzc             _glp_ssx_chuzc
#define ssx_chuzr             _glp_ssx_chuzr
#define ssx_update_bbar       _glp_ssx_update_bbar
#define ssx_update_pi         _glp_ssx_update_pi
#define ssx_update_cbar       _glp_ssx_update_cbar
#define ssx_change_basis      _glp_ssx_change_basis
#define ssx_delete            _glp_ssx_delete

#define ssx_phase_I           _glp_ssx_phase_I
#define ssx_phase_II          _glp_ssx_phase_II
#define ssx_driver            _glp_ssx_driver

SSX *ssx_create(int m, int n, int nnz);
/* create simplex solver workspace */

int ssx_factorize(SSX *ssx);
/* factorize the current basis matrix */

void ssx_get_xNj(SSX *ssx, int j, mpq_t x);
/* determine value of non-basic variable */

void ssx_eval_bbar(SSX *ssx);
/* compute values of basic variables */

void ssx_eval_pi(SSX *ssx);
/* compute values of simplex multipliers */

void ssx_eval_dj(SSX *ssx, int j, mpq_t dj);
/* compute reduced cost of non-basic variable */

void ssx_eval_cbar(SSX *ssx);
/* compute reduced costs of all non-basic variables */

void ssx_eval_rho(SSX *ssx);
/* compute p-th row of the inverse */

void ssx_eval_row(SSX *ssx);
/* compute pivot row of the simplex table */

void ssx_eval_col(SSX *ssx);
/* compute pivot column of the simplex table */

void ssx_chuzc(SSX *ssx);
/* choose pivot column */

void ssx_chuzr(SSX *ssx);
/* choose pivot row */

void ssx_update_bbar(SSX *ssx);
/* update values of basic variables */

void ssx_update_pi(SSX *ssx);
/* update simplex multipliers */

void ssx_update_cbar(SSX *ssx);
/* update reduced costs of non-basic variables */

void ssx_change_basis(SSX *ssx);
/* change current basis to adjacent one */

void ssx_delete(SSX *ssx);
/* delete simplex solver workspace */

int ssx_phase_I(SSX *ssx);
/* find primal feasible solution */

int ssx_phase_II(SSX *ssx);
/* find optimal solution */

int ssx_driver(SSX *ssx);
/* base driver to exact simplex method */


/***********************************************************************
*  NAME
*
*  glp_exact - solve LP problem in exact arithmetic
*
*  SYNOPSIS
*
*  int glp_exact(glp_prob *lp, const glp_smcp *parm);
*
*  DESCRIPTION
*
*  The routine glp_exact is a tentative implementation of the primal
*  two-phase simplex method based on exact (rational) arithmetic. It is
*  similar to the routine glp_simplex, however, for all internal
*  computations it uses arithmetic of rational numbers, which is exact
*  in mathematical sense, i.e. free of round-off errors unlike floating
*  point arithmetic.
*
*  Note that the routine glp_exact uses inly two control parameters
*  passed in the structure glp_smcp, namely, it_lim and tm_lim.
*
*  RETURNS
*
*  0  The LP problem instance has been successfully solved. This code
*     does not necessarily mean that the solver has found optimal
*     solution. It only means that the solution process was successful.
*
*  GLP_EBADB
*     Unable to start the search, because the initial basis specified
*     in the problem object is invalid--the number of basic (auxiliary
*     and structural) variables is not the same as the number of rows in
*     the problem object.
*
*  GLP_ESING
*     Unable to start the search, because the basis matrix correspodning
*     to the initial basis is exactly singular.
*
*  GLP_EBOUND
*     Unable to start the search, because some double-bounded variables
*     have incorrect bounds.
*
*  GLP_EFAIL
*     The problem has no rows/columns.
*
*  GLP_EITLIM
*     The search was prematurely terminated, because the simplex
*     iteration limit has been exceeded.
*
*  GLP_ETMLIM
*     The search was prematurely terminated, because the time limit has
*     been exceeded. */

static void set_d_eps(mpq_t x, double val)
{     /* convert double val to rational x obtaining a more adequate
         fraction than provided by mpq_set_d due to allowing a small
         approximation error specified by a given relative tolerance;
         for example, mpq_set_d would give the following
         1/3 ~= 0.333333333333333314829616256247391... ->
             -> 6004799503160661/18014398509481984
         while this routine gives exactly 1/3 */
      int s, n, j;
      double f, p, q, eps = 1e-9;
      mpq_t temp;
      xassert(-DBL_MAX <= val && val <= +DBL_MAX);
#if 1 /* 30/VII-2008 */
      if (val == floor(val))
      {  /* if val is integral, do not approximate */
         mpq_set_d(x, val);
         goto done;
      }
#endif
      if (val > 0.0)
         s = +1;
      else if (val < 0.0)
         s = -1;
      else
      {  mpq_set_si(x, 0, 1);
         goto done;
      }
      f = frexp(fabs(val), &n);
      /* |val| = f * 2^n, where 0.5 <= f < 1.0 */
      fp2rat(f, 0.1 * eps, &p, &q);
      /* f ~= p / q, where p and q are integers */
      mpq_init(temp);
      mpq_set_d(x, p);
      mpq_set_d(temp, q);
      mpq_div(x, x, temp);
      mpq_set_si(temp, 1, 1);
      for (j = 1; j <= abs(n); j++)
         mpq_add(temp, temp, temp);
      if (n > 0)
         mpq_mul(x, x, temp);
      else if (n < 0)
         mpq_div(x, x, temp);
      mpq_clear(temp);
      if (s < 0) mpq_neg(x, x);
      /* check that the desired tolerance has been attained */
      xassert(fabs(val - mpq_get_d(x)) <= eps * (1.0 + fabs(val)));
done: return;
}

static void load_data(SSX *ssx, glp_prob *lp)
{     /* load LP problem data into simplex solver workspace */
      int m = ssx->m;
      int n = ssx->n;
      int nnz = ssx->A_ptr[n+1]-1;
      int j, k, type, loc, len, *ind;
      double lb, ub, coef, *val;
      xassert(lp->m == m);
      xassert(lp->n == n);
      xassert(lp->nnz == nnz);
      /* types and bounds of rows and columns */
      for (k = 1; k <= m+n; k++)
      {  if (k <= m)
         {  type = lp->row[k]->type;
            lb = lp->row[k]->lb;
            ub = lp->row[k]->ub;
         }
         else
         {  type = lp->col[k-m]->type;
            lb = lp->col[k-m]->lb;
            ub = lp->col[k-m]->ub;
         }
         switch (type)
         {  case GLP_FR: type = SSX_FR; break;
            case GLP_LO: type = SSX_LO; break;
            case GLP_UP: type = SSX_UP; break;
            case GLP_DB: type = SSX_DB; break;
            case GLP_FX: type = SSX_FX; break;
            default: xassert(type != type);
         }
         ssx->type[k] = type;
         set_d_eps(ssx->lb[k], lb);
         set_d_eps(ssx->ub[k], ub);
      }
      /* optimization direction */
      switch (lp->dir)
      {  case GLP_MIN: ssx->dir = SSX_MIN; break;
         case GLP_MAX: ssx->dir = SSX_MAX; break;
         default: xassert(lp != lp);
      }
      /* objective coefficients */
      for (k = 0; k <= m+n; k++)
      {  if (k == 0)
            coef = lp->c0;
         else if (k <= m)
            coef = 0.0;
         else
            coef = lp->col[k-m]->coef;
         set_d_eps(ssx->coef[k], coef);
      }
      /* constraint coefficients */
      ind = xcalloc(1+m, sizeof(int));
      val = xcalloc(1+m, sizeof(double));
      loc = 0;
      for (j = 1; j <= n; j++)
      {  ssx->A_ptr[j] = loc+1;
         len = glp_get_mat_col(lp, j, ind, val);
         for (k = 1; k <= len; k++)
         {  loc++;
            ssx->A_ind[loc] = ind[k];
            set_d_eps(ssx->A_val[loc], val[k]);
         }
      }
      xassert(loc == nnz);
      xfree(ind);
      xfree(val);
      return;
}

static int load_basis(SSX *ssx, glp_prob *lp)
{     /* load current LP basis into simplex solver workspace */
      int m = ssx->m;
      int n = ssx->n;
      int *type = ssx->type;
      int *stat = ssx->stat;
      int *Q_row = ssx->Q_row;
      int *Q_col = ssx->Q_col;
      int i, j, k;
      xassert(lp->m == m);
      xassert(lp->n == n);
      /* statuses of rows and columns */
      for (k = 1; k <= m+n; k++)
      {  if (k <= m)
            stat[k] = lp->row[k]->stat;
         else
            stat[k] = lp->col[k-m]->stat;
         switch (stat[k])
         {  case GLP_BS:
               stat[k] = SSX_BS;
               break;
            case GLP_NL:
               stat[k] = SSX_NL;
               xassert(type[k] == SSX_LO || type[k] == SSX_DB);
               break;
            case GLP_NU:
               stat[k] = SSX_NU;
               xassert(type[k] == SSX_UP || type[k] == SSX_DB);
               break;
            case GLP_NF:
               stat[k] = SSX_NF;
               xassert(type[k] == SSX_FR);
               break;
            case GLP_NS:
               stat[k] = SSX_NS;
               xassert(type[k] == SSX_FX);
               break;
            default:
               xassert(stat != stat);
         }
      }
      /* build permutation matix Q */
      i = j = 0;
      for (k = 1; k <= m+n; k++)
      {  if (stat[k] == SSX_BS)
         {  i++;
            if (i > m) return 1;
            Q_row[k] = i, Q_col[i] = k;
         }
         else
         {  j++;
            if (j > n) return 1;
            Q_row[k] = m+j, Q_col[m+j] = k;
         }
      }
      xassert(i == m && j == n);
      return 0;
}

int glp_exact(glp_prob *lp, const glp_smcp *parm)
{     glp_smcp _parm;
      SSX *ssx;
      int m = lp->m;
      int n = lp->n;
      int nnz = lp->nnz;
      int i, j, k, type, pst, dst, ret, stat;
      double lb, ub, prim, dual, sum;
      if (parm == NULL)
         parm = &_parm, glp_init_smcp((glp_smcp *)parm);
      /* check control parameters */
      if (parm->it_lim < 0)
         xerror("glp_exact: it_lim = %d; invalid parameter\n",
            parm->it_lim);
      if (parm->tm_lim < 0)
         xerror("glp_exact: tm_lim = %d; invalid parameter\n",
            parm->tm_lim);
      /* the problem must have at least one row and one column */
      if (!(m > 0 && n > 0))
      {  xprintf("glp_exact: problem has no rows/columns\n");
         return GLP_EFAIL;
      }
#if 1
      /* basic solution is currently undefined */
      lp->pbs_stat = lp->dbs_stat = GLP_UNDEF;
      lp->obj_val = 0.0;
      lp->some = 0;
#endif
      /* check that all double-bounded variables have correct bounds */
      for (k = 1; k <= m+n; k++)
      {  if (k <= m)
         {  type = lp->row[k]->type;
            lb = lp->row[k]->lb;
            ub = lp->row[k]->ub;
         }
         else
         {  type = lp->col[k-m]->type;
            lb = lp->col[k-m]->lb;
            ub = lp->col[k-m]->ub;
         }
         if (type == GLP_DB && lb >= ub)
         {  xprintf("glp_exact: %s %d has invalid bounds\n",
               k <= m ? "row" : "column", k <= m ? k : k-m);
            return GLP_EBOUND;
         }
      }
      /* create the simplex solver workspace */
      xprintf("glp_exact: %d rows, %d columns, %d non-zeros\n",
         m, n, nnz);
#ifdef HAVE_GMP
      xprintf("GNU MP bignum library is being used\n");
#else
      xprintf("GLPK bignum module is being used\n");
      xprintf("(Consider installing GNU MP to attain a much better perf"
         "ormance.)\n");
#endif
      ssx = ssx_create(m, n, nnz);
      /* load LP problem data into the workspace */
      load_data(ssx, lp);
      /* load current LP basis into the workspace */
      if (load_basis(ssx, lp))
      {  xprintf("glp_exact: initial LP basis is invalid\n");
         ret = GLP_EBADB;
         goto done;
      }
      /* inherit some control parameters from the LP object */
#if 0
      ssx->it_lim = lpx_get_int_parm(lp, LPX_K_ITLIM);
      ssx->it_cnt = lpx_get_int_parm(lp, LPX_K_ITCNT);
      ssx->tm_lim = lpx_get_real_parm(lp, LPX_K_TMLIM);
#else
      ssx->it_lim = parm->it_lim;
      ssx->it_cnt = lp->it_cnt;
      ssx->tm_lim = (double)parm->tm_lim / 1000.0;
#endif
      ssx->out_frq = 5.0;
      ssx->tm_beg = xtime();
#if 0 /* 10/VI-2013 */
      ssx->tm_lag = xlset(0);
#else
      ssx->tm_lag = 0.0;
#endif
      /* solve LP */
      ret = ssx_driver(ssx);
      /* copy back some statistics to the LP object */
#if 0
      lpx_set_int_parm(lp, LPX_K_ITLIM, ssx->it_lim);
      lpx_set_int_parm(lp, LPX_K_ITCNT, ssx->it_cnt);
      lpx_set_real_parm(lp, LPX_K_TMLIM, ssx->tm_lim);
#else
      lp->it_cnt = ssx->it_cnt;
#endif
      /* analyze the return code */
      switch (ret)
      {  case 0:
            /* optimal solution found */
            ret = 0;
            pst = dst = GLP_FEAS;
            break;
         case 1:
            /* problem has no feasible solution */
            ret = 0;
            pst = GLP_NOFEAS, dst = GLP_INFEAS;
            break;
         case 2:
            /* problem has unbounded solution */
            ret = 0;
            pst = GLP_FEAS, dst = GLP_NOFEAS;
#if 1
            xassert(1 <= ssx->q && ssx->q <= n);
            lp->some = ssx->Q_col[m + ssx->q];
            xassert(1 <= lp->some && lp->some <= m+n);
#endif
            break;
         case 3:
            /* iteration limit exceeded (phase I) */
            ret = GLP_EITLIM;
            pst = dst = GLP_INFEAS;
            break;
         case 4:
            /* iteration limit exceeded (phase II) */
            ret = GLP_EITLIM;
            pst = GLP_FEAS, dst = GLP_INFEAS;
            break;
         case 5:
            /* time limit exceeded (phase I) */
            ret = GLP_ETMLIM;
            pst = dst = GLP_INFEAS;
            break;
         case 6:
            /* time limit exceeded (phase II) */
            ret = GLP_ETMLIM;
            pst = GLP_FEAS, dst = GLP_INFEAS;
            break;
         case 7:
            /* initial basis matrix is singular */
            ret = GLP_ESING;
            goto done;
         default:
            xassert(ret != ret);
      }
      /* store final basic solution components into LP object */
      lp->pbs_stat = pst;
      lp->dbs_stat = dst;
      sum = lp->c0;
      for (k = 1; k <= m+n; k++)
      {  if (ssx->stat[k] == SSX_BS)
         {  i = ssx->Q_row[k]; /* x[k] = xB[i] */
            xassert(1 <= i && i <= m);
            stat = GLP_BS;
            prim = mpq_get_d(ssx->bbar[i]);
            dual = 0.0;
         }
         else
         {  j = ssx->Q_row[k] - m; /* x[k] = xN[j] */
            xassert(1 <= j && j <= n);
            switch (ssx->stat[k])
            {  case SSX_NF:
                  stat = GLP_NF;
                  prim = 0.0;
                  break;
               case SSX_NL:
                  stat = GLP_NL;
                  prim = mpq_get_d(ssx->lb[k]);
                  break;
               case SSX_NU:
                  stat = GLP_NU;
                  prim = mpq_get_d(ssx->ub[k]);
                  break;
               case SSX_NS:
                  stat = GLP_NS;
                  prim = mpq_get_d(ssx->lb[k]);
                  break;
               default:
                  xassert(ssx != ssx);
            }
            dual = mpq_get_d(ssx->cbar[j]);
         }
         if (k <= m)
         {  glp_set_row_stat(lp, k, stat);
            lp->row[k]->prim = prim;
            lp->row[k]->dual = dual;
         }
         else
         {  glp_set_col_stat(lp, k-m, stat);
            lp->col[k-m]->prim = prim;
            lp->col[k-m]->dual = dual;
            sum += lp->col[k-m]->coef * prim;
         }
      }
      lp->obj_val = sum;
done: /* delete the simplex solver workspace */
      ssx_delete(ssx);
#if 1 /* 23/XI-2015 */
      xassert(gmp_pool_count() == 0);
      gmp_free_mem();
#endif
      /* return to the application program */
      return ret;
}




/***********************************************************************
*  NAME
*
*  glp_interior - solve LP problem with the interior-point method
*
*  SYNOPSIS
*
*  int glp_interior(glp_prob *P, const glp_iptcp *parm);
*
*  The routine glp_interior is a driver to the LP solver based on the
*  interior-point method.
*
*  The interior-point solver has a set of control parameters. Values of
*  the control parameters can be passed in a structure glp_iptcp, which
*  the parameter parm points to.
*
*  Currently this routine implements an easy variant of the primal-dual
*  interior-point method based on Mehrotra's technique.
*
*  This routine transforms the original LP problem to an equivalent LP
*  problem in the standard formulation (all constraints are equalities,
*  all variables are non-negative), calls the routine ipm_main to solve
*  the transformed problem, and then transforms an obtained solution to
*  the solution of the original problem.
*
*  RETURNS
*
*  0  The LP problem instance has been successfully solved. This code
*     does not necessarily mean that the solver has found optimal
*     solution. It only means that the solution process was successful.
*
*  GLP_EFAIL
*     The problem has no rows/columns.
*
*  GLP_ENOCVG
*     Very slow convergence or divergence.
*
*  GLP_EITLIM
*     Iteration limit exceeded.
*
*  GLP_EINSTAB
*     Numerical instability on solving Newtonian system. */

static void transform(NPP *npp)
{     /* transform LP to the standard formulation */
      NPPROW *row, *prev_row;
      NPPCOL *col, *prev_col;
      for (row = npp->r_tail; row != NULL; row = prev_row)
      {  prev_row = row->prev;
         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)
            npp_free_row(npp, row);
         else if (row->lb == -DBL_MAX)
            npp_leq_row(npp, row);
         else if (row->ub == +DBL_MAX)
            npp_geq_row(npp, row);
         else if (row->lb != row->ub)
         {  if (fabs(row->lb) < fabs(row->ub))
               npp_geq_row(npp, row);
            else
               npp_leq_row(npp, row);
         }
      }
      for (col = npp->c_tail; col != NULL; col = prev_col)
      {  prev_col = col->prev;
         if (col->lb == -DBL_MAX && col->ub == +DBL_MAX)
            npp_free_col(npp, col);
         else if (col->lb == -DBL_MAX)
            npp_ubnd_col(npp, col);
         else if (col->ub == +DBL_MAX)
         {  if (col->lb != 0.0)
               npp_lbnd_col(npp, col);
         }
         else if (col->lb != col->ub)
         {  if (fabs(col->lb) < fabs(col->ub))
            {  if (col->lb != 0.0)
                  npp_lbnd_col(npp, col);
            }
            else
               npp_ubnd_col(npp, col);
            npp_dbnd_col(npp, col);
         }
         else
            npp_fixed_col(npp, col);
      }
      for (row = npp->r_head; row != NULL; row = row->next)
         xassert(row->lb == row->ub);
      for (col = npp->c_head; col != NULL; col = col->next)
         xassert(col->lb == 0.0 && col->ub == +DBL_MAX);
      return;
}

int glp_interior(glp_prob *P, const glp_iptcp *parm)
{     glp_iptcp _parm;
      GLPROW *row;
      GLPCOL *col;
      NPP *npp = NULL;
      glp_prob *prob = NULL;
      int i, j, ret;
      /* check control parameters */
      if (parm == NULL)
         glp_init_iptcp(&_parm), parm = &_parm;
      if (!(parm->msg_lev == GLP_MSG_OFF ||
            parm->msg_lev == GLP_MSG_ERR ||
            parm->msg_lev == GLP_MSG_ON  ||
            parm->msg_lev == GLP_MSG_ALL))
         xerror("glp_interior: msg_lev = %d; invalid parameter\n",
            parm->msg_lev);
      if (!(parm->ord_alg == GLP_ORD_NONE ||
            parm->ord_alg == GLP_ORD_QMD ||
            parm->ord_alg == GLP_ORD_AMD ||
            parm->ord_alg == GLP_ORD_SYMAMD))
         xerror("glp_interior: ord_alg = %d; invalid parameter\n",
            parm->ord_alg);
      /* interior-point solution is currently undefined */
      P->ipt_stat = GLP_UNDEF;
      P->ipt_obj = 0.0;
      /* check bounds of double-bounded variables */
      for (i = 1; i <= P->m; i++)
      {  row = P->row[i];
         if (row->type == GLP_DB && row->lb >= row->ub)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf("glp_interior: row %d: lb = %g, ub = %g; incorre"
                  "ct bounds\n", i, row->lb, row->ub);
            ret = GLP_EBOUND;
            goto done;
         }
      }
      for (j = 1; j <= P->n; j++)
      {  col = P->col[j];
         if (col->type == GLP_DB && col->lb >= col->ub)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf("glp_interior: column %d: lb = %g, ub = %g; inco"
                  "rrect bounds\n", j, col->lb, col->ub);
            ret = GLP_EBOUND;
            goto done;
         }
      }
      /* transform LP to the standard formulation */
      if (parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Original LP has %d row(s), %d column(s), and %d non-z"
            "ero(s)\n", P->m, P->n, P->nnz);
      npp = npp_create_wksp();
      npp_load_prob(npp, P, GLP_OFF, GLP_IPT, GLP_ON);
      transform(npp);
      prob = glp_create_prob();
      npp_build_prob(npp, prob);
      if (parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Working LP has %d row(s), %d column(s), and %d non-ze"
            "ro(s)\n", prob->m, prob->n, prob->nnz);
#if 1
      /* currently empty problem cannot be solved */
      if (!(prob->m > 0 && prob->n > 0))
      {  if (parm->msg_lev >= GLP_MSG_ERR)
            xprintf("glp_interior: unable to solve empty problem\n");
         ret = GLP_EFAIL;
         goto done;
      }
#endif
      /* scale the resultant LP */
      {  ENV *env = get_env_ptr();
         int term_out = env->term_out;
         env->term_out = GLP_OFF;
         glp_scale_prob(prob, GLP_SF_EQ);
         env->term_out = term_out;
      }
      /* warn about dense columns */
      if (parm->msg_lev >= GLP_MSG_ON && prob->m >= 200)
      {  int len, cnt = 0;
         for (j = 1; j <= prob->n; j++)
         {  len = glp_get_mat_col(prob, j, NULL, NULL);
            if ((double)len >= 0.20 * (double)prob->m) cnt++;
         }
         if (cnt == 1)
            xprintf("WARNING: PROBLEM HAS ONE DENSE COLUMN\n");
         else if (cnt > 0)
            xprintf("WARNING: PROBLEM HAS %d DENSE COLUMNS\n", cnt);
      }
      /* solve the transformed LP */
      ret = ipm_solve(prob, parm);
      /* postprocess solution from the transformed LP */
      npp_postprocess(npp, prob);
      /* and store solution to the original LP */
      npp_unload_sol(npp, P);
done: /* free working program objects */
      if (npp != NULL) npp_delete_wksp(npp);
      if (prob != NULL) glp_delete_prob(prob);
      /* return to the application program */
      return ret;
}

/***********************************************************************
*  NAME
*
*  glp_init_iptcp - initialize interior-point solver control parameters
*
*  SYNOPSIS
*
*  void glp_init_iptcp(glp_iptcp *parm);
*
*  DESCRIPTION
*
*  The routine glp_init_iptcp initializes control parameters, which are
*  used by the interior-point solver, with default values.
*
*  Default values of the control parameters are stored in the glp_iptcp
*  structure, which the parameter parm points to. */

void glp_init_iptcp(glp_iptcp *parm)
{     parm->msg_lev = GLP_MSG_ALL;
      parm->ord_alg = GLP_ORD_AMD;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_ipt_status - retrieve status of interior-point solution
*
*  SYNOPSIS
*
*  int glp_ipt_status(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_ipt_status reports the status of solution found by
*  the interior-point solver as follows:
*
*  GLP_UNDEF  - interior-point solution is undefined;
*  GLP_OPT    - interior-point solution is optimal;
*  GLP_INFEAS - interior-point solution is infeasible;
*  GLP_NOFEAS - no feasible solution exists. */

int glp_ipt_status(glp_prob *lp)
{     int ipt_stat = lp->ipt_stat;
      return ipt_stat;
}

/***********************************************************************
*  NAME
*
*  glp_ipt_obj_val - retrieve objective value (interior point)
*
*  SYNOPSIS
*
*  double glp_ipt_obj_val(glp_prob *lp);
*
*  RETURNS
*
*  The routine glp_ipt_obj_val returns value of the objective function
*  for interior-point solution. */

double glp_ipt_obj_val(glp_prob *lp)
{     /*struct LPXCPS *cps = lp->cps;*/
      double z;
      z = lp->ipt_obj;
      /*if (cps->round && fabs(z) < 1e-9) z = 0.0;*/
      return z;
}

/***********************************************************************
*  NAME
*
*  glp_ipt_row_prim - retrieve row primal value (interior point)
*
*  SYNOPSIS
*
*  double glp_ipt_row_prim(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_ipt_row_prim returns primal value of the auxiliary
*  variable associated with i-th row. */

double glp_ipt_row_prim(glp_prob *lp, int i)
{     /*struct LPXCPS *cps = lp->cps;*/
      double pval;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_ipt_row_prim: i = %d; row number out of range\n",
            i);
      pval = lp->row[i]->pval;
      /*if (cps->round && fabs(pval) < 1e-9) pval = 0.0;*/
      return pval;
}

/***********************************************************************
*  NAME
*
*  glp_ipt_row_dual - retrieve row dual value (interior point)
*
*  SYNOPSIS
*
*  double glp_ipt_row_dual(glp_prob *lp, int i);
*
*  RETURNS
*
*  The routine glp_ipt_row_dual returns dual value (i.e. reduced cost)
*  of the auxiliary variable associated with i-th row. */

double glp_ipt_row_dual(glp_prob *lp, int i)
{     /*struct LPXCPS *cps = lp->cps;*/
      double dval;
      if (!(1 <= i && i <= lp->m))
         xerror("glp_ipt_row_dual: i = %d; row number out of range\n",
            i);
      dval = lp->row[i]->dval;
      /*if (cps->round && fabs(dval) < 1e-9) dval = 0.0;*/
      return dval;
}

/***********************************************************************
*  NAME
*
*  glp_ipt_col_prim - retrieve column primal value (interior point)
*
*  SYNOPSIS
*
*  double glp_ipt_col_prim(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_ipt_col_prim returns primal value of the structural
*  variable associated with j-th column. */

double glp_ipt_col_prim(glp_prob *lp, int j)
{     /*struct LPXCPS *cps = lp->cps;*/
      double pval;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_ipt_col_prim: j = %d; column number out of range\n"
            , j);
      pval = lp->col[j]->pval;
      /*if (cps->round && fabs(pval) < 1e-9) pval = 0.0;*/
      return pval;
}

/***********************************************************************
*  NAME
*
*  glp_ipt_col_dual - retrieve column dual value (interior point)
*
*  SYNOPSIS
*
*  double glp_ipt_col_dual(glp_prob *lp, int j);
*
*  RETURNS
*
*  The routine glp_ipt_col_dual returns dual value (i.e. reduced cost)
*  of the structural variable associated with j-th column. */

double glp_ipt_col_dual(glp_prob *lp, int j)
{     /*struct LPXCPS *cps = lp->cps;*/
      double dval;
      if (!(1 <= j && j <= lp->n))
         xerror("glp_ipt_col_dual: j = %d; column number out of range\n"
            , j);
      dval = lp->col[j]->dval;
      /*if (cps->round && fabs(dval) < 1e-9) dval = 0.0;*/
      return dval;
}



/***********************************************************************
*  NAME
*
*  glp_set_col_kind - set (change) column kind
*
*  SYNOPSIS
*
*  void glp_set_col_kind(glp_prob *mip, int j, int kind);
*
*  DESCRIPTION
*
*  The routine glp_set_col_kind sets (changes) the kind of j-th column
*  (structural variable) as specified by the parameter kind:
*
*  GLP_CV - continuous variable;
*  GLP_IV - integer variable;
*  GLP_BV - binary variable. */

void glp_set_col_kind(glp_prob *mip, int j, int kind)
{     GLPCOL *col;
      if (!(1 <= j && j <= mip->n))
         xerror("glp_set_col_kind: j = %d; column number out of range\n"
            , j);
      col = mip->col[j];
      switch (kind)
      {  case GLP_CV:
            col->kind = GLP_CV;
            break;
         case GLP_IV:
            col->kind = GLP_IV;
            break;
         case GLP_BV:
            col->kind = GLP_IV;
            if (!(col->type == GLP_DB && col->lb == 0.0 && col->ub ==
               1.0)) glp_set_col_bnds(mip, j, GLP_DB, 0.0, 1.0);
            break;
         default:
            xerror("glp_set_col_kind: j = %d; kind = %d; invalid column"
               " kind\n", j, kind);
      }
      return;
}

/***********************************************************************
*  NAME
*
*  glp_get_col_kind - retrieve column kind
*
*  SYNOPSIS
*
*  int glp_get_col_kind(glp_prob *mip, int j);
*
*  RETURNS
*
*  The routine glp_get_col_kind returns the kind of j-th column, i.e.
*  the kind of corresponding structural variable, as follows:
*
*  GLP_CV - continuous variable;
*  GLP_IV - integer variable;
*  GLP_BV - binary variable */

int glp_get_col_kind(glp_prob *mip, int j)
{     GLPCOL *col;
      int kind;
      if (!(1 <= j && j <= mip->n))
         xerror("glp_get_col_kind: j = %d; column number out of range\n"
            , j);
      col = mip->col[j];
      kind = col->kind;
      switch (kind)
      {  case GLP_CV:
            break;
         case GLP_IV:
            if (col->type == GLP_DB && col->lb == 0.0 && col->ub == 1.0)
               kind = GLP_BV;
            break;
         default:
            xassert(kind != kind);
      }
      return kind;
}

/***********************************************************************
*  NAME
*
*  glp_get_num_int - retrieve number of integer columns
*
*  SYNOPSIS
*
*  int glp_get_num_int(glp_prob *mip);
*
*  RETURNS
*
*  The routine glp_get_num_int returns the current number of columns,
*  which are marked as integer. */

int glp_get_num_int(glp_prob *mip)
{     GLPCOL *col;
      int j, count = 0;
      for (j = 1; j <= mip->n; j++)
      {  col = mip->col[j];
         if (col->kind == GLP_IV) count++;
      }
      return count;
}

/***********************************************************************
*  NAME
*
*  glp_get_num_bin - retrieve number of binary columns
*
*  SYNOPSIS
*
*  int glp_get_num_bin(glp_prob *mip);
*
*  RETURNS
*
*  The routine glp_get_num_bin returns the current number of columns,
*  which are marked as binary. */

int glp_get_num_bin(glp_prob *mip)
{     GLPCOL *col;
      int j, count = 0;
      for (j = 1; j <= mip->n; j++)
      {  col = mip->col[j];
         if (col->kind == GLP_IV && col->type == GLP_DB && col->lb ==
            0.0 && col->ub == 1.0) count++;
      }
      return count;
}

/***********************************************************************
*  NAME
*
*  glp_intopt - solve MIP problem with the branch-and-bound method
*
*  SYNOPSIS
*
*  int glp_intopt(glp_prob *P, const glp_iocp *parm);
*
*  DESCRIPTION
*
*  The routine glp_intopt is a driver to the MIP solver based on the
*  branch-and-bound method.
*
*  On entry the problem object should contain optimal solution to LP
*  relaxation (which can be obtained with the routine glp_simplex).
*
*  The MIP solver has a set of control parameters. Values of the control
*  parameters can be passed in a structure glp_iocp, which the parameter
*  parm points to.
*
*  The parameter parm can be specified as NULL, in which case the MIP
*  solver uses default settings.
*
*  RETURNS
*
*  0  The MIP problem instance has been successfully solved. This code
*     does not necessarily mean that the solver has found optimal
*     solution. It only means that the solution process was successful.
*
*  GLP_EBOUND
*     Unable to start the search, because some double-bounded variables
*     have incorrect bounds or some integer variables have non-integer
*     (fractional) bounds.
*
*  GLP_EROOT
*     Unable to start the search, because optimal basis for initial LP
*     relaxation is not provided.
*
*  GLP_EFAIL
*     The search was prematurely terminated due to the solver failure.
*
*  GLP_EMIPGAP
*     The search was prematurely terminated, because the relative mip
*     gap tolerance has been reached.
*
*  GLP_ETMLIM
*     The search was prematurely terminated, because the time limit has
*     been exceeded.
*
*  GLP_ENOPFS
*     The MIP problem instance has no primal feasible solution (only if
*     the MIP presolver is used).
*
*  GLP_ENODFS
*     LP relaxation of the MIP problem instance has no dual feasible
*     solution (only if the MIP presolver is used).
*
*  GLP_ESTOP
*     The search was prematurely terminated by application. */

#if 0 /* 11/VII-2013 */
static int solve_mip(glp_prob *P, const glp_iocp *parm)
#else
static int solve_mip(glp_prob *P, const glp_iocp *parm,
      glp_prob *P0 /* problem passed to glp_intopt */,
      NPP *npp /* preprocessor workspace or NULL */)
#endif
{     /* solve MIP directly without using the preprocessor */
      glp_tree *T;
      int ret;
      /* optimal basis to LP relaxation must be provided */
      if (glp_get_status(P) != GLP_OPT)
      {  if (parm->msg_lev >= GLP_MSG_ERR)
            xprintf("glp_intopt: optimal basis to initial LP relaxation"
               " not provided\n");
         ret = GLP_EROOT;
         goto done;
      }
      /* it seems all is ok */
      if (parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Integer optimization begins...\n");
      /* create the branch-and-bound tree */
      T = ios_create_tree(P, parm);
#if 1 /* 11/VII-2013 */
      T->P = P0;
      T->npp = npp;
#endif
      /* solve the problem instance */
      ret = ios_driver(T);
      /* delete the branch-and-bound tree */
      ios_delete_tree(T);
      /* analyze exit code reported by the mip driver */
      if (ret == 0)
      {  if (P->mip_stat == GLP_FEAS)
         {  if (parm->msg_lev >= GLP_MSG_ALL)
               xprintf("INTEGER OPTIMAL SOLUTION FOUND\n");
            P->mip_stat = GLP_OPT;
         }
         else
         {  if (parm->msg_lev >= GLP_MSG_ALL)
               xprintf("PROBLEM HAS NO INTEGER FEASIBLE SOLUTION\n");
            P->mip_stat = GLP_NOFEAS;
         }
      }
      else if (ret == GLP_EMIPGAP)
      {  if (parm->msg_lev >= GLP_MSG_ALL)
            xprintf("RELATIVE MIP GAP TOLERANCE REACHED; SEARCH TERMINA"
               "TED\n");
      }
      else if (ret == GLP_ETMLIM)
      {  if (parm->msg_lev >= GLP_MSG_ALL)
            xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
      }
      else if (ret == GLP_EFAIL)
      {  if (parm->msg_lev >= GLP_MSG_ERR)
            xprintf("glp_intopt: cannot solve current LP relaxation\n");
      }
      else if (ret == GLP_ESTOP)
      {  if (parm->msg_lev >= GLP_MSG_ALL)
            xprintf("SEARCH TERMINATED BY APPLICATION\n");
      }
      else
         xassert(ret != ret);
done: return ret;
}

static int preprocess_and_solve_mip(glp_prob *P, const glp_iocp *parm)
{     /* solve MIP using the preprocessor */
      ENV *env = get_env_ptr();
      int term_out = env->term_out;
      NPP *npp;
      glp_prob *mip = NULL;
      glp_bfcp bfcp;
      glp_smcp smcp;
      int ret;
      if (parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Preprocessing...\n");
      /* create preprocessor workspace */
      npp = npp_create_wksp();
      /* load original problem into the preprocessor workspace */
      npp_load_prob(npp, P, GLP_OFF, GLP_MIP, GLP_OFF);
      /* process MIP prior to applying the branch-and-bound method */
      if (!term_out || parm->msg_lev < GLP_MSG_ALL)
         env->term_out = GLP_OFF;
      else
         env->term_out = GLP_ON;
      ret = npp_integer(npp, parm);
      env->term_out = term_out;
      if (ret == 0)
         ;
      else if (ret == GLP_ENOPFS)
      {  if (parm->msg_lev >= GLP_MSG_ALL)
            xprintf("PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\n");
      }
      else if (ret == GLP_ENODFS)
      {  if (parm->msg_lev >= GLP_MSG_ALL)
            xprintf("LP RELAXATION HAS NO DUAL FEASIBLE SOLUTION\n");
      }
      else
         xassert(ret != ret);
      if (ret != 0) goto done;
      /* build transformed MIP */
      mip = glp_create_prob();
      npp_build_prob(npp, mip);
      /* if the transformed MIP is empty, it has empty solution, which
         is optimal */
      if (mip->m == 0 && mip->n == 0)
      {  mip->mip_stat = GLP_OPT;
         mip->mip_obj = mip->c0;
         if (parm->msg_lev >= GLP_MSG_ALL)
         {  xprintf("Objective value = %17.9e\n", mip->mip_obj);
            xprintf("INTEGER OPTIMAL SOLUTION FOUND BY MIP PREPROCESSOR"
               "\n");
         }
         goto post;
      }
      /* display some statistics */
      if (parm->msg_lev >= GLP_MSG_ALL)
      {  int ni = glp_get_num_int(mip);
         int nb = glp_get_num_bin(mip);
         char s[50];
         xprintf("%d row%s, %d column%s, %d non-zero%s\n",
            mip->m, mip->m == 1 ? "" : "s", mip->n, mip->n == 1 ? "" :
            "s", mip->nnz, mip->nnz == 1 ? "" : "s");
         if (nb == 0)
            strcpy(s, "none of");
         else if (ni == 1 && nb == 1)
            strcpy(s, "");
         else if (nb == 1)
            strcpy(s, "one of");
         else if (nb == ni)
            strcpy(s, "all of");
         else
            sprintf(s, "%d of", nb);
         xprintf("%d integer variable%s, %s which %s binary\n",
            ni, ni == 1 ? "" : "s", s, nb == 1 ? "is" : "are");
      }
      /* inherit basis factorization control parameters */
      glp_get_bfcp(P, &bfcp);
      glp_set_bfcp(mip, &bfcp);
      /* scale the transformed problem */
      if (!term_out || parm->msg_lev < GLP_MSG_ALL)
         env->term_out = GLP_OFF;
      else
         env->term_out = GLP_ON;
      glp_scale_prob(mip,
         GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP);
      env->term_out = term_out;
      /* build advanced initial basis */
      if (!term_out || parm->msg_lev < GLP_MSG_ALL)
         env->term_out = GLP_OFF;
      else
         env->term_out = GLP_ON;
      glp_adv_basis(mip, 0);
      env->term_out = term_out;
      /* solve initial LP relaxation */
      if (parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Solving LP relaxation...\n");
      glp_init_smcp(&smcp);
      smcp.msg_lev = parm->msg_lev;
      /* respect time limit */
      smcp.tm_lim = parm->tm_lim;
      mip->it_cnt = P->it_cnt;
      ret = glp_simplex(mip, &smcp);
      P->it_cnt = mip->it_cnt;
      if (ret == GLP_ETMLIM)
         goto done;
      else if (ret != 0)
      {  if (parm->msg_lev >= GLP_MSG_ERR)
            xprintf("glp_intopt: cannot solve LP relaxation\n");
         ret = GLP_EFAIL;
         goto done;
      }
      /* check status of the basic solution */
      ret = glp_get_status(mip);
      if (ret == GLP_OPT)
         ret = 0;
      else if (ret == GLP_NOFEAS)
         ret = GLP_ENOPFS;
      else if (ret == GLP_UNBND)
         ret = GLP_ENODFS;
      else
         xassert(ret != ret);
      if (ret != 0) goto done;
      /* solve the transformed MIP */
      mip->it_cnt = P->it_cnt;
#if 0 /* 11/VII-2013 */
      ret = solve_mip(mip, parm);
#else
      if (parm->use_sol)
      {  mip->mip_stat = P->mip_stat;
         mip->mip_obj = P->mip_obj;
      }
      ret = solve_mip(mip, parm, P, npp);
#endif
      P->it_cnt = mip->it_cnt;
      /* only integer feasible solution can be postprocessed */
      if (!(mip->mip_stat == GLP_OPT || mip->mip_stat == GLP_FEAS))
      {  P->mip_stat = mip->mip_stat;
         goto done;
      }
      /* postprocess solution from the transformed MIP */
post: npp_postprocess(npp, mip);
      /* the transformed MIP is no longer needed */
      glp_delete_prob(mip), mip = NULL;
      /* store solution to the original problem */
      npp_unload_sol(npp, P);
done: /* delete the transformed MIP, if it exists */
      if (mip != NULL) glp_delete_prob(mip);
      /* delete preprocessor workspace */
      npp_delete_wksp(npp);
      return ret;
}

#ifndef HAVE_ALIEN_SOLVER /* 28/V-2010 */
int _glp_intopt1(glp_prob *P, const glp_iocp *parm)
{     xassert(P == P);
      xassert(parm == parm);
      xprintf("glp_intopt: no alien solver is available\n");
      return GLP_EFAIL;
}
#endif

int glp_intopt(glp_prob *P, const glp_iocp *parm)
{     /* solve MIP problem with the branch-and-bound method */
      glp_iocp _parm;
      int i, j, ret;
      /* check problem object */
      if (P == NULL || P->magic != GLP_PROB_MAGIC)
         xerror("glp_intopt: P = %p; invalid problem object\n", P);
      if (P->tree != NULL)
         xerror("glp_intopt: operation not allowed\n");
      /* check control parameters */
      if (parm == NULL)
         parm = &_parm, glp_init_iocp((glp_iocp *)parm);
      if (!(parm->msg_lev == GLP_MSG_OFF ||
            parm->msg_lev == GLP_MSG_ERR ||
            parm->msg_lev == GLP_MSG_ON  ||
            parm->msg_lev == GLP_MSG_ALL ||
            parm->msg_lev == GLP_MSG_DBG))
         xerror("glp_intopt: msg_lev = %d; invalid parameter\n",
            parm->msg_lev);
      if (!(parm->br_tech == GLP_BR_FFV ||
            parm->br_tech == GLP_BR_LFV ||
            parm->br_tech == GLP_BR_MFV ||
            parm->br_tech == GLP_BR_DTH ||
            parm->br_tech == GLP_BR_PCH))
         xerror("glp_intopt: br_tech = %d; invalid parameter\n",
            parm->br_tech);
      if (!(parm->bt_tech == GLP_BT_DFS ||
            parm->bt_tech == GLP_BT_BFS ||
            parm->bt_tech == GLP_BT_BLB ||
            parm->bt_tech == GLP_BT_BPH))
         xerror("glp_intopt: bt_tech = %d; invalid parameter\n",
            parm->bt_tech);
      if (!(0.0 < parm->tol_int && parm->tol_int < 1.0))
         xerror("glp_intopt: tol_int = %g; invalid parameter\n",
            parm->tol_int);
      if (!(0.0 < parm->tol_obj && parm->tol_obj < 1.0))
         xerror("glp_intopt: tol_obj = %g; invalid parameter\n",
            parm->tol_obj);
      if (parm->tm_lim < 0)
         xerror("glp_intopt: tm_lim = %d; invalid parameter\n",
            parm->tm_lim);
      if (parm->out_frq < 0)
         xerror("glp_intopt: out_frq = %d; invalid parameter\n",
            parm->out_frq);
      if (parm->out_dly < 0)
         xerror("glp_intopt: out_dly = %d; invalid parameter\n",
            parm->out_dly);
      if (!(0 <= parm->cb_size && parm->cb_size <= 256))
         xerror("glp_intopt: cb_size = %d; invalid parameter\n",
            parm->cb_size);
      if (!(parm->pp_tech == GLP_PP_NONE ||
            parm->pp_tech == GLP_PP_ROOT ||
            parm->pp_tech == GLP_PP_ALL))
         xerror("glp_intopt: pp_tech = %d; invalid parameter\n",
            parm->pp_tech);
      if (parm->mip_gap < 0.0)
         xerror("glp_intopt: mip_gap = %g; invalid parameter\n",
            parm->mip_gap);
      if (!(parm->mir_cuts == GLP_ON || parm->mir_cuts == GLP_OFF))
         xerror("glp_intopt: mir_cuts = %d; invalid parameter\n",
            parm->mir_cuts);
      if (!(parm->gmi_cuts == GLP_ON || parm->gmi_cuts == GLP_OFF))
         xerror("glp_intopt: gmi_cuts = %d; invalid parameter\n",
            parm->gmi_cuts);
      if (!(parm->cov_cuts == GLP_ON || parm->cov_cuts == GLP_OFF))
         xerror("glp_intopt: cov_cuts = %d; invalid parameter\n",
            parm->cov_cuts);
      if (!(parm->clq_cuts == GLP_ON || parm->clq_cuts == GLP_OFF))
         xerror("glp_intopt: clq_cuts = %d; invalid parameter\n",
            parm->clq_cuts);
      if (!(parm->presolve == GLP_ON || parm->presolve == GLP_OFF))
         xerror("glp_intopt: presolve = %d; invalid parameter\n",
            parm->presolve);
      if (!(parm->binarize == GLP_ON || parm->binarize == GLP_OFF))
         xerror("glp_intopt: binarize = %d; invalid parameter\n",
            parm->binarize);
      if (!(parm->fp_heur == GLP_ON || parm->fp_heur == GLP_OFF))
         xerror("glp_intopt: fp_heur = %d; invalid parameter\n",
            parm->fp_heur);
#if 1 /* 28/V-2010 */
      if (!(parm->alien == GLP_ON || parm->alien == GLP_OFF))
         xerror("glp_intopt: alien = %d; invalid parameter\n",
            parm->alien);
#endif
#if 0 /* 11/VII-2013 */
      /* integer solution is currently undefined */
      P->mip_stat = GLP_UNDEF;
      P->mip_obj = 0.0;
#else
      if (!parm->use_sol)
         P->mip_stat = GLP_UNDEF;
      if (P->mip_stat == GLP_NOFEAS)
         P->mip_stat = GLP_UNDEF;
      if (P->mip_stat == GLP_UNDEF)
         P->mip_obj = 0.0;
      else if (P->mip_stat == GLP_OPT)
         P->mip_stat = GLP_FEAS;
#endif
      /* check bounds of double-bounded variables */
      for (i = 1; i <= P->m; i++)
      {  GLPROW *row = P->row[i];
         if (row->type == GLP_DB && row->lb >= row->ub)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf("glp_intopt: row %d: lb = %g, ub = %g; incorrect"
                  " bounds\n", i, row->lb, row->ub);
            ret = GLP_EBOUND;
            goto done;
         }
      }
      for (j = 1; j <= P->n; j++)
      {  GLPCOL *col = P->col[j];
         if (col->type == GLP_DB && col->lb >= col->ub)
         {  if (parm->msg_lev >= GLP_MSG_ERR)
               xprintf("glp_intopt: column %d: lb = %g, ub = %g; incorr"
                  "ect bounds\n", j, col->lb, col->ub);
            ret = GLP_EBOUND;
            goto done;
         }
      }
      /* bounds of all integer variables must be integral */
      for (j = 1; j <= P->n; j++)
      {  GLPCOL *col = P->col[j];
         if (col->kind != GLP_IV) continue;
         if (col->type == GLP_LO || col->type == GLP_DB)
         {  if (col->lb != floor(col->lb))
            {  if (parm->msg_lev >= GLP_MSG_ERR)
                  xprintf("glp_intopt: integer column %d has non-intege"
                     "r lower bound %g\n", j, col->lb);
               ret = GLP_EBOUND;
               goto done;
            }
         }
         if (col->type == GLP_UP || col->type == GLP_DB)
         {  if (col->ub != floor(col->ub))
            {  if (parm->msg_lev >= GLP_MSG_ERR)
                  xprintf("glp_intopt: integer column %d has non-intege"
                     "r upper bound %g\n", j, col->ub);
               ret = GLP_EBOUND;
               goto done;
            }
         }
         if (col->type == GLP_FX)
         {  if (col->lb != floor(col->lb))
            {  if (parm->msg_lev >= GLP_MSG_ERR)
                  xprintf("glp_intopt: integer column %d has non-intege"
                     "r fixed value %g\n", j, col->lb);
               ret = GLP_EBOUND;
               goto done;
            }
         }
      }
      /* solve MIP problem */
      if (parm->msg_lev >= GLP_MSG_ALL)
      {  int ni = glp_get_num_int(P);
         int nb = glp_get_num_bin(P);
         char s[50];
         xprintf("GLPK Integer Optimizer, v%s\n", glp_version());
         xprintf("%d row%s, %d column%s, %d non-zero%s\n",
            P->m, P->m == 1 ? "" : "s", P->n, P->n == 1 ? "" : "s",
            P->nnz, P->nnz == 1 ? "" : "s");
         if (nb == 0)
            strcpy(s, "none of");
         else if (ni == 1 && nb == 1)
            strcpy(s, "");
         else if (nb == 1)
            strcpy(s, "one of");
         else if (nb == ni)
            strcpy(s, "all of");
         else
            sprintf(s, "%d of", nb);
         xprintf("%d integer variable%s, %s which %s binary\n",
            ni, ni == 1 ? "" : "s", s, nb == 1 ? "is" : "are");
      }
#if 1 /* 28/V-2010 */
      if (parm->alien)
      {  /* use alien integer optimizer */
         ret = _glp_intopt1(P, parm);
         goto done;
      }
#endif
      if (!parm->presolve)
#if 0 /* 11/VII-2013 */
         ret = solve_mip(P, parm);
#else
         ret = solve_mip(P, parm, P, NULL);
#endif
      else
         ret = preprocess_and_solve_mip(P, parm);
#if 1 /* 12/III-2013 */
      if (ret == GLP_ENOPFS)
         P->mip_stat = GLP_NOFEAS;
#endif
done: /* return to the application program */
      return ret;
}

/***********************************************************************
*  NAME
*
*  glp_init_iocp - initialize integer optimizer control parameters
*
*  SYNOPSIS
*
*  void glp_init_iocp(glp_iocp *parm);
*
*  DESCRIPTION
*
*  The routine glp_init_iocp initializes control parameters, which are
*  used by the integer optimizer, with default values.
*
*  Default values of the control parameters are stored in a glp_iocp
*  structure, which the parameter parm points to. */

void glp_init_iocp(glp_iocp *parm)
{     parm->msg_lev = GLP_MSG_ALL;
      parm->br_tech = GLP_BR_DTH;
      parm->bt_tech = GLP_BT_BLB;
      parm->tol_int = 1e-5;
      parm->tol_obj = 1e-7;
      parm->tm_lim = INT_MAX;
      parm->out_frq = 5000;
      parm->out_dly = 10000;
      parm->cb_func = NULL;
      parm->cb_info = NULL;
      parm->cb_size = 0;
      parm->pp_tech = GLP_PP_ALL;
      parm->mip_gap = 0.0;
      parm->mir_cuts = GLP_OFF;
      parm->gmi_cuts = GLP_OFF;
      parm->cov_cuts = GLP_OFF;
      parm->clq_cuts = GLP_OFF;
      parm->presolve = GLP_OFF;
      parm->binarize = GLP_OFF;
      parm->fp_heur = GLP_OFF;
      parm->ps_heur = GLP_OFF;
      parm->ps_tm_lim = 60000; /* 1 minute */
      parm->sr_heur = GLP_ON;
#if 1 /* 24/X-2015; not documented--should not be used */
      parm->use_sol = GLP_OFF;
      parm->save_sol = NULL;
      parm->alien = GLP_OFF;
#endif
#if 1 /* 16/III-2016; not documented--should not be used */
      parm->flip = GLP_OFF;
#endif
      return;
}

/***********************************************************************
*  NAME
*
*  glp_mip_status - retrieve status of MIP solution
*
*  SYNOPSIS
*
*  int glp_mip_status(glp_prob *mip);
*
*  RETURNS
*
*  The routine lpx_mip_status reports the status of MIP solution found
*  by the branch-and-bound solver as follows:
*
*  GLP_UNDEF  - MIP solution is undefined;
*  GLP_OPT    - MIP solution is integer optimal;
*  GLP_FEAS   - MIP solution is integer feasible but its optimality
*               (or non-optimality) has not been proven, perhaps due to
*               premature termination of the search;
*  GLP_NOFEAS - problem has no integer feasible solution (proven by the
*               solver). */

int glp_mip_status(glp_prob *mip)
{     int mip_stat = mip->mip_stat;
      return mip_stat;
}

/***********************************************************************
*  NAME
*
*  glp_mip_obj_val - retrieve objective value (MIP solution)
*
*  SYNOPSIS
*
*  double glp_mip_obj_val(glp_prob *mip);
*
*  RETURNS
*
*  The routine glp_mip_obj_val returns value of the objective function
*  for MIP solution. */

double glp_mip_obj_val(glp_prob *mip)
{     /*struct LPXCPS *cps = mip->cps;*/
      double z;
      z = mip->mip_obj;
      /*if (cps->round && fabs(z) < 1e-9) z = 0.0;*/
      return z;
}

/***********************************************************************
*  NAME
*
*  glp_mip_row_val - retrieve row value (MIP solution)
*
*  SYNOPSIS
*
*  double glp_mip_row_val(glp_prob *mip, int i);
*
*  RETURNS
*
*  The routine glp_mip_row_val returns value of the auxiliary variable
*  associated with i-th row. */

double glp_mip_row_val(glp_prob *mip, int i)
{     /*struct LPXCPS *cps = mip->cps;*/
      double mipx;
      if (!(1 <= i && i <= mip->m))
         xerror("glp_mip_row_val: i = %d; row number out of range\n", i)
            ;
      mipx = mip->row[i]->mipx;
      /*if (cps->round && fabs(mipx) < 1e-9) mipx = 0.0;*/
      return mipx;
}

/***********************************************************************
*  NAME
*
*  glp_mip_col_val - retrieve column value (MIP solution)
*
*  SYNOPSIS
*
*  double glp_mip_col_val(glp_prob *mip, int j);
*
*  RETURNS
*
*  The routine glp_mip_col_val returns value of the structural variable
*  associated with j-th column. */

double glp_mip_col_val(glp_prob *mip, int j)
{     /*struct LPXCPS *cps = mip->cps;*/
      double mipx;
      if (!(1 <= j && j <= mip->n))
         xerror("glp_mip_col_val: j = %d; column number out of range\n",
            j);
      mipx = mip->col[j]->mipx;
      /*if (cps->round && fabs(mipx) < 1e-9) mipx = 0.0;*/
      return mipx;
}



void glp_check_kkt(glp_prob *P, int sol, int cond, double *_ae_max,
      int *_ae_ind, double *_re_max, int *_re_ind)
{     /* check feasibility and optimality conditions */
      int m = P->m;
      int n = P->n;
      GLPROW *row;
      GLPCOL *col;
      GLPAIJ *aij;
      int i, j, ae_ind, re_ind;
      double e, sp, sn, t, ae_max, re_max;
      if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))
         xerror("glp_check_kkt: sol = %d; invalid solution indicator\n",
            sol);
      if (!(cond == GLP_KKT_PE || cond == GLP_KKT_PB ||
            cond == GLP_KKT_DE || cond == GLP_KKT_DB ||
            cond == GLP_KKT_CS))
         xerror("glp_check_kkt: cond = %d; invalid condition indicator "
            "\n", cond);
      ae_max = re_max = 0.0;
      ae_ind = re_ind = 0;
      if (cond == GLP_KKT_PE)
      {  /* xR - A * xS = 0 */
         for (i = 1; i <= m; i++)
         {  row = P->row[i];
            sp = sn = 0.0;
            /* t := xR[i] */
            if (sol == GLP_SOL)
               t = row->prim;
            else if (sol == GLP_IPT)
               t = row->pval;
            else if (sol == GLP_MIP)
               t = row->mipx;
            else
               xassert(sol != sol);
            if (t >= 0.0) sp += t; else sn -= t;
            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
            {  col = aij->col;
               /* t := - a[i,j] * xS[j] */
               if (sol == GLP_SOL)
                  t = - aij->val * col->prim;
               else if (sol == GLP_IPT)
                  t = - aij->val * col->pval;
               else if (sol == GLP_MIP)
                  t = - aij->val * col->mipx;
               else
                  xassert(sol != sol);
               if (t >= 0.0) sp += t; else sn -= t;
            }
            /* absolute error */
            e = fabs(sp - sn);
            if (ae_max < e)
               ae_max = e, ae_ind = i;
            /* relative error */
            e /= (1.0 + sp + sn);
            if (re_max < e)
               re_max = e, re_ind = i;
         }
      }
      else if (cond == GLP_KKT_PB)
      {  /* lR <= xR <= uR */
         for (i = 1; i <= m; i++)
         {  row = P->row[i];
            /* t := xR[i] */
            if (sol == GLP_SOL)
               t = row->prim;
            else if (sol == GLP_IPT)
               t = row->pval;
            else if (sol == GLP_MIP)
               t = row->mipx;
            else
               xassert(sol != sol);
            /* check lower bound */
            if (row->type == GLP_LO || row->type == GLP_DB ||
                row->type == GLP_FX)
            {  if (t < row->lb)
               {  /* absolute error */
                  e = row->lb - t;
                  if (ae_max < e)
                     ae_max = e, ae_ind = i;
                  /* relative error */
                  e /= (1.0 + fabs(row->lb));
                  if (re_max < e)
                     re_max = e, re_ind = i;
               }
            }
            /* check upper bound */
            if (row->type == GLP_UP || row->type == GLP_DB ||
                row->type == GLP_FX)
            {  if (t > row->ub)
               {  /* absolute error */
                  e = t - row->ub;
                  if (ae_max < e)
                     ae_max = e, ae_ind = i;
                  /* relative error */
                  e /= (1.0 + fabs(row->ub));
                  if (re_max < e)
                     re_max = e, re_ind = i;
               }
            }
         }
         /* lS <= xS <= uS */
         for (j = 1; j <= n; j++)
         {  col = P->col[j];
            /* t := xS[j] */
            if (sol == GLP_SOL)
               t = col->prim;
            else if (sol == GLP_IPT)
               t = col->pval;
            else if (sol == GLP_MIP)
               t = col->mipx;
            else
               xassert(sol != sol);
            /* check lower bound */
            if (col->type == GLP_LO || col->type == GLP_DB ||
                col->type == GLP_FX)
            {  if (t < col->lb)
               {  /* absolute error */
                  e = col->lb - t;
                  if (ae_max < e)
                     ae_max = e, ae_ind = m+j;
                  /* relative error */
                  e /= (1.0 + fabs(col->lb));
                  if (re_max < e)
                     re_max = e, re_ind = m+j;
               }
            }
            /* check upper bound */
            if (col->type == GLP_UP || col->type == GLP_DB ||
                col->type == GLP_FX)
            {  if (t > col->ub)
               {  /* absolute error */
                  e = t - col->ub;
                  if (ae_max < e)
                     ae_max = e, ae_ind = m+j;
                  /* relative error */
                  e /= (1.0 + fabs(col->ub));
                  if (re_max < e)
                     re_max = e, re_ind = m+j;
               }
            }
         }
      }
      else if (cond == GLP_KKT_DE)
      {  /* A' * (lambdaR - cR) + (lambdaS - cS) = 0 */
         for (j = 1; j <= n; j++)
         {  col = P->col[j];
            sp = sn = 0.0;
            /* t := lambdaS[j] - cS[j] */
            if (sol == GLP_SOL)
               t = col->dual - col->coef;
            else if (sol == GLP_IPT)
               t = col->dval - col->coef;
            else
               xassert(sol != sol);
            if (t >= 0.0) sp += t; else sn -= t;
            for (aij = col->ptr; aij != NULL; aij = aij->c_next)
            {  row = aij->row;
               /* t := a[i,j] * (lambdaR[i] - cR[i]) */
               if (sol == GLP_SOL)
                  t = aij->val * row->dual;
               else if (sol == GLP_IPT)
                  t = aij->val * row->dval;
               else
                  xassert(sol != sol);
               if (t >= 0.0) sp += t; else sn -= t;
            }
            /* absolute error */
            e = fabs(sp - sn);
            if (ae_max < e)
               ae_max = e, ae_ind = m+j;
            /* relative error */
            e /= (1.0 + sp + sn);
            if (re_max < e)
               re_max = e, re_ind = m+j;
         }
      }
      else if (cond == GLP_KKT_DB)
      {  /* check lambdaR */
         for (i = 1; i <= m; i++)
         {  row = P->row[i];
            /* t := lambdaR[i] */
            if (sol == GLP_SOL)
               t = row->dual;
            else if (sol == GLP_IPT)
               t = row->dval;
            else
               xassert(sol != sol);
            /* correct sign */
            if (P->dir == GLP_MIN)
               t = + t;
            else if (P->dir == GLP_MAX)
               t = - t;
            else
               xassert(P != P);
            /* check for positivity */
#if 1 /* 08/III-2013 */
            /* the former check was correct */
            /* the bug reported by David Price is related to violation
               of complementarity slackness, not to this condition */
            if (row->type == GLP_FR || row->type == GLP_LO)
#else
            if (row->stat == GLP_NF || row->stat == GLP_NL)
#endif
            {  if (t < 0.0)
               {  e = - t;
                  if (ae_max < e)
                     ae_max = re_max = e, ae_ind = re_ind = i;
               }
            }
            /* check for negativity */
#if 1 /* 08/III-2013 */
            /* see comment above */
            if (row->type == GLP_FR || row->type == GLP_UP)
#else
            if (row->stat == GLP_NF || row->stat == GLP_NU)
#endif
            {  if (t > 0.0)
               {  e = + t;
                  if (ae_max < e)
                     ae_max = re_max = e, ae_ind = re_ind = i;
               }
            }
         }
         /* check lambdaS */
         for (j = 1; j <= n; j++)
         {  col = P->col[j];
            /* t := lambdaS[j] */
            if (sol == GLP_SOL)
               t = col->dual;
            else if (sol == GLP_IPT)
               t = col->dval;
            else
               xassert(sol != sol);
            /* correct sign */
            if (P->dir == GLP_MIN)
               t = + t;
            else if (P->dir == GLP_MAX)
               t = - t;
            else
               xassert(P != P);
            /* check for positivity */
#if 1 /* 08/III-2013 */
            /* see comment above */
            if (col->type == GLP_FR || col->type == GLP_LO)
#else
            if (col->stat == GLP_NF || col->stat == GLP_NL)
#endif
            {  if (t < 0.0)
               {  e = - t;
                  if (ae_max < e)
                     ae_max = re_max = e, ae_ind = re_ind = m+j;
               }
            }
            /* check for negativity */
#if 1 /* 08/III-2013 */
            /* see comment above */
            if (col->type == GLP_FR || col->type == GLP_UP)
#else
            if (col->stat == GLP_NF || col->stat == GLP_NU)
#endif
            {  if (t > 0.0)
               {  e = + t;
                  if (ae_max < e)
                     ae_max = re_max = e, ae_ind = re_ind = m+j;
               }
            }
         }
      }
      else
         xassert(cond != cond);
      if (_ae_max != NULL) *_ae_max = ae_max;
      if (_ae_ind != NULL) *_ae_ind = ae_ind;
      if (_re_max != NULL) *_re_max = re_max;
      if (_re_ind != NULL) *_re_ind = re_ind;
      return;
}






/***********************************************************************
*  NAME
*
*  glp_ios_reason - determine reason for calling the callback routine
*
*  SYNOPSIS
*
*  glp_ios_reason(glp_tree *tree);
*
*  RETURNS
*
*  The routine glp_ios_reason returns a code, which indicates why the
*  user-defined callback routine is being called. */

int glp_ios_reason(glp_tree *tree)
{     return
         tree->reason;
}

/***********************************************************************
*  NAME
*
*  glp_ios_get_prob - access the problem object
*
*  SYNOPSIS
*
*  glp_prob *glp_ios_get_prob(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine glp_ios_get_prob can be called from the user-defined
*  callback routine to access the problem object, which is used by the
*  MIP solver. It is the original problem object passed to the routine
*  glp_intopt if the MIP presolver is not used; otherwise it is an
*  internal problem object built by the presolver. If the current
*  subproblem exists, LP segment of the problem object corresponds to
*  its LP relaxation.
*
*  RETURNS
*
*  The routine glp_ios_get_prob returns a pointer to the problem object
*  used by the MIP solver. */

glp_prob *glp_ios_get_prob(glp_tree *tree)
{     return
         tree->mip;
}

/***********************************************************************
*  NAME
*
*  glp_ios_tree_size - determine size of the branch-and-bound tree
*
*  SYNOPSIS
*
*  void glp_ios_tree_size(glp_tree *tree, int *a_cnt, int *n_cnt,
*     int *t_cnt);
*
*  DESCRIPTION
*
*  The routine glp_ios_tree_size stores the following three counts which
*  characterize the current size of the branch-and-bound tree:
*
*  a_cnt is the current number of active nodes, i.e. the current size of
*        the active list;
*
*  n_cnt is the current number of all (active and inactive) nodes;
*
*  t_cnt is the total number of nodes including those which have been
*        already removed from the tree. This count is increased whenever
*        a new node appears in the tree and never decreased.
*
*  If some of the parameters a_cnt, n_cnt, t_cnt is a null pointer, the
*  corresponding count is not stored. */

void glp_ios_tree_size(glp_tree *tree, int *a_cnt, int *n_cnt,
      int *t_cnt)
{     if (a_cnt != NULL) *a_cnt = tree->a_cnt;
      if (n_cnt != NULL) *n_cnt = tree->n_cnt;
      if (t_cnt != NULL) *t_cnt = tree->t_cnt;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_ios_curr_node - determine current active subproblem
*
*  SYNOPSIS
*
*  int glp_ios_curr_node(glp_tree *tree);
*
*  RETURNS
*
*  The routine glp_ios_curr_node returns the reference number of the
*  current active subproblem. However, if the current subproblem does
*  not exist, the routine returns zero. */

int glp_ios_curr_node(glp_tree *tree)
{     IOSNPD *node;
      /* obtain pointer to the current subproblem */
      node = tree->curr;
      /* return its reference number */
      return node == NULL ? 0 : node->p;
}

/***********************************************************************
*  NAME
*
*  glp_ios_next_node - determine next active subproblem
*
*  SYNOPSIS
*
*  int glp_ios_next_node(glp_tree *tree, int p);
*
*  RETURNS
*
*  If the parameter p is zero, the routine glp_ios_next_node returns
*  the reference number of the first active subproblem. However, if the
*  tree is empty, zero is returned.
*
*  If the parameter p is not zero, it must specify the reference number
*  of some active subproblem, in which case the routine returns the
*  reference number of the next active subproblem. However, if there is
*  no next active subproblem in the list, zero is returned.
*
*  All subproblems in the active list are ordered chronologically, i.e.
*  subproblem A precedes subproblem B if A was created before B. */

int glp_ios_next_node(glp_tree *tree, int p)
{     IOSNPD *node;
      if (p == 0)
      {  /* obtain pointer to the first active subproblem */
         node = tree->head;
      }
      else
      {  /* obtain pointer to the specified subproblem */
         if (!(1 <= p && p <= tree->nslots))
err:        xerror("glp_ios_next_node: p = %d; invalid subproblem refer"
               "ence number\n", p);
         node = tree->slot[p].node;
         if (node == NULL) goto err;
         /* the specified subproblem must be active */
         if (node->count != 0)
            xerror("glp_ios_next_node: p = %d; subproblem not in the ac"
               "tive list\n", p);
         /* obtain pointer to the next active subproblem */
         node = node->next;
      }
      /* return the reference number */
      return node == NULL ? 0 : node->p;
}

/***********************************************************************
*  NAME
*
*  glp_ios_prev_node - determine previous active subproblem
*
*  SYNOPSIS
*
*  int glp_ios_prev_node(glp_tree *tree, int p);
*
*  RETURNS
*
*  If the parameter p is zero, the routine glp_ios_prev_node returns
*  the reference number of the last active subproblem. However, if the
*  tree is empty, zero is returned.
*
*  If the parameter p is not zero, it must specify the reference number
*  of some active subproblem, in which case the routine returns the
*  reference number of the previous active subproblem. However, if there
*  is no previous active subproblem in the list, zero is returned.
*
*  All subproblems in the active list are ordered chronologically, i.e.
*  subproblem A precedes subproblem B if A was created before B. */

int glp_ios_prev_node(glp_tree *tree, int p)
{     IOSNPD *node;
      if (p == 0)
      {  /* obtain pointer to the last active subproblem */
         node = tree->tail;
      }
      else
      {  /* obtain pointer to the specified subproblem */
         if (!(1 <= p && p <= tree->nslots))
err:        xerror("glp_ios_prev_node: p = %d; invalid subproblem refer"
               "ence number\n", p);
         node = tree->slot[p].node;
         if (node == NULL) goto err;
         /* the specified subproblem must be active */
         if (node->count != 0)
            xerror("glp_ios_prev_node: p = %d; subproblem not in the ac"
               "tive list\n", p);
         /* obtain pointer to the previous active subproblem */
         node = node->prev;
      }
      /* return the reference number */
      return node == NULL ? 0 : node->p;
}

/***********************************************************************
*  NAME
*
*  glp_ios_up_node - determine parent subproblem
*
*  SYNOPSIS
*
*  int glp_ios_up_node(glp_tree *tree, int p);
*
*  RETURNS
*
*  The parameter p must specify the reference number of some (active or
*  inactive) subproblem, in which case the routine iet_get_up_node
*  returns the reference number of its parent subproblem. However, if
*  the specified subproblem is the root of the tree and, therefore, has
*  no parent, the routine returns zero. */

int glp_ios_up_node(glp_tree *tree, int p)
{     IOSNPD *node;
      /* obtain pointer to the specified subproblem */
      if (!(1 <= p && p <= tree->nslots))
err:     xerror("glp_ios_up_node: p = %d; invalid subproblem reference "
            "number\n", p);
      node = tree->slot[p].node;
      if (node == NULL) goto err;
      /* obtain pointer to the parent subproblem */
      node = node->up;
      /* return the reference number */
      return node == NULL ? 0 : node->p;
}

/***********************************************************************
*  NAME
*
*  glp_ios_node_level - determine subproblem level
*
*  SYNOPSIS
*
*  int glp_ios_node_level(glp_tree *tree, int p);
*
*  RETURNS
*
*  The routine glp_ios_node_level returns the level of the subproblem,
*  whose reference number is p, in the branch-and-bound tree. (The root
*  subproblem has level 0, and the level of any other subproblem is the
*  level of its parent plus one.) */

int glp_ios_node_level(glp_tree *tree, int p)
{     IOSNPD *node;
      /* obtain pointer to the specified subproblem */
      if (!(1 <= p && p <= tree->nslots))
err:     xerror("glp_ios_node_level: p = %d; invalid subproblem referen"
            "ce number\n", p);
      node = tree->slot[p].node;
      if (node == NULL) goto err;
      /* return the node level */
      return node->level;
}

/***********************************************************************
*  NAME
*
*  glp_ios_node_bound - determine subproblem local bound
*
*  SYNOPSIS
*
*  double glp_ios_node_bound(glp_tree *tree, int p);
*
*  RETURNS
*
*  The routine glp_ios_node_bound returns the local bound for (active or
*  inactive) subproblem, whose reference number is p.
*
*  COMMENTS
*
*  The local bound for subproblem p is an lower (minimization) or upper
*  (maximization) bound for integer optimal solution to this subproblem
*  (not to the original problem). This bound is local in the sense that
*  only subproblems in the subtree rooted at node p cannot have better
*  integer feasible solutions.
*
*  On creating a subproblem (due to the branching step) its local bound
*  is inherited from its parent and then may get only stronger (never
*  weaker). For the root subproblem its local bound is initially set to
*  -DBL_MAX (minimization) or +DBL_MAX (maximization) and then improved
*  as the root LP relaxation has been solved.
*
*  Note that the local bound is not necessarily the optimal objective
*  value to corresponding LP relaxation; it may be stronger. */

double glp_ios_node_bound(glp_tree *tree, int p)
{     IOSNPD *node;
      /* obtain pointer to the specified subproblem */
      if (!(1 <= p && p <= tree->nslots))
err:     xerror("glp_ios_node_bound: p = %d; invalid subproblem referen"
            "ce number\n", p);
      node = tree->slot[p].node;
      if (node == NULL) goto err;
      /* return the node local bound */
      return node->bound;
}

/***********************************************************************
*  NAME
*
*  glp_ios_best_node - find active subproblem with best local bound
*
*  SYNOPSIS
*
*  int glp_ios_best_node(glp_tree *tree);
*
*  RETURNS
*
*  The routine glp_ios_best_node returns the reference number of the
*  active subproblem, whose local bound is best (i.e. smallest in case
*  of minimization or largest in case of maximization). However, if the
*  tree is empty, the routine returns zero.
*
*  COMMENTS
*
*  The best local bound is an lower (minimization) or upper
*  (maximization) bound for integer optimal solution to the original
*  MIP problem. */

int glp_ios_best_node(glp_tree *tree)
{     return
         ios_best_node(tree);
}

/***********************************************************************
*  NAME
*
*  glp_ios_mip_gap - compute relative MIP gap
*
*  SYNOPSIS
*
*  double glp_ios_mip_gap(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine glp_ios_mip_gap computes the relative MIP gap with the
*  following formula:
*
*     gap = |best_mip - best_bnd| / (|best_mip| + DBL_EPSILON),
*
*  where best_mip is the best integer feasible solution found so far,
*  best_bnd is the best (global) bound. If no integer feasible solution
*  has been found yet, gap is set to DBL_MAX.
*
*  RETURNS
*
*  The routine glp_ios_mip_gap returns the relative MIP gap. */

double glp_ios_mip_gap(glp_tree *tree)
{     return
         ios_relative_gap(tree);
}

/***********************************************************************
*  NAME
*
*  glp_ios_node_data - access subproblem application-specific data
*
*  SYNOPSIS
*
*  void *glp_ios_node_data(glp_tree *tree, int p);
*
*  DESCRIPTION
*
*  The routine glp_ios_node_data allows the application accessing a
*  memory block allocated for the subproblem (which may be active or
*  inactive), whose reference number is p.
*
*  The size of the block is defined by the control parameter cb_size
*  passed to the routine glp_intopt. The block is initialized by binary
*  zeros on creating corresponding subproblem, and its contents is kept
*  until the subproblem will be removed from the tree.
*
*  The application may use these memory blocks to store specific data
*  for each subproblem.
*
*  RETURNS
*
*  The routine glp_ios_node_data returns a pointer to the memory block
*  for the specified subproblem. Note that if cb_size = 0, the routine
*  returns a null pointer. */

void *glp_ios_node_data(glp_tree *tree, int p)
{     IOSNPD *node;
      /* obtain pointer to the specified subproblem */
      if (!(1 <= p && p <= tree->nslots))
err:     xerror("glp_ios_node_level: p = %d; invalid subproblem referen"
            "ce number\n", p);
      node = tree->slot[p].node;
      if (node == NULL) goto err;
      /* return pointer to the application-specific data */
      return node->data;
}

/***********************************************************************
*  NAME
*
*  glp_ios_row_attr - retrieve additional row attributes
*
*  SYNOPSIS
*
*  void glp_ios_row_attr(glp_tree *tree, int i, glp_attr *attr);
*
*  DESCRIPTION
*
*  The routine glp_ios_row_attr retrieves additional attributes of row
*  i and stores them in the structure glp_attr. */

void glp_ios_row_attr(glp_tree *tree, int i, glp_attr *attr)
{     GLPROW *row;
      if (!(1 <= i && i <= tree->mip->m))
         xerror("glp_ios_row_attr: i = %d; row number out of range\n",
            i);
      row = tree->mip->row[i];
      attr->level = row->level;
      attr->origin = row->origin;
      attr->klass = row->klass;
      return;
}

/**********************************************************************/

int glp_ios_pool_size(glp_tree *tree)
{     /* determine current size of the cut pool */
      if (tree->reason != GLP_ICUTGEN)
         xerror("glp_ios_pool_size: operation not allowed\n");
      xassert(tree->local != NULL);
      return tree->local->size;
}

/**********************************************************************/

int glp_ios_add_row(glp_tree *tree,
      const char *name, int klass, int flags, int len, const int ind[],
      const double val[], int type, double rhs)
{     /* add row (constraint) to the cut pool */
      int num;
      if (tree->reason != GLP_ICUTGEN)
         xerror("glp_ios_add_row: operation not allowed\n");
      xassert(tree->local != NULL);
      num = ios_add_row(tree, tree->local, name, klass, flags, len,
         ind, val, type, rhs);
      return num;
}

/**********************************************************************/

void glp_ios_del_row(glp_tree *tree, int i)
{     /* remove row (constraint) from the cut pool */
      if (tree->reason != GLP_ICUTGEN)
         xerror("glp_ios_del_row: operation not allowed\n");
      ios_del_row(tree, tree->local, i);
      return;
}

/**********************************************************************/

void glp_ios_clear_pool(glp_tree *tree)
{     /* remove all rows (constraints) from the cut pool */
      if (tree->reason != GLP_ICUTGEN)
         xerror("glp_ios_clear_pool: operation not allowed\n");
      ios_clear_pool(tree, tree->local);
      return;
}

/***********************************************************************
*  NAME
*
*  glp_ios_can_branch - check if can branch upon specified variable
*
*  SYNOPSIS
*
*  int glp_ios_can_branch(glp_tree *tree, int j);
*
*  RETURNS
*
*  If j-th variable (column) can be used to branch upon, the routine
*  glp_ios_can_branch returns non-zero, otherwise zero. */

int glp_ios_can_branch(glp_tree *tree, int j)
{     if (!(1 <= j && j <= tree->mip->n))
         xerror("glp_ios_can_branch: j = %d; column number out of range"
            "\n", j);
      return tree->non_int[j];
}

/***********************************************************************
*  NAME
*
*  glp_ios_branch_upon - choose variable to branch upon
*
*  SYNOPSIS
*
*  void glp_ios_branch_upon(glp_tree *tree, int j, int sel);
*
*  DESCRIPTION
*
*  The routine glp_ios_branch_upon can be called from the user-defined
*  callback routine in response to the reason GLP_IBRANCH to choose a
*  branching variable, whose ordinal number is j. Should note that only
*  variables, for which the routine glp_ios_can_branch returns non-zero,
*  can be used to branch upon.
*
*  The parameter sel is a flag that indicates which branch (subproblem)
*  should be selected next to continue the search:
*
*  GLP_DN_BRNCH - select down-branch;
*  GLP_UP_BRNCH - select up-branch;
*  GLP_NO_BRNCH - use general selection technique. */

void glp_ios_branch_upon(glp_tree *tree, int j, int sel)
{     if (!(1 <= j && j <= tree->mip->n))
         xerror("glp_ios_branch_upon: j = %d; column number out of rang"
            "e\n", j);
      if (!(sel == GLP_DN_BRNCH || sel == GLP_UP_BRNCH ||
            sel == GLP_NO_BRNCH))
         xerror("glp_ios_branch_upon: sel = %d: invalid branch selectio"
            "n flag\n", sel);
      if (!(tree->non_int[j]))
         xerror("glp_ios_branch_upon: j = %d; variable cannot be used t"
            "o branch upon\n", j);
      if (tree->br_var != 0)
         xerror("glp_ios_branch_upon: branching variable already chosen"
            "\n");
      tree->br_var = j;
      tree->br_sel = sel;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_ios_select_node - select subproblem to continue the search
*
*  SYNOPSIS
*
*  void glp_ios_select_node(glp_tree *tree, int p);
*
*  DESCRIPTION
*
*  The routine glp_ios_select_node can be called from the user-defined
*  callback routine in response to the reason GLP_ISELECT to select an
*  active subproblem, whose reference number is p. The search will be
*  continued from the subproblem selected. */

void glp_ios_select_node(glp_tree *tree, int p)
{     IOSNPD *node;
      /* obtain pointer to the specified subproblem */
      if (!(1 <= p && p <= tree->nslots))
err:     xerror("glp_ios_select_node: p = %d; invalid subproblem refere"
            "nce number\n", p);
      node = tree->slot[p].node;
      if (node == NULL) goto err;
      /* the specified subproblem must be active */
      if (node->count != 0)
         xerror("glp_ios_select_node: p = %d; subproblem not in the act"
            "ive list\n", p);
      /* no subproblem must be selected yet */
      if (tree->next_p != 0)
         xerror("glp_ios_select_node: subproblem already selected\n");
      /* select the specified subproblem to continue the search */
      tree->next_p = p;
      return;
}

/***********************************************************************
*  NAME
*
*  glp_ios_heur_sol - provide solution found by heuristic
*
*  SYNOPSIS
*
*  int glp_ios_heur_sol(glp_tree *tree, const double x[]);
*
*  DESCRIPTION
*
*  The routine glp_ios_heur_sol can be called from the user-defined
*  callback routine in response to the reason GLP_IHEUR to provide an
*  integer feasible solution found by a primal heuristic.
*
*  Primal values of *all* variables (columns) found by the heuristic
*  should be placed in locations x[1], ..., x[n], where n is the number
*  of columns in the original problem object. Note that the routine
*  glp_ios_heur_sol *does not* check primal feasibility of the solution
*  provided.
*
*  Using the solution passed in the array x the routine computes value
*  of the objective function. If the objective value is better than the
*  best known integer feasible solution, the routine computes values of
*  auxiliary variables (rows) and stores all solution components in the
*  problem object.
*
*  RETURNS
*
*  If the provided solution is accepted, the routine glp_ios_heur_sol
*  returns zero. Otherwise, if the provided solution is rejected, the
*  routine returns non-zero. */

int glp_ios_heur_sol(glp_tree *tree, const double x[])
{     glp_prob *mip = tree->mip;
      int m = tree->orig_m;
      int n = tree->n;
      int i, j;
      double obj;
      xassert(mip->m >= m);
      xassert(mip->n == n);
      /* check values of integer variables and compute value of the
         objective function */
      obj = mip->c0;
      for (j = 1; j <= n; j++)
      {  GLPCOL *col = mip->col[j];
         if (col->kind == GLP_IV)
         {  /* provided value must be integral */
            if (x[j] != floor(x[j])) return 1;
         }
         obj += col->coef * x[j];
      }
      /* check if the provided solution is better than the best known
         integer feasible solution */
      if (mip->mip_stat == GLP_FEAS)
      {  switch (mip->dir)
         {  case GLP_MIN:
               if (obj >= tree->mip->mip_obj) return 1;
               break;
            case GLP_MAX:
               if (obj <= tree->mip->mip_obj) return 1;
               break;
            default:
               xassert(mip != mip);
         }
      }
      /* it is better; store it in the problem object */
      if (tree->parm->msg_lev >= GLP_MSG_ON)
         xprintf("Solution found by heuristic: %.12g\n", obj);
      mip->mip_stat = GLP_FEAS;
      mip->mip_obj = obj;
      for (j = 1; j <= n; j++)
         mip->col[j]->mipx = x[j];
      for (i = 1; i <= m; i++)
      {  GLPROW *row = mip->row[i];
         GLPAIJ *aij;
         row->mipx = 0.0;
         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
            row->mipx += aij->val * aij->col->mipx;
      }
#if 1 /* 11/VII-2013 */
      ios_process_sol(tree);
#endif
      return 0;
}

/***********************************************************************
*  NAME
*
*  glp_ios_terminate - terminate the solution process.
*
*  SYNOPSIS
*
*  void glp_ios_terminate(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine glp_ios_terminate sets a flag indicating that the MIP
*  solver should prematurely terminate the search. */

void glp_ios_terminate(glp_tree *tree)
{     if (tree->parm->msg_lev >= GLP_MSG_DBG)
         xprintf("The search is prematurely terminated due to applicati"
            "on request\n");
      tree->stop = 1;
      return;
}


/***********************************************************************
*  The structure SPXLP describes LP problem and its current basis.
*
*  It is assumed that LP problem has the following formulation (this is
*  so called "working format"):
*
*     z = c'* x + c0 -> min                                          (1)
*
*     A * x = b                                                      (2)
*
*     l <= x <= u                                                    (3)
*
*  where:
*
*  x = (x[k]) is a n-vector of variables;
*
*  z is an objective function;
*
*  c = (c[k]) is a n-vector of objective coefficients;
*
*  c0 is a constant term of the objective function;
*
*  A = (a[i,k]) is a mxn-matrix of constraint coefficients;
*
*  b = (b[i]) is a m-vector of right-hand sides;
*
*  l = (l[k]) is a n-vector of lower bounds of variables;
*
*  u = (u[k]) is a n-vector of upper bounds of variables.
*
*  If variable x[k] has no lower (upper) bound, it is formally assumed
*  that l[k] = -inf (u[k] = +inf). Variable having no bounds is called
*  free (unbounded) variable. If l[k] = u[k], variable x[k] is assumed
*  to be fixed.
*
*  It is also assumed that matrix A has full row rank: rank(A) = m,
*  i.e. all its rows are linearly independent, so m <= n.
*
*  The (current) basis is defined by an appropriate permutation matrix
*  P of order n such that:
*
*             ( xB )
*     P * x = (    ),                                                (4)
*             ( xN )
*
*  where xB = (xB[i]) is a m-vector of basic variables, xN = (xN[j]) is
*  a (n-m)-vector of non-basic variables. If a non-basic variable xN[j]
*  has both lower and upper bounds, there is used an additional flag to
*  indicate which bound is active.
*
*  From (2) and (4) it follows that:
*
*     A * P'* P * x = b   <=>   B * xB + N * xN = b,                 (5)
*
*  where P' is a matrix transposed to P, and
*
*     A * P' = (B | N).                                              (6)
*
*  Here B is the basis matrix, which is a square non-singular matrix
*  of order m composed from columns of matrix A that correspond to
*  basic variables xB, and N is a mx(n-m) matrix composed from columns
*  of matrix A that correspond to non-basic variables xN. */

typedef struct SPXLP SPXLP;

struct SPXLP
{     /* LP problem data and its (current) basis */
      int m;
      /* number of equality constraints, m > 0 */
      int n;
      /* number of variables, n >= m */
      int nnz;
      /* number of non-zeros in constraint matrix A */
      /*--------------------------------------------------------------*/
      /* mxn-matrix A of constraint coefficients in sparse column-wise
       * format */
      int *A_ptr; /* int A_ptr[1+n+1]; */
      /* A_ptr[0] is not used;
       * A_ptr[k], 1 <= k <= n, is starting position of k-th column in
       * arrays A_ind and A_val; note that A_ptr[1] is always 1;
       * A_ptr[n+1] indicates the position after the last element in
       * arrays A_ind and A_val, i.e. A_ptr[n+1] = nnz+1, where nnz is
       * the number of non-zero elements in matrix A;
       * the length of k-th column (the number of non-zero elements in
       * that column) can be calculated as A_ptr[k+1] - A_ptr[k] */
      int *A_ind; /* int A_ind[1+nnz]; */
      /* row indices */
      double *A_val; /* double A_val[1+nnz]; */
      /* non-zero element values (constraint coefficients) */
      /*--------------------------------------------------------------*/
      /* principal vectors of LP formulation */
      double *b; /* double b[1+m]; */
      /* b[0] is not used;
       * b[i], 1 <= i <= m, is the right-hand side of i-th equality
       * constraint */
      double *c; /* double c[1+n]; */
      /* c[0] is the constant term of the objective function;
       * c[k], 1 <= k <= n, is the objective function coefficient at
       * variable x[k] */
      double *l; /* double l[1+n]; */
      /* l[0] is not used;
       * l[k], 1 <= k <= n, is the lower bound of variable x[k];
       * if x[k] has no lower bound, l[k] = -DBL_MAX */
      double *u; /* double u[1+n]; */
      /* u[0] is not used;
       * u[k], 1 <= k <= n, is the upper bound of variable u[k];
       * if x[k] has no upper bound, u[k] = +DBL_MAX;
       * note that l[k] = u[k] means that x[k] is fixed variable */
      /*--------------------------------------------------------------*/
      /* LP basis */
      int *head; /* int head[1+n]; */
      /* basis header, which is permutation matrix P (4):
       * head[0] is not used;
       * head[i] = k means that xB[i] = x[k], 1 <= i <= m;
       * head[m+j] = k, means that xN[j] = x[k], 1 <= j <= n-m */
      char *flag; /* char flag[1+n-m]; */
      /* flags of non-basic variables:
       * flag[0] is not used;
       * flag[j], 1 <= j <= n-m, indicates that non-basic variable
       * xN[j] is non-fixed and has its upper bound active */
      /*--------------------------------------------------------------*/
      /* basis matrix B of order m stored in factorized form */
      int valid;
      /* factorization validity flag */
      BFD *bfd;
      /* driver to factorization of the basis matrix */
};

#define spx_factorize _glp_spx_factorize
int spx_factorize(SPXLP *lp);
/* compute factorization of current basis matrix */

#define spx_eval_beta _glp_spx_eval_beta
void spx_eval_beta(SPXLP *lp, double beta[/*1+m*/]);
/* compute values of basic variables */

#define spx_eval_obj _glp_spx_eval_obj
double spx_eval_obj(SPXLP *lp, const double beta[/*1+m*/]);
/* compute value of objective function */

#define spx_eval_pi _glp_spx_eval_pi
void spx_eval_pi(SPXLP *lp, double pi[/*1+m*/]);
/* compute simplex multipliers */

#define spx_eval_dj _glp_spx_eval_dj
double spx_eval_dj(SPXLP *lp, const double pi[/*1+m*/], int j);
/* compute reduced cost of j-th non-basic variable */

#define spx_eval_tcol _glp_spx_eval_tcol
void spx_eval_tcol(SPXLP *lp, int j, double tcol[/*1+m*/]);
/* compute j-th column of simplex table */

#define spx_eval_rho _glp_spx_eval_rho
void spx_eval_rho(SPXLP *lp, int i, double rho[/*1+m*/]);
/* compute i-th row of basis matrix inverse */

#if 1 /* 31/III-2016 */
#define spx_eval_rho_s _glp_spx_eval_rho_s
void spx_eval_rho_s(SPXLP *lp, int i, FVS *rho);
/* sparse version of spx_eval_rho */
#endif

#define spx_eval_tij _glp_spx_eval_tij
double spx_eval_tij(SPXLP *lp, const double rho[/*1+m*/], int j);
/* compute element T[i,j] of simplex table */

#define spx_eval_trow _glp_spx_eval_trow
void spx_eval_trow(SPXLP *lp, const double rho[/*1+m*/], double
      trow[/*1+n-m*/]);
/* compute i-th row of simplex table */

#define spx_update_beta _glp_spx_update_beta
void spx_update_beta(SPXLP *lp, double beta[/*1+m*/], int p,
      int p_flag, int q, const double tcol[/*1+m*/]);
/* update values of basic variables */

#if 1 /* 30/III-2016 */
#define spx_update_beta_s _glp_spx_update_beta_s
void spx_update_beta_s(SPXLP *lp, double beta[/*1+m*/], int p,
      int p_flag, int q, const FVS *tcol);
/* sparse version of spx_update_beta */
#endif

#define spx_update_d _glp_spx_update_d
double spx_update_d(SPXLP *lp, double d[/*1+n-m*/], int p, int q,
      const double trow[/*1+n-m*/], const double tcol[/*1+m*/]);
/* update reduced costs of non-basic variables */

#if 1 /* 30/III-2016 */
#define spx_update_d_s _glp_spx_update_d_s
double spx_update_d_s(SPXLP *lp, double d[/*1+n-m*/], int p, int q,
      const FVS *trow, const FVS *tcol);
/* sparse version of spx_update_d */
#endif

#define spx_change_basis _glp_spx_change_basis
void spx_change_basis(SPXLP *lp, int p, int p_flag, int q);
/* change current basis to adjacent one */

#define spx_update_invb _glp_spx_update_invb
int spx_update_invb(SPXLP *lp, int i, int k);
/* update factorization of basis matrix */


/***********************************************************************
*  spx_factorize - compute factorization of current basis matrix
*
*  This routine computes factorization of the current basis matrix B.
*
*  If the factorization has been successfully computed, the routine
*  validates it and returns zero. Otherwise, the routine invalidates
*  the factorization and returns the code provided by the factorization
*  driver (bfd_factorize). */

static int jth_col(void *info, int j, int ind[], double val[])
{     /* provide column B[j] */
      SPXLP *lp = info;
      int m = lp->m;
      int *A_ptr = lp->A_ptr;
      int *head = lp->head;
      int k, ptr, len;
      xassert(1 <= j && j <= m);
      k = head[j]; /* x[k] = xB[j] */
      ptr = A_ptr[k];
      len = A_ptr[k+1] - ptr;
      memcpy(&ind[1], &lp->A_ind[ptr], len * sizeof(int));
      memcpy(&val[1], &lp->A_val[ptr], len * sizeof(double));
      return len;
}

int spx_factorize(SPXLP *lp)
{     int ret;
      ret = bfd_factorize(lp->bfd, lp->m, jth_col, lp);
      lp->valid = (ret == 0);
      return ret;
}

/***********************************************************************
*  spx_eval_beta - compute current values of basic variables
*
*  This routine computes vector beta = (beta[i]) of current values of
*  basic variables xB = (xB[i]). (Factorization of the current basis
*  matrix should be valid.)
*
*  First the routine computes a modified vector of right-hand sides:
*
*                         n-m
*     y = b - N * f = b - sum N[j] * f[j],
*                         j=1
*
*  where b = (b[i]) is the original vector of right-hand sides, N is
*  a matrix composed from columns of the original constraint matrix A,
*  which (columns) correspond to non-basic variables, f = (f[j]) is the
*  vector of active bounds of non-basic variables xN = (xN[j]),
*  N[j] = A[k] is a column of matrix A corresponding to non-basic
*  variable xN[j] = x[k], f[j] is current active bound lN[j] = l[k] or
*  uN[j] = u[k] of non-basic variable xN[j] = x[k]. The matrix-vector
*  product N * f is computed as a linear combination of columns of N,
*  so if f[j] = 0, column N[j] can be skipped.
*
*  Then the routine performs FTRAN to compute the vector beta:
*
*     beta = inv(B) * y.
*
*  On exit the routine stores components of the vector beta to array
*  locations beta[1], ..., beta[m]. */

void spx_eval_beta(SPXLP *lp, double beta[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      double *A_val = lp->A_val;
      double *b = lp->b;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int j, k, ptr, end;
      double fj, *y;
      /* compute y = b - N * xN */
      /* y := b */
      y = beta;
      memcpy(&y[1], &b[1], m * sizeof(double));
      /* y := y - N * f */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         /* f[j] := active bound of xN[j] */
         fj = flag[j] ? u[k] : l[k];
         if (fj == 0.0 || fj == -DBL_MAX)
         {  /* either xN[j] has zero active bound or it is unbounded;
             * in the latter case its value is assumed to be zero */
            continue;
         }
         /* y := y - N[j] * f[j] */
         ptr = A_ptr[k];
         end = A_ptr[k+1];
         for (; ptr < end; ptr++)
            y[A_ind[ptr]] -= A_val[ptr] * fj;
      }
      /* compute beta = inv(B) * y */
      xassert(lp->valid);
      bfd_ftran(lp->bfd, beta);
      return;
}

/***********************************************************************
*  spx_eval_obj - compute current value of objective function
*
*  This routine computes the value of the objective function in the
*  current basic solution:
*
*     z = cB'* beta + cN'* f + c[0] =
*
*          m                    n-m
*       = sum cB[i] * beta[i] + sum cN[j] * f[j] + c[0],
*         i=1                   j=1
*
*  where cB = (cB[i]) is the vector of objective coefficients at basic
*  variables, beta = (beta[i]) is the vector of current values of basic
*  variables, cN = (cN[j]) is the vector of objective coefficients at
*  non-basic variables, f = (f[j]) is the vector of current active
*  bounds of non-basic variables, c[0] is the constant term of the
*  objective function.
*
*  It as assumed that components of the vector beta are stored in the
*  array locations beta[1], ..., beta[m]. */

double spx_eval_obj(SPXLP *lp, const double beta[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int i, j, k;
      double fj, z;
      /* compute z = cB'* beta + cN'* f + c0 */
      /* z := c0 */
      z = c[0];
      /* z := z + cB'* beta */
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         z += c[k] * beta[i];
      }
      /* z := z + cN'* f */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         /* f[j] := active bound of xN[j] */
         fj = flag[j] ? u[k] : l[k];
         if (fj == 0.0 || fj == -DBL_MAX)
         {  /* either xN[j] has zero active bound or it is unbounded;
             * in the latter case its value is assumed to be zero */
            continue;
         }
         z += c[k] * fj;
      }
      return z;
}

/***********************************************************************
*  spx_eval_pi - compute simplex multipliers in current basis
*
*  This routine computes vector pi = (pi[i]) of simplex multipliers in
*  the current basis. (Factorization of the current basis matrix should
*  be valid.)
*
*  The vector pi is computed by performing BTRAN:
*
*     pi = inv(B') * cB,
*
*  where cB = (cB[i]) is the vector of objective coefficients at basic
*  variables xB = (xB[i]).
*
*  On exit components of vector pi are stored in the array locations
*  pi[1], ..., pi[m]. */

void spx_eval_pi(SPXLP *lp, double pi[/*1+m*/])
{     int m = lp->m;
      double *c = lp->c;
      int *head = lp->head;
      int i;
      double *cB;
      /* construct cB */
      cB = pi;
      for (i = 1; i <= m; i++)
         cB[i] = c[head[i]];
      /* compute pi = inv(B) * cB */
      bfd_btran(lp->bfd, pi);
      return;
}

/***********************************************************************
*  spx_eval_dj - compute reduced cost of j-th non-basic variable
*
*  This routine computes reduced cost d[j] of non-basic variable
*  xN[j] = x[k], 1 <= j <= n-m, in the current basic solution:
*
*     d[j] = c[k] - A'[k] * pi,
*
*  where c[k] is the objective coefficient at x[k], A[k] is k-th column
*  of the constraint matrix, pi is the vector of simplex multipliers in
*  the current basis.
*
*  It as assumed that components of the vector pi are stored in the
*  array locations pi[1], ..., pi[m]. */

double spx_eval_dj(SPXLP *lp, const double pi[/*1+m*/], int j)
{     int m = lp->m;
      int n = lp->n;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      double *A_val = lp->A_val;
      int k, ptr, end;
      double dj;
      xassert(1 <= j && j <= n-m);
      k = lp->head[m+j]; /* x[k] = xN[j] */
      /* dj := c[k] */
      dj = lp->c[k];
      /* dj := dj - A'[k] * pi */
      ptr = A_ptr[k];
      end = A_ptr[k+1];
      for (; ptr < end; ptr++)
         dj -= A_val[ptr] * pi[A_ind[ptr]];
      return dj;
}

/***********************************************************************
*  spx_eval_tcol - compute j-th column of simplex table
*
*  This routine computes j-th column of the current simplex table
*  T = (T[i,j]) = - inv(B) * N, 1 <= j <= n-m. (Factorization of the
*  current basis matrix should be valid.)
*
*  The simplex table column is computed by performing FTRAN:
*
*     tcol = - inv(B) * N[j],
*
*  where B is the current basis matrix, N[j] = A[k] is a column of the
*  constraint matrix corresponding to non-basic variable xN[j] = x[k].
*
*  On exit components of the simplex table column are stored in the
*  array locations tcol[1], ... tcol[m]. */

void spx_eval_tcol(SPXLP *lp, int j, double tcol[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      double *A_val = lp->A_val;
      int *head = lp->head;
      int i, k, ptr, end;
      xassert(1 <= j && j <= n-m);
      k = head[m+j]; /* x[k] = xN[j] */
      /* compute tcol = - inv(B) * N[j] */
      for (i = 1; i <= m; i++)
         tcol[i] = 0.0;
      ptr = A_ptr[k];
      end = A_ptr[k+1];
      for (; ptr < end; ptr++)
         tcol[A_ind[ptr]] = -A_val[ptr];
      bfd_ftran(lp->bfd, tcol);
      return;
}

/***********************************************************************
*  spx_eval_rho - compute i-th row of basis matrix inverse
*
*  This routine computes i-th row of the matrix inv(B), where B is
*  the current basis matrix, 1 <= i <= m. (Factorization of the current
*  basis matrix should be valid.)
*
*  The inverse row is computed by performing BTRAN:
*
*     rho = inv(B') * e[i],
*
*  where e[i] is i-th column of unity matrix.
*
*  On exit components of the row are stored in the array locations
*  row[1], ..., row[m]. */

void spx_eval_rho(SPXLP *lp, int i, double rho[/*1+m*/])
{     int m = lp->m;
      int j;
      xassert(1 <= i && i <= m);
      /* compute rho = inv(B') * e[i] */
      for (j = 1; j <= m; j++)
         rho[j] = 0.0;
      rho[i] = 1.0;
      bfd_btran(lp->bfd, rho);
      return;
}

#if 1 /* 31/III-2016 */
void spx_eval_rho_s(SPXLP *lp, int i, FVS *rho)
{     /* sparse version of spx_eval_rho */
      int m = lp->m;
      xassert(1 <= i && i <= m);
      /* compute rho = inv(B') * e[i] */
      xassert(rho->n == m);
      fvs_clear_vec(rho);
      rho->nnz = 1;
      rho->ind[1] = i;
      rho->vec[i] = 1.0;
      bfd_btran_s(lp->bfd, rho);
      return;
}
#endif

/***********************************************************************
*  spx_eval_tij - compute element T[i,j] of simplex table
*
*  This routine computes element T[i,j] of the current simplex table
*  T = - inv(B) * N, 1 <= i <= m, 1 <= j <= n-m, with the following
*  formula:
*
*     T[i,j] = - N'[j] * rho,                                        (1)
*
*  where N[j] = A[k] is a column of the constraint matrix corresponding
*  to non-basic variable xN[j] = x[k], rho is i-th row of the inverse
*  matrix inv(B).
*
*  It as assumed that components of the inverse row rho = (rho[j]) are
*  stored in the array locations rho[1], ..., rho[m]. */

double spx_eval_tij(SPXLP *lp, const double rho[/*1+m*/], int j)
{     int m = lp->m;
      int n = lp->n;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      double *A_val = lp->A_val;
      int k, ptr, end;
      double tij;
      xassert(1 <= j && j <= n-m);
      k = lp->head[m+j]; /* x[k] = xN[j] */
      /* compute t[i,j] = - N'[j] * pi */
      tij = 0.0;
      ptr = A_ptr[k];
      end = A_ptr[k+1];
      for (; ptr < end; ptr++)
         tij -= A_val[ptr] * rho[A_ind[ptr]];
      return tij;
}

/***********************************************************************
*  spx_eval_trow - compute i-th row of simplex table
*
*  This routine computes i-th row of the current simplex table
*  T = (T[i,j]) = - inv(B) * N, 1 <= i <= m.
*
*  Elements of the row T[i] = (T[i,j]), j = 1, ..., n-m, are computed
*  directly with the routine spx_eval_tij.
*
*  The vector rho = (rho[j]), which is i-th row of the basis inverse
*  inv(B), should be previously computed with the routine spx_eval_rho.
*  It is assumed that elements of this vector are stored in the array
*  locations rho[1], ..., rho[m].
*
*  On exit components of the simplex table row are stored in the array
*  locations trow[1], ... trow[n-m].
*
*  NOTE: For testing/debugging only. */

void spx_eval_trow(SPXLP *lp, const double rho[/*1+m*/], double
      trow[/*1+n-m*/])
{     int m = lp->m;
      int n = lp->n;
      int j;
      for (j = 1; j <= n-m; j++)
         trow[j] = spx_eval_tij(lp, rho, j);
      return;
}

/***********************************************************************
*  spx_update_beta - update values of basic variables
*
*  This routine updates the vector beta = (beta[i]) of values of basic
*  variables xB = (xB[i]) for the adjacent basis.
*
*  On entry to the routine components of the vector beta in the current
*  basis should be placed in array locations beta[1], ..., beta[m].
*
*  The parameter 1 <= p <= m specifies basic variable xB[p] which
*  becomes non-basic variable xN[q] in the adjacent basis. The special
*  case p < 0 means that non-basic variable xN[q] goes from its current
*  active bound to opposite one in the adjacent basis.
*
*  If the flag p_flag is set, the active bound of xB[p] in the adjacent
*  basis is set to its upper bound. (In this case xB[p] should have its
*  upper bound and should not be fixed.)
*
*  The parameter 1 <= q <= n-m specifies non-basic variable xN[q] which
*  becomes basic variable xB[p] in the adjacent basis (if 1 <= p <= m),
*  or goes to its opposite bound (if p < 0). (In the latter case xN[q]
*  should have both lower and upper bounds and should not be fixed.)
*
*  It is assumed that the array tcol contains elements of q-th (pivot)
*  column T[q] of the simple table in locations tcol[1], ..., tcol[m].
*  (This column should be computed for the current basis.)
*
*  First, the routine determines the increment of basic variable xB[p]
*  in the adjacent basis (but only if 1 <= p <= m):
*
*                   (       - beta[p], if -inf < xB[p] < +inf
*                   (
*     delta xB[p] = { lB[p] - beta[p], if p_flag = 0
*                   (
*                   ( uB[p] - beta[p], if p_flag = 1
*
*  where beta[p] is the value of xB[p] in the current basis, lB[p] and
*  uB[p] are its lower and upper bounds. Then, the routine determines
*  the increment of non-basic variable xN[q] in the adjacent basis:
*
*                   ( delta xB[p] / T[p,q], if 1 <= p <= m
*                   (
*     delta xN[q] = { uN[q] - lN[q],        if p < 0 and f[q] = lN[q]
*                   (
*                   ( lN[q] - uN[q],        if p < 0 and f[q] = uN[q]
*
*  where T[p,q] is the pivot element of the simplex table, f[q] is the
*  active bound of xN[q] in the current basis.
*
*  If 1 <= p <= m, in the adjacent basis xN[q] becomes xB[p], so:
*
*     new beta[p] = f[q] + delta xN[q].
*
*  Values of other basic variables xB[i] for 1 <= i <= m, i != p, are
*  updated as follows:
*
*     new beta[i] = beta[i] + T[i,q] * delta xN[q].
*
*  On exit the routine stores updated components of the vector beta to
*  the same locations, where the input vector beta was stored. */

void spx_update_beta(SPXLP *lp, double beta[/*1+m*/], int p,
      int p_flag, int q, const double tcol[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int i, k;
      double delta_p, delta_q;
      if (p < 0)
      {  /* special case: xN[q] goes to its opposite bound */
         xassert(1 <= q && q <= n-m);
         /* xN[q] should be double-bounded variable */
         k = head[m+q]; /* x[k] = xN[q] */
         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);
         /* determine delta xN[q] */
         if (flag[q])
         {  /* xN[q] goes from its upper bound to its lower bound */
            delta_q = l[k] - u[k];
         }
         else
         {  /* xN[q] goes from its lower bound to its upper bound */
            delta_q = u[k] - l[k];
         }
      }
      else
      {  /* xB[p] leaves the basis, xN[q] enters the basis */
         xassert(1 <= p && p <= m);
         xassert(1 <= q && q <= n-m);
         /* determine delta xB[p] */
         k = head[p]; /* x[k] = xB[p] */
         if (p_flag)
         {  /* xB[p] goes to its upper bound */
            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
            delta_p = u[k] - beta[p];
         }
         else if (l[k] == -DBL_MAX)
         {  /* unbounded xB[p] becomes non-basic (unusual case) */
            xassert(u[k] == +DBL_MAX);
            delta_p = 0.0 - beta[p];
         }
         else
         {  /* xB[p] goes to its lower bound or becomes fixed */
            delta_p = l[k] - beta[p];
         }
         /* determine delta xN[q] */
         delta_q = delta_p / tcol[p];
         /* compute new beta[p], which is the value of xN[q] in the
          * adjacent basis */
         k = head[m+q]; /* x[k] = xN[q] */
         if (flag[q])
         {  /* xN[q] has its upper bound active */
            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
            beta[p] = u[k] + delta_q;
         }
         else if (l[k] == -DBL_MAX)
         {  /* xN[q] is non-basic unbounded variable */
            xassert(u[k] == +DBL_MAX);
            beta[p] = 0.0 + delta_q;
         }
         else
         {  /* xN[q] has its lower bound active or is fixed (latter
             * case is unusual) */
            beta[p] = l[k] + delta_q;
         }
      }
      /* compute new beta[i] for all i != p */
      for (i = 1; i <= m; i++)
      {  if (i != p)
            beta[i] += tcol[i] * delta_q;
      }
      return;
}

#if 1 /* 30/III-2016 */
void spx_update_beta_s(SPXLP *lp, double beta[/*1+m*/], int p,
      int p_flag, int q, const FVS *tcol)
{     /* sparse version of spx_update_beta */
      int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int nnz = tcol->nnz;
      int *ind = tcol->ind;
      double *vec = tcol->vec;
      int i, k;
      double delta_p, delta_q;
      xassert(tcol->n == m);
      if (p < 0)
      {  /* special case: xN[q] goes to its opposite bound */
#if 1
         /* FIXME: not tested yet */
         xassert(0);
#endif
         xassert(1 <= q && q <= n-m);
         /* xN[q] should be double-bounded variable */
         k = head[m+q]; /* x[k] = xN[q] */
         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);
         /* determine delta xN[q] */
         if (flag[q])
         {  /* xN[q] goes from its upper bound to its lower bound */
            delta_q = l[k] - u[k];
         }
         else
         {  /* xN[q] goes from its lower bound to its upper bound */
            delta_q = u[k] - l[k];
         }
      }
      else
      {  /* xB[p] leaves the basis, xN[q] enters the basis */
         xassert(1 <= p && p <= m);
         xassert(1 <= q && q <= n-m);
         /* determine delta xB[p] */
         k = head[p]; /* x[k] = xB[p] */
         if (p_flag)
         {  /* xB[p] goes to its upper bound */
            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
            delta_p = u[k] - beta[p];
         }
         else if (l[k] == -DBL_MAX)
         {  /* unbounded xB[p] becomes non-basic (unusual case) */
            xassert(u[k] == +DBL_MAX);
            delta_p = 0.0 - beta[p];
         }
         else
         {  /* xB[p] goes to its lower bound or becomes fixed */
            delta_p = l[k] - beta[p];
         }
         /* determine delta xN[q] */
         delta_q = delta_p / vec[p];
         /* compute new beta[p], which is the value of xN[q] in the
          * adjacent basis */
         k = head[m+q]; /* x[k] = xN[q] */
         if (flag[q])
         {  /* xN[q] has its upper bound active */
            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
            beta[p] = u[k] + delta_q;
         }
         else if (l[k] == -DBL_MAX)
         {  /* xN[q] is non-basic unbounded variable */
            xassert(u[k] == +DBL_MAX);
            beta[p] = 0.0 + delta_q;
         }
         else
         {  /* xN[q] has its lower bound active or is fixed (latter
             * case is unusual) */
            beta[p] = l[k] + delta_q;
         }
      }
      /* compute new beta[i] for all i != p */
      for (k = 1; k <= nnz; k++)
      {  i = ind[k];
         if (i != p)
            beta[i] += vec[i] * delta_q;
      }
      return;
}
#endif

/***********************************************************************
*  spx_update_d - update reduced costs of non-basic variables
*
*  This routine updates the vector d = (d[j]) of reduced costs of
*  non-basic variables xN = (xN[j]) for the adjacent basis.
*
*  On entry to the routine components of the vector d in the current
*  basis should be placed in locations d[1], ..., d[n-m].
*
*  The parameter 1 <= p <= m specifies basic variable xB[p] which
*  becomes non-basic variable xN[q] in the adjacent basis.
*
*  The parameter 1 <= q <= n-m specified non-basic variable xN[q] which
*  becomes basic variable xB[p] in the adjacent basis.
*
*  It is assumed that the array trow contains elements of p-th (pivot)
*  row T'[p] of the simplex table in locations trow[1], ..., trow[n-m].
*  It is also assumed that the array tcol contains elements of q-th
*  (pivot) column T[q] of the simple table in locations tcol[1], ...,
*  tcol[m]. (These row and column should be computed for the current
*  basis.)
*
*  First, the routine computes more accurate reduced cost d[q] in the
*  current basis using q-th column of the simplex table:
*
*                    n-m
*     d[q] = cN[q] + sum t[i,q] * cB[i],
*                    i=1
*
*  where cN[q] and cB[i] are objective coefficients at variables xN[q]
*  and xB[i], resp. The routine also computes the relative error:
*
*     e = |d[q] - d'[q]| / (1 + |d[q]|),
*
*  where d'[q] is the reduced cost of xN[q] on entry to the routine,
*  and returns e on exit. (If e happens to be large enough, the calling
*  program may compute the reduced costs directly, since other reduced
*  costs also may be inaccurate.)
*
*  In the adjacent basis xB[p] becomes xN[q], so:
*
*     new d[q] = d[q] / T[p,q],
*
*  where T[p,q] is the pivot element of the simplex table (it is taken
*  from column T[q] as more accurate). Reduced costs of other non-basic
*  variables xN[j] for 1 <= j <= n-m, j != q, are updated as follows:
*
*     new d[j] = d[j] + T[p,j] * new d[q].
*
*  On exit the routine stores updated components of the vector d to the
*  same locations, where the input vector d was stored. */

double spx_update_d(SPXLP *lp, double d[/*1+n-m*/], int p, int q,
      const double trow[/*1+n-m*/], const double tcol[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      int *head = lp->head;
      int i, j, k;
      double dq, e;
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n);
      /* compute d[q] in current basis more accurately */
      k = head[m+q]; /* x[k] = xN[q] */
      dq = c[k];
      for (i = 1; i <= m; i++)
         dq += tcol[i] * c[head[i]];
      /* compute relative error in d[q] */
      e = fabs(dq - d[q]) / (1.0 + fabs(dq));
      /* compute new d[q], which is the reduced cost of xB[p] in the
       * adjacent basis */
      d[q] = (dq /= tcol[p]);
      /* compute new d[j] for all j != q */
      for (j = 1; j <= n-m; j++)
      {  if (j != q)
            d[j] -= trow[j] * dq;
      }
      return e;
}

#if 1 /* 30/III-2016 */
double spx_update_d_s(SPXLP *lp, double d[/*1+n-m*/], int p, int q,
      const FVS *trow, const FVS *tcol)
{     /* sparse version of spx_update_d */
      int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      int *head = lp->head;
      int trow_nnz = trow->nnz;
      int *trow_ind = trow->ind;
      double *trow_vec = trow->vec;
      int tcol_nnz = tcol->nnz;
      int *tcol_ind = tcol->ind;
      double *tcol_vec = tcol->vec;
      int i, j, k;
      double dq, e;
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n);
      xassert(trow->n == n-m);
      xassert(tcol->n == m);
      /* compute d[q] in current basis more accurately */
      k = head[m+q]; /* x[k] = xN[q] */
      dq = c[k];
      for (k = 1; k <= tcol_nnz; k++)
      {  i = tcol_ind[k];
         dq += tcol_vec[i] * c[head[i]];
      }
      /* compute relative error in d[q] */
      e = fabs(dq - d[q]) / (1.0 + fabs(dq));
      /* compute new d[q], which is the reduced cost of xB[p] in the
       * adjacent basis */
      d[q] = (dq /= tcol_vec[p]);
      /* compute new d[j] for all j != q */
      for (k = 1; k <= trow_nnz; k++)
      {  j = trow_ind[k];
         if (j != q)
            d[j] -= trow_vec[j] * dq;
      }
      return e;
}
#endif

/***********************************************************************
*  spx_change_basis - change current basis to adjacent one
*
*  This routine changes the current basis to the adjacent one making
*  necessary changes in lp->head and lp->flag members.
*
*  The parameters p, p_flag, and q have the same meaning as for the
*  routine spx_update_beta. */

void spx_change_basis(SPXLP *lp, int p, int p_flag, int q)
{     int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int k;
      if (p < 0)
      {  /* special case: xN[q] goes to its opposite bound */
         xassert(1 <= q && q <= n-m);
         /* xN[q] should be double-bounded variable */
         k = head[m+q]; /* x[k] = xN[q] */
         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);
         /* change active bound flag */
         flag[q] = 1 - flag[q];
      }
      else
      {  /* xB[p] leaves the basis, xN[q] enters the basis */
         xassert(1 <= p && p <= m);
         xassert(p_flag == 0 || p_flag == 1);
         xassert(1 <= q && q <= n-m);
         k = head[p]; /* xB[p] = x[k] */
         if (p_flag)
         {  /* xB[p] goes to its upper bound */
            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
         }
         /* swap xB[p] and xN[q] in the basis */
         head[p] = head[m+q], head[m+q] = k;
         /* and set active bound flag for new xN[q] */
         lp->flag[q] = p_flag;
      }
      return;
}

/***********************************************************************
*  spx_update_invb - update factorization of basis matrix
*
*  This routine updates factorization of the basis matrix B when i-th
*  column of B is replaced by k-th column of the constraint matrix A.
*
*  The parameter 1 <= i <= m specifies the number of column of matrix B
*  to be replaced by a new column.
*
*  The parameter 1 <= k <= n specifies the number of column of matrix A
*  to be used for replacement.
*
*  If the factorization has been successfully updated, the routine
*  validates it and returns zero. Otherwise, the routine invalidates
*  the factorization and returns the code provided by the factorization
*  driver (bfd_update). */

int spx_update_invb(SPXLP *lp, int i, int k)
{     int m = lp->m;
      int n = lp->n;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      double *A_val = lp->A_val;
      int ptr, len, ret;
      xassert(1 <= i && i <= m);
      xassert(1 <= k && k <= n);
      ptr = A_ptr[k];
      len = A_ptr[k+1] - ptr;
      ret = bfd_update(lp->bfd, i, len, &A_ind[ptr-1], &A_val[ptr-1]);
      lp->valid = (ret == 0);
      return ret;
}




struct SPXAT
{     /* mxn-matrix A of constraint coefficients in sparse row-wise
       * format */
      int *ptr; /* int ptr[1+m+1]; */
      /* ptr[0] is not used;
       * ptr[i], 1 <= i <= m, is starting position of i-th row in
       * arrays ind and val; note that ptr[1] is always 1;
       * ptr[m+1] indicates the position after the last element in
       * arrays ind and val, i.e. ptr[m+1] = nnz+1, where nnz is the
       * number of non-zero elements in matrix A;
       * the length of i-th row (the number of non-zero elements in
       * that row) can be calculated as ptr[i+1] - ptr[i] */
      int *ind; /* int ind[1+nnz]; */
      /* column indices */
      double *val; /* double val[1+nnz]; */
      /* non-zero element values */
      double *work; /* double work[1+n]; */
      /* working array */
};
typedef struct SPXAT SPXAT;

#define spx_alloc_at _glp_spx_alloc_at
void spx_alloc_at(SPXLP *lp, SPXAT *at);
/* allocate constraint matrix in sparse row-wise format */

#define spx_build_at _glp_spx_build_at
void spx_build_at(SPXLP *lp, SPXAT *at);
/* build constraint matrix in sparse row-wise format */

#define spx_at_prod _glp_spx_at_prod
void spx_at_prod(SPXLP *lp, SPXAT *at, double y[/*1+n*/], double s,
      const double x[/*1+m*/]);
/* compute product y := y + s * A'* x */

#define spx_nt_prod1 _glp_spx_nt_prod1
void spx_nt_prod1(SPXLP *lp, SPXAT *at, double y[/*1+n-m*/], int ign,
      double s, const double x[/*1+m*/]);
/* compute product y := y + s * N'* x */

#define spx_eval_trow1 _glp_spx_eval_trow1
void spx_eval_trow1(SPXLP *lp, SPXAT *at, const double rho[/*1+m*/],
      double trow[/*1+n-m*/]);
/* compute i-th row of simplex table */

#define spx_free_at _glp_spx_free_at
void spx_free_at(SPXLP *lp, SPXAT *at);
/* deallocate constraint matrix in sparse row-wise format */


/***********************************************************************
*  spx_alloc_at - allocate constraint matrix in sparse row-wise format
*
*  This routine allocates the memory for arrays needed to represent the
*  constraint matrix in sparse row-wise format. */

void spx_alloc_at(SPXLP *lp, SPXAT *at)
{     int m = lp->m;
      int n = lp->n;
      int nnz = lp->nnz;
      at->ptr = talloc(1+m+1, int);
      at->ind = talloc(1+nnz, int);
      at->val = talloc(1+nnz, double);
      at->work = talloc(1+n, double);
      return;
}

/***********************************************************************
*  spx_build_at - build constraint matrix in sparse row-wise format
*
*  This routine builds sparse row-wise representation of the constraint
*  matrix A using its sparse column-wise representation stored in the
*  lp object, and stores the result in the at object. */

void spx_build_at(SPXLP *lp, SPXAT *at)
{     int m = lp->m;
      int n = lp->n;
      int nnz = lp->nnz;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      double *A_val = lp->A_val;
      int *AT_ptr = at->ptr;
      int *AT_ind = at->ind;
      double *AT_val = at->val;
      int i, k, ptr, end, pos;
      /* calculate AT_ptr[i] = number of non-zeros in i-th row */
      memset(&AT_ptr[1], 0, m * sizeof(int));
      for (k = 1; k <= n; k++)
      {  ptr = A_ptr[k];
         end = A_ptr[k+1];
         for (; ptr < end; ptr++)
            AT_ptr[A_ind[ptr]]++;
      }
      /* set AT_ptr[i] to position after last element in i-th row */
      AT_ptr[1]++;
      for (i = 2; i <= m; i++)
         AT_ptr[i] += AT_ptr[i-1];
      xassert(AT_ptr[m] == nnz+1);
      AT_ptr[m+1] = nnz+1;
      /* build row-wise representation and re-arrange AT_ptr[i] */
      for (k = n; k >= 1; k--)
      {  /* copy elements from k-th column to corresponding rows */
         ptr = A_ptr[k];
         end = A_ptr[k+1];
         for (; ptr < end; ptr++)
         {  pos = --AT_ptr[A_ind[ptr]];
            AT_ind[pos] = k;
            AT_val[pos] = A_val[ptr];
         }
      }
      xassert(AT_ptr[1] == 1);
      return;
}

/***********************************************************************
*  spx_at_prod - compute product y := y + s * A'* x
*
*  This routine computes the product:
*
*     y := y + s * A'* x,
*
*  where A' is a matrix transposed to the mxn-matrix A of constraint
*  coefficients, x is a m-vector, s is a scalar, y is a n-vector.
*
*  The routine uses the row-wise representation of the matrix A and
*  computes the product as a linear combination:
*
*     y := y + s * (A'[1] * x[1] + ... + A'[m] * x[m]),
*
*  where A'[i] is i-th row of A, 1 <= i <= m. */

void spx_at_prod(SPXLP *lp, SPXAT *at, double y[/*1+n*/], double s,
      const double x[/*1+m*/])
{     int m = lp->m;
      int *AT_ptr = at->ptr;
      int *AT_ind = at->ind;
      double *AT_val = at->val;
      int i, ptr, end;
      double t;
      for (i = 1; i <= m; i++)
      {  if (x[i] != 0.0)
         {  /* y := y + s * (i-th row of A) * x[i] */
            t = s * x[i];
            ptr = AT_ptr[i];
            end = AT_ptr[i+1];
            for (; ptr < end; ptr++)
               y[AT_ind[ptr]] += AT_val[ptr] * t;
         }
      }
      return;
}

/***********************************************************************
*  spx_nt_prod1 - compute product y := y + s * N'* x
*
*  This routine computes the product:
*
*     y := y + s * N'* x,
*
*  where N' is a matrix transposed to the mx(n-m)-matrix N composed
*  from non-basic columns of the constraint matrix A, x is a m-vector,
*  s is a scalar, y is (n-m)-vector.
*
*  If the flag ign is non-zero, the routine ignores the input content
*  of the array y assuming that y = 0. */

void spx_nt_prod1(SPXLP *lp, SPXAT *at, double y[/*1+n-m*/], int ign,
      double s, const double x[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      double *work = at->work;
      int j, k;
      for (k = 1; k <= n; k++)
         work[k] = 0.0;
      if (!ign)
      {  for (j = 1; j <= n-m; j++)
            work[head[m+j]] = y[j];
      }
      spx_at_prod(lp, at, work, s, x);
      for (j = 1; j <= n-m; j++)
         y[j] = work[head[m+j]];
      return;
}

/***********************************************************************
*  spx_eval_trow1 - compute i-th row of simplex table
*
*  This routine computes i-th row of the current simplex table
*  T = (T[i,j]) = - inv(B) * N, 1 <= i <= m, using representation of
*  the constraint matrix A in row-wise format.
*
*  The vector rho = (rho[j]), which is i-th row of the basis inverse
*  inv(B), should be previously computed with the routine spx_eval_rho.
*  It is assumed that elements of this vector are stored in the array
*  locations rho[1], ..., rho[m].
*
*  There exist two ways to compute the simplex table row.
*
*  1. T[i,j], j = 1,...,n-m, is computed as inner product:
*
*                    m
*        T[i,j] = - sum a[i,k] * rho[i],
*                   i=1
*
*  where N[j] = A[k] is a column of the constraint matrix corresponding
*  to non-basic variable xN[j]. The estimated number of operations in
*  this case is:
*
*        n1 = (n - m) * (nnz(A) / n),
*
*  (n - m) is the number of columns of N, nnz(A) / n is the average
*  number of non-zeros in one column of A and, therefore, of N.
*
*  2. The simplex table row is computed as part of a linear combination
*     of rows of A with coefficients rho[i] != 0. The estimated number
*     of operations in this case is:
*
*        n2 = nnz(rho) * (nnz(A) / m),
*
*     where nnz(rho) is the number of non-zeros in the vector rho,
*     nnz(A) / m is the average number of non-zeros in one row of A.
*
*  If n1 < n2, the routine computes the simples table row using the
*  first way (like the routine spx_eval_trow). Otherwise, the routine
*  uses the second way calling the routine spx_nt_prod1.
*
*  On exit components of the simplex table row are stored in the array
*  locations trow[1], ... trow[n-m]. */

void spx_eval_trow1(SPXLP *lp, SPXAT *at, const double rho[/*1+m*/],
      double trow[/*1+n-m*/])
{     int m = lp->m;
      int n = lp->n;
      int nnz = lp->nnz;
      int i, j, nnz_rho;
      double cnt1, cnt2;
      /* determine nnz(rho) */
      nnz_rho = 0;
      for (i = 1; i <= m; i++)
      {  if (rho[i] != 0.0)
            nnz_rho++;
      }
      /* estimate the number of operations for both ways */
      cnt1 = (double)(n - m) * ((double)nnz / (double)n);
      cnt2 = (double)nnz_rho * ((double)nnz / (double)m);
      /* compute i-th row of simplex table */
      if (cnt1 < cnt2)
      {  /* as inner products */
         int *A_ptr = lp->A_ptr;
         int *A_ind = lp->A_ind;
         double *A_val = lp->A_val;
         int *head = lp->head;
         int k, ptr, end;
         double tij;
         for (j = 1; j <= n-m; j++)
         {  k = head[m+j]; /* x[k] = xN[j] */
            /* compute t[i,j] = - N'[j] * pi */
            tij = 0.0;
            ptr = A_ptr[k];
            end = A_ptr[k+1];
            for (; ptr < end; ptr++)
               tij -= A_val[ptr] * rho[A_ind[ptr]];
            trow[j] = tij;
         }
      }
      else
      {  /* as linear combination */
         spx_nt_prod1(lp, at, trow, 1, -1.0, rho);
      }
      return;
}

/***********************************************************************
*  spx_free_at - deallocate constraint matrix in sparse row-wise format
*
*  This routine deallocates the memory used for arrays of the program
*  object at. */

void spx_free_at(SPXLP *lp, SPXAT *at)
{     xassert(lp == lp);
      tfree(at->ptr);
      tfree(at->ind);
      tfree(at->val);
      tfree(at->work);
      return;
}


struct SPXNT
{     /* mx(n-m)-matrix N composed of non-basic columns of constraint
       * matrix A, in sparse row-wise format */
      int *ptr; /* int ptr[1+m]; */
      /* ptr[0] is not used;
       * ptr[i], 1 <= i <= m, is starting position of i-th row in
       * arrays ind and val; note that ptr[1] is always 1;
       * these starting positions are set up *once* as if they would
       * correspond to rows of matrix A stored without gaps, i.e.
       * ptr[i+1] - ptr[i] is the number of non-zeros in i-th (i < m)
       * row of matrix A, and (nnz+1) - ptr[m] is the number of
       * non-zero in m-th (last) row of matrix A, where nnz is the
       * total number of non-zeros in matrix A */
      int *len; /* int len[1+m]; */
      /* len[0] is not used;
       * len[i], 1 <= i <= m, is the number of non-zeros in i-th row
       * of current matrix N */
      int *ind; /* int ind[1+nnz]; */
      /* column indices */
      double *val; /* double val[1+nnz]; */
      /* non-zero element values */
};
typedef struct SPXNT SPXNT;

#define spx_alloc_nt _glp_spx_alloc_nt
void spx_alloc_nt(SPXLP *lp, SPXNT *nt);
/* allocate matrix N in sparse row-wise format */

#define spx_init_nt _glp_spx_init_nt
void spx_init_nt(SPXLP *lp, SPXNT *nt);
/* initialize row pointers for matrix N */

#define spx_nt_add_col _glp_spx_nt_add_col
void spx_nt_add_col(SPXLP *lp, SPXNT *nt, int j, int k);
/* add column N[j] = A[k] */

#define spx_build_nt _glp_spx_build_nt
void spx_build_nt(SPXLP *lp, SPXNT *nt);
/* build matrix N for current basis */

#define spx_nt_del_col _glp_spx_nt_del_col
void spx_nt_del_col(SPXLP *lp, SPXNT *nt, int j, int k);
/* remove column N[j] = A[k] from matrix N */

#define spx_update_nt _glp_spx_update_nt
void spx_update_nt(SPXLP *lp, SPXNT *nt, int p, int q);
/* update matrix N for adjacent basis */

#define spx_nt_prod _glp_spx_nt_prod
void spx_nt_prod(SPXLP *lp, SPXNT *nt, double y[/*1+n-m*/], int ign,
      double s, const double x[/*1+m*/]);
/* compute product y := y + s * N'* x */

#if 1 /* 31/III-2016 */
void spx_nt_prod_s(SPXLP *lp, SPXNT *nt, FVS *y, int ign, double s,
      const FVS *x, double eps);
/* sparse version of spx_nt_prod */
#endif

#define spx_free_nt _glp_spx_free_nt
void spx_free_nt(SPXLP *lp, SPXNT *nt);
/* deallocate matrix N in sparse row-wise format */





/***********************************************************************
*  spx_alloc_nt - allocate matrix N in sparse row-wise format
*
*  This routine allocates the memory for arrays needed to represent the
*  matrix N composed of non-basic columns of the constraint matrix A. */

void spx_alloc_nt(SPXLP *lp, SPXNT *nt)
{     int m = lp->m;
      int nnz = lp->nnz;
      nt->ptr = talloc(1+m, int);
      nt->len = talloc(1+m, int);
      nt->ind = talloc(1+nnz, int);
      nt->val = talloc(1+nnz, double);
      return;
}

/***********************************************************************
*  spx_init_nt - initialize row pointers for matrix N
*
*  This routine initializes (sets up) row pointers for the matrix N
*  using column-wise representation of the constraint matrix A.
*
*  This routine needs to be called only once. */

void spx_init_nt(SPXLP *lp, SPXNT *nt)
{     int m = lp->m;
      int n = lp->n;
      int nnz = lp->nnz;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      int *NT_ptr = nt->ptr;
      int *NT_len = nt->len;
      int i, k, ptr, end;
      /* calculate NT_len[i] = maximal number of non-zeros in i-th row
       * of N = number of non-zeros in i-th row of A */
      memset(&NT_len[1], 0, m * sizeof(int));
      for (k = 1; k <= n; k++)
      {  ptr = A_ptr[k];
         end = A_ptr[k+1];
         for (; ptr < end; ptr++)
            NT_len[A_ind[ptr]]++;
      }
      /* initialize row pointers NT_ptr[i], i = 1,...,n-m */
      NT_ptr[1] = 1;
      for (i = 2; i <= m; i++)
         NT_ptr[i] = NT_ptr[i-1] + NT_len[i-1];
      xassert(NT_ptr[m] + NT_len[m] == nnz+1);
      return;
}

/***********************************************************************
*  spx_nt_add_col - add column N[j] = A[k] to matrix N
*
*  This routine adds elements of column N[j] = A[k], 1 <= j <= n-m,
*  1 <= k <= n, to the row-wise represntation of the matrix N. It is
*  assumed (with no check) that elements of the specified column are
*  missing in the row-wise represntation of N. */

void spx_nt_add_col(SPXLP *lp, SPXNT *nt, int j, int k)
{     int m = lp->m;
      int n = lp->n;
      int nnz = lp->nnz;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      double *A_val = lp->A_val;
      int *NT_ptr = nt->ptr;
      int *NT_len = nt->len;
      int *NT_ind = nt->ind;
      double *NT_val = nt->val;
      int i, ptr, end, pos;
      xassert(1 <= j && j <= n-m);
      xassert(1 <= k && k <= n);
      ptr = A_ptr[k];
      end = A_ptr[k+1];
      for (; ptr < end; ptr++)
      {  i = A_ind[ptr];
         /* add element N[i,j] = A[i,k] to i-th row of matrix N */
         pos = NT_ptr[i] + (NT_len[i]++);
         if (i < m)
            xassert(pos < NT_ptr[i+1]);
         else
            xassert(pos <= nnz);
         NT_ind[pos] = j;
         NT_val[pos] = A_val[ptr];
      }
      return;
}

/***********************************************************************
*  spx_build_nt - build matrix N for current basis
*
*  This routine builds the row-wise represntation of the matrix N
*  for the current basis by adding columns of the constraint matrix A
*  corresponding to non-basic variables. */

void spx_build_nt(SPXLP *lp, SPXNT *nt)
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      int *NT_len = nt->len;
      int j, k;
      /* N := 0 */
      memset(&NT_len[1], 0, m * sizeof(int));
      /* add non-basic columns N[j] = A[k] */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         spx_nt_add_col(lp, nt, j, k);
      }
      return;
}

/***********************************************************************
*  spx_nt_del_col - remove column N[j] = A[k] from matrix N
*
*  This routine removes elements of column N[j] = A[k], 1 <= j <= n-m,
*  1 <= k <= n, from the row-wise representation of the matrix N. It is
*  assumed (with no check) that elements of the specified column are
*  present in the row-wise representation of N. */

void spx_nt_del_col(SPXLP *lp, SPXNT *nt, int j, int k)
{     int m = lp->m;
      int n = lp->n;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      int *NT_ptr = nt->ptr;
      int *NT_len = nt->len;
      int *NT_ind = nt->ind;
      double *NT_val = nt->val;
      int i, ptr, end, ptr1, end1;
      xassert(1 <= j && j <= n-m);
      xassert(1 <= k && k <= n);
      ptr = A_ptr[k];
      end = A_ptr[k+1];
      for (; ptr < end; ptr++)
      {  i = A_ind[ptr];
         /* find element N[i,j] = A[i,k] in i-th row of matrix N */
         ptr1 = NT_ptr[i];
         end1 = ptr1 + NT_len[i];
         for (; NT_ind[ptr1] != j; ptr1++)
            /* nop */;
         xassert(ptr1 < end1);
         /* and remove it from i-th row element list */
         NT_len[i]--;
         NT_ind[ptr1] = NT_ind[end1-1];
         NT_val[ptr1] = NT_val[end1-1];
      }
      return;
}

/***********************************************************************
*  spx_update_nt - update matrix N for adjacent basis
*
*  This routine updates the row-wise represntation of matrix N for
*  the adjacent basis, where column N[q], 1 <= q <= n-m, is replaced by
*  column B[p], 1 <= p <= m, of the current basis matrix B. */

void spx_update_nt(SPXLP *lp, SPXNT *nt, int p, int q)
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n-m);
      /* remove old column N[q] corresponding to variable xN[q] */
      spx_nt_del_col(lp, nt, q, head[m+q]);
      /* add new column N[q] corresponding to variable xB[p] */
      spx_nt_add_col(lp, nt, q, head[p]);
      return;
}

/***********************************************************************
*  spx_nt_prod - compute product y := y + s * N'* x
*
*  This routine computes the product:
*
*     y := y + s * N'* x,
*
*  where N' is a matrix transposed to the mx(n-m)-matrix N composed
*  from non-basic columns of the constraint matrix A, x is a m-vector,
*  s is a scalar, y is (n-m)-vector.
*
*  If the flag ign is non-zero, the routine ignores the input content
*  of the array y assuming that y = 0.
*
*  The routine uses the row-wise representation of the matrix N and
*  computes the product as a linear combination:
*
*     y := y + s * (N'[1] * x[1] + ... + N'[m] * x[m]),
*
*  where N'[i] is i-th row of N, 1 <= i <= m. */

void spx_nt_prod(SPXLP *lp, SPXNT *nt, double y[/*1+n-m*/], int ign,
      double s, const double x[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      int *NT_ptr = nt->ptr;
      int *NT_len = nt->len;
      int *NT_ind = nt->ind;
      double *NT_val = nt->val;
      int i, j, ptr, end;
      double t;
      if (ign)
      {  /* y := 0 */
         for (j = 1; j <= n-m; j++)
            y[j] = 0.0;
      }
      for (i = 1; i <= m; i++)
      {  if (x[i] != 0.0)
         {  /* y := y + s * (i-th row of N) * x[i] */
            t = s * x[i];
            ptr = NT_ptr[i];
            end = ptr + NT_len[i];
            for (; ptr < end; ptr++)
               y[NT_ind[ptr]] += NT_val[ptr] * t;
         }
      }
      return;
}

#if 1 /* 31/III-2016 */
void spx_nt_prod_s(SPXLP *lp, SPXNT *nt, FVS *y, int ign, double s,
      const FVS *x, double eps)
{     /* sparse version of spx_nt_prod */
      int *NT_ptr = nt->ptr;
      int *NT_len = nt->len;
      int *NT_ind = nt->ind;
      double *NT_val = nt->val;
      int *x_ind = x->ind;
      double *x_vec = x->vec;
      int *y_ind = y->ind;
      double *y_vec = y->vec;
      int i, j, k, nnz, ptr, end;
      double t;
      xassert(x->n == lp->m);
      xassert(y->n == lp->n-lp->m);
      if (ign)
      {  /* y := 0 */
         fvs_clear_vec(y);
      }
      nnz = y->nnz;
      for (k = x->nnz; k >= 1; k--)
      {  i = x_ind[k];
         /* y := y + s * (i-th row of N) * x[i] */
         t = s * x_vec[i];
         ptr = NT_ptr[i];
         end = ptr + NT_len[i];
         for (; ptr < end; ptr++)
         {  j = NT_ind[ptr];
            if (y_vec[j] == 0.0)
               y_ind[++nnz] = j;
            y_vec[j] += NT_val[ptr] * t;
            /* don't forget about numeric cancellation */
            if (y_vec[j] == 0.0)
               y_vec[j] = DBL_MIN;
         }
      }
      y->nnz = nnz;
      fvs_adjust_vec(y, eps);
      return;
}
#endif

/***********************************************************************
*  spx_free_nt - deallocate matrix N in sparse row-wise format
*
*  This routine deallocates the memory used for arrays of the program
*  object nt. */

void spx_free_nt(SPXLP *lp, SPXNT *nt)
{     xassert(lp == lp);
      tfree(nt->ptr);
      tfree(nt->len);
      tfree(nt->ind);
      tfree(nt->val);
      return;
}
#define spx_chuzr_std _glp_spx_chuzr_std
int spx_chuzr_std(SPXLP *lp, int phase, const double beta[/*1+m*/],
      int q, double s, const double tcol[/*1+m*/], int *p_flag,
      double tol_piv, double tol, double tol1);
/* choose basic variable (textbook ratio test) */

#define spx_chuzr_harris _glp_spx_chuzr_harris
int spx_chuzr_harris(SPXLP *lp, int phase, const double beta[/*1+m*/],
      int q, double s, const double tcol[/*1+m*/], int *p_flag,
      double tol_piv, double tol, double tol1);
/* choose basic variable (Harris' ratio test) */








#define spx_chuzc_sel _glp_spx_chuzc_sel
int spx_chuzc_sel(SPXLP *lp, const double d[/*1+n-m*/], double tol,
      double tol1, int list[/*1+n-m*/]);
/* select eligible non-basic variables */

#define spx_chuzc_std _glp_spx_chuzc_std
int spx_chuzc_std(SPXLP *lp, const double d[/*1+n-m*/], int num,
      const int list[]);
/* choose non-basic variable (Dantzig's rule) */

typedef struct SPXSE SPXSE;

struct SPXSE
{     /* projected steepest edge and Devex pricing data block */
      int valid;
      /* content validity flag */
      char *refsp; /* char refsp[1+n]; */
      /* refsp[0] is not used;
       * refsp[k], 1 <= k <= n, is the flag meaning that variable x[k]
       * is in the reference space */
      double *gamma; /* double gamma[1+n-m]; */
      /* gamma[0] is not used;
       * gamma[j], 1 <= j <= n-m, is the weight for reduced cost d[j]
       * of non-basic variable xN[j] in the current basis */
      double *work; /* double work[1+m]; */
      /* working array */
};

#define spx_alloc_se _glp_spx_alloc_se
void spx_alloc_se(SPXLP *lp, SPXSE *se);
/* allocate pricing data block */

#define spx_reset_refsp _glp_spx_reset_refsp
void spx_reset_refsp(SPXLP *lp, SPXSE *se);
/* reset reference space */

#define spx_eval_gamma_j _glp_spx_eval_gamma_j
double spx_eval_gamma_j(SPXLP *lp, SPXSE *se, int j);
/* compute projeted steepest edge weight directly */

#define spx_chuzc_pse _glp_spx_chuzc_pse
int spx_chuzc_pse(SPXLP *lp, SPXSE *se, const double d[/*1+n-m*/],
      int num, const int list[]);
/* choose non-basic variable (projected steepest edge) */

#define spx_update_gamma _glp_spx_update_gamma
double spx_update_gamma(SPXLP *lp, SPXSE *se, int p, int q,
      const double trow[/*1+n-m*/], const double tcol[/*1+m*/]);
/* update projected steepest edge weights exactly */

#define spx_free_se _glp_spx_free_se
void spx_free_se(SPXLP *lp, SPXSE *se);
/* deallocate pricing data block */




int spx_chuzc_sel(SPXLP *lp, const double d[/*1+n-m*/], double tol,
      double tol1, int list[/*1+n-m*/])
{     int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int j, k, num;
      double ck, eps;
      num = 0;
      /* walk thru list of non-basic variables */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         if (l[k] == u[k])
         {  /* xN[j] is fixed variable; skip it */
            continue;
         }
         /* determine absolute tolerance eps[j] */
         ck = c[k];
         eps = tol + tol1 * (ck >= 0.0 ? +ck : -ck);
         /* check if xN[j] is eligible */
         if (d[j] <= -eps)
         {  /* xN[j] should be able to increase */
            if (flag[j])
            {  /* but its upper bound is active */
               continue;
            }
         }
         else if (d[j] >= +eps)
         {  /* xN[j] should be able to decrease */
            if (!flag[j] && l[k] != -DBL_MAX)
            {  /* but its lower bound is active */
               continue;
            }
         }
         else /* -eps < d[j] < +eps */
         {  /* xN[j] does not affect the objective function within the
             * specified tolerance */
            continue;
         }
         /* xN[j] is eligible non-basic variable */
         num++;
         if (list != NULL)
            list[num] = j;
      }
      return num;
}

/***********************************************************************
*  spx_chuzc_std - choose non-basic variable (Dantzig's rule)
*
*  This routine chooses most eligible non-basic variable xN[q]
*  according to Dantzig's ("standard") rule:
*
*     d[q] =   max |d[j]|,
*            j in J
*
*  where J <= {1, ..., n-m} is the set of indices of eligible non-basic
*  variables, d[j] is the reduced cost of non-basic variable xN[j] in
*  the current basis.
*
*  Reduced costs of non-basic variables should be placed in the array
*  locations d[1], ..., d[n-m].
*
*  Indices of eligible non-basic variables j in J should be placed in
*  the array locations list[1], ..., list[num], where num = |J| > 0 is
*  the total number of such variables.
*
*  On exit the routine returns q, the index of the non-basic variable
*  xN[q] chosen. */

int spx_chuzc_std(SPXLP *lp, const double d[/*1+n-m*/], int num,
      const int list[])
{     int m = lp->m;
      int n = lp->n;
      int j, q, t;
      double abs_dj, abs_dq;
      xassert(0 < num && num <= n-m);
      q = 0, abs_dq = -1.0;
      for (t = 1; t <= num; t++)
      {  j = list[t];
         abs_dj = (d[j] >= 0.0 ? +d[j] : -d[j]);
         if (abs_dq < abs_dj)
            q = j, abs_dq = abs_dj;
      }
      xassert(q != 0);
      return q;
}

/***********************************************************************
*  spx_alloc_se - allocate pricing data block
*
*  This routine allocates the memory for arrays used in the pricing
*  data block. */

void spx_alloc_se(SPXLP *lp, SPXSE *se)
{     int m = lp->m;
      int n = lp->n;
      se->valid = 0;
      se->refsp = talloc(1+n, char);
      se->gamma = talloc(1+n-m, double);
      se->work = talloc(1+m, double);
      return;
}

/***********************************************************************
*  spx_reset_refsp - reset reference space
*
*  This routine resets (re-initializes) the reference space composing
*  it from variables which are non-basic in the current basis, and sets
*  all weights gamma[j] to 1. */

void spx_reset_refsp(SPXLP *lp, SPXSE *se)
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *refsp = se->refsp;
      double *gamma = se->gamma;
      int j, k;
      se->valid = 1;
      memset(&refsp[1], 0, n * sizeof(char));
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         refsp[k] = 1;
         gamma[j] = 1.0;
      }
      return;
}

/***********************************************************************
*  spx_eval_gamma_j - compute projected steepest edge weight directly
*
*  This routine computes projected steepest edge weight gamma[j],
*  1 <= j <= n-m, for the current basis directly with the formula:
*
*                            m
*     gamma[j] = delta[j] + sum eta[i] * T[i,j]**2,
*                           i=1
*
*  where T[i,j] is element of the current simplex table, and
*
*                ( 1, if xB[i] is in the reference space
*     eta[i]   = {
*                ( 0, otherwise
*
*                ( 1, if xN[j] is in the reference space
*     delta[j] = {
*                ( 0, otherwise
*
*  NOTE: For testing/debugging only. */

double spx_eval_gamma_j(SPXLP *lp, SPXSE *se, int j)
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *refsp = se->refsp;
      double *tcol = se->work;
      int i, k;
      double gamma_j;
      xassert(se->valid);
      xassert(1 <= j && j <= n-m);
      k = head[m+j]; /* x[k] = xN[j] */
      gamma_j = (refsp[k] ? 1.0 : 0.0);
      spx_eval_tcol(lp, j, tcol);
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         if (refsp[k])
            gamma_j += tcol[i] * tcol[i];
      }
      return gamma_j;
}

/***********************************************************************
*  spx_chuzc_pse - choose non-basic variable (projected steepest edge)
*
*  This routine chooses most eligible non-basic variable xN[q]
*  according to the projected steepest edge method:
*
*      d[q]**2           d[j]**2
*     -------- =   max  -------- ,
*     gamma[q]   j in J gamma[j]
*
*  where J <= {1, ..., n-m} is the set of indices of eligible non-basic
*  variable, d[j] is the reduced cost of non-basic variable xN[j] in
*  the current basis, gamma[j] is the projected steepest edge weight.
*
*  Reduced costs of non-basic variables should be placed in the array
*  locations d[1], ..., d[n-m].
*
*  Indices of eligible non-basic variables j in J should be placed in
*  the array locations list[1], ..., list[num], where num = |J| > 0 is
*  the total number of such variables.
*
*  On exit the routine returns q, the index of the non-basic variable
*  xN[q] chosen. */

int spx_chuzc_pse(SPXLP *lp, SPXSE *se, const double d[/*1+n-m*/],
      int num, const int list[])
{     int m = lp->m;
      int n = lp->n;
      double *gamma = se->gamma;
      int j, q, t;
      double best, temp;
      xassert(se->valid);
      xassert(0 < num && num <= n-m);
      q = 0, best = -1.0;
      for (t = 1; t <= num; t++)
      {  j = list[t];
         /* FIXME */
         if (gamma[j] < DBL_EPSILON)
            temp = 0.0;
         else
            temp = (d[j] * d[j]) / gamma[j];
         if (best < temp)
            q = j, best = temp;
      }
      xassert(q != 0);
      return q;
}

/***********************************************************************
*  spx_update_gamma - update projected steepest edge weights exactly
*
*  This routine updates the vector gamma = (gamma[j]) of projected
*  steepest edge weights exactly, for the adjacent basis.
*
*  On entry to the routine the content of the se object should be valid
*  and should correspond to the current basis.
*
*  The parameter 1 <= p <= m specifies basic variable xB[p] which
*  becomes non-basic variable xN[q] in the adjacent basis.
*
*  The parameter 1 <= q <= n-m specified non-basic variable xN[q] which
*  becomes basic variable xB[p] in the adjacent basis.
*
*  It is assumed that the array trow contains elements of p-th (pivot)
*  row T'[p] of the simplex table in locations trow[1], ..., trow[n-m].
*  It is also assumed that the array tcol contains elements of q-th
*  (pivot) column T[q] of the simple table in locations tcol[1], ...,
*  tcol[m]. (These row and column should be computed for the current
*  basis.)
*
*  For details about the formulae used see the program documentation.
*
*  The routine also computes the relative error:
*
*     e = |gamma[q] - gamma'[q]| / (1 + |gamma[q]|),
*
*  where gamma'[q] is the weight for xN[q] on entry to the routine,
*  and returns e on exit. (If e happens to be large enough, the calling
*  program may reset the reference space, since other weights also may
*  be inaccurate.) */

double spx_update_gamma(SPXLP *lp, SPXSE *se, int p, int q,
      const double trow[/*1+n-m*/], const double tcol[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *refsp = se->refsp;
      double *gamma = se->gamma;
      double *u = se->work;
      int i, j, k, ptr, end;
      double gamma_q, delta_q, e, r, s, t1, t2;
      xassert(se->valid);
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n-m);
      /* compute gamma[q] in current basis more accurately; also
       * compute auxiliary vector u */
      k = head[m+q]; /* x[k] = xN[q] */
      gamma_q = delta_q = (refsp[k] ? 1.0 : 0.0);
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         if (refsp[k])
         {  gamma_q += tcol[i] * tcol[i];
            u[i] = tcol[i];
         }
         else
            u[i] = 0.0;
      }
      bfd_btran(lp->bfd, u);
      /* compute relative error in gamma[q] */
      e = fabs(gamma_q - gamma[q]) / (1.0 + gamma_q);
      /* compute new gamma[q] */
      gamma[q] = gamma_q / (tcol[p] * tcol[p]);
      /* compute new gamma[j] for all j != q */
      for (j = 1; j <= n-m; j++)
      {  if (j == q)
            continue;
         if (-1e-9 < trow[j] && trow[j] < +1e-9)
         {  /* T[p,j] is close to zero; gamma[j] is not changed */
            continue;
         }
         /* compute r[j] = T[p,j] / T[p,q] */
         r = trow[j] / tcol[p];
         /* compute inner product s[j] = N'[j] * u, where N[j] = A[k]
          * is constraint matrix column corresponding to xN[j] */
         s = 0.0;
         k = head[m+j]; /* x[k] = xN[j] */
         ptr = lp->A_ptr[k];
         end = lp->A_ptr[k+1];
         for (; ptr < end; ptr++)
            s += lp->A_val[ptr] * u[lp->A_ind[ptr]];
         /* compute new gamma[j] */
         t1 = gamma[j] + r * (r * gamma_q + s + s);
         t2 = (refsp[k] ? 1.0 : 0.0) + delta_q * r * r;
         gamma[j] = (t1 >= t2 ? t1 : t2);
      }
      return e;
}

/***********************************************************************
*  spx_free_se - deallocate pricing data block
*
*  This routine deallocates the memory used for arrays in the pricing
*  data block. */

void spx_free_se(SPXLP *lp, SPXSE *se)
{     xassert(lp == lp);
      tfree(se->refsp);
      tfree(se->gamma);
      tfree(se->work);
      return;
}
#define spx_chuzr_std _glp_spx_chuzr_std
int spx_chuzr_std(SPXLP *lp, int phase, const double beta[/*1+m*/],
      int q, double s, const double tcol[/*1+m*/], int *p_flag,
      double tol_piv, double tol, double tol1);
/* choose basic variable (textbook ratio test) */

#define spx_chuzr_harris _glp_spx_chuzr_harris
int spx_chuzr_harris(SPXLP *lp, int phase, const double beta[/*1+m*/],
      int q, double s, const double tcol[/*1+m*/], int *p_flag,
      double tol_piv, double tol, double tol1);
/* choose basic variable (Harris' ratio test) */


int spx_chuzr_std(SPXLP *lp, int phase, const double beta[/*1+m*/],
      int q, double s, const double tcol[/*1+m*/], int *p_flag,
      double tol_piv, double tol, double tol1)
{     int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      int i, i_flag, k, p;
      double alfa, biga, delta, lk, uk, teta, teta_min;
      xassert(phase == 1 || phase == 2);
      xassert(1 <= q && q <= n-m);
      xassert(s == +1.0 || s == -1.0);
      /* determine initial teta_min */
      k = head[m+q]; /* x[k] = xN[q] */
      if (l[k] == -DBL_MAX || u[k] == +DBL_MAX)
      {  /* xN[q] has no opposite bound */
         p = 0, *p_flag = 0, teta_min = DBL_MAX, biga = 0.0;
      }
      else
      {  /* xN[q] have both lower and upper bounds */
         p = -1, *p_flag = 0, teta_min = fabs(l[k] - u[k]), biga = 1.0;
      }
      /* walk thru the list of basic variables */
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         /* determine alfa such that delta xB[i] = alfa * teta */
         alfa = s * tcol[i];
         if (alfa <= -tol_piv)
         {  /* xB[i] decreases */
            /* determine actual lower bound of xB[i] */
            if (phase == 1 && c[k] < 0.0)
            {  /* xB[i] has no actual lower bound */
               continue;
            }
            else if (phase == 1 && c[k] > 0.0)
            {  /* actual lower bound of xB[i] is its upper bound */
               lk = u[k];
               xassert(lk != +DBL_MAX);
               i_flag = 1;
            }
            else
            {  /* actual lower bound of xB[i] is its original bound */
               lk = l[k];
               if (lk == -DBL_MAX)
                  continue;
               i_flag = 0;
            }
            /* determine teta on which xB[i] reaches its lower bound */
            delta = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
            if (beta[i] <= lk + delta)
               teta = 0.0;
            else
               teta = (lk - beta[i]) / alfa;
         }
         else if (alfa >= +tol_piv)
         {  /* xB[i] increases */
            /* determine actual upper bound of xB[i] */
            if (phase == 1 && c[k] < 0.0)
            {  /* actual upper bound of xB[i] is its lower bound */
               uk = l[k];
               xassert(uk != -DBL_MAX);
               i_flag = 0;
            }
            else if (phase == 1 && c[k] > 0.0)
            {  /* xB[i] has no actual upper bound */
               continue;
            }
            else
            {  /* actual upper bound of xB[i] is its original bound */
               uk = u[k];
               if (uk == +DBL_MAX)
                  continue;
               i_flag = 1;
            }
            /* determine teta on which xB[i] reaches its upper bound */
            delta = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
            if (beta[i] >= uk - delta)
               teta = 0.0;
            else
               teta = (uk - beta[i]) / alfa;
         }
         else
         {  /* xB[i] does not depend on teta */
            continue;
         }
         /* choose basic variable xB[p] for which teta is minimal */
         xassert(teta >= 0.0);
         alfa = (alfa >= 0.0 ? +alfa : -alfa);
         if (teta_min > teta || (teta_min == teta && biga < alfa))
            p = i, *p_flag = i_flag, teta_min = teta, biga = alfa;
      }
      /* if xB[p] is fixed variable, adjust its bound flag */
      if (p > 0)
      {  k = head[p];
         if (l[k] == u[k])
            *p_flag = 0;
      }
      return p;
}

/***********************************************************************
*  spx_chuzr_harris - choose basic variable (Harris' ratio test)
*
*  This routine implements Harris' ratio test to choose basic variable
*  xB[p].
*
*  All the parameters, except tol and tol1, as well as the returned
*  value have the same meaning as for the routine spx_chuzr_std (see
*  above).
*
*  The parameters tol and tol1 specify tolerances on bound violations
*  for basic variables. For the lower bound of basic variable xB[i] the
*  tolerance is delta[i] = tol + tol1 |lB[i]|, and for the upper bound
*  the tolerance is delta[i] = tol + tol1 |uB[i]|. */

int spx_chuzr_harris(SPXLP *lp, int phase, const double beta[/*1+m*/],
      int q, double s, const double tcol[/*1+m*/], int *p_flag,
      double tol_piv, double tol, double tol1)
{     int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      int i, i_flag, k, p;
      double alfa, biga, delta, lk, uk, teta, teta_min;
      xassert(phase == 1 || phase == 2);
      xassert(1 <= q && q <= n-m);
      xassert(s == +1.0 || s == -1.0);
      /*--------------------------------------------------------------*/
      /* first pass: determine teta_min for relaxed bounds            */
      /*--------------------------------------------------------------*/
      teta_min = DBL_MAX;
      /* walk thru the list of basic variables */
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         /* determine alfa such that delta xB[i] = alfa * teta */
         alfa = s * tcol[i];
         if (alfa <= -tol_piv)
         {  /* xB[i] decreases */
            /* determine actual lower bound of xB[i] */
            if (phase == 1 && c[k] < 0.0)
            {  /* xB[i] has no actual lower bound */
               continue;
            }
            else if (phase == 1 && c[k] > 0.0)
            {  /* actual lower bound of xB[i] is its upper bound */
               lk = u[k];
               xassert(lk != +DBL_MAX);
            }
            else
            {  /* actual lower bound of xB[i] is its original bound */
               lk = l[k];
               if (lk == -DBL_MAX)
                  continue;
            }
            /* determine teta on which xB[i] reaches its relaxed lower
             * bound */
            delta = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
            if (beta[i] < lk)
               teta = - delta / alfa;
            else
               teta = ((lk - delta) - beta[i]) / alfa;
         }
         else if (alfa >= +tol_piv)
         {  /* xB[i] increases */
            /* determine actual upper bound of xB[i] */
            if (phase == 1 && c[k] < 0.0)
            {  /* actual upper bound of xB[i] is its lower bound */
               uk = l[k];
               xassert(uk != -DBL_MAX);
            }
            else if (phase == 1 && c[k] > 0.0)
            {  /* xB[i] has no actual upper bound */
               continue;
            }
            else
            {  /* actual upper bound of xB[i] is its original bound */
               uk = u[k];
               if (uk == +DBL_MAX)
                  continue;
            }
            /* determine teta on which xB[i] reaches its relaxed upper
             * bound */
            delta = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
            if (beta[i] > uk)
               teta = + delta / alfa;
            else
               teta = ((uk + delta) - beta[i]) / alfa;
         }
         else
         {  /* xB[i] does not depend on teta */
            continue;
         }
         xassert(teta >= 0.0);
         if (teta_min > teta)
            teta_min = teta;
      }
      /*--------------------------------------------------------------*/
      /* second pass: choose basic variable xB[p]                     */
      /*--------------------------------------------------------------*/
      k = head[m+q]; /* x[k] = xN[q] */
      if (l[k] != -DBL_MAX && u[k] != +DBL_MAX)
      {  /* xN[q] has both lower and upper bounds */
         if (fabs(l[k] - u[k]) <= teta_min)
         {  /* and reaches its opposite bound */
            p = -1, *p_flag = 0;
            goto done;
         }
      }
      if (teta_min == DBL_MAX)
      {  /* teta may increase unlimitedly */
         p = 0, *p_flag = 0;
         goto done;
      }
      /* nothing is chosen so far */
      p = 0, *p_flag = 0, biga = 0.0;
      /* walk thru the list of basic variables */
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         /* determine alfa such that delta xB[i] = alfa * teta */
         alfa = s * tcol[i];
         if (alfa <= -tol_piv)
         {  /* xB[i] decreases */
            /* determine actual lower bound of xB[i] */
            if (phase == 1 && c[k] < 0.0)
            {  /* xB[i] has no actual lower bound */
               continue;
            }
            else if (phase == 1 && c[k] > 0.0)
            {  /* actual lower bound of xB[i] is its upper bound */
               lk = u[k];
               xassert(lk != +DBL_MAX);
               i_flag = 1;
            }
            else
            {  /* actual lower bound of xB[i] is its original bound */
               lk = l[k];
               if (lk == -DBL_MAX)
                  continue;
               i_flag = 0;
            }
            /* determine teta on which xB[i] reaches its lower bound */
            teta = (lk - beta[i]) / alfa;
         }
         else if (alfa >= +tol_piv)
         {  /* xB[i] increases */
            /* determine actual upper bound of xB[i] */
            if (phase == 1 && c[k] < 0.0)
            {  /* actual upper bound of xB[i] is its lower bound */
               uk = l[k];
               xassert(uk != -DBL_MAX);
               i_flag = 0;
            }
            else if (phase == 1 && c[k] > 0.0)
            {  /* xB[i] has no actual upper bound */
               continue;
            }
            else
            {  /* actual upper bound of xB[i] is its original bound */
               uk = u[k];
               if (uk == +DBL_MAX)
                  continue;
               i_flag = 1;
            }
            /* determine teta on which xB[i] reaches its upper bound */
            teta = (uk - beta[i]) / alfa;
         }
         else
         {  /* xB[i] does not depend on teta */
            continue;
         }
         /* choose basic variable for which teta is not greater than
          * teta_min determined for relaxed bounds and which has best
          * (largest in magnitude) pivot */
         alfa = (alfa >= 0.0 ? +alfa : -alfa);
         if (teta <= teta_min && biga < alfa)
            p = i, *p_flag = i_flag, biga = alfa;
      }
      /* something must be chosen */
      xassert(1 <= p && p <= m);
      /* if xB[p] is fixed variable, adjust its bound flag */
      k = head[p];
      if (l[k] == u[k])
         *p_flag = 0;
done: return p;
}


#define spx_init_lp _glp_spx_init_lp
void spx_init_lp(SPXLP *lp, glp_prob *P, int excl);
/* initialize working LP object */

#define spx_alloc_lp _glp_spx_alloc_lp
void spx_alloc_lp(SPXLP *lp);
/* allocate working LP arrays */

#define spx_build_lp _glp_spx_build_lp
void spx_build_lp(SPXLP *lp, glp_prob *P, int excl, int shift,
      int map[/*1+P->m+P->n*/]);
/* convert original LP to working LP */

#define spx_build_basis _glp_spx_build_basis
void spx_build_basis(SPXLP *lp, glp_prob *P, const int map[]);
/* convert original LP basis to working LP basis */

#define spx_store_basis _glp_spx_store_basis
void spx_store_basis(SPXLP *lp, glp_prob *P, const int map[],
      int daeh[/*1+n*/]);
/* convert working LP basis to original LP basis */

#define spx_store_sol _glp_spx_store_sol
void spx_store_sol(SPXLP *lp, glp_prob *P, int shift,
      const int map[], const int daeh[], const double beta[],
      const double pi[], const double d[]);
/* convert working LP solution to original LP solution */

#define spx_free_lp _glp_spx_free_lp
void spx_free_lp(SPXLP *lp);
/* deallocate working LP arrays */


void spx_init_lp(SPXLP *lp, glp_prob *P, int excl)
{     int i, j, m, n, nnz;
      m = P->m;
      xassert(m > 0);
      n = 0;
      nnz = P->nnz;
      xassert(P->valid);
      /* scan rows of original LP */
      for (i = 1; i <= m; i++)
      {  GLPROW *row = P->row[i];
         if (excl && row->stat == GLP_NS)
         {  /* skip non-basic fixed auxiliary variable */
            /* nop */
         }
         else
         {  /* include auxiliary variable in working LP */
            n++;
            nnz++; /* unity column */
         }
      }
      /* scan columns of original LP */
      for (j = 1; j <= P->n; j++)
      {  GLPCOL *col = P->col[j];
         if (excl && col->stat == GLP_NS)
         {  /* skip non-basic fixed structural variable */
            GLPAIJ *aij;
            for (aij = col->ptr; aij != NULL; aij = aij->c_next)
               nnz--;
         }
         else
         {  /* include structural variable in working LP */
            n++;
         }
      }
      /* initialize working LP data block */
      memset(lp, 0, sizeof(SPXLP));
      lp->m = m;
      xassert(n > 0);
      lp->n = n;
      lp->nnz = nnz;
      return;
}

/***********************************************************************
*  spx_alloc_lp - allocate working LP arrays
*
*  This routine allocates the memory for all arrays in the working LP
*  object. */

void spx_alloc_lp(SPXLP *lp)
{     int m = lp->m;
      int n = lp->n;
      int nnz = lp->nnz;
      lp->A_ptr = talloc(1+n+1, int);
      lp->A_ind = talloc(1+nnz, int);
      lp->A_val = talloc(1+nnz, double);
      lp->b = talloc(1+m, double);
      lp->c = talloc(1+n, double);
      lp->l = talloc(1+n, double);
      lp->u = talloc(1+n, double);
      lp->head = talloc(1+n, int);
      lp->flag = talloc(1+n-m, char);
      return;
}

/***********************************************************************
*  spx_build_lp - convert original LP to working LP
*
*  This routine converts components (except the current basis) of the
*  original LP to components of the working LP and perform scaling of
*  these components. Also, if the original LP is maximization, the
*  routine changes the signs of the objective coefficients and constant
*  term to opposite ones.
*
*  If the flag excl is set, original non-basic fixed variables are
*  *not* included in the working LP. Otherwise, all (auxiliary and
*  structural) original variables are included in the working LP. Note
*  that this flag should have the same value as it has in a call to the
*  routine spx_init_lp.
*
*  If the flag shift is set, the routine shift bounds of variables
*  included in the working LP to make at least one bound to be zero.
*  If a variable has both lower and upper bounds, the bound having
*  smaller magnitude is shifted to zero.
*
*  On exit the routine stores information about correspondence between
*  numbers of variables in the original and working LPs to the array
*  map, which should have 1+P->m+P->n locations (location [0] is not
*  used), where P->m is the numbers of rows and P->n is the number of
*  columns in the original LP:
*
*  map[i] = +k, 1 <= i <= P->m, means that i-th auxiliary variable of
*  the original LP corresponds to variable x[k] of the working LP;
*
*  map[i] = -k, 1 <= i <= P->m, means that i-th auxiliary variable of
*  the original LP corresponds to variable x[k] of the working LP, and
*  the upper bound of that variable was shifted to zero;
*
*  map[i] = 0, 1 <= i <= P->m, means that i-th auxiliary variable of
*  the original LP was excluded from the working LP;
*
*  map[P->m+j], 1 <= j <= P->n, has the same sense as above, however,
*  for j-th structural variable of the original LP. */

void spx_build_lp(SPXLP *lp, glp_prob *P, int excl, int shift,
      int map[/*1+P->m+P->n*/])
{     int m = lp->m;
      int n = lp->n;
      int nnz = lp->nnz;
      int *A_ptr = lp->A_ptr;
      int *A_ind = lp->A_ind;
      double *A_val = lp->A_val;
      double *b = lp->b;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int i, j, k, kk, ptr, end;
      double dir, delta;
      /* working LP is always minimization */
      switch (P->dir)
      {  case GLP_MIN:
            dir = +1.0;
            break;
         case GLP_MAX:
            dir = -1.0;
            break;
         default:
            xassert(P != P);
      }
      /* initialize constant term of the objective */
      c[0] = dir * P->c0;
      k = 0; /* number of variable in working LP */
      ptr = 1; /* current available position in A_ind/A_val */
      /* process rows of original LP */
      xassert(P->m == m);
      for (i = 1; i <= m; i++)
      {  GLPROW *row = P->row[i];
         if (excl && row->stat == GLP_NS)
         {  /* i-th auxiliary variable is non-basic and fixed */
            /* substitute its scaled value in working LP */
            xassert(row->type == GLP_FX);
            map[i] = 0;
            b[i] = - row->lb * row->rii;
         }
         else
         {  /* include i-th auxiliary variable in working LP */
            map[i] = ++k;
            /* setup k-th column of working constraint matrix which is
             * i-th column of unity matrix */
            A_ptr[k] = ptr;
            A_ind[ptr] = i;
            A_val[ptr] = 1.0;
            ptr++;
            /* initialize right-hand side of i-th equality constraint
             * and setup zero objective coefficient at variable x[k] */
            b[i] = c[k] = 0.0;
            /* setup scaled bounds of variable x[k] */
            switch (row->type)
            {  case GLP_FR:
                  l[k] = -DBL_MAX, u[k] = +DBL_MAX;
                  break;
               case GLP_LO:
                  l[k] = row->lb * row->rii, u[k] = +DBL_MAX;
                  break;
               case GLP_UP:
                  l[k] = -DBL_MAX, u[k] = row->ub * row->rii;
                  break;
               case GLP_DB:
                  l[k] = row->lb * row->rii, u[k] = row->ub * row->rii;
                  xassert(l[k] != u[k]);
                  break;
               case GLP_FX:
                  l[k] = u[k] = row->lb * row->rii;
                  break;
               default:
                  xassert(row != row);
            }
         }
      }
      /* process columns of original LP */
      for (j = 1; j <= P->n; j++)
      {  GLPCOL *col = P->col[j];
         GLPAIJ *aij;
         if (excl && col->stat == GLP_NS)
         {  /* j-th structural variable is non-basic and fixed */
            /* substitute its scaled value in working LP */
            xassert(col->type == GLP_FX);
            map[m+j] = 0;
            if (col->lb != 0.0)
            {  /* (note that sjj scale factor is cancelled) */
               for (aij = col->ptr; aij != NULL; aij = aij->c_next)
                  b[aij->row->i] +=
                     (aij->row->rii * aij->val) * col->lb;
               c[0] += (dir * col->coef) * col->lb;
            }
         }
         else
         {  /* include j-th structural variable in working LP */
            map[m+j] = ++k;
            /* setup k-th column of working constraint matrix which is
             * scaled j-th column of original constraint matrix (-A) */
            A_ptr[k] = ptr;
            for (aij = col->ptr; aij != NULL; aij = aij->c_next)
            {  A_ind[ptr] = aij->row->i;
               A_val[ptr] = - aij->row->rii * aij->val * col->sjj;
               ptr++;
            }
            /* setup scaled objective coefficient at variable x[k] */
            c[k] = dir * col->coef * col->sjj;
            /* setup scaled bounds of variable x[k] */
            switch (col->type)
            {  case GLP_FR:
                  l[k] = -DBL_MAX, u[k] = +DBL_MAX;
                  break;
               case GLP_LO:
                  l[k] = col->lb / col->sjj, u[k] = +DBL_MAX;
                  break;
               case GLP_UP:
                  l[k] = -DBL_MAX, u[k] = col->ub / col->sjj;
                  break;
               case GLP_DB:
                  l[k] = col->lb / col->sjj, u[k] = col->ub / col->sjj;
                  xassert(l[k] != u[k]);
                  break;
               case GLP_FX:
                  l[k] = u[k] = col->lb / col->sjj;
                  break;
               default:
                  xassert(col != col);
            }
         }
      }
      xassert(k == n);
      xassert(ptr == nnz+1);
      A_ptr[n+1] = ptr;
      /* shift bounds of all variables of working LP (optionally) */
      if (shift)
      {  for (kk = 1; kk <= m+P->n; kk++)
         {  k = map[kk];
            if (k == 0)
            {  /* corresponding original variable was excluded */
               continue;
            }
            /* shift bounds of variable x[k] */
            if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)
            {  /* x[k] is unbounded variable */
               delta = 0.0;
            }
            else if (l[k] != -DBL_MAX && u[k] == +DBL_MAX)
            {  /* shift lower bound to zero */
               delta = l[k];
               l[k] = 0.0;
            }
            else if (l[k] == -DBL_MAX && u[k] != +DBL_MAX)
            {  /* shift upper bound to zero */
               map[kk] = -k;
               delta = u[k];
               u[k] = 0.0;
            }
            else if (l[k] != u[k])
            {  /* x[k] is double bounded variable */
               if (fabs(l[k]) <= fabs(u[k]))
               {  /* shift lower bound to zero */
                  delta = l[k];
                  l[k] = 0.0, u[k] -= delta;
               }
               else
               {  /* shift upper bound to zero */
                  map[kk] = -k;
                  delta = u[k];
                  l[k] -= delta, u[k] = 0.0;
               }
               xassert(l[k] != u[k]);
            }
            else
            {  /* shift fixed value to zero */
               delta = l[k];
               l[k] = u[k] = 0.0;
            }
            /* substitute x[k] = x'[k] + delta into all constraints
             * and the objective function of working LP */
            if (delta != 0.0)
            {  ptr = A_ptr[k];
               end = A_ptr[k+1];
               for (; ptr < end; ptr++)
                  b[A_ind[ptr]] -= A_val[ptr] * delta;
               c[0] += c[k] * delta;
            }
         }
      }
      return;
}

/***********************************************************************
*  spx_build_basis - convert original LP basis to working LP basis
*
*  This routine converts the current basis of the original LP to
*  corresponding initial basis of the working LP, and moves the basis
*  factorization driver from the original LP object to the working LP
*  object.
*
*  The array map should contain information provided by the routine
*  spx_build_lp. */

void spx_build_basis(SPXLP *lp, glp_prob *P, const int map[])
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *flag = lp->flag;
      int i, j, k, ii, jj;
      /* original basis factorization should be valid that guarantees
       * the basis is correct */
      xassert(P->m == m);
      xassert(P->valid);
      /* initialize basis header for working LP */
      memset(&head[1], 0, m * sizeof(int));
      jj = 0;
      /* scan rows of original LP */
      xassert(P->m == m);
      for (i = 1; i <= m; i++)
      {  GLPROW *row = P->row[i];
         /* determine ordinal number of x[k] in working LP */
         if ((k = map[i]) < 0)
            k = -k;
         if (k == 0)
         {  /* corresponding original variable was excluded */
            continue;
         }
         xassert(1 <= k && k <= n);
         if (row->stat == GLP_BS)
         {  /* x[k] is basic variable xB[ii] */
            ii = row->bind;
            xassert(1 <= ii && ii <= m);
            xassert(head[ii] == 0);
            head[ii] = k;
         }
         else
         {  /* x[k] is non-basic variable xN[jj] */
            jj++;
            head[m+jj] = k;
            flag[jj] = (row->stat == GLP_NU);
         }
      }
      /* scan columns of original LP */
      for (j = 1; j <= P->n; j++)
      {  GLPCOL *col = P->col[j];
         /* determine ordinal number of x[k] in working LP */
         if ((k = map[m+j]) < 0)
            k = -k;
         if (k == 0)
         {  /* corresponding original variable was excluded */
            continue;
         }
         xassert(1 <= k && k <= n);
         if (col->stat == GLP_BS)
         {  /* x[k] is basic variable xB[ii] */
            ii = col->bind;
            xassert(1 <= ii && ii <= m);
            xassert(head[ii] == 0);
            head[ii] = k;
         }
         else
         {  /* x[k] is non-basic variable xN[jj] */
            jj++;
            head[m+jj] = k;
            flag[jj] = (col->stat == GLP_NU);
         }
      }
      xassert(m+jj == n);
      /* acquire basis factorization */
      lp->valid = 1;
      lp->bfd = P->bfd;
      P->valid = 0;
      P->bfd = NULL;
      return;
}

/***********************************************************************
*  spx_store_basis - convert working LP basis to original LP basis
*
*  This routine converts the current working LP basis to corresponding
*  original LP basis. This operations includes determining and setting
*  statuses of all rows (auxiliary variables) and columns (structural
*  variables), and building the basis header.
*
*  The array map should contain information provided by the routine
*  spx_build_lp.
*
*  On exit the routine fills the array daeh. This array should have
*  1+lp->n locations (location [0] is not used) and contain the inverse
*  of the working basis header lp->head, i.e. head[k'] = k means that
*  daeh[k] = k'. */

void spx_store_basis(SPXLP *lp, glp_prob *P, const int map[],
      int daeh[/*1+n*/])
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *flag = lp->flag;
      int i, j, k, kk;
      /* determine inverse of working basis header */
      for (kk = 1; kk <= n; kk++)
         daeh[head[kk]] = kk;
      /* set row statuses */
      xassert(P->m == m);
      for (i = 1; i <= m; i++)
      {  GLPROW *row = P->row[i];
         if ((k = map[i]) < 0)
            k = -k;
         if (k == 0)
         {  /* non-basic fixed auxiliary variable was excluded */
            xassert(row->type == GLP_FX);
            row->stat = GLP_NS;
            row->bind = 0;
         }
         else
         {  /* auxiliary variable corresponds to variable x[k] */
            kk = daeh[k];
            if (kk <= m)
            {  /* x[k] = xB[kk] */
               P->head[kk] = i;
               row->stat = GLP_BS;
               row->bind = kk;
            }
            else
            {  /* x[k] = xN[kk-m] */
               switch (row->type)
               {  case GLP_FR:
                     row->stat = GLP_NF;
                     break;
                  case GLP_LO:
                     row->stat = GLP_NL;
                     break;
                  case GLP_UP:
                     row->stat = GLP_NU;
                     break;
                  case GLP_DB:
                     row->stat = (flag[kk-m] ? GLP_NU : GLP_NL);
                     break;
                  case GLP_FX:
                     row->stat = GLP_NS;
                     break;
                  default:
                     xassert(row != row);
               }
               row->bind = 0;
            }
         }
      }
      /* set column statuses */
      for (j = 1; j <= P->n; j++)
      {  GLPCOL *col = P->col[j];
         if ((k = map[m+j]) < 0)
            k = -k;
         if (k == 0)
         {  /* non-basic fixed structural variable was excluded */
            xassert(col->type == GLP_FX);
            col->stat = GLP_NS;
            col->bind = 0;
         }
         else
         {  /* structural variable corresponds to variable x[k] */
            kk = daeh[k];
            if (kk <= m)
            {  /* x[k] = xB[kk] */
               P->head[kk] = m+j;
               col->stat = GLP_BS;
               col->bind = kk;
            }
            else
            {  /* x[k] = xN[kk-m] */
               switch (col->type)
               {  case GLP_FR:
                     col->stat = GLP_NF;
                     break;
                  case GLP_LO:
                     col->stat = GLP_NL;
                     break;
                  case GLP_UP:
                     col->stat = GLP_NU;
                     break;
                  case GLP_DB:
                     col->stat = (flag[kk-m] ? GLP_NU : GLP_NL);
                     break;
                  case GLP_FX:
                     col->stat = GLP_NS;
                     break;
                  default:
                     xassert(col != col);
               }
               col->bind = 0;
            }
         }
      }
      return;
}

/***********************************************************************
*  spx_store_sol - convert working LP solution to original LP solution
*
*  This routine converts the current basic solution of the working LP
*  (values of basic variables, simplex multipliers, reduced costs of
*  non-basic variables) to corresponding basic solution of the original
*  LP (values and reduced costs of auxiliary and structural variables).
*  This conversion includes unscaling all basic solution components,
*  computing reduced costs of excluded non-basic variables, recovering
*  unshifted values of basic variables, changing the signs of reduced
*  costs (if the original LP is maximization), and computing the value
*  of the objective function.
*
*  The flag shift should have the same value as it has in a call to the
*  routine spx_build_lp.
*
*  The array map should contain information provided by the routine
*  spx_build_lp.
*
*  The array daeh should contain information provided by the routine
*  spx_store_basis.
*
*  The arrays beta, pi, and d should contain basic solution components
*  for the working LP:
*
*  array locations beta[1], ..., beta[m] should contain values of basic
*  variables beta = (beta[i]);
*
*  array locations pi[1], ..., pi[m] should contain simplex multipliers
*  pi = (pi[i]);
*
*  array locations d[1], ..., d[n-m] should contain reduced costs of
*  non-basic variables d = (d[j]). */

void spx_store_sol(SPXLP *lp, glp_prob *P, int shift,
      const int map[], const int daeh[], const double beta[],
      const double pi[], const double d[])
{     int m = lp->m;
      char *flag = lp->flag;
      int i, j, k, kk;
      double dir;
      /* working LP is always minimization */
      switch (P->dir)
      {  case GLP_MIN:
            dir = +1.0;
            break;
         case GLP_MAX:
            dir = -1.0;
            break;
         default:
            xassert(P != P);
      }
      /* compute row solution components */
      xassert(P->m == m);
      for (i = 1; i <= m; i++)
      {  GLPROW *row = P->row[i];
         if ((k = map[i]) < 0)
            k = -k;
         if (k == 0)
         {  /* non-basic fixed auxiliary variable was excluded */
            xassert(row->type == GLP_FX);
            row->prim = row->lb;
            /* compute reduced cost d[k] = c[k] - A'[k] * pi as if x[k]
             * would be non-basic in working LP */
            row->dual = - dir * pi[i] * row->rii;
         }
         else
         {  /* auxiliary variable corresponds to variable x[k] */
            kk = daeh[k];
            if (kk <= m)
            {  /* x[k] = xB[kk] */
               row->prim = beta[kk] / row->rii;
               if (shift)
                  row->prim += (map[i] < 0 ? row->ub : row->lb);
               row->dual = 0.0;
            }
            else
            {  /* x[k] = xN[kk-m] */
               row->prim = (flag[kk-m] ? row->ub : row->lb);
               row->dual = (dir * d[kk-m]) * row->rii;
            }
         }
      }
      /* compute column solution components and objective value */
      P->obj_val = P->c0;
      for (j = 1; j <= P->n; j++)
      {  GLPCOL *col = P->col[j];
         if ((k = map[m+j]) < 0)
            k = -k;
         if (k == 0)
         {  /* non-basic fixed structural variable was excluded */
            GLPAIJ *aij;
            double dk;
            xassert(col->type == GLP_FX);
            col->prim = col->lb;
            /* compute reduced cost d[k] = c[k] - A'[k] * pi as if x[k]
             * would be non-basic in working LP */
            /* (note that sjj scale factor is cancelled) */
            dk = dir * col->coef;
            for (aij = col->ptr; aij != NULL; aij = aij->c_next)
               dk += (aij->row->rii * aij->val) * pi[aij->row->i];
            col->dual = dir * dk;
         }
         else
         {  /* structural variable corresponds to variable x[k] */
            kk = daeh[k];
            if (kk <= m)
            {  /* x[k] = xB[kk] */
               col->prim = beta[kk] * col->sjj;
               if (shift)
                  col->prim += (map[m+j] < 0 ? col->ub : col->lb);
               col->dual = 0.0;
            }
            else
            {  /* x[k] = xN[kk-m] */
               col->prim = (flag[kk-m] ? col->ub : col->lb);
               col->dual = (dir * d[kk-m]) / col->sjj;
            }
         }
         P->obj_val += col->coef * col->prim;
      }
      return;
}

/***********************************************************************
*  spx_free_lp - deallocate working LP arrays
*
*  This routine deallocates the memory used for arrays of the working
*  LP object. */

void spx_free_lp(SPXLP *lp)
{     tfree(lp->A_ptr);
      tfree(lp->A_ind);
      tfree(lp->A_val);
      tfree(lp->b);
      tfree(lp->c);
      tfree(lp->l);
      tfree(lp->u);
      tfree(lp->head);
      tfree(lp->flag);
      return;
}


#define USE_AT 0
/* 1 - use A in row-wise format
 * 0 - use N in row-wise format */

#define EXCL 1
/* 1 - exclude fixed non-basic variables
 * 0 - don't exclude variables */

#define SHIFT 1
/* 1 - shift bounds of variables toward zero
 * 0 - don't shift bounds of variables */

#define CHECK_ACCURACY 0
/* (for debugging) */

struct csa1
{     /* common storage area */
      SPXLP *lp;
      /* LP problem data and its (current) basis; this LP has m rows
       * and n columns */
      int dir;
      /* original optimization direction:
       * +1 - minimization
       * -1 - maximization */
      double *c; /* double c[1+n]; */
      /* copy of original objective coefficients */
      SPXAT *at;
      /* mxn-matrix A of constraint coefficients, in sparse row-wise
       * format (NULL if not used) */
      SPXNT *nt;
      /* mx(n-m)-matrix N composed of non-basic columns of constraint
       * matrix A, in sparse row-wise format (NULL if not used) */
      int phase;
      /* search phase:
       * 0 - not determined yet
       * 1 - searching for primal feasible solution
       * 2 - searching for optimal solution */
      double *beta; /* double beta[1+m]; */
      /* beta[i] is primal value of basic variable xB[i] */
      int beta_st;
      /* status of the vector beta:
       * 0 - undefined
       * 1 - just computed
       * 2 - updated */
      double *d; /* double d[1+n-m]; */
      /* d[j] is reduced cost of non-basic variable xN[j] */
      int d_st;
      /* status of the vector d:
       * 0 - undefined
       * 1 - just computed
       * 2 - updated */
      SPXSE *se;
      /* projected steepest edge and Devex pricing data block (NULL if
       * not used) */
      int num;
      /* number of eligible non-basic variables */
      int *list; /* int list[1+n-m]; */
      /* list[1], ..., list[num] are indices j of eligible non-basic
       * variables xN[j] */
      int q;
      /* xN[q] is a non-basic variable chosen to enter the basis */
      double *tcol; /* double tcol[1+m]; */
      /* q-th (pivot) column of the simplex table */
      int p;
      /* xB[p] is a basic variable chosen to leave the basis;
       * p = 0 means that no basic variable reaches its bound;
       * p < 0 means that non-basic variable xN[q] reaches its opposite
       * bound before any basic variable */
      int p_flag;
      /* if this flag is set, the active bound of xB[p] in the adjacent
       * basis should be set to the upper bound */
      double *trow; /* double trow[1+n-m]; */
      /* p-th (pivot) row of the simplex table */
      double *work; /* double work[1+m]; */
      /* working array */
      int p_stat, d_stat;
      /* primal and dual solution statuses */
      /*--------------------------------------------------------------*/
      /* control parameters (see struct glp_smcp) */
      int msg_lev;
      /* message level */
      int harris;
      /* ratio test technique:
       * 0 - textbook ratio test
       * 1 - Harris' two pass ratio test */
      double tol_bnd, tol_bnd1;
      /* primal feasibility tolerances */
      double tol_dj, tol_dj1;
      /* dual feasibility tolerances */
      double tol_piv;
      /* pivot tolerance */
      int it_lim;
      /* iteration limit */
      int tm_lim;
      /* time limit, milliseconds */
      int out_frq;
      /* display output frequency, iterations */
      int out_dly;
      /* display output delay, milliseconds */
      /*--------------------------------------------------------------*/
      /* working parameters */
      double tm_beg;
      /* time value at the beginning of the search */
      int it_beg;
      /* simplex iteration count at the beginning of the search */
      int it_cnt;
      /* simplex iteration count; it increases by one every time the
       * basis changes (including the case when a non-basic variable
       * jumps to its opposite bound) */
      int it_dpy;
      /* simplex iteration count at most recent display output */
      int inv_cnt;
      /* basis factorization count since most recent display output */
};

/***********************************************************************
*  set_penalty - set penalty function coefficients
*
*  This routine sets up objective coefficients of the penalty function,
*  which is the sum of primal infeasibilities, as follows:
*
*     if beta[i] < l[k] - eps1, set c[k] = -1,
*
*     if beta[i] > u[k] + eps2, set c[k] = +1,
*
*     otherwise, set c[k] = 0,
*
*  where beta[i] is current value of basic variable xB[i] = x[k], l[k]
*  and u[k] are original bounds of x[k], and
*
*     eps1 = tol + tol1 * |l[k]|,
*
*     eps2 = tol + tol1 * |u[k]|.
*
*  The routine returns the number of non-zero objective coefficients,
*  which is the number of basic variables violating their bounds. Thus,
*  if the value returned is zero, the current basis is primal feasible
*  within the specified tolerances. */

static int set_penalty(struct csa1 *csa, double tol, double tol1)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      double *beta = csa->beta;
      int i, k, count = 0;
      double t, eps;
      /* reset objective coefficients */
      for (k = 0; k <= n; k++)
         c[k] = 0.0;
      /* walk thru the list of basic variables */
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         /* check lower bound */
         if ((t = l[k]) != -DBL_MAX)
         {  eps = tol + tol1 * (t >= 0.0 ? +t : -t);
            if (beta[i] < t - eps)
            {  /* lower bound is violated */
               c[k] = -1.0, count++;
            }
         }
         /* check upper bound */
         if ((t = u[k]) != +DBL_MAX)
         {  eps = tol + tol1 * (t >= 0.0 ? +t : -t);
            if (beta[i] > t + eps)
            {  /* upper bound is violated */
               c[k] = +1.0, count++;
            }
         }
      }
      return count;
}

/***********************************************************************
*  check_feas - check primal feasibility of basic solution
*
*  This routine checks if the specified values of all basic variables
*  beta = (beta[i]) are within their bounds.
*
*  Let l[k] and u[k] be original bounds of basic variable xB[i] = x[k].
*  The actual bounds of x[k] are determined as follows:
*
*  1) if phase = 1 and c[k] < 0, x[k] violates its lower bound, so its
*     actual bounds are artificial: -inf < x[k] <= l[k];
*
*  2) if phase = 1 and c[k] > 0, x[k] violates its upper bound, so its
*     actual bounds are artificial: u[k] <= x[k] < +inf;
*
*  3) in all other cases (if phase = 1 and c[k] = 0, or if phase = 2)
*     actual bounds are original: l[k] <= x[k] <= u[k].
*
*  The parameters tol and tol1 are bound violation tolerances. The
*  actual bounds l'[k] and u'[k] are considered as non-violated within
*  the specified tolerance if
*
*     l'[k] - eps1 <= beta[i] <= u'[k] + eps2,
*
*  where eps1 = tol + tol1 * |l'[k]|, eps2 = tol + tol1 * |u'[k]|.
*
*  The routine returns one of the following codes:
*
*  0 - solution is feasible (no actual bounds are violated);
*
*  1 - solution is infeasible, however, only artificial bounds are
*      violated (this is possible only if phase = 1);
*
*  2 - solution is infeasible and at least one original bound is
*      violated. */

static int check_feas1(struct csa1 *csa, int phase, double tol, double
      tol1)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      double *beta = csa->beta;
      int i, k, orig, ret = 0;
      double lk, uk, eps;
      xassert(phase == 1 || phase == 2);
      /* walk thru the list of basic variables */
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         /* determine actual bounds of x[k] */
         if (phase == 1 && c[k] < 0.0)
         {  /* -inf < x[k] <= l[k] */
            lk = -DBL_MAX, uk = l[k];
            orig = 0; /* artificial bounds */
         }
         else if (phase == 1 && c[k] > 0.0)
         {  /* u[k] <= x[k] < +inf */
            lk = u[k], uk = +DBL_MAX;
            orig = 0; /* artificial bounds */
         }
         else
         {  /* l[k] <= x[k] <= u[k] */
            lk = l[k], uk = u[k];
            orig = 1; /* original bounds */
         }
         /* check actual lower bound */
         if (lk != -DBL_MAX)
         {  eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
            if (beta[i] < lk - eps)
            {  /* actual lower bound is violated */
               if (orig)
               {  ret = 2;
                  break;
               }
               ret = 1;
            }
         }
         /* check actual upper bound */
         if (uk != +DBL_MAX)
         {  eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
            if (beta[i] > uk + eps)
            {  /* actual upper bound is violated */
               if (orig)
               {  ret = 2;
                  break;
               }
               ret = 1;
            }
         }
      }
      return ret;
}

/***********************************************************************
*  adjust_penalty - adjust penalty function coefficients
*
*  On searching for primal feasible solution it may happen that some
*  basic variable xB[i] = x[k] has non-zero objective coefficient c[k]
*  indicating that xB[i] violates its lower (if c[k] < 0) or upper (if
*  c[k] > 0) original bound, but due to primal degenarcy the violation
*  is close to zero.
*
*  This routine identifies such basic variables and sets objective
*  coefficients at these variables to zero that allows avoiding zero-
*  step simplex iterations.
*
*  The parameters tol and tol1 are bound violation tolerances. The
*  original bounds l[k] and u[k] are considered as non-violated within
*  the specified tolerance if
*
*     l[k] - eps1 <= beta[i] <= u[k] + eps2,
*
*  where beta[i] is value of basic variable xB[i] = x[k] in the current
*  basis, eps1 = tol + tol1 * |l[k]|, eps2 = tol + tol1 * |u[k]|.
*
*  The routine returns the number of objective coefficients which were
*  set to zero. */

static int adjust_penalty(struct csa1 *csa, double tol, double tol1)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      double *beta = csa->beta;
      int i, k, count = 0;
      double t, eps;
      xassert(csa->phase == 1);
      /* walk thru the list of basic variables */
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         if (c[k] < 0.0)
         {  /* x[k] violates its original lower bound l[k] */
            xassert((t = l[k]) != -DBL_MAX);
            eps = tol + tol1 * (t >= 0.0 ? +t : -t);
            if (beta[i] >= t - eps)
            {  /* however, violation is close to zero */
               c[k] = 0.0, count++;
            }
         }
         else if (c[k] > 0.0)
         {  /* x[k] violates its original upper bound u[k] */
            xassert((t = u[k]) != +DBL_MAX);
            eps = tol + tol1 * (t >= 0.0 ? +t : -t);
            if (beta[i] <= t + eps)
            {  /* however, violation is close to zero */
               c[k] = 0.0, count++;
            }
         }
      }
      return count;
}

#if CHECK_ACCURACY
/***********************************************************************
*  err_in_vec - compute maximal relative error between two vectors
*
*  This routine computes and returns maximal relative error between
*  n-vectors x and y:
*
*     err_max = max |x[i] - y[i]| / (1 + |x[i]|).
*
*  NOTE: This routine is intended only for debugginig purposes. */

static double err_in_vec(int n, const double x[], const double y[])
{     int i;
      double err, err_max;
      err_max = 0.0;
      for (i = 1; i <= n; i++)
      {  err = fabs(x[i] - y[i]) / (1.0 + fabs(x[i]));
         if (err_max < err)
            err_max = err;
      }
      return err_max;
}
#endif

#if CHECK_ACCURACY
/***********************************************************************
*  err_in_beta - compute maximal relative error in vector beta
*
*  This routine computes and returns maximal relative error in vector
*  of values of basic variables beta = (beta[i]).
*
*  NOTE: This routine is intended only for debugginig purposes. */

static double err_in_beta(struct csa1 *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      double err, *beta;
      beta = talloc(1+m, double);
      spx_eval_beta(lp, beta);
      err = err_in_vec(m, beta, csa->beta);
      tfree(beta);
      return err;
}
#endif

#if CHECK_ACCURACY
/***********************************************************************
*  err_in_d - compute maximal relative error in vector d
*
*  This routine computes and returns maximal relative error in vector
*  of reduced costs of non-basic variables d = (d[j]).
*
*  NOTE: This routine is intended only for debugginig purposes. */

static double err_in_d(struct csa1 *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      int j;
      double err, *pi, *d;
      pi = talloc(1+m, double);
      d = talloc(1+n-m, double);
      spx_eval_pi(lp, pi);
      for (j = 1; j <= n-m; j++)
         d[j] = spx_eval_dj(lp, pi, j);
      err = err_in_vec(n-m, d, csa->d);
      tfree(pi);
      tfree(d);
      return err;
}
#endif

#if CHECK_ACCURACY
/***********************************************************************
*  err_in_gamma - compute maximal relative error in vector gamma
*
*  This routine computes and returns maximal relative error in vector
*  of projected steepest edge weights gamma = (gamma[j]).
*
*  NOTE: This routine is intended only for debugginig purposes. */

static double err_in_gamma(struct csa1 *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      SPXSE *se = csa->se;
      int j;
      double err, *gamma;
      xassert(se != NULL);
      gamma = talloc(1+n-m, double);
      for (j = 1; j <= n-m; j++)
         gamma[j] = spx_eval_gamma_j(lp, se, j);
      err = err_in_vec(n-m, gamma, se->gamma);
      tfree(gamma);
      return err;
}
#endif

#if CHECK_ACCURACY
/***********************************************************************
*  check_accuracy - check accuracy of basic solution components
*
*  This routine checks accuracy of current basic solution components.
*
*  NOTE: This routine is intended only for debugginig purposes. */

static void check_accuracy(struct csa1 *csa)
{     double e_beta, e_d, e_gamma;
      e_beta = err_in_beta(csa);
      e_d = err_in_d(csa);
      if (csa->se == NULL)
         e_gamma = 0.;
      else
         e_gamma = err_in_gamma(csa);
      xprintf("e_beta = %10.3e; e_d = %10.3e; e_gamma = %10.3e\n",
         e_beta, e_d, e_gamma);
      xassert(e_beta <= 1e-5 && e_d <= 1e-5 && e_gamma <= 1e-3);
      return;
}
#endif

/***********************************************************************
*  choose_pivot - choose xN[q] and xB[p]
*
*  Given the list of eligible non-basic variables this routine first
*  chooses non-basic variable xN[q]. This choice is always possible,
*  because the list is assumed to be non-empty. Then the routine
*  computes q-th column T[*,q] of the simplex table T[i,j] and chooses
*  basic variable xB[p]. If the pivot T[p,q] is small in magnitude,
*  the routine attempts to choose another xN[q] and xB[p] in order to
*  avoid badly conditioned adjacent bases. */

#if 1 /* 17/III-2016 */
#define MIN_RATIO 0.0001

static int choose_pivot1(struct csa1 *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *beta = csa->beta;
      double *d = csa->d;
      SPXSE *se = csa->se;
      int *list = csa->list;
      double *tcol = csa->work;
      double tol_piv = csa->tol_piv;
      int try, nnn, /*i,*/ p, p_flag, q, t;
      double big, /*temp,*/ best_ratio;
      xassert(csa->beta_st);
      xassert(csa->d_st);
more: /* initial number of eligible non-basic variables */
      nnn = csa->num;
      /* nothing has been chosen so far */
      csa->q = 0;
      best_ratio = 0.0;
      try = 0;
try:  /* choose non-basic variable xN[q] */
      xassert(nnn > 0);
      try++;
      if (se == NULL)
      {  /* Dantzig's rule */
         q = spx_chuzc_std(lp, d, nnn, list);
      }
      else
      {  /* projected steepest edge */
         q = spx_chuzc_pse(lp, se, d, nnn, list);
      }
      xassert(1 <= q && q <= n-m);
      /* compute q-th column of the simplex table */
      spx_eval_tcol(lp, q, tcol);
#if 0
      /* big := max(1, |tcol[1]|, ..., |tcol[m]|) */
      big = 1.0;
      for (i = 1; i <= m; i++)
      {  temp = tcol[i];
         if (temp < 0.0)
            temp = - temp;
         if (big < temp)
            big = temp;
      }
#else
      /* this still puzzles me */
      big = 1.0;
#endif
      /* choose basic variable xB[p] */
      if (!csa->harris)
      {  /* textbook ratio test */
         p = spx_chuzr_std(lp, csa->phase, beta, q,
            d[q] < 0.0 ? +1. : -1., tcol, &p_flag, tol_piv,
            .30 * csa->tol_bnd, .30 * csa->tol_bnd1);
      }
      else
      {  /* Harris' two-pass ratio test */
         p = spx_chuzr_harris(lp, csa->phase, beta, q,
            d[q] < 0.0 ? +1. : -1., tcol, &p_flag , tol_piv,
            .50 * csa->tol_bnd, .50 * csa->tol_bnd1);
      }
      if (p <= 0)
      {  /* primal unboundedness or special case */
         csa->q = q;
         memcpy(&csa->tcol[1], &tcol[1], m * sizeof(double));
         csa->p = p;
         csa->p_flag = p_flag;
         best_ratio = 1.0;
         goto done;
      }
      /* either keep previous choice or accept new choice depending on
       * which one is better */
      if (best_ratio < fabs(tcol[p]) / big)
      {  csa->q = q;
         memcpy(&csa->tcol[1], &tcol[1], m * sizeof(double));
         csa->p = p;
         csa->p_flag = p_flag;
         best_ratio = fabs(tcol[p]) / big;
      }
      /* check if the current choice is acceptable */
      if (best_ratio >= MIN_RATIO || nnn == 1 || try == 5)
         goto done;
      /* try to choose other xN[q] and xB[p] */
      /* find xN[q] in the list */
      for (t = 1; t <= nnn; t++)
         if (list[t] == q) break;
      xassert(t <= nnn);
      /* move xN[q] to the end of the list */
      list[t] = list[nnn], list[nnn] = q;
      /* and exclude it from consideration */
      nnn--;
      /* repeat the choice */
      goto try;
done: /* the choice has been made */
#if 1 /* FIXME: currently just to avoid badly conditioned basis */
      if (best_ratio < .001 * MIN_RATIO)
      {  /* looks like this helps */
         if (bfd_get_count(lp->bfd) > 0)
            return -1;
         /* didn't help; last chance to improve the choice */
         if (tol_piv == csa->tol_piv)
         {  tol_piv *= 1000.;
            goto more;
         }
      }
#endif
      return 0;
}
#endif

/***********************************************************************
*  sum_infeas - compute sum of primal infeasibilities
*
*  This routine compute the sum of primal infeasibilities, which is the
*  current penalty function value. */

static double sum_infeas(SPXLP *lp, const double beta[/*1+m*/])
{     int m = lp->m;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      int i, k;
      double sum = 0.0;
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         if (l[k] != -DBL_MAX && beta[i] < l[k])
            sum += l[k] - beta[i];
         if (u[k] != +DBL_MAX && beta[i] > u[k])
            sum += beta[i] - u[k];
      }
      return sum;
}

/***********************************************************************
*  display - display search progress
*
*  This routine displays some information about the search progress
*  that includes:
*
*  search phase;
*
*  number of simplex iterations performed by the solver;
*
*  original objective value;
*
*  sum of (scaled) primal infeasibilities;
*
*  number of infeasibilities (phase I) or non-optimalities (phase II);
*
*  number of basic factorizations since last display output. */

static void display1(struct csa1 *csa, int spec)
{     int nnn, k;
      double obj, sum, *save;
      /* check if the display output should be skipped */
      if (csa->msg_lev < GLP_MSG_ON) goto skip;
      if (csa->out_dly > 0 &&
         1000.0 * xdifftime(xtime(), csa->tm_beg) < csa->out_dly)
         goto skip;
      if (csa->it_cnt == csa->it_dpy) goto skip;
      if (!spec && csa->it_cnt % csa->out_frq != 0) goto skip;
      /* compute original objective value */
      save = csa->lp->c;
      csa->lp->c = csa->c;
      obj = csa->dir * spx_eval_obj(csa->lp, csa->beta);
      csa->lp->c = save;
      /* compute sum of (scaled) primal infeasibilities */
      sum = sum_infeas(csa->lp, csa->beta);
      /* compute number of infeasibilities/non-optimalities */
      switch (csa->phase)
      {  case 1:
            nnn = 0;
            for (k = 1; k <= csa->lp->n; k++)
               if (csa->lp->c[k] != 0.0) nnn++;
            break;
         case 2:
            xassert(csa->d_st);
            nnn = spx_chuzc_sel(csa->lp, csa->d, csa->tol_dj,
               csa->tol_dj1, NULL);
            break;
         default:
            xassert(csa != csa);
      }
      /* display search progress */
      xprintf("%c%6d: obj = %17.9e inf = %11.3e (%d)",
         csa->phase == 2 ? '*' : ' ', csa->it_cnt, obj, sum, nnn);
      if (csa->inv_cnt)
      {  /* number of basis factorizations performed */
         xprintf(" %d", csa->inv_cnt);
         csa->inv_cnt = 0;
      }
      xprintf("\n");
      csa->it_dpy = csa->it_cnt;
skip: return;
}

/***********************************************************************
*  spx_primal - driver to primal simplex method
*
*  This routine is a driver to the two-phase primal simplex method.
*
*  On exit this routine returns one of the following codes:
*
*  0  LP instance has been successfully solved.
*
*  GLP_EITLIM
*     Iteration limit has been exhausted.
*
*  GLP_ETMLIM
*     Time limit has been exhausted.
*
*  GLP_EFAIL
*     The solver failed to solve LP instance. */

static int primal_simplex(struct csa1 *csa)
{     /* primal simplex method main logic routine */
      SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      int *head = lp->head;
      SPXAT *at = csa->at;
      SPXNT *nt = csa->nt;
      double *beta = csa->beta;
      double *d = csa->d;
      SPXSE *se = csa->se;
      int *list = csa->list;
      double *tcol = csa->tcol;
      double *trow = csa->trow;
      double *pi = csa->work;
      double *rho = csa->work;
      int msg_lev = csa->msg_lev;
      double tol_bnd = csa->tol_bnd;
      double tol_bnd1 = csa->tol_bnd1;
      double tol_dj = csa->tol_dj;
      double tol_dj1 = csa->tol_dj1;
      int j, refct, ret;
loop: /* main loop starts here */
      /* compute factorization of the basis matrix */
      if (!lp->valid)
      {  double cond;
         ret = spx_factorize(lp);
         csa->inv_cnt++;
         if (ret != 0)
         {  if (msg_lev >= GLP_MSG_ERR)
               xprintf("Error: unable to factorize the basis matrix (%d"
                  ")\n", ret);
            csa->p_stat = csa->d_stat = GLP_UNDEF;
            ret = GLP_EFAIL;
            goto fini;
         }
         /* check condition of the basis matrix */
         cond = bfd_condest(lp->bfd);
         if (cond > 1.0 / DBL_EPSILON)
         {  if (msg_lev >= GLP_MSG_ERR)
               xprintf("Error: basis matrix is singular to working prec"
                  "ision (cond = %.3g)\n", cond);
            csa->p_stat = csa->d_stat = GLP_UNDEF;
            ret = GLP_EFAIL;
            goto fini;
         }
         if (cond > 0.001 / DBL_EPSILON)
         {  if (msg_lev >= GLP_MSG_ERR)
               xprintf("Warning: basis matrix is ill-conditioned (cond "
                  "= %.3g)\n", cond);
         }
         /* invalidate basic solution components */
         csa->beta_st = csa->d_st = 0;
      }
      /* compute values of basic variables beta = (beta[i]) */
      if (!csa->beta_st)
      {  spx_eval_beta(lp, beta);
         csa->beta_st = 1; /* just computed */
         /* determine the search phase, if not determined yet */
         if (!csa->phase)
         {  if (set_penalty(csa, 0.97 * tol_bnd, 0.97 * tol_bnd1))
            {  /* current basic solution is primal infeasible */
               /* start to minimize the sum of infeasibilities */
               csa->phase = 1;
            }
            else
            {  /* current basic solution is primal feasible */
               /* start to minimize the original objective function */
               csa->phase = 2;
               memcpy(c, csa->c, (1+n) * sizeof(double));
            }
            /* working objective coefficients have been changed, so
             * invalidate reduced costs */
            csa->d_st = 0;
         }
         /* make sure that the current basic solution remains primal
          * feasible (or pseudo-feasible on phase I) */
         if (check_feas1(csa, csa->phase, tol_bnd, tol_bnd1))
         {  /* excessive bound violations due to round-off errors */
            if (msg_lev >= GLP_MSG_ERR)
               xprintf("Warning: numerical instability (primal simplex,"
                  " phase %s)\n", csa->phase == 1 ? "I" : "II");
            /* restart the search */
            lp->valid = 0;
            csa->phase = 0;
            goto loop;
         }
      }
      /* at this point the search phase is determined */
      xassert(csa->phase == 1 || csa->phase == 2);
      if (csa->phase == 1)
      {  /* adjust penalty function coefficients */
         if (adjust_penalty(csa, tol_bnd, tol_bnd1))
         {  /* some coefficients were changed, so invalidate reduced
             * costs of non-basic variables */
            csa->d_st = 0;
         }
      }
      /* compute reduced costs of non-basic variables d = (d[j]) */
      if (!csa->d_st)
      {  spx_eval_pi(lp, pi);
         for (j = 1; j <= n-m; j++)
            d[j] = spx_eval_dj(lp, pi, j);
         csa->d_st = 1; /* just computed */
      }
      /* reset the reference space, if necessary */
      if (se != NULL && !se->valid)
         spx_reset_refsp(lp, se), refct = 1000;
      /* at this point the basis factorization and all basic solution
       * components are valid */
      xassert(lp->valid && csa->beta_st && csa->d_st);
#if CHECK_ACCURACY
      /* check accuracy of current basic solution components (only for
       * debugging) */
      check_accuracy(csa);
#endif
      /* check if the iteration limit has been exhausted */
      if (csa->it_cnt - csa->it_beg >= csa->it_lim)
      {  if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         display1(csa, 1);
         if (msg_lev >= GLP_MSG_ALL)
            xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
         csa->p_stat = (csa->phase == 2 ? GLP_FEAS : GLP_INFEAS);
         csa->d_stat = GLP_UNDEF; /* will be set below */
         ret = GLP_EITLIM;
         goto fini;
      }
      /* check if the time limit has been exhausted */
      if (1000.0 * xdifftime(xtime(), csa->tm_beg) >= csa->tm_lim)
      {  if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         display1(csa, 1);
         if (msg_lev >= GLP_MSG_ALL)
            xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
         csa->p_stat = (csa->phase == 2 ? GLP_FEAS : GLP_INFEAS);
         csa->d_stat = GLP_UNDEF; /* will be set below */
         ret = GLP_ETMLIM;
         goto fini;
      }
      /* display the search progress */
      display1(csa, 0);
      /* select eligible non-basic variables */
      switch (csa->phase)
      {  case 1:
            csa->num = spx_chuzc_sel(lp, d, 1e-8, 0.0, list);
            break;
         case 2:
            csa->num = spx_chuzc_sel(lp, d, tol_dj, tol_dj1, list);
            break;
         default:
            xassert(csa != csa);
      }
      /* check for optimality */
      if (csa->num == 0)
      {  if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         /* current basis is optimal */
         display1(csa, 1);
         switch (csa->phase)
         {  case 1:
               /* check for primal feasibility */
               if (!check_feas1(csa, 2, tol_bnd, tol_bnd1))
               {  /* feasible solution found; switch to phase II */
                  memcpy(c, csa->c, (1+n) * sizeof(double));
                  csa->phase = 2;
                  csa->d_st = 0;
                  goto loop;
               }
               /* no feasible solution exists */
               if (msg_lev >= GLP_MSG_ALL)
                  xprintf("LP HAS NO PRIMAL FEASIBLE SOLUTION\n");
               csa->p_stat = GLP_NOFEAS;
               csa->d_stat = GLP_UNDEF; /* will be set below */
               ret = 0;
               goto fini;
            case 2:
               /* optimal solution found */
               if (msg_lev >= GLP_MSG_ALL)
                  xprintf("OPTIMAL LP SOLUTION FOUND\n");
               csa->p_stat = csa->d_stat = GLP_FEAS;
               ret = 0;
               goto fini;
            default:
               xassert(csa != csa);
         }
      }
      /* choose xN[q] and xB[p] */
#if 0 /* 17/III-2016 */
      choose_pivot1(csa);
#else
      if (choose_pivot1(csa) < 0)
      {  lp->valid = 0;
         goto loop;
      }
#endif
      /* check for unboundedness */
      if (csa->p == 0)
      {  if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         display1(csa, 1);
         switch (csa->phase)
         {  case 1:
               /* this should never happen */
               if (msg_lev >= GLP_MSG_ERR)
                  xprintf("Error: primal simplex failed\n");
               csa->p_stat = csa->d_stat = GLP_UNDEF;
               ret = GLP_EFAIL;
               goto fini;
            case 2:
               /* primal unboundedness detected */
               if (msg_lev >= GLP_MSG_ALL)
                  xprintf("LP HAS UNBOUNDED PRIMAL SOLUTION\n");
               csa->p_stat = GLP_FEAS;
               csa->d_stat = GLP_NOFEAS;
               ret = 0;
               goto fini;
            default:
               xassert(csa != csa);
         }
      }
      /* update values of basic variables for adjacent basis */
      spx_update_beta(lp, beta, csa->p, csa->p_flag, csa->q, tcol);
      csa->beta_st = 2;
      /* p < 0 means that xN[q] jumps to its opposite bound */
      if (csa->p < 0)
         goto skip;
      /* xN[q] enters and xB[p] leaves the basis */
      /* compute p-th row of inv(B) */
      spx_eval_rho(lp, csa->p, rho);
      /* compute p-th (pivot) row of the simplex table */
      if (at != NULL)
         spx_eval_trow1(lp, at, rho, trow);
      else
         spx_nt_prod(lp, nt, trow, 1, -1.0, rho);
      /* FIXME: tcol[p] and trow[q] should be close to each other */
      xassert(trow[csa->q] != 0.0);
      /* update reduced costs of non-basic variables for adjacent
       * basis */
      if (spx_update_d(lp, d, csa->p, csa->q, trow, tcol) <= 1e-9)
      {  /* successful updating */
         csa->d_st = 2;
         if (csa->phase == 1)
         {  /* adjust reduced cost of xN[q] in adjacent basis, since
             * its penalty coefficient changes (see below) */
            d[csa->q] -= c[head[csa->p]];
         }
      }
      else
      {  /* new reduced costs are inaccurate */
         csa->d_st = 0;
      }
      if (csa->phase == 1)
      {  /* xB[p] leaves the basis replacing xN[q], so set its penalty
          * coefficient to zero */
         c[head[csa->p]] = 0.0;
      }
      /* update steepest edge weights for adjacent basis, if used */
      if (se != NULL)
      {  if (refct > 0)
         {  if (spx_update_gamma(lp, se, csa->p, csa->q, trow, tcol)
               <= 1e-3)
            {  /* successful updating */
               refct--;
            }
            else
            {  /* new weights are inaccurate; reset reference space */
               se->valid = 0;
            }
         }
         else
         {  /* too many updates; reset reference space */
            se->valid = 0;
         }
      }
      /* update matrix N for adjacent basis, if used */
      if (nt != NULL)
         spx_update_nt(lp, nt, csa->p, csa->q);
skip: /* change current basis header to adjacent one */
      spx_change_basis(lp, csa->p, csa->p_flag, csa->q);
      /* and update factorization of the basis matrix */
      if (csa->p > 0)
         spx_update_invb(lp, csa->p, head[csa->p]);
      /* simplex iteration complete */
      csa->it_cnt++;
      goto loop;
fini: /* restore original objective function */
      memcpy(c, csa->c, (1+n) * sizeof(double));
      /* compute reduced costs of non-basic variables and determine
       * solution dual status, if necessary */
      if (csa->p_stat != GLP_UNDEF && csa->d_stat == GLP_UNDEF)
      {  xassert(ret != GLP_EFAIL);
         spx_eval_pi(lp, pi);
         for (j = 1; j <= n-m; j++)
            d[j] = spx_eval_dj(lp, pi, j);
         csa->num = spx_chuzc_sel(lp, d, tol_dj, tol_dj1, NULL);
         csa->d_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
      }
      return ret;
}

int spx_primal(glp_prob *P, const glp_smcp *parm)
{     /* driver to primal simplex method */
      struct csa1 csa_, *csa = &csa_;
      SPXLP lp;
#if USE_AT
      SPXAT at;
#else
      SPXNT nt;
#endif
      SPXSE se;
      int ret, *map, *daeh;
      /* build working LP and its initial basis */
      memset(csa, 0, sizeof(struct csa1));
      csa->lp = &lp;
      spx_init_lp(csa->lp, P, EXCL);
      spx_alloc_lp(csa->lp);
      map = talloc(1+P->m+P->n, int);
      spx_build_lp(csa->lp, P, EXCL, SHIFT, map);
      spx_build_basis(csa->lp, P, map);
      switch (P->dir)
      {  case GLP_MIN:
            csa->dir = +1;
            break;
         case GLP_MAX:
            csa->dir = -1;
            break;
         default:
            xassert(P != P);
      }
      csa->c = talloc(1+csa->lp->n, double);
      memcpy(csa->c, csa->lp->c, (1+csa->lp->n) * sizeof(double));
#if USE_AT
      /* build matrix A in row-wise format */
      csa->at = &at;
      csa->nt = NULL;
      spx_alloc_at(csa->lp, csa->at);
      spx_build_at(csa->lp, csa->at);
#else
      /* build matrix N in row-wise format for initial basis */
      csa->at = NULL;
      csa->nt = &nt;
      spx_alloc_nt(csa->lp, csa->nt);
      spx_init_nt(csa->lp, csa->nt);
      spx_build_nt(csa->lp, csa->nt);
#endif
      /* allocate and initialize working components */
      csa->phase = 0;
      csa->beta = talloc(1+csa->lp->m, double);
      csa->beta_st = 0;
      csa->d = talloc(1+csa->lp->n-csa->lp->m, double);
      csa->d_st = 0;
      switch (parm->pricing)
      {  case GLP_PT_STD:
            csa->se = NULL;
            break;
         case GLP_PT_PSE:
            csa->se = &se;
            spx_alloc_se(csa->lp, csa->se);
            break;
         default:
            xassert(parm != parm);
      }
      csa->list = talloc(1+csa->lp->n-csa->lp->m, int);
      csa->tcol = talloc(1+csa->lp->m, double);
      csa->trow = talloc(1+csa->lp->n-csa->lp->m, double);
      csa->work = talloc(1+csa->lp->m, double);
      /* initialize control parameters */
      csa->msg_lev = parm->msg_lev;
      switch (parm->r_test)
      {  case GLP_RT_STD:
            csa->harris = 0;
            break;
         case GLP_RT_HAR:
#if 1 /* 16/III-2016 */
         case GLP_RT_FLIP:
            /* FIXME */
            /* currently for primal simplex GLP_RT_FLIP is equivalent
             * to GLP_RT_HAR */
#endif
            csa->harris = 1;
            break;
         default:
            xassert(parm != parm);
      }
      csa->tol_bnd = parm->tol_bnd;
      csa->tol_bnd1 = .001 * parm->tol_bnd;
      csa->tol_dj = parm->tol_dj;
      csa->tol_dj1 = .001 * parm->tol_dj;
      csa->tol_piv = parm->tol_piv;
      csa->it_lim = parm->it_lim;
      csa->tm_lim = parm->tm_lim;
      csa->out_frq = parm->out_frq;
      csa->out_dly = parm->out_dly;
      /* initialize working parameters */
      csa->tm_beg = xtime();
      csa->it_beg = csa->it_cnt = P->it_cnt;
      csa->it_dpy = -1;
      csa->inv_cnt = 0;
      /* try to solve working LP */
      ret = primal_simplex(csa);
      /* return basis factorization back to problem object */
      P->valid = csa->lp->valid;
      P->bfd = csa->lp->bfd;
      /* set solution status */
      P->pbs_stat = csa->p_stat;
      P->dbs_stat = csa->d_stat;
      /* if the solver failed, do not store basis header and basic
       * solution components to problem object */
      if (ret == GLP_EFAIL)
         goto skip;
      /* convert working LP basis to original LP basis and store it to
       * problem object */
      daeh = talloc(1+csa->lp->n, int);
      spx_store_basis(csa->lp, P, map, daeh);
      /* compute simplex multipliers for final basic solution found by
       * the solver */
      spx_eval_pi(csa->lp, csa->work);
      /* convert working LP solution to original LP solution and store
       * it to problem object */
      spx_store_sol(csa->lp, P, SHIFT, map, daeh, csa->beta, csa->work,
         csa->d);
      tfree(daeh);
      /* save simplex iteration count */
      P->it_cnt = csa->it_cnt;
      /* report auxiliary/structural variable causing unboundedness */
      P->some = 0;
      if (csa->p_stat == GLP_FEAS && csa->d_stat == GLP_NOFEAS)
      {  int k, kk;
         /* xN[q] = x[k] causes unboundedness */
         xassert(1 <= csa->q && csa->q <= csa->lp->n - csa->lp->m);
         k = csa->lp->head[csa->lp->m + csa->q];
         xassert(1 <= k && k <= csa->lp->n);
         /* convert to number of original variable */
         for (kk = 1; kk <= P->m + P->n; kk++)
         {  if (abs(map[kk]) == k)
            {  P->some = kk;
               break;
            }
         }
         xassert(P->some != 0);
      }
skip: /* deallocate working objects and arrays */
      spx_free_lp(csa->lp);
      tfree(map);
      tfree(csa->c);
      if (csa->at != NULL)
         spx_free_at(csa->lp, csa->at);
      if (csa->nt != NULL)
         spx_free_nt(csa->lp, csa->nt);
      tfree(csa->beta);
      tfree(csa->d);
      if (csa->se != NULL)
         spx_free_se(csa->lp, csa->se);
      tfree(csa->list);
      tfree(csa->tcol);
      tfree(csa->trow);
      tfree(csa->work);
      /* return to calling program */
      return ret;
}



#define spy_chuzc_std _glp_spy_chuzc_std
int spy_chuzc_std(SPXLP *lp, const double d[/*1+n-m*/],
#if 0 /* 14/III-2016 */
      double s, const double trow[/*1+n-m*/], double tol_piv,
#else
      double r, const double trow[/*1+n-m*/], double tol_piv,
#endif
      double tol, double tol1);
/* choose non-basic variable (dual textbook ratio test) */

#define spy_chuzc_harris _glp_spy_chuzc_harris
int spy_chuzc_harris(SPXLP *lp, const double d[/*1+n-m*/],
#if 0 /* 14/III-2016 */
      double s, const double trow[/*1+n-m*/], double tol_piv,
#else
      double r, const double trow[/*1+n-m*/], double tol_piv,
#endif
      double tol, double tol1);
/* choose non-basic variable (dual Harris' ratio test) */

typedef struct SPYBP SPYBP;

struct SPYBP
{     /* dual objective function break point */
      int j;
      /* dual basic variable lambdaN[j], 1 <= j <= n-m, that intersects
       * zero at this break point */
      double teta;
      /* ray parameter value, teta[j] >= 0, at this break point */
      double dz;
      /* increment, zeta[j] - zeta[0], of the dual objective function
       * at this break point */
};

#if 0 /* 23/III-2016 */
#define spy_eval_bp _glp_spy_eval_bp
int spy_eval_bp(SPXLP *lp, const double d[/*1+n-m*/],
      double r, const double trow[/*1+n-m*/], double tol_piv,
      SPYBP bp[/*1+n-m*/]);
/* determine dual objective function break-points */
#endif

#define spy_ls_eval_bp _glp_spy_ls_eval_bp
int spy_ls_eval_bp(SPXLP *lp, const double d[/*1+n-m*/],
      double r, const double trow[/*1+n-m*/], double tol_piv,
      SPYBP bp[/*1+n-m*/]);
/* determine dual objective function break-points */

#define spy_ls_select_bp _glp_spy_ls_select_bp
int spy_ls_select_bp(SPXLP *lp, const double trow[/*1+n-m*/],
      int nbp, SPYBP bp[/*1+n-m*/], int num, double *slope, double
      teta_lim);
/* select and process dual objective break-points */

#define spy_chuzr_sel _glp_spy_chuzr_sel
int spy_chuzr_sel(SPXLP *lp, const double beta[/*1+m*/], double tol,
      double tol1, int list[/*1+m*/]);
/* select eligible basic variables */

#define spy_chuzr_std _glp_spy_chuzr_std
int spy_chuzr_std(SPXLP *lp, const double beta[/*1+m*/], int num,
      const int list[]);
/* choose basic variable (dual Dantzig's rule) */

typedef struct SPYSE SPYSE;

struct SPYSE
{     /* dual projected steepest edge and Devex pricing data block */
      int valid;
      /* content validity flag */
      char *refsp; /* char refsp[1+n]; */
      /* refsp[0] is not used;
       * refsp[k], 1 <= k <= n, is the flag meaning that dual variable
       * lambda[k] is in the dual reference space */
      double *gamma; /* double gamma[1+m]; */
      /* gamma[0] is not used;
       * gamma[i], 1 <= i <= m, is the weight for reduced cost r[i]
       * of dual non-basic variable lambdaB[j] in the current basis
       * (r[i] is bound violation for basic variable xB[i]) */
      double *work; /* double work[1+m]; */
      /* working array */
#if 1 /* 30/III-2016 */
      FVS u; /* FVS u[1:m]; */
      /* working vector */
#endif
};

#define spy_alloc_se _glp_spy_alloc_se
void spy_alloc_se(SPXLP *lp, SPYSE *se);
/* allocate dual pricing data block */

#define spy_reset_refsp _glp_spy_reset_refsp
void spy_reset_refsp(SPXLP *lp, SPYSE *se);
/* reset dual reference space */

#define spy_eval_gamma_i _glp_spy_eval_gamma_i
double spy_eval_gamma_i(SPXLP *lp, SPYSE *se, int i);
/* compute dual projected steepest edge weight directly */

#define spy_chuzr_pse _glp_spy_chuzr_pse
int spy_chuzr_pse(SPXLP *lp, SPYSE *se, const double beta[/*1+m*/],
      int num, const int list[]);
/* choose basic variable (dual projected steepest edge) */

#define spy_update_gamma _glp_spy_update_gamma
double spy_update_gamma(SPXLP *lp, SPYSE *se, int p, int q,
      const double trow[/*1+n-m*/], const double tcol[/*1+m*/]);
/* update dual projected steepest edge weights exactly */

#if 1 /* 30/III-2016 */
#define spy_update_gamma_s _glp_spy_update_gamma_s
double spy_update_gamma_s(SPXLP *lp, SPYSE *se, int p, int q,
      const FVS *trow, const FVS *tcol);
/* sparse version of spy_update_gamma */
#endif

#define spy_free_se _glp_spy_free_se
void spy_free_se(SPXLP *lp, SPYSE *se);
/* deallocate dual pricing data block */




#if 1 /* 27/III-2016 */
#define PERTURB 1
#endif


#if 0 /* 23/III-2016 */
#define USE_AT 1
/* 1 - use A in row-wise format
 * 0 - use N in row-wise format */
/* (Looks like using A' provide more accuracy for dual simplex.) */
#else
#define USE_AT 0
#endif

#define EXCL 1
/* 1 - exclude fixed non-basic variables
 * 0 - don't exclude variables */

#define SHIFT 1
/* 1 - shift bounds of variables toward zero
 * 0 - don't shift bounds of variables */

#define CHECK_ACCURACY 0
/* (for debugging) */

struct csa
{     /* common storage area */
      SPXLP *lp;
      /* LP problem data and its (current) basis; this LP has m rows
       * and n columns */
      int dir;
      /* original optimization direction:
       * +1 - minimization
       * -1 - maximization */
      double *orig_b; /* double orig_b[1+m]; */
      /* copy of original right-hand sides */
#if PERTURB
      double *orig_c; /* double orig_c[1+n]; */
      /* copy of original objective coefficients */
#endif
      double *orig_l; /* double orig_l[1+n]; */
      /* copy of original lower bounds */
      double *orig_u; /* double orig_u[1+n]; */
      /* copy of original upper bounds */
      SPXAT *at;
      /* mxn-matrix A of constraint coefficients, in sparse row-wise
       * format (NULL if not used) */
      SPXNT *nt;
      /* mx(n-m)-matrix N composed of non-basic columns of constraint
       * matrix A, in sparse row-wise format (NULL if not used) */
      int phase;
      /* search phase:
       * 0 - not determined yet
       * 1 - searching for dual feasible solution
       * 2 - searching for optimal solution */
      double *beta; /* double beta[1+m]; */
      /* beta[i] is primal value of basic variable xB[i] */
      int beta_st;
      /* status of the vector beta:
       * 0 - undefined
       * 1 - just computed
       * 2 - updated */
      double *d; /* double d[1+n-m]; */
      /* d[j] is reduced cost of non-basic variable xN[j] */
      int d_st;
      /* status of the vector d:
       * 0 - undefined
       * 1 - just computed
       * 2 - updated */
      SPYSE *se;
      /* dual projected steepest edge and Devex pricing data block
       * (NULL if not used) */
#if 0 /* 30/III-2016 */
      int num;
      /* number of eligible basic variables */
      int *list; /* int list[1+m]; */
      /* list[1], ..., list[num] are indices i of eligible basic
       * variables xB[i] */
#else
      FVS r; /* FVS r[1:m]; */
      /* vector of primal infeasibilities */
      /* r->nnz = num; r->ind = list */
      /* vector r has the same status as vector beta (see above) */
#endif
      int p;
      /* xB[p] is a basic variable chosen to leave the basis */
#if 0 /* 29/III-2016 */
      double *trow; /* double trow[1+n-m]; */
#else
      FVS trow; /* FVS trow[1:n-m]; */
#endif
      /* p-th (pivot) row of the simplex table */
#if 1 /* 16/III-2016 */
      SPYBP *bp; /* SPYBP bp[1+n-m]; */
      /* dual objective break-points */
#endif
      int q;
      /* xN[q] is a non-basic variable chosen to enter the basis */
#if 0 /* 29/III-2016 */
      double *tcol; /* double tcol[1+m]; */
#else
      FVS tcol; /* FVS tcol[1:m]; */
#endif
      /* q-th (pivot) column of the simplex table */
      double *work; /* double work[1+m]; */
      /* working array */
      double *work1; /* double work1[1+n-m]; */
      /* another working array */
#if 1 /* 31/III-2016 */
      FVS wrow; /* FVS wrow[1:n-m]; */
      FVS wcol; /* FVS wcol[1:m]; */
      /* working sparse vectors */
#endif
      int p_stat, d_stat;
      /* primal and dual solution statuses */
      /*--------------------------------------------------------------*/
      /* control parameters (see struct glp_smcp) */
      int msg_lev;
      /* message level */
      int dualp;
      /* if this flag is set, report failure in case of instability */
#if 0 /* 16/III-2016 */
      int harris;
      /* dual ratio test technique:
       * 0 - textbook ratio test
       * 1 - Harris' two pass ratio test */
#else
      int r_test;
      /* dual ratio test technique:
       * GLP_RT_STD  - textbook ratio test
       * GLP_RT_HAR  - Harris' two pass ratio test
       * GLP_RT_FLIP - long-step (flip-flop) ratio test */
#endif
      double tol_bnd, tol_bnd1;
      /* primal feasibility tolerances */
      double tol_dj, tol_dj1;
      /* dual feasibility tolerances */
      double tol_piv;
      /* pivot tolerance */
      double obj_lim;
      /* objective limit */
      int it_lim;
      /* iteration limit */
      int tm_lim;
      /* time limit, milliseconds */
      int out_frq;
      /* display output frequency, iterations */
      int out_dly;
      /* display output delay, milliseconds */
      /*--------------------------------------------------------------*/
      /* working parameters */
      double tm_beg;
      /* time value at the beginning of the search */
      int it_beg;
      /* simplex iteration count at the beginning of the search */
      int it_cnt;
      /* simplex iteration count; it increases by one every time the
       * basis changes */
      int it_dpy;
      /* simplex iteration count at most recent display output */
      int inv_cnt;
      /* basis factorization count since most recent display output */
#if 1 /* 23/III-2016 */
      int ns_cnt;
      /* normal iteration count */
      int ls_cnt;
      /* long-step iteration count */
#endif
};

/***********************************************************************
*  check_flags - check correctness of active bound flags
*
*  This routine checks that flags specifying active bounds of all
*  non-basic variables are correct.
*
*  NOTE: It is important to note that if bounds of variables have been
*  changed, active bound flags should be corrected accordingly. */

static void check_flags(struct csa *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int j, k;
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)
            xassert(!flag[j]);
         else if (l[k] != -DBL_MAX && u[k] == +DBL_MAX)
            xassert(!flag[j]);
         else if (l[k] == -DBL_MAX && u[k] != +DBL_MAX)
            xassert(flag[j]);
         else if (l[k] == u[k])
            xassert(!flag[j]);
      }
      return;
}

/***********************************************************************
*  set_art_bounds - set artificial right-hand sides and bounds
*
*  This routine sets artificial right-hand sides and artificial bounds
*  for all variables to minimize the sum of dual infeasibilities on
*  phase I. Given current reduced costs d = (d[j]) this routine also
*  sets active artificial bounds of non-basic variables to provide dual
*  feasibility (this is always possible because all variables have both
*  lower and upper artificial bounds). */

static void set_art_bounds(struct csa *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *b = lp->b;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      double *d = csa->d;
      int i, j, k;
#if 1 /* 31/III-2016: FIXME */
      /* set artificial right-hand sides */
      for (i = 1; i <= m; i++)
         b[i] = 0.0;
      /* set artificial bounds depending on types of variables */
      for (k = 1; k <= n; k++)
      {  if (csa->orig_l[k] == -DBL_MAX && csa->orig_u[k] == +DBL_MAX)
         {  /* force free variables to enter the basis */
            l[k] = -1e3, u[k] = +1e3;
         }
      else if (csa->orig_l[k] != -DBL_MAX && csa->orig_u[k] == +DBL_MAX)
            l[k] = 0.0, u[k] = +1.0;
      else if (csa->orig_l[k] == -DBL_MAX && csa->orig_u[k] != +DBL_MAX)
            l[k] = -1.0, u[k] = 0.0;
         else
            l[k] = u[k] = 0.0;
      }
#endif
      /* set active artificial bounds for non-basic variables */
      xassert(csa->d_st == 1);
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         flag[j] = (l[k] != u[k] && d[j] < 0.0);
      }
      /* invalidate values of basic variables, since active bounds of
       * non-basic variables have been changed */
      csa->beta_st = 0;
      return;
}

/***********************************************************************
*  set_orig_bounds - restore original right-hand sides and bounds
*
*  This routine restores original right-hand sides and original bounds
*  for all variables. This routine also sets active original bounds for
*  non-basic variables; for double-bounded non-basic variables current
*  reduced costs d = (d[j]) are used to decide which bound (lower or
*  upper) should be made active. */

static void set_orig_bounds(struct csa *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *b = lp->b;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      double *d = csa->d;
      int j, k;
      /* restore original right-hand sides */
      memcpy(b, csa->orig_b, (1+m) * sizeof(double));
      /* restore original bounds of all variables */
      memcpy(l, csa->orig_l, (1+n) * sizeof(double));
      memcpy(u, csa->orig_u, (1+n) * sizeof(double));
      /* set active original bounds for non-basic variables */
      xassert(csa->d_st == 1);
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)
            flag[j] = 0;
         else if (l[k] != -DBL_MAX && u[k] == +DBL_MAX)
            flag[j] = 0;
         else if (l[k] == -DBL_MAX && u[k] != +DBL_MAX)
            flag[j] = 1;
         else if (l[k] != u[k])
            flag[j] = (d[j] < 0.0);
         else
            flag[j] = 0;
      }
      /* invalidate values of basic variables, since active bounds of
       * non-basic variables have been changed */
      csa->beta_st = 0;
      return;
}

/***********************************************************************
*  check_feas - check dual feasibility of basic solution
*
*  This routine checks that reduced costs of all non-basic variables
*  d = (d[j]) have correct signs.
*
*  Reduced cost d[j] is considered as having correct sign within the
*  specified tolerance depending on status of non-basic variable xN[j]
*  if one of the following conditions is met:
*
*     xN[j] is free                       -eps <= d[j] <= +eps
*
*     xN[j] has its lower bound active    d[j] >= -eps
*
*     xN[j] has its upper bound active    d[j] <= +eps
*
*     xN[j] is fixed                      d[j] has any value
*
*  where eps = tol + tol1 * |cN[j]|, cN[j] is the objective coefficient
*  at xN[j]. (See also the routine spx_chuzc_sel.)
*
*  The flag recov allows the routine to recover dual feasibility by
*  changing active bounds of non-basic variables. (For example, if
*  xN[j] has its lower bound active and d[j] < -eps, the feasibility
*  can be recovered by making xN[j] active on its upper bound.)
*
*  If the basic solution is dual feasible, the routine returns zero.
*  If the basic solution is dual infeasible, but its dual feasibility
*  can be recovered (or has been recovered, if the flag recov is set),
*  the routine returns a negative value. Otherwise, the routine returns
*  the number j of some non-basic variable xN[j], whose reduced cost
*  d[j] is dual infeasible and cannot be recovered. */

static int check_feas(struct csa *csa, double tol, double tol1, int recov)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      double *d = csa->d;
      int j, k, ret = 0;
      double eps;
      /* reduced costs should be just computed */
      xassert(csa->d_st == 1);
      /* walk thru list of non-basic variables */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         if (l[k] == u[k])
         {  /* xN[j] is fixed variable; skip it */
            continue;
         }
         /* determine absolute tolerance eps[j] */
         eps = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);
         /* check dual feasibility of xN[j] */
         if (d[j] > +eps)
         {  /* xN[j] should have its lower bound active */
            if (l[k] == -DBL_MAX || flag[j])
            {  /* but it either has no lower bound or its lower bound
                * is inactive */
               if (l[k] == -DBL_MAX)
               {  /* cannot recover, since xN[j] has no lower bound */
                  ret = j;
                  break;
               }
               /* recovering is possible */
               if (recov)
                  flag[j] = 0;
               ret = -1;
            }
         }
         else if (d[j] < -eps)
         {  /* xN[j] should have its upper bound active */
            if (!flag[j])
            {  /* but it either has no upper bound or its upper bound
                * is inactive */
               if (u[k] == +DBL_MAX)
               {  /* cannot recover, since xN[j] has no upper bound */
                  ret = j;
                  break;
               }
               /* recovering is possible */
               if (recov)
                  flag[j] = 1;
               ret = -1;
            }
         }
      }
      if (recov && ret)
      {  /* invalidate values of basic variables, since active bounds
          * of non-basic variables have been changed */
         csa->beta_st = 0;
      }
      return ret;
}

#if CHECK_ACCURACY
/***********************************************************************
*  err_in_vec - compute maximal relative error between two vectors
*
*  This routine computes and returns maximal relative error between
*  n-vectors x and y:
*
*     err_max = max |x[i] - y[i]| / (1 + |x[i]|).
*
*  NOTE: This routine is intended only for debugging purposes. */

static double err_in_vec(int n, const double x[], const double y[])
{     int i;
      double err, err_max;
      err_max = 0.0;
      for (i = 1; i <= n; i++)
      {  err = fabs(x[i] - y[i]) / (1.0 + fabs(x[i]));
         if (err_max < err)
            err_max = err;
      }
      return err_max;
}
#endif

#if CHECK_ACCURACY
/***********************************************************************
*  err_in_beta - compute maximal relative error in vector beta
*
*  This routine computes and returns maximal relative error in vector
*  of values of basic variables beta = (beta[i]).
*
*  NOTE: This routine is intended only for debugging purposes. */

static double err_in_beta(struct csa *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      double err, *beta;
      beta = talloc(1+m, double);
      spx_eval_beta(lp, beta);
      err = err_in_vec(m, beta, csa->beta);
      tfree(beta);
      return err;
}
#endif

#if CHECK_ACCURACY
static double err_in_r(struct csa *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int i, k;
      double err, *r;
      r = talloc(1+m, double);
      for (i = 1; i <= m; i++)
      {  k = lp->head[i];
         if (csa->beta[i] < lp->l[k])
            r[i] = lp->l[k] - csa->beta[i];
         else if (csa->beta[i] > lp->u[k])
            r[i] = lp->u[k] - csa->beta[i];
         else
            r[i] = 0.0;

if (fabs(r[i] - csa->r.vec[i]) > 1e-6)
printf("i = %d; r = %g; csa->r = %g\n", i, r[i], csa->r.vec[i]);


      }
      err = err_in_vec(m, r, csa->r.vec);
      tfree(r);
      return err;
}
#endif

#if CHECK_ACCURACY
/***********************************************************************
*  err_in_d - compute maximal relative error in vector d
*
*  This routine computes and returns maximal relative error in vector
*  of reduced costs of non-basic variables d = (d[j]).
*
*  NOTE: This routine is intended only for debugging purposes. */

static double err_in_d(struct csa *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      int j;
      double err, *pi, *d;
      pi = talloc(1+m, double);
      d = talloc(1+n-m, double);
      spx_eval_pi(lp, pi);
      for (j = 1; j <= n-m; j++)
         d[j] = spx_eval_dj(lp, pi, j);
      err = err_in_vec(n-m, d, csa->d);
      tfree(pi);
      tfree(d);
      return err;
}
#endif

#if CHECK_ACCURACY
/***********************************************************************
*  err_in_gamma - compute maximal relative error in vector gamma
*
*  This routine computes and returns maximal relative error in vector
*  of projected steepest edge weights gamma = (gamma[j]).
*
*  NOTE: This routine is intended only for debugging purposes. */

static double err_in_gamma(struct csa *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      SPYSE *se = csa->se;
      int i;
      double err, *gamma;
      xassert(se != NULL);
gamma = talloc(1+m, double);
      for (i = 1; i <= m; i++)
         gamma[i] = spy_eval_gamma_i(lp, se, i);
      err = err_in_vec(m, gamma, se->gamma);
      tfree(gamma);
      return err;
}
#endif

#if CHECK_ACCURACY
/***********************************************************************
*  check_accuracy - check accuracy of basic solution components
*
*  This routine checks accuracy of current basic solution components.
*
*  NOTE: This routine is intended only for debugging purposes. */

static void check_accuracy(struct csa *csa)
{     double e_beta, e_r, e_d, e_gamma;
      e_beta = err_in_beta(csa);
      e_r = err_in_r(csa);
      e_d = err_in_d(csa);
      if (csa->se == NULL)
         e_gamma = 0.;
      else
         e_gamma = err_in_gamma(csa);
      xprintf("e_beta = %10.3e; e_r = %10.3e; e_d = %10.3e; e_gamma = %"
         "10.3e\n", e_beta, e_r, e_d, e_gamma);
      xassert(e_beta <= 1e-5 && e_d <= 1e-5 && e_gamma <= 1e-3);
      return;
}
#endif

#if 1 /* 30/III-2016 */
static
void spy_eval_r(SPXLP *lp, const double beta[/*1+m*/], double tol,
      double tol1, FVS *r)
{     /* this routine computes the vector of primal infeasibilities:
       *
       *        ( lB[i] - beta[i] > 0, if beta[i] < lb[i]
       * r[i] = { 0,                   if lb[i] <= beta[i] <= ub[i]
       *        ( ub[i] - beta[i] < 0, if beta[i] > ub[i]
       *
       * (this routine replaces spy_chuzr_sel) */
      int m = lp->m;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      int *ind = r->ind;
      double *vec = r->vec;
      int i, k, nnz = 0;
      double lk, uk, eps;
      xassert(r->n == m);
      /* walk thru the list of basic variables */
      for (i = 1; i <= m; i++)
      {  vec[i] = 0.0;
         k = head[i]; /* x[k] = xB[i] */
         lk = l[k], uk = u[k];
         /* check primal feasibility */
         if (beta[i] < lk)
         {  /* determine absolute tolerance eps1[i] */
            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
            if (beta[i] < lk - eps)
            {  /* lower bound is violated */
               ind[++nnz] = i;
               vec[i] = lk - beta[i];
            }
         }
         else if (beta[i] > uk)
         {  /* determine absolute tolerance eps2[i] */
            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
            if (beta[i] > uk + eps)
            {  /* upper bound is violated */
               ind[++nnz] = i;
               vec[i] = uk - beta[i];
            }
         }
      }
      r->nnz = nnz;
      return;
}
#endif

/***********************************************************************
*  choose_pivot - choose xB[p] and xN[q]
*
*  Given the list of eligible basic variables this routine first
*  chooses basic variable xB[p]. This choice is always possible,
*  because the list is assumed to be non-empty. Then the routine
*  computes p-th row T[p,*] of the simplex table T[i,j] and chooses
*  non-basic variable xN[q]. If the pivot T[p,q] is small in magnitude,
*  the routine attempts to choose another xB[p] and xN[q] in order to
*  avoid badly conditioned adjacent bases.
*
*  If the normal choice was made, the routine returns zero. Otherwise,
*  if the long-step choice was made, the routine returns non-zero. */

#ifdef TIMING /* 31/III-2016 */

#else

#define MIN_RATIO 0.0001

static int choose_pivot(struct csa *csa)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      SPXAT *at = csa->at;
      SPXNT *nt = csa->nt;
      double *beta = csa->beta;
      double *d = csa->d;
      SPYSE *se = csa->se;
#if 0 /* 30/III-2016 */
      int *list = csa->list;
#else
      int *list = csa->r.ind;
#endif
      double *rho = csa->work;
      double *trow = csa->work1;
      SPYBP *bp = csa->bp;
      double tol_piv = csa->tol_piv;
      int try, nnn, j, k, p, q, t, t_best, nbp, ret;
      double big, temp, r, best_ratio, dz_best;
      xassert(csa->beta_st);
      xassert(csa->d_st);
more: /* initial number of eligible basic variables */
#if 0 /* 30/III-2016 */
      nnn = csa->num;
#else
      nnn = csa->r.nnz;
#endif
      /* nothing has been chosen so far */
      csa->p = 0;
      best_ratio = 0.0;
      try = ret = 0;
try:  /* choose basic variable xB[p] */
      xassert(nnn > 0);
      try++;
      if (se == NULL)
      {  /* dual Dantzig's rule */
         p = spy_chuzr_std(lp, beta, nnn, list);
      }
      else
      {  /* dual projected steepest edge */
         p = spy_chuzr_pse(lp, se, beta, nnn, list);
      }
      xassert(1 <= p && p <= m);
      /* compute p-th row of inv(B) */
      spx_eval_rho(lp, p, rho);
      /* compute p-th row of the simplex table */
      if (at != NULL)
         spx_eval_trow1(lp, at, rho, trow);
      else
         spx_nt_prod(lp, nt, trow, 1, -1.0, rho);
#if 1 /* 23/III-2016 */
      /* big := max(1, |trow[1]|, ..., |trow[n-m]|) */
      big = 1.0;
      for (j = 1; j <= n-m; j++)
      {  temp = trow[j];
         if (temp < 0.0)
            temp = - temp;
         if (big < temp)
            big = temp;
      }
#else
      /* this still puzzles me */
      big = 1.0;
#endif
      /* choose non-basic variable xN[q] */
      k = head[p]; /* x[k] = xB[p] */
      xassert(beta[p] < l[k] || beta[p] > u[k]);
      r = beta[p] < l[k] ? l[k] - beta[p] : u[k] - beta[p];
      if (csa->r_test == GLP_RT_FLIP && try <= 2)
      {  /* long-step ratio test */
#if 0 /* 23/III-2016 */
         /* determine dual objective break-points */
         nbp = spy_eval_bp(lp, d, r, trow, tol_piv, bp);
         if (nbp <= 1)
            goto skip;
         /* choose appropriate break-point */
         t_best = 0, dz_best = -DBL_MAX;
         for (t = 1; t <= nbp; t++)
         {  if (fabs(trow[bp[t].j]) / big >= MIN_RATIO)
            {  if (dz_best < bp[t].dz)
                  t_best = t, dz_best = bp[t].dz;
            }
         }
         if (t_best == 0)
            goto skip;
#else
         int t, num, num1;
         double slope, teta_lim;
         /* determine dual objective break-points */
         nbp = spy_ls_eval_bp(lp, d, r, trow, tol_piv, bp);
         if (nbp < 2)
            goto skip;
         /* set initial slope */
         slope = fabs(r);
         /* estimate initial teta_lim */
         teta_lim = DBL_MAX;
         for (t = 1; t <= nbp; t++)
         {  if (teta_lim > bp[t].teta)
               teta_lim = bp[t].teta;
         }
         xassert(teta_lim >= 0.0);
         if (teta_lim < 1e-6)
            teta_lim = 1e-6;
         /* nothing has been chosen so far */
         t_best = 0, dz_best = 0.0, num = 0;
         /* choose appropriate break-point */
         while (num < nbp)
         {  /* select and process a new portion of break-points */
            num1 = spy_ls_select_bp(lp, trow, nbp, bp, num, &slope,
               teta_lim);
            for (t = num+1; t <= num1; t++)
            {  if (fabs(trow[bp[t].j]) / big >= MIN_RATIO)
               {  if (dz_best < bp[t].dz)
                     t_best = t, dz_best = bp[t].dz;
               }
            }
            if (slope < 0.0)
            {  /* the dual objective starts decreasing */
               break;
            }
            /* the dual objective continues increasing */
            num = num1;
            teta_lim += teta_lim;
         }
         if (dz_best == 0.0)
            goto skip;
         xassert(1 <= t_best && t_best <= num1);
#endif
         /* the choice has been made */
         csa->p = p;
#if 0 /* 29/III-2016 */
         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));
#else
         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));
         fvs_gather_vec(&csa->trow, DBL_EPSILON);
#endif
         csa->q = bp[t_best].j;
         best_ratio = fabs(trow[bp[t_best].j]) / big;
#if 0
         xprintf("num = %d; t_best = %d; dz = %g\n", num, t_best,
            bp[t_best].dz);
#endif
         ret = 1;
         goto done;
skip:    ;
      }
      if (csa->r_test == GLP_RT_STD)
      {  /* textbook dual ratio test */
         q = spy_chuzc_std(lp, d, r, trow, tol_piv,
            .30 * csa->tol_dj, .30 * csa->tol_dj1);
      }
      else
      {  /* Harris' two-pass dual ratio test */
         q = spy_chuzc_harris(lp, d, r, trow, tol_piv,
            .35 * csa->tol_dj, .35 * csa->tol_dj1);
      }
      if (q == 0)
      {  /* dual unboundedness */
         csa->p = p;
#if 0 /* 29/III-2016 */
         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));
#else
         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));
         fvs_gather_vec(&csa->trow, DBL_EPSILON);
#endif
         csa->q = q;
         best_ratio = 1.0;
         goto done;
      }
      /* either keep previous choice or accept new choice depending on
       * which one is better */
      if (best_ratio < fabs(trow[q]) / big)
      {  csa->p = p;
#if 0 /* 29/III-2016 */
         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));
#else
         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));
         fvs_gather_vec(&csa->trow, DBL_EPSILON);
#endif
         csa->q = q;
         best_ratio = fabs(trow[q]) / big;
      }
      /* check if the current choice is acceptable */
      if (best_ratio >= MIN_RATIO || nnn == 1 || try == 5)
         goto done;
      /* try to choose other xB[p] and xN[q] */
      /* find xB[p] in the list */
      for (t = 1; t <= nnn; t++)
         if (list[t] == p) break;
      xassert(t <= nnn);
      /* move xB[p] to the end of the list */
      list[t] = list[nnn], list[nnn] = p;
      /* and exclude it from consideration */
      nnn--;
      /* repeat the choice */
      goto try;
done: /* the choice has been made */
#if 1 /* FIXME: currently just to avoid badly conditioned basis */
      if (best_ratio < .001 * MIN_RATIO)
      {  /* looks like this helps */
         if (bfd_get_count(lp->bfd) > 0)
            return -1;
         /* didn't help; last chance to improve the choice */
         if (tol_piv == csa->tol_piv)
         {  tol_piv *= 1000.;
            goto more;
         }
      }
#endif
#if 1 /* FIXME */
      if (ret)
      {  /* invalidate basic solution components */
#if 0 /* 28/III-2016 */
         csa->beta_st = csa->d_st = 0;
#else
         /* dual solution remains valid */
         csa->beta_st = 0;
#endif
         /* set double-bounded non-basic variables to opposite bounds
          * for all break-points preceding the chosen one */
         for (t = 1; t < t_best; t++)
         {  k = head[m + bp[t].j];
            xassert(-DBL_MAX < l[k] && l[k] < u[k] && u[k] < +DBL_MAX);
            lp->flag[bp[t].j] = !(lp->flag[bp[t].j]);
         }
      }
#endif
      return ret;
}

#endif

#if PERTURB
/***********************************************************************
*  play_coef - play objective coefficients
*
*  This routine is called after the reduced costs d[j] was updated and
*  the basis was changed to the adjacent one.
*
*  It is assumed that before updating all the reduced costs d[j] were
*  strongly feasible, so in the adjacent basis d[j] remain feasible
*  within a tolerance, i.e. if some d[j] violates its zero bound, the
*  violation is insignificant.
*
*  If some d[j] violates its zero bound, the routine changes (perturbs)
*  objective coefficient cN[j] to provide d[j] = 0, i.e. to make all
*  d[j] strongly feasible. Otherwise, if d[j] has a feasible value, the
*  routine attempts to reduce (or remove) perturbation in cN[j] by
*  shifting d[j] to its zero bound keeping strong feasibility. */

static void play_coef(struct csa *csa, int all)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      double *orig_c = csa->orig_c;
      double *d = csa->d;
#if 0 /* 29/III-2016 */
      double *trow = csa->trow; /* was used to update d = (d[j]) */
#else
      const double *trow = csa->trow.vec;
#endif
      int j, k;
      double temp;
      /* reduced costs d = (d[j]) should be valid */
      xassert(csa->d_st);
      /* walk thru the list of non-basic variables xN = (xN[j]) */
      for (j = 1; j <= n-m; j++)
      {  if (all || trow[j] != 0.0)
         {  /* d[j] has changed in the adjacent basis */
            k = head[m+j]; /* x[k] = xN[j] */
            if (l[k] == u[k])
            {  /* xN[j] is fixed variable */
               /* d[j] may have any sign */
            }
            else if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)
            {  /* xN[j] is free variable */
               /* strong feasibility means d[j] = 0 */
               c[k] -= d[j], d[j] = 0.0;
            }
            else if (!flag[j])
            {  /* xN[j] has its lower bound active */
               /* strong feasibility means d[j] >= 0 */
               if (d[j] < 0.0)
                  c[k] -= d[j], d[j] = 0.0;
               else if (c[k] > orig_c[k])
               {  /* remove/reduce perturbation of cN[j] */
                  temp = c[k] - orig_c[k]; /* > 0 */
                  if (temp < d[j])
                     c[k] = orig_c[k], d[j] -= temp;
                  else
                     c[k] -= d[j], d[j] = 0.0;
               }
            }
            else
            {  /* xN[j] has its upper bound active */
               /* strong feasibility means d[j] <= 0 */
               if (d[j] > 0.0)
                  c[k] -= d[j], d[j] = 0.0;
               else if (c[k] < orig_c[k])
               {  /* remove/reduce perturbation of cN[j] */
                  temp = c[k] - orig_c[k]; /* < 0 */
                  if (temp > d[j])
                     c[k] = orig_c[k], d[j] -= temp;
                  else
                     c[k] -= d[j], d[j] = 0.0;
               }
            }
         }
      }
      return;
}
#endif

/***********************************************************************
*  display - display search progress
*
*  This routine displays some information about the search progress
*  that includes:
*
*  search phase;
*
*  number of simplex iterations performed by the solver;
*
*  original objective value (only on phase II);
*
*  sum of (scaled) dual infeasibilities for original bounds;
*
*  number of dual infeasibilities (phase I) or primal infeasibilities
*  (phase II);
*
*  number of basic factorizations since last display output. */

static void display(struct csa *csa, int spec)
{     SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *flag = lp->flag;
      double *l = csa->orig_l; /* original lower bounds */
      double *u = csa->orig_u; /* original upper bounds */
      double *beta = csa->beta;
      double *d = csa->d;
      int j, k, nnn;
      double sum;
      /* check if the display output should be skipped */
      if (csa->msg_lev < GLP_MSG_ON) goto skip;
      if (csa->out_dly > 0 &&
         1000.0 * xdifftime(xtime(), csa->tm_beg) < csa->out_dly)
         goto skip;
      if (csa->it_cnt == csa->it_dpy) goto skip;
      if (!spec && csa->it_cnt % csa->out_frq != 0) goto skip;
      /* display search progress depending on search phase */
      switch (csa->phase)
      {  case 1:
            /* compute sum and number of (scaled) dual infeasibilities
             * for original bounds */
            sum = 0.0, nnn = 0;
            for (j = 1; j <= n-m; j++)
            {  k = head[m+j]; /* x[k] = xN[j] */
               if (d[j] > 0.0)
               {  /* xN[j] should have lower bound */
                  if (l[k] == -DBL_MAX)
                  {  sum += d[j];
                     if (d[j] > +1e-7)
                        nnn++;
                  }
               }
               else if (d[j] < 0.0)
               {  /* xN[j] should have upper bound */
                  if (u[k] == +DBL_MAX)
                  {  sum -= d[j];
                     if (d[j] < -1e-7)
                        nnn++;
                  }
               }
            }
            /* on phase I variables have artificial bounds which are
             * meaningless for original LP, so corresponding objective
             * function value is also meaningless */
#if 0 /* 27/III-2016 */
            xprintf(" %6d: %23s inf = %11.3e (%d)",
               csa->it_cnt, "", sum, nnn);
#else
            xprintf(" %6d: sum = %17.9e inf = %11.3e (%d)",
               csa->it_cnt, lp->c[0] - spx_eval_obj(lp, beta),
               sum, nnn);
#endif
            break;
         case 2:
            /* compute sum of (scaled) dual infeasibilities */
            sum = 0.0, nnn = 0;
            for (j = 1; j <= n-m; j++)
            {  k = head[m+j]; /* x[k] = xN[j] */
               if (d[j] > 0.0)
               {  /* xN[j] should have its lower bound active */
                  if (l[k] == -DBL_MAX || flag[j])
                     sum += d[j];
               }
               else if (d[j] < 0.0)
               {  /* xN[j] should have its upper bound active */
                  if (l[k] != u[k] && !flag[j])
                     sum -= d[j];
               }
            }
            /* compute number of primal infeasibilities */
            nnn = spy_chuzr_sel(lp, beta, csa->tol_bnd, csa->tol_bnd1,
               NULL);
            xprintf("#%6d: obj = %17.9e inf = %11.3e (%d)",
               csa->it_cnt, (double)csa->dir * spx_eval_obj(lp, beta),
               sum, nnn);
            break;
         default:
            xassert(csa != csa);
      }
      if (csa->inv_cnt)
      {  /* number of basis factorizations performed */
         xprintf(" %d", csa->inv_cnt);
         csa->inv_cnt = 0;
      }
#if 1 /* 23/III-2016 */
      if (csa->r_test == GLP_RT_FLIP)
      {  xprintf("   %d,%d", csa->ns_cnt, csa->ls_cnt);
         csa->ns_cnt = csa->ls_cnt = 0;
      }
#endif
      xprintf("\n");
      csa->it_dpy = csa->it_cnt;
skip: return;
}

#if 1 /* 31/III-2016 */
static
void spy_update_r(SPXLP *lp, int p, int q, const double beta[/*1+m*/],
      const FVS *tcol, double tol, double tol1, FVS *r)
{     /* update vector r of primal infeasibilities */
      /* it is assumed that xB[p] leaves the basis, xN[q] enters the
       * basis, and beta corresponds to the adjacent basis (i.e. this
       * routine should be called after spx_update_beta) */
      int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      int *tcol_ind = tcol->ind;
      int *ind = r->ind;
      double *vec = r->vec;
      int i, k, t, nnz;
      double lk, uk, ri, eps;
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n-m);
      nnz = r->nnz;
      for (t = tcol->nnz; t >= 1; t--)
      {  i = tcol_ind[t];
         /* xB[i] changes in the adjacent basis to beta[i], so only
          * r[i] should be updated */
         if (i == p)
            k = head[m+q]; /* x[k] = new xB[p] = old xN[q] */
         else
            k = head[i];   /* x[k] = new xB[i] = old xB[i] */
         lk = l[k], uk = u[k];
         /* determine new value of r[i]; see spy_eval_r */
         ri = 0.0;
         if (beta[i] < lk)
         {  /* determine absolute tolerance eps1[i] */
            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
            if (beta[i] < lk - eps)
            {  /* lower bound is violated */
               ri = lk - beta[i];
            }
         }
         else if (beta[i] > uk)
         {  /* determine absolute tolerance eps2[i] */
            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
            if (beta[i] > uk + eps)
            {  /* upper bound is violated */
               ri = uk - beta[i];
            }
         }
         if (ri == 0.0)
         {  if (vec[i] != 0.0)
               vec[i] = DBL_MIN; /* will be removed */
         }
         else
         {  if (vec[i] == 0.0)
               ind[++nnz] = i;
            vec[i] = ri;
         }

      }
      r->nnz = nnz;
      /* remove zero elements */
      fvs_adjust_vec(r, DBL_MIN + DBL_MIN);
      return;
}
#endif





/***********************************************************************
*  NAME
*
*  round2n - round floating-point number to nearest power of two
*
*  SYNOPSIS
*
*  #include "misc.h"
*  double round2n(double x);
*
*  RETURNS
*
*  Given a positive floating-point value x the routine round2n returns
*  2^n such that |x - 2^n| is minimal.
*
*  EXAMPLES
*
*  round2n(10.1) = 2^3 = 8
*  round2n(15.3) = 2^4 = 16
*  round2n(0.01) = 2^(-7) = 0.0078125
*
*  BACKGROUND
*
*  Let x = f * 2^e, where 0.5 <= f < 1 is a normalized fractional part,
*  e is an integer exponent. Then, obviously, 0.5 * 2^e <= x < 2^e, so
*  if x - 0.5 * 2^e <= 2^e - x, we choose 0.5 * 2^e = 2^(e-1), and 2^e
*  otherwise. The latter condition can be written as 2 * x <= 1.5 * 2^e
*  or 2 * f * 2^e <= 1.5 * 2^e or, finally, f <= 0.75. */

double round2n(double x)
{     int e;
      double f;
      xassert(x > 0.0);
      f = frexp(x, &e);
      return ldexp(1.0, f <= 0.75 ? e-1 : e);
}












/***********************************************************************
*  spy_dual - driver to dual simplex method
*
*  This routine is a driver to the two-phase dual simplex method.
*
*  On exit this routine returns one of the following codes:
*
*  0  LP instance has been successfully solved.
*
*  GLP_EOBJLL
*     Objective lower limit has been reached (maximization).
*
*  GLP_EOBJUL
*     Objective upper limit has been reached (minimization).
*
*  GLP_EITLIM
*     Iteration limit has been exhausted.
*
*  GLP_ETMLIM
*     Time limit has been exhausted.
*
*  GLP_EFAIL
*     The solver failed to solve LP instance. */

static int dual_simplex(struct csa *csa)
{     /* dual simplex method main logic routine */
      SPXLP *lp = csa->lp;
      int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      SPXNT *nt = csa->nt;
      double *beta = csa->beta;
      double *d = csa->d;
      SPYSE *se = csa->se;
#if 0 /* 30/III-2016 */
      int *list = csa->list;
#endif
#if 0 /* 31/III-2016 */
      double *trow = csa->trow;
      double *tcol = csa->tcol;
#endif
      double *pi = csa->work;
      int msg_lev = csa->msg_lev;
      double tol_bnd = csa->tol_bnd;
      double tol_bnd1 = csa->tol_bnd1;
      double tol_dj = csa->tol_dj;
      double tol_dj1 = csa->tol_dj1;
      int j, k, p_flag, refct, ret;
#if PERTURB
      int perturb = 1;
#endif
#if 1 /* 27/III-2016 */
      int instab = 0; /* instability count */
#endif
#ifdef TIMING
      double t_total  = timer(); /* total time */
      double t_fact   = 0.0;     /* computing factorization */
      double t_rtest  = 0.0;     /* performing ratio test */
      double t_pivcol = 0.0;     /* computing pivot column */
      double t_upd1   = 0.0;     /* updating primal values */
      double t_upd2   = 0.0;     /* updating dual values */
      double t_upd3   = 0.0;     /* updating se weights */
      double t_upd4   = 0.0;     /* updating matrix N */
      double t_upd5   = 0.0;     /* updating factorization */
      double t_start;
#endif
      check_flags(csa);
loop: /* main loop starts here */
      /* compute factorization of the basis matrix */
      if (!lp->valid)
      {  double cond;
#ifdef TIMING
         t_start = timer();
#endif
         ret = spx_factorize(lp);
#ifdef TIMING
         t_fact += timer() - t_start;
#endif
         csa->inv_cnt++;
         if (ret != 0)
         {  if (msg_lev >= GLP_MSG_ERR)
               xprintf("Error: unable to factorize the basis matrix (%d"
                  ")\n", ret);
            csa->p_stat = csa->d_stat = GLP_UNDEF;
            ret = GLP_EFAIL;
            goto fini;
         }
         /* check condition of the basis matrix */
         cond = bfd_condest(lp->bfd);
         if (cond > 1.0 / DBL_EPSILON)
         {  if (msg_lev >= GLP_MSG_ERR)
               xprintf("Error: basis matrix is singular to working prec"
                  "ision (cond = %.3g)\n", cond);
            csa->p_stat = csa->d_stat = GLP_UNDEF;
            ret = GLP_EFAIL;
            goto fini;
         }
         if (cond > 0.001 / DBL_EPSILON)
         {  if (msg_lev >= GLP_MSG_ERR)
               xprintf("Warning: basis matrix is ill-conditioned (cond "
                  "= %.3g)\n", cond);
         }
         /* invalidate basic solution components */
         csa->beta_st = csa->d_st = 0;
      }
      /* compute reduced costs of non-basic variables d = (d[j]) */
      if (!csa->d_st)
      {  spx_eval_pi(lp, pi);
         for (j = 1; j <= n-m; j++)
            d[j] = spx_eval_dj(lp, pi, j);
         csa->d_st = 1; /* just computed */
         /* determine the search phase, if not determined yet (this is
          * performed only once at the beginning of the search for the
          * original bounds) */
         if (!csa->phase)
         {  j = check_feas(csa, 0.97 * tol_dj, 0.97 * tol_dj1, 1);
            if (j > 0)
            {  /* initial basic solution is dual infeasible and cannot
                * be recovered */
               /* start to search for dual feasible solution */
               set_art_bounds(csa);
               csa->phase = 1;
            }
            else
            {  /* initial basic solution is either dual feasible or its
                * dual feasibility has been recovered */
               /* start to search for optimal solution */
               csa->phase = 2;
            }
         }
         /* make sure that current basic solution is dual feasible */
#if 0 /* 29/III-2016 */
         j = check_feas(csa, tol_dj, tol_dj1, 0);
#else
         if (perturb)
            j = check_feas(csa, 3.14 * tol_dj, 3.14 * tol_dj1, 0);
         else
            j = check_feas(csa, tol_dj, tol_dj1, 0);
#endif
         if (j)
         {  /* dual feasibility is broken due to excessive round-off
             * errors */
            if (bfd_get_count(lp->bfd))
            {  /* try to provide more accuracy */
               lp->valid = 0;
               goto loop;
            }
            if (msg_lev >= GLP_MSG_ERR)
               xprintf("Warning: numerical instability (dual simplex, p"
                  "hase %s)\n", csa->phase == 1 ? "I" : "II");
#if 0 /* 27/III-2016 */
            if (csa->dualp)
#else
            instab++;
            if (csa->dualp && instab >= 10)
#endif
            {  /* do not continue the search; report failure */
               if (msg_lev >= GLP_MSG_ERR)
                  xprintf("Warning: dual simplex failed due to excessiv"
                     "e numerical instability\n");
               csa->p_stat = csa->d_stat = GLP_UNDEF;
               ret = -1; /* special case of GLP_EFAIL */
               goto fini;
            }
            /* try to recover dual feasibility */
            j = check_feas(csa, 0.97 * tol_dj, 0.97 * tol_dj1, 1);
            if (j > 0)
            {  /* dual feasibility cannot be recovered (this may happen
                * only on phase II) */
               xassert(csa->phase == 2);
               /* restart to search for dual feasible solution */
               set_art_bounds(csa);
               csa->phase = 1;
            }
         }
#if PERTURB
         /* check_feas guarantees that all d[j] are feasible within
          * a tolerance */
         if (perturb)
            play_coef(csa, 1);
#endif
      }
      /* at this point the search phase is determined */
      xassert(csa->phase == 1 || csa->phase == 2);
      /* compute values of basic variables beta = (beta[i]) */
      if (!csa->beta_st)
      {  spx_eval_beta(lp, beta);
#if 1 /* 31/III-2016 */
         /* also compute vector r of primal infeasibilities */
         switch (csa->phase)
         {  case 1:
               spy_eval_r(lp, beta, 1e-8, 0.0, &csa->r);
               break;
            case 2:
               spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
               break;
            default:
               xassert(csa != csa);
         }
#endif
         csa->beta_st = 1; /* just computed */
      }
      /* reset the dual reference space, if necessary */
      if (se != NULL && !se->valid)
         spy_reset_refsp(lp, se), refct = 1000;
      /* at this point the basis factorization and all basic solution
       * components are valid */
      xassert(lp->valid && csa->beta_st && csa->d_st);
#ifdef GLP_DEBUG
      check_flags(csa);
#endif
#if CHECK_ACCURACY
      /* check accuracy of current basic solution components (only for
       * debugging) */
      check_accuracy(csa);
#endif
      /* check if the objective limit has been reached */
#if PERTURB
      /* FIXME */
      if (!perturb)
#endif
      if (csa->phase == 2 && csa->obj_lim != DBL_MAX
         && spx_eval_obj(lp, beta) >= csa->obj_lim)
      {  if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         display(csa, 1);
         if (msg_lev >= GLP_MSG_ALL)
            xprintf("OBJECTIVE %s LIMIT REACHED; SEARCH TERMINATED\n",
               csa->dir > 0 ? "UPPER" : "LOWER");
#if 0 /* 30/III-2016 */
         csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1, list);
         csa->p_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
#else
         spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
         csa->p_stat = (csa->r.nnz == 0 ? GLP_FEAS : GLP_INFEAS);
#endif
         csa->d_stat = GLP_FEAS;
         ret = (csa->dir > 0 ? GLP_EOBJUL : GLP_EOBJLL);
         goto fini;
      }
      /* check if the iteration limit has been exhausted */
      if (csa->it_cnt - csa->it_beg >= csa->it_lim)
      {
#if PERTURB
         if (perturb)
         {  /* remove perturbation */
            perturb = 0;
            memcpy(csa->lp->c, csa->orig_c, (1+n) * sizeof(double));
            csa->phase = csa->d_st = 0;
         }
#endif
         if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         display(csa, 1);
         if (msg_lev >= GLP_MSG_ALL)
            xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
         if (csa->phase == 1)
         {  set_orig_bounds(csa);
            check_flags(csa);
            spx_eval_beta(lp, beta);
         }
#if 0 /* 30/III-2016 */
         csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1, list);
         csa->p_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
#else
         spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
         csa->p_stat = (csa->r.nnz == 0 ? GLP_FEAS : GLP_INFEAS);
#endif
         csa->d_stat = (csa->phase == 1 ? GLP_INFEAS : GLP_FEAS);
         ret = GLP_EITLIM;
         goto fini;
      }
      /* check if the time limit has been exhausted */
      if (1000.0 * xdifftime(xtime(), csa->tm_beg) >= csa->tm_lim)
      {
#if PERTURB
         if (perturb)
         {  /* remove perturbation */
            perturb = 0;
            memcpy(csa->lp->c, csa->orig_c, (1+n) * sizeof(double));
            csa->phase = csa->d_st = 0;
         }
#endif
         if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         display(csa, 1);
         if (msg_lev >= GLP_MSG_ALL)
            xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
         if (csa->phase == 1)
         {  set_orig_bounds(csa);
            check_flags(csa);
            spx_eval_beta(lp, beta);
         }
#if 0 /* 30/III-2016 */
         csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1, list);
         csa->p_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
#else
         spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
         csa->p_stat = (csa->r.nnz == 0 ? GLP_FEAS : GLP_INFEAS);
#endif
         csa->d_stat = (csa->phase == 1 ? GLP_INFEAS : GLP_FEAS);
         ret = GLP_ETMLIM;
         goto fini;
      }
      /* display the search progress */
      display(csa, 0);
      /* select eligible basic variables */
#if 0 /* 31/III-2016; not needed because r is valid */
      switch (csa->phase)
      {  case 1:
#if 0 /* 30/III-2016 */
            csa->num = spy_chuzr_sel(lp, beta, 1e-8, 0.0, list);
#else
            spy_eval_r(lp, beta, 1e-8, 0.0, &csa->r);
#endif
            break;
         case 2:
#if 0 /* 30/III-2016 */
            csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1, list);
#else
            spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
#endif
            break;
         default:
            xassert(csa != csa);
      }
#endif
      /* check for optimality */
#if 0 /* 30/III-2016 */
      if (csa->num == 0)
#else
      if (csa->r.nnz == 0)
#endif
      {
#if PERTURB
         if (perturb && csa->phase == 2)
         {  /* remove perturbation */
            perturb = 0;
            memcpy(csa->lp->c, csa->orig_c, (1+n) * sizeof(double));
            csa->phase = csa->d_st = 0;
         }
#endif
         if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         /* current basis is optimal */
         display(csa, 1);
         switch (csa->phase)
         {  case 1:
               /* check for dual feasibility */
               set_orig_bounds(csa);
               check_flags(csa);
               if (check_feas(csa, tol_dj, tol_dj1, 0) == 0)
               {  /* dual feasible solution found; switch to phase II */
                  csa->phase = 2;
                  xassert(!csa->beta_st);
                  goto loop;
               }
               /* no dual feasible solution exists */
               if (msg_lev >= GLP_MSG_ALL)
                  xprintf("LP HAS NO DUAL FEASIBLE SOLUTION\n");
               spx_eval_beta(lp, beta);
#if 0 /* 30/III-2016 */
               csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1,
                  list);
               csa->p_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
#else
               spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
               csa->p_stat = (csa->r.nnz == 0 ? GLP_FEAS : GLP_INFEAS);
#endif
               csa->d_stat = GLP_NOFEAS;
               ret = 0;
               goto fini;
            case 2:
               /* optimal solution found */
               if (msg_lev >= GLP_MSG_ALL)
                  xprintf("OPTIMAL LP SOLUTION FOUND\n");
               csa->p_stat = csa->d_stat = GLP_FEAS;
               ret = 0;
               goto fini;
            default:
               xassert(csa != csa);
         }
      }
      /* choose xB[p] and xN[q] */
#if 0 /* 23/III-2016 */
      choose_pivot(csa);
#else
#ifdef TIMING
      t_start = timer();
#endif
#if 1 /* 31/III-2016 */
      ret = choose_pivot(csa);
#endif
#ifdef TIMING
      t_rtest += timer() - t_start;
#endif
      if (ret < 0)
      {  lp->valid = 0;
         goto loop;
      }
      if (ret == 0)
         csa->ns_cnt++;
      else
         csa->ls_cnt++;
#endif
      /* check for dual unboundedness */
      if (csa->q == 0)
      {
#if PERTURB
         if (perturb)
         {  /* remove perturbation */
            perturb = 0;
            memcpy(csa->lp->c, csa->orig_c, (1+n) * sizeof(double));
            csa->phase = csa->d_st = 0;
         }
#endif
         if (csa->beta_st != 1)
            csa->beta_st = 0;
         if (csa->d_st != 1)
            csa->d_st = 0;
         if (!(csa->beta_st && csa->d_st))
            goto loop;
         display(csa, 1);
         switch (csa->phase)
         {  case 1:
               /* this should never happen */
               if (msg_lev >= GLP_MSG_ERR)
                  xprintf("Error: dual simplex failed\n");
               csa->p_stat = csa->d_stat = GLP_UNDEF;
               ret = GLP_EFAIL;
               goto fini;
            case 2:
               /* dual unboundedness detected */
               if (msg_lev >= GLP_MSG_ALL)
                  xprintf("LP HAS NO PRIMAL FEASIBLE SOLUTION\n");
               csa->p_stat = GLP_NOFEAS;
               csa->d_stat = GLP_FEAS;
               ret = 0;
               goto fini;
            default:
               xassert(csa != csa);
         }
      }
      /* compute q-th column of the simplex table */
#ifdef TIMING
      t_start = timer();
#endif
#if 0 /* 31/III-2016 */
      spx_eval_tcol(lp, csa->q, tcol);
#else
      spx_eval_tcol(lp, csa->q, csa->tcol.vec);
      fvs_gather_vec(&csa->tcol, DBL_EPSILON);
#endif
#ifdef TIMING
      t_pivcol += timer() - t_start;
#endif
      /* FIXME: tcol[p] and trow[q] should be close to each other */
      xassert(csa->tcol.vec[csa->p] != 0.0);
      /* update values of basic variables for adjacent basis */
      k = head[csa->p]; /* x[k] = xB[p] */
      p_flag = (l[k] != u[k] && beta[csa->p] > u[k]);
#if 0 /* 16/III-2016 */
      spx_update_beta(lp, beta, csa->p, p_flag, csa->q, tcol);
      csa->beta_st = 2;
#else
      /* primal solution may be invalidated due to long step */
#ifdef TIMING
      t_start = timer();
#endif
      if (csa->beta_st)
#if 0 /* 30/III-2016 */
      {  spx_update_beta(lp, beta, csa->p, p_flag, csa->q, tcol);
#else
      {  spx_update_beta_s(lp, beta, csa->p, p_flag, csa->q,
            &csa->tcol);
         /* also update vector r of primal infeasibilities */
         /*fvs_check_vec(&csa->r);*/
         switch (csa->phase)
         {  case 1:
               spy_update_r(lp, csa->p, csa->q, beta, &csa->tcol,
                  1e-8, 0.0, &csa->r);
               break;
            case 2:
               spy_update_r(lp, csa->p, csa->q, beta, &csa->tcol,
                  tol_bnd, tol_bnd1, &csa->r);
               break;
            default:
               xassert(csa != csa);
         }
         /*fvs_check_vec(&csa->r);*/
#endif
         csa->beta_st = 2;
      }
#ifdef TIMING
      t_upd1 += timer() - t_start;
#endif
#endif
      /* update reduced costs of non-basic variables for adjacent
       * basis */
#if 1 /* 28/III-2016 */
      xassert(csa->d_st);
#endif
#ifdef TIMING
      t_start = timer();
#endif
#if 0 /* 30/III-2016 */
      if (spx_update_d(lp, d, csa->p, csa->q, trow, tcol) <= 1e-9)
#else
      if (spx_update_d_s(lp, d, csa->p, csa->q, &csa->trow, &csa->tcol)
         <= 1e-9)
#endif
      {  /* successful updating */
         csa->d_st = 2;
      }
      else
      {  /* new reduced costs are inaccurate */
         csa->d_st = 0;
      }
#ifdef TIMING
      t_upd2 += timer() - t_start;
#endif
      /* update steepest edge weights for adjacent basis, if used */
#ifdef TIMING
      t_start = timer();
#endif
      if (se != NULL)
      {  if (refct > 0)
#if 0 /* 30/III-2016 */
         {  if (spy_update_gamma(lp, se, csa->p, csa->q, trow, tcol)
               <= 1e-3)
#else
         {  if (spy_update_gamma_s(lp, se, csa->p, csa->q, &csa->trow,
               &csa->tcol) <= 1e-3)
#endif
            {  /* successful updating */
               refct--;
            }
            else
            {  /* new weights are inaccurate; reset reference space */
               se->valid = 0;
            }
         }
         else
         {  /* too many updates; reset reference space */
            se->valid = 0;
         }
      }
#ifdef TIMING
      t_upd3 += timer() - t_start;
#endif
#ifdef TIMING
      t_start = timer();
#endif
      /* update matrix N for adjacent basis, if used */
      if (nt != NULL)
         spx_update_nt(lp, nt, csa->p, csa->q);
#ifdef TIMING
      t_upd4 += timer() - t_start;
#endif
      /* change current basis header to adjacent one */
      spx_change_basis(lp, csa->p, p_flag, csa->q);
      /* and update factorization of the basis matrix */
#ifdef TIMING
      t_start = timer();
#endif
#if 0 /* 16/III-2016 */
      if (csa->p > 0)
#endif
         spx_update_invb(lp, csa->p, head[csa->p]);
#ifdef TIMING
      t_upd5 += timer() - t_start;
#endif
#if PERTURB
      if (perturb && csa->d_st)
         play_coef(csa, 0);
#endif
      /* dual simplex iteration complete */
      csa->it_cnt++;
      goto loop;
fini:
#ifdef TIMING
      t_total = timer() - t_total;
      xprintf("Total time      = %10.3f\n", t_total);
      xprintf("Factorization   = %10.3f\n", t_fact);
      xprintf("Ratio test      = %10.3f\n", t_rtest);
      xprintf("Pivot column    = %10.3f\n", t_pivcol);
      xprintf("Updating beta   = %10.3f\n", t_upd1);
      xprintf("Updating d      = %10.3f\n", t_upd2);
      xprintf("Updating gamma  = %10.3f\n", t_upd3);
      xprintf("Updating N      = %10.3f\n", t_upd4);
      xprintf("Updating inv(B) = %10.3f\n", t_upd5);
#endif
      return ret;
}

int spy_dual(glp_prob *P, const glp_smcp *parm)
{     /* driver to dual simplex method */
      struct csa csa_, *csa = &csa_;
      SPXLP lp;
#if USE_AT
      SPXAT at;
#else
      SPXNT nt;
#endif
      SPYSE se;
      int ret, *map, *daeh;
      /* build working LP and its initial basis */
      memset(csa, 0, sizeof(struct csa));
      csa->lp = &lp;
      spx_init_lp(csa->lp, P, EXCL);
      spx_alloc_lp(csa->lp);
      map = talloc(1+P->m+P->n, int);
      spx_build_lp(csa->lp, P, EXCL, SHIFT, map);
      spx_build_basis(csa->lp, P, map);
      switch (P->dir)
      {  case GLP_MIN:
            csa->dir = +1;
            break;
         case GLP_MAX:
            csa->dir = -1;
            break;
         default:
            xassert(P != P);
      }
      csa->orig_b = talloc(1+csa->lp->m, double);
      memcpy(csa->orig_b, csa->lp->b, (1+csa->lp->m) * sizeof(double));
#if PERTURB
      csa->orig_c = talloc(1+csa->lp->n, double);
      memcpy(csa->orig_c, csa->lp->c, (1+csa->lp->n) * sizeof(double));
#endif
      csa->orig_l = talloc(1+csa->lp->n, double);
      memcpy(csa->orig_l, csa->lp->l, (1+csa->lp->n) * sizeof(double));
      csa->orig_u = talloc(1+csa->lp->n, double);
      memcpy(csa->orig_u, csa->lp->u, (1+csa->lp->n) * sizeof(double));
#if USE_AT
      /* build matrix A in row-wise format */
      csa->at = &at;
      csa->nt = NULL;
      spx_alloc_at(csa->lp, csa->at);
      spx_build_at(csa->lp, csa->at);
#else
      /* build matrix N in row-wise format for initial basis */
      csa->at = NULL;
      csa->nt = &nt;
      spx_alloc_nt(csa->lp, csa->nt);
      spx_init_nt(csa->lp, csa->nt);
      spx_build_nt(csa->lp, csa->nt);
#endif
      /* allocate and initialize working components */
      csa->phase = 0;
      csa->beta = talloc(1+csa->lp->m, double);
      csa->beta_st = 0;
      csa->d = talloc(1+csa->lp->n-csa->lp->m, double);
      csa->d_st = 0;
      switch (parm->pricing)
      {  case GLP_PT_STD:
            csa->se = NULL;
            break;
         case GLP_PT_PSE:
            csa->se = &se;
            spy_alloc_se(csa->lp, csa->se);
            break;
         default:
            xassert(parm != parm);
      }
#if 0 /* 30/III-2016 */
      csa->list = talloc(1+csa->lp->m, int);
      csa->trow = talloc(1+csa->lp->n-csa->lp->m, double);
      csa->tcol = talloc(1+csa->lp->m, double);
#else
      fvs_alloc_vec(&csa->r, csa->lp->m);
      fvs_alloc_vec(&csa->trow, csa->lp->n-csa->lp->m);
      fvs_alloc_vec(&csa->tcol, csa->lp->m);
#endif
#if 1 /* 16/III-2016 */
      csa->bp = NULL;
#endif
      csa->work = talloc(1+csa->lp->m, double);
      csa->work1 = talloc(1+csa->lp->n-csa->lp->m, double);
#if 1 /* 31/III-2016 */
      fvs_alloc_vec(&csa->wrow, csa->lp->n-csa->lp->m);
      fvs_alloc_vec(&csa->wcol, csa->lp->m);
#endif
      /* initialize control parameters */
      csa->msg_lev = parm->msg_lev;
      csa->dualp = (parm->meth == GLP_DUALP);
#if 0 /* 16/III-2016 */
      switch (parm->r_test)
      {  case GLP_RT_STD:
            csa->harris = 0;
            break;
         case GLP_RT_HAR:
            csa->harris = 1;
            break;
         default:
            xassert(parm != parm);
      }
#else
      switch (parm->r_test)
      {  case GLP_RT_STD:
         case GLP_RT_HAR:
            break;
         case GLP_RT_FLIP:
            csa->bp = talloc(1+csa->lp->n-csa->lp->m, SPYBP);
            break;
         default:
            xassert(parm != parm);
      }
      csa->r_test = parm->r_test;
#endif
      csa->tol_bnd = parm->tol_bnd;
      csa->tol_bnd1 = .001 * parm->tol_bnd;
      csa->tol_dj = parm->tol_dj;
      csa->tol_dj1 = .001 * parm->tol_dj;
#if 0
      csa->tol_dj1 = 1e-9 * parm->tol_dj;
#endif
      csa->tol_piv = parm->tol_piv;
      switch (P->dir)
      {  case GLP_MIN:
            csa->obj_lim = + parm->obj_ul;
            break;
         case GLP_MAX:
            csa->obj_lim = - parm->obj_ll;
            break;
         default:
            xassert(parm != parm);
      }
      csa->it_lim = parm->it_lim;
      csa->tm_lim = parm->tm_lim;
      csa->out_frq = parm->out_frq;
      csa->out_dly = parm->out_dly;
      /* initialize working parameters */
      csa->tm_beg = xtime();
      csa->it_beg = csa->it_cnt = P->it_cnt;
      csa->it_dpy = -1;
      csa->inv_cnt = 0;
#if 1 /* 23/III-2016 */
      csa->ns_cnt = csa->ls_cnt = 0;
#endif
      /* try to solve working LP */
      ret = dual_simplex(csa);
      /* return basis factorization back to problem object */
      P->valid = csa->lp->valid;
      P->bfd = csa->lp->bfd;
      /* set solution status */
      P->pbs_stat = csa->p_stat;
      P->dbs_stat = csa->d_stat;
      /* if the solver failed, do not store basis header and basic
       * solution components to problem object */
      if (ret == GLP_EFAIL)
         goto skip;
      /* convert working LP basis to original LP basis and store it to
       * problem object */
      daeh = talloc(1+csa->lp->n, int);
      spx_store_basis(csa->lp, P, map, daeh);
      /* compute simplex multipliers for final basic solution found by
       * the solver */
      spx_eval_pi(csa->lp, csa->work);
      /* convert working LP solution to original LP solution and store
       * it to problem object */
      spx_store_sol(csa->lp, P, SHIFT, map, daeh, csa->beta, csa->work,
         csa->d);
      tfree(daeh);
      /* save simplex iteration count */
      P->it_cnt = csa->it_cnt;
      /* report auxiliary/structural variable causing unboundedness */
      P->some = 0;
      if (csa->p_stat == GLP_NOFEAS && csa->d_stat == GLP_FEAS)
      {  int k, kk;
         /* xB[p] = x[k] causes dual unboundedness */
         xassert(1 <= csa->p && csa->p <= csa->lp->m);
         k = csa->lp->head[csa->p];
         xassert(1 <= k && k <= csa->lp->n);
         /* convert to number of original variable */
         for (kk = 1; kk <= P->m + P->n; kk++)
         {  if (abs(map[kk]) == k)
            {  P->some = kk;
               break;
            }
         }
         xassert(P->some != 0);
      }
skip: /* deallocate working objects and arrays */
      spx_free_lp(csa->lp);
      tfree(map);
      tfree(csa->orig_b);
#if PERTURB
      tfree(csa->orig_c);
#endif
      tfree(csa->orig_l);
      tfree(csa->orig_u);
      if (csa->at != NULL)
         spx_free_at(csa->lp, csa->at);
      if (csa->nt != NULL)
         spx_free_nt(csa->lp, csa->nt);
      tfree(csa->beta);
      tfree(csa->d);
      if (csa->se != NULL)
         spy_free_se(csa->lp, csa->se);
#if 0 /* 30/III-2016 */
      tfree(csa->list);
      tfree(csa->trow);
#else
      fvs_free_vec(&csa->r);
      fvs_free_vec(&csa->trow);
#endif
#if 1 /* 16/III-2016 */
      if (csa->bp != NULL)
         tfree(csa->bp);
#endif
#if 0 /* 29/III-2016 */
      tfree(csa->tcol);
#else
      fvs_free_vec(&csa->tcol);
#endif
      tfree(csa->work);
      tfree(csa->work1);
#if 1 /* 31/III-2016 */
      fvs_free_vec(&csa->wrow);
      fvs_free_vec(&csa->wcol);
#endif
      /* return to calling program */
      return ret >= 0 ? ret : GLP_EFAIL;
}





/***********************************************************************
*  min_row_aij - determine minimal |a[i,j]| in i-th row
*
*  This routine returns minimal magnitude of (non-zero) constraint
*  coefficients in i-th row of the constraint matrix.
*
*  If the parameter scaled is zero, the original constraint matrix A is
*  assumed. Otherwise, the scaled constraint matrix R*A*S is assumed.
*
*  If i-th row of the matrix is empty, the routine returns 1. */

static double min_row_aij(glp_prob *lp, int i, int scaled)
{     GLPAIJ *aij;
      double min_aij, temp;
      xassert(1 <= i && i <= lp->m);
      min_aij = 1.0;
      for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)
      {  temp = fabs(aij->val);
         if (scaled) temp *= (aij->row->rii * aij->col->sjj);
         if (aij->r_prev == NULL || min_aij > temp)
            min_aij = temp;
      }
      return min_aij;
}

/***********************************************************************
*  max_row_aij - determine maximal |a[i,j]| in i-th row
*
*  This routine returns maximal magnitude of (non-zero) constraint
*  coefficients in i-th row of the constraint matrix.
*
*  If the parameter scaled is zero, the original constraint matrix A is
*  assumed. Otherwise, the scaled constraint matrix R*A*S is assumed.
*
*  If i-th row of the matrix is empty, the routine returns 1. */

static double max_row_aij(glp_prob *lp, int i, int scaled)
{     GLPAIJ *aij;
      double max_aij, temp;
      xassert(1 <= i && i <= lp->m);
      max_aij = 1.0;
      for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)
      {  temp = fabs(aij->val);
         if (scaled) temp *= (aij->row->rii * aij->col->sjj);
         if (aij->r_prev == NULL || max_aij < temp)
            max_aij = temp;
      }
      return max_aij;
}

/***********************************************************************
*  min_col_aij - determine minimal |a[i,j]| in j-th column
*
*  This routine returns minimal magnitude of (non-zero) constraint
*  coefficients in j-th column of the constraint matrix.
*
*  If the parameter scaled is zero, the original constraint matrix A is
*  assumed. Otherwise, the scaled constraint matrix R*A*S is assumed.
*
*  If j-th column of the matrix is empty, the routine returns 1. */

static double min_col_aij(glp_prob *lp, int j, int scaled)
{     GLPAIJ *aij;
      double min_aij, temp;
      xassert(1 <= j && j <= lp->n);
      min_aij = 1.0;
      for (aij = lp->col[j]->ptr; aij != NULL; aij = aij->c_next)
      {  temp = fabs(aij->val);
         if (scaled) temp *= (aij->row->rii * aij->col->sjj);
         if (aij->c_prev == NULL || min_aij > temp)
            min_aij = temp;
      }
      return min_aij;
}

/***********************************************************************
*  max_col_aij - determine maximal |a[i,j]| in j-th column
*
*  This routine returns maximal magnitude of (non-zero) constraint
*  coefficients in j-th column of the constraint matrix.
*
*  If the parameter scaled is zero, the original constraint matrix A is
*  assumed. Otherwise, the scaled constraint matrix R*A*S is assumed.
*
*  If j-th column of the matrix is empty, the routine returns 1. */

static double max_col_aij(glp_prob *lp, int j, int scaled)
{     GLPAIJ *aij;
      double max_aij, temp;
      xassert(1 <= j && j <= lp->n);
      max_aij = 1.0;
      for (aij = lp->col[j]->ptr; aij != NULL; aij = aij->c_next)
      {  temp = fabs(aij->val);
         if (scaled) temp *= (aij->row->rii * aij->col->sjj);
         if (aij->c_prev == NULL || max_aij < temp)
            max_aij = temp;
      }
      return max_aij;
}

/***********************************************************************
*  min_mat_aij - determine minimal |a[i,j]| in constraint matrix
*
*  This routine returns minimal magnitude of (non-zero) constraint
*  coefficients in the constraint matrix.
*
*  If the parameter scaled is zero, the original constraint matrix A is
*  assumed. Otherwise, the scaled constraint matrix R*A*S is assumed.
*
*  If the matrix is empty, the routine returns 1. */

static double min_mat_aij(glp_prob *lp, int scaled)
{     int i;
      double min_aij, temp;
      min_aij = 1.0;
      for (i = 1; i <= lp->m; i++)
      {  temp = min_row_aij(lp, i, scaled);
         if (i == 1 || min_aij > temp)
            min_aij = temp;
      }
      return min_aij;
}

/***********************************************************************
*  max_mat_aij - determine maximal |a[i,j]| in constraint matrix
*
*  This routine returns maximal magnitude of (non-zero) constraint
*  coefficients in the constraint matrix.
*
*  If the parameter scaled is zero, the original constraint matrix A is
*  assumed. Otherwise, the scaled constraint matrix R*A*S is assumed.
*
*  If the matrix is empty, the routine returns 1. */

static double max_mat_aij(glp_prob *lp, int scaled)
{     int i;
      double max_aij, temp;
      max_aij = 1.0;
      for (i = 1; i <= lp->m; i++)
      {  temp = max_row_aij(lp, i, scaled);
         if (i == 1 || max_aij < temp)
            max_aij = temp;
      }
      return max_aij;
}

/***********************************************************************
*  eq_scaling - perform equilibration scaling
*
*  This routine performs equilibration scaling of rows and columns of
*  the constraint matrix.
*
*  If the parameter flag is zero, the routine scales rows at first and
*  then columns. Otherwise, the routine scales columns and then rows.
*
*  Rows are scaled as follows:
*
*                         n
*     a'[i,j] = a[i,j] / max |a[i,j]|,  i = 1,...,m.
*                        j=1
*
*  This makes the infinity (maximum) norm of each row of the matrix
*  equal to 1.
*
*  Columns are scaled as follows:
*
*                         m
*     a'[i,j] = a[i,j] / max |a[i,j]|,  j = 1,...,n.
*                        i=1
*
*  This makes the infinity (maximum) norm of each column of the matrix
*  equal to 1. */

static void eq_scaling(glp_prob *lp, int flag)
{     int i, j, pass;
      double temp;
      xassert(flag == 0 || flag == 1);
      for (pass = 0; pass <= 1; pass++)
      {  if (pass == flag)
         {  /* scale rows */
            for (i = 1; i <= lp->m; i++)
            {  temp = max_row_aij(lp, i, 1);
               glp_set_rii(lp, i, glp_get_rii(lp, i) / temp);
            }
         }
         else
         {  /* scale columns */
            for (j = 1; j <= lp->n; j++)
            {  temp = max_col_aij(lp, j, 1);
               glp_set_sjj(lp, j, glp_get_sjj(lp, j) / temp);
            }
         }
      }
      return;
}

/***********************************************************************
*  gm_scaling - perform geometric mean scaling
*
*  This routine performs geometric mean scaling of rows and columns of
*  the constraint matrix.
*
*  If the parameter flag is zero, the routine scales rows at first and
*  then columns. Otherwise, the routine scales columns and then rows.
*
*  Rows are scaled as follows:
*
*     a'[i,j] = a[i,j] / sqrt(alfa[i] * beta[i]),  i = 1,...,m,
*
*  where:
*                n                        n
*     alfa[i] = min |a[i,j]|,  beta[i] = max |a[i,j]|.
*               j=1                      j=1
*
*  This allows decreasing the ratio beta[i] / alfa[i] for each row of
*  the matrix.
*
*  Columns are scaled as follows:
*
*     a'[i,j] = a[i,j] / sqrt(alfa[j] * beta[j]),  j = 1,...,n,
*
*  where:
*                m                        m
*     alfa[j] = min |a[i,j]|,  beta[j] = max |a[i,j]|.
*               i=1                      i=1
*
*  This allows decreasing the ratio beta[j] / alfa[j] for each column
*  of the matrix. */

static void gm_scaling(glp_prob *lp, int flag)
{     int i, j, pass;
      double temp;
      xassert(flag == 0 || flag == 1);
      for (pass = 0; pass <= 1; pass++)
      {  if (pass == flag)
         {  /* scale rows */
            for (i = 1; i <= lp->m; i++)
            {  temp = min_row_aij(lp, i, 1) * max_row_aij(lp, i, 1);
               glp_set_rii(lp, i, glp_get_rii(lp, i) / sqrt(temp));
            }
         }
         else
         {  /* scale columns */
            for (j = 1; j <= lp->n; j++)
            {  temp = min_col_aij(lp, j, 1) * max_col_aij(lp, j, 1);
               glp_set_sjj(lp, j, glp_get_sjj(lp, j) / sqrt(temp));
            }
         }
      }
      return;
}

/***********************************************************************
*  max_row_ratio - determine worst scaling "quality" for rows
*
*  This routine returns the worst scaling "quality" for rows of the
*  currently scaled constraint matrix:
*
*              m
*     ratio = max ratio[i],
*             i=1
*  where:
*                 n              n
*     ratio[i] = max |a[i,j]| / min |a[i,j]|,  1 <= i <= m,
*                j=1            j=1
*
*  is the scaling "quality" of i-th row. */

static double max_row_ratio(glp_prob *lp)
{     int i;
      double ratio, temp;
      ratio = 1.0;
      for (i = 1; i <= lp->m; i++)
      {  temp = max_row_aij(lp, i, 1) / min_row_aij(lp, i, 1);
         if (i == 1 || ratio < temp) ratio = temp;
      }
      return ratio;
}

/***********************************************************************
*  max_col_ratio - determine worst scaling "quality" for columns
*
*  This routine returns the worst scaling "quality" for columns of the
*  currently scaled constraint matrix:
*
*              n
*     ratio = max ratio[j],
*             j=1
*  where:
*                 m              m
*     ratio[j] = max |a[i,j]| / min |a[i,j]|,  1 <= j <= n,
*                i=1            i=1
*
*  is the scaling "quality" of j-th column. */

static double max_col_ratio(glp_prob *lp)
{     int j;
      double ratio, temp;
      ratio = 1.0;
      for (j = 1; j <= lp->n; j++)
      {  temp = max_col_aij(lp, j, 1) / min_col_aij(lp, j, 1);
         if (j == 1 || ratio < temp) ratio = temp;
      }
      return ratio;
}

/***********************************************************************
*  gm_iterate - perform iterative geometric mean scaling
*
*  This routine performs iterative geometric mean scaling of rows and
*  columns of the constraint matrix.
*
*  The parameter it_max specifies the maximal number of iterations.
*  Recommended value of it_max is 15.
*
*  The parameter tau specifies a minimal improvement of the scaling
*  "quality" on each iteration, 0 < tau < 1. It means than the scaling
*  process continues while the following condition is satisfied:
*
*     ratio[k] <= tau * ratio[k-1],
*
*  where ratio = max |a[i,j]| / min |a[i,j]| is the scaling "quality"
*  to be minimized, k is the iteration number. Recommended value of tau
*  is 0.90. */

static void gm_iterate(glp_prob *lp, int it_max, double tau)
{     int k, flag;
      double ratio = 0.0, r_old;
      /* if the scaling "quality" for rows is better than for columns,
         the rows are scaled first; otherwise, the columns are scaled
         first */
      flag = (max_row_ratio(lp) > max_col_ratio(lp));
      for (k = 1; k <= it_max; k++)
      {  /* save the scaling "quality" from previous iteration */
         r_old = ratio;
         /* determine the current scaling "quality" */
         ratio = max_mat_aij(lp, 1) / min_mat_aij(lp, 1);
#if 0
         xprintf("k = %d; ratio = %g\n", k, ratio);
#endif
         /* if improvement is not enough, terminate scaling */
         if (k > 1 && ratio > tau * r_old) break;
         /* otherwise, perform another iteration */
         gm_scaling(lp, flag);
      }
      return;
}

/***********************************************************************
*  NAME
*
*  scale_prob - scale problem data
*
*  SYNOPSIS
*
*  #include "glpscl.h"
*  void scale_prob(glp_prob *lp, int flags);
*
*  DESCRIPTION
*
*  The routine scale_prob performs automatic scaling of problem data
*  for the specified problem object. */

static void scale_prob(glp_prob *lp, int flags)
{     static const char *fmt =
         "%s: min|aij| = %10.3e  max|aij| = %10.3e  ratio = %10.3e\n";
      double min_aij, max_aij, ratio;
      xprintf("Scaling...\n");
      /* cancel the current scaling effect */
      glp_unscale_prob(lp);
      /* report original scaling "quality" */
      min_aij = min_mat_aij(lp, 1);
      max_aij = max_mat_aij(lp, 1);
      ratio = max_aij / min_aij;
      xprintf(fmt, " A", min_aij, max_aij, ratio);
      /* check if the problem is well scaled */
      if (min_aij >= 0.10 && max_aij <= 10.0)
      {  xprintf("Problem data seem to be well scaled\n");
         /* skip scaling, if required */
         if (flags & GLP_SF_SKIP) goto done;
      }
      /* perform iterative geometric mean scaling, if required */
      if (flags & GLP_SF_GM)
      {  gm_iterate(lp, 15, 0.90);
         min_aij = min_mat_aij(lp, 1);
         max_aij = max_mat_aij(lp, 1);
         ratio = max_aij / min_aij;
         xprintf(fmt, "GM", min_aij, max_aij, ratio);
      }
      /* perform equilibration scaling, if required */
      if (flags & GLP_SF_EQ)
      {  eq_scaling(lp, max_row_ratio(lp) > max_col_ratio(lp));
         min_aij = min_mat_aij(lp, 1);
         max_aij = max_mat_aij(lp, 1);
         ratio = max_aij / min_aij;
         xprintf(fmt, "EQ", min_aij, max_aij, ratio);
      }
      /* round scale factors to nearest power of two, if required */
      if (flags & GLP_SF_2N)
      {  int i, j;
         for (i = 1; i <= lp->m; i++)
            glp_set_rii(lp, i, round2n(glp_get_rii(lp, i)));
         for (j = 1; j <= lp->n; j++)
            glp_set_sjj(lp, j, round2n(glp_get_sjj(lp, j)));
         min_aij = min_mat_aij(lp, 1);
         max_aij = max_mat_aij(lp, 1);
         ratio = max_aij / min_aij;
         xprintf(fmt, "2N", min_aij, max_aij, ratio);
      }
done: return;
}

/***********************************************************************
*  NAME
*
*  glp_scale_prob - scale problem data
*
*  SYNOPSIS
*
*  void glp_scale_prob(glp_prob *lp, int flags);
*
*  DESCRIPTION
*
*  The routine glp_scale_prob performs automatic scaling of problem
*  data for the specified problem object.
*
*  The parameter flags specifies scaling options used by the routine.
*  Options can be combined with the bitwise OR operator and may be the
*  following:
*
*  GLP_SF_GM      perform geometric mean scaling;
*  GLP_SF_EQ      perform equilibration scaling;
*  GLP_SF_2N      round scale factors to nearest power of two;
*  GLP_SF_SKIP    skip scaling, if the problem is well scaled.
*
*  The parameter flags may be specified as GLP_SF_AUTO, in which case
*  the routine chooses scaling options automatically. */

void glp_scale_prob(glp_prob *lp, int flags)
{     if (flags & ~(GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP |
                    GLP_SF_AUTO))
         xerror("glp_scale_prob: flags = 0x%02X; invalid scaling option"
            "s\n", flags);
      if (flags & GLP_SF_AUTO)
         flags = (GLP_SF_GM | GLP_SF_EQ | GLP_SF_SKIP);
      scale_prob(lp, flags);
      return;
}






/***********************************************************************
*  NAME
*
*  glp_adv_basis - construct advanced initial LP basis
*
*  SYNOPSIS
*
*  void glp_adv_basis(glp_prob *P, int flags);
*
*  DESCRIPTION
*
*  The routine glp_adv_basis constructs an advanced initial LP basis
*  for the specified problem object.
*
*  The parameter flag is reserved for use in the future and should be
*  specified as zero.
*
*  NOTE
*
*  The routine glp_adv_basis should be called after the constraint
*  matrix has been scaled (if scaling is used). */

static int mat(void *info, int k, int ind[], double val[])
{     glp_prob *P = info;
      int m = P->m;
      int n = P->n;
      GLPROW **row = P->row;
      GLPCOL **col = P->col;
      GLPAIJ *aij;
      int i, j, len;
      if (k > 0)
      {  /* retrieve scaled row of constraint matrix */
         i = +k;
         xassert(1 <= i && i <= m);
         len = 0;
         if (row[i]->type == GLP_FX)
         {  for (aij = row[i]->ptr; aij != NULL; aij = aij->r_next)
            {  j = aij->col->j;
               if (col[j]->type != GLP_FX)
               {  len++;
                  ind[len] = j;
                  val[len] = aij->row->rii * aij->val * aij->col->sjj;
               }
            }
         }
      }
      else
      {  /* retrieve scaled column of constraint matrix */
         j = -k;
         xassert(1 <= j && j <= n);
         len = 0;
         if (col[j]->type != GLP_FX)
         {  for (aij = col[j]->ptr; aij != NULL; aij = aij->c_next)
            {  i = aij->row->i;
               if (row[i]->type == GLP_FX)
               {  len++;
                  ind[len] = i;
                  val[len] = aij->row->rii * aij->val * aij->col->sjj;
               }
            }
         }
      }
      return len;
}

#define triang _glp_triang
extern int triang(int m, int n, int (*mat)(void *info, int k, int ind[],
      double val[]), void *info, double tol, int rn[], int cn[]);
/* find maximal triangular part of rectangular matrix */


int triang(int m, int n, int (*mat)(void *info, int k, int ind[],
      double val[]), void *info, double tol, int rn[], int cn[])
{     int head, i, j, jj, k, kk, ks, len, len2, next_j, ns, size;
      int *cind, *rind, *cnt, *ptr, *list, *prev, *next;
      double *cval, *rval, *big;
      char *flag;
      /* allocate working arrays */
      cind = talloc(1+m, int);
      cval = talloc(1+m, double);
      rind = talloc(1+n, int);
      rval = talloc(1+n, double);
      cnt = ptr = talloc(1+m, int);
      list = talloc(1+n, int);
      prev = talloc(1+n, int);
      next = talloc(1+n, int);
      big = talloc(1+n, double);
      flag = talloc(1+n, char);
      /*--------------------------------------------------------------*/
      /* build linked lists of columns having equal lengths           */
      /*--------------------------------------------------------------*/
      /* ptr[len], 0 <= len <= m, is number of first column of length
       * len;
       * next[j], 1 <= j <= n, is number of next column having the same
       * length as column j;
       * big[j], 1 <= j <= n, is maximal magnitude of elements in j-th
       * column */
      for (len = 0; len <= m; len++)
         ptr[len] = 0;
      for (j = 1; j <= n; j++)
      {  /* get j-th column */
         len = mat(info, -j, cind, cval);
         xassert(0 <= len && len <= m);
         /* add this column to beginning of list ptr[len] */
         next[j] = ptr[len];
         ptr[len] = j;
         /* determine maximal magnitude of elements in this column */
         big[j] = 0.0;
         for (k = 1; k <= len; k++)
         {  if (big[j] < fabs(cval[k]))
               big[j] = fabs(cval[k]);
         }
      }
      /*--------------------------------------------------------------*/
      /* build doubly linked list of columns ordered by decreasing    */
      /* column lengths                                               */
      /*--------------------------------------------------------------*/
      /* head is number of first column in the list;
       * prev[j], 1 <= j <= n, is number of column that precedes j-th
       * column in the list;
       * next[j], 1 <= j <= n, is number of column that follows j-th
       * column in the list */
      head = 0;
      for (len = 0; len <= m; len++)
      {  /* walk thru list of columns of length len */
         for (j = ptr[len]; j != 0; j = next_j)
         {  next_j = next[j];
            /* add j-th column to beginning of the column list */
            prev[j] = 0;
            next[j] = head;
            if (head != 0)
               prev[head] = j;
            head = j;
         }
      }
      /*--------------------------------------------------------------*/
      /* build initial singleton list                                 */
      /*--------------------------------------------------------------*/
      /* there are used two list of columns:
       * 1) doubly linked list of active columns, in which all columns
       *    are ordered by decreasing column lengths;
       * 2) singleton list; an active column is included in this list
       *    if it has at least one row singleton in active submatrix */
      /* flag[j], 1 <= j <= n, is a flag of j-th column:
       * 0  j-th column is inactive;
       * 1  j-th column is active;
       * 2  j-th column is active and has row singleton(s) */
      /* initially all columns are active */
      for (j = 1; j <= n; j++)
         flag[j] = 1;
      /* initialize row counts and build initial singleton list */
      /* cnt[i], 1 <= i <= m, is number of non-zeros, which i-th row
       * has in active submatrix;
       * ns is size of singleton list;
       * list[1], ..., list[ns] are numbers of active columns included
       * in the singleton list */
      ns = 0;
      for (i = 1; i <= m; i++)
      {  /* get i-th row */
         len = cnt[i] = mat(info, +i, rind, rval);
         xassert(0 <= len && len <= n);
         if (len == 1)
         {  /* a[i,j] is row singleton */
            j = rind[1];
            xassert(1 <= j && j <= n);
            if (flag[j] != 2)
            {  /* include j-th column in singleton list */
               flag[j] = 2;
               list[++ns] = j;
            }
         }
      }
      /*--------------------------------------------------------------*/
      /* main loop                                                    */
      /*--------------------------------------------------------------*/
      size = 0; /* size of triangular part */
      /* loop until active column list is non-empty, i.e. until the
       * active submatrix has at least one column */
      while (head != 0)
      {  if (ns == 0)
         {  /* singleton list is empty */
            /* remove from the active submatrix a column of maximal
             * length in the hope that some row singletons appear */
            j = head;
            len = mat(info, -j, cind, cval);
            xassert(0 <= len && len <= m);
            goto drop;
         }
         /* take column j from the singleton list */
         j = list[ns--];
         xassert(flag[j] == 2);
         /* j-th column has at least one row singleton in the active
          * submatrix; choose one having maximal magnitude */
         len = mat(info, -j, cind, cval);
         xassert(0 <= len && len <= m);
         kk = 0;
         for (k = 1; k <= len; k++)
         {  i = cind[k];
            xassert(1 <= i && i <= m);
            if (cnt[i] == 1)
            {  /* a[i,j] is row singleton */
               if (kk == 0 || fabs(cval[kk]) < fabs(cval[k]))
                  kk = k;
            }
         }
         xassert(kk > 0);
         /* check magnitude of the row singleton chosen */
         if (fabs(cval[kk]) < tol * big[j])
         {  /* all row singletons are too small in magnitude; drop j-th
             * column */
            goto drop;
         }
         /* row singleton a[i,j] is ok; add i-th row and j-th column to
          * the triangular part */
         size++;
         rn[size] = cind[kk];
         cn[size] = j;
drop:    /* remove j-th column from the active submatrix */
         xassert(flag[j]);
         flag[j] = 0;
         if (prev[j] == 0)
            head = next[j];
         else
            next[prev[j]] = next[j];
         if (next[j] == 0)
            ;
         else
            prev[next[j]] = prev[j];
         /* decrease row counts */
         for (k = 1; k <= len; k++)
         {  i = cind[k];
            xassert(1 <= i && i <= m);
            xassert(cnt[i] > 0);
            cnt[i]--;
            if (cnt[i] == 1)
            {  /* new singleton appeared in i-th row; determine number
                * of corresponding column (it is the only active column
                * in this row) */
               len2 = mat(info, +i, rind, rval);
               xassert(0 <= len2 && len2 <= n);
               ks = 0;
               for (kk = 1; kk <= len2; kk++)
               {  jj = rind[kk];
                  xassert(1 <= jj && jj <= n);
                  if (flag[jj])
                  {  xassert(ks == 0);
                     ks = kk;
                  }
               }
               xassert(ks > 0);
               /* a[i,jj] is new row singleton */
               jj = rind[ks];
               if (flag[jj] != 2)
               {  /* include jj-th column in the singleton list */
                  flag[jj] = 2;
                  list[++ns] = jj;
               }
            }
         }
      }
      /* now all row counts should be zero */
      for (i = 1; i <= m; i++)
         xassert(cnt[i] == 0);
      /* deallocate working arrays */
      tfree(cind);
      tfree(cval);
      tfree(rind);
      tfree(rval);
      tfree(ptr);
      tfree(list);
      tfree(prev);
      tfree(next);
      tfree(big);
      tfree(flag);
      return size;
}

/* eof */


void glp_adv_basis(glp_prob *P, int flags)
{     int i, j, k, m, n, min_mn, size, *rn, *cn;
      char *flag;
      if (flags != 0)
         xerror("glp_adv_basis: flags = %d; invalid flags\n", flags);
      m = P->m; /* number of rows */
      n = P->n; /* number of columns */
      if (m == 0 || n == 0)
      {  /* trivial case */
         glp_std_basis(P);
         goto done;
      }
      xprintf("Constructing initial basis...\n");
      /* allocate working arrays */
      min_mn = (m < n ? m : n);
      rn = talloc(1+min_mn, int);
      cn = talloc(1+min_mn, int);
      flag = talloc(1+m, char);
      /* make the basis empty */
      for (i = 1; i <= m; i++)
      {  flag[i] = 0;
         glp_set_row_stat(P, i, GLP_NS);
      }
      for (j = 1; j <= n; j++)
         glp_set_col_stat(P, j, GLP_NS);
      /* find maximal triangular part of the constraint matrix;
         to prevent including non-fixed rows and fixed columns in the
         triangular part, such rows and columns are temporarily made
         empty by the routine mat */
#if 1 /* FIXME: tolerance */
      size = triang(m, n, mat, P, 0.001, rn, cn);
#endif
      xassert(0 <= size && size <= min_mn);
      /* include in the basis non-fixed structural variables, whose
         columns constitute the triangular part */
      for (k = 1; k <= size; k++)
      {  i = rn[k];
         xassert(1 <= i && i <= m);
         flag[i] = 1;
         j = cn[k];
         xassert(1 <= j && j <= n);
         glp_set_col_stat(P, j, GLP_BS);
      }
      /* include in the basis appropriate auxiliary variables, whose
         unity columns preserve triangular form of the basis matrix */
      for (i = 1; i <= m; i++)
      {  if (flag[i] == 0)
         {  glp_set_row_stat(P, i, GLP_BS);
            if (P->row[i]->type != GLP_FX)
               size++;
         }
      }
      /* size of triangular part = (number of rows) - (number of basic
         fixed auxiliary variables) */
      xprintf("Size of triangular part is %d\n", size);
      /* deallocate working arrays */
      tfree(rn);
      tfree(cn);
      tfree(flag);
done: return;
}


/* ========================================================================== */
/* === Include files ======================================================== */
/* ========================================================================== */


/* Written by Andrew Makhorin <mao@gnu.org>. */

#ifndef COLAMD_H
#define COLAMD_H

#define _GLPSTD_STDIO

#define COLAMD_DATE "Nov 1, 2007"
#define COLAMD_VERSION_CODE(main, sub) ((main) * 1000 + (sub))
#define COLAMD_MAIN_VERSION 2
#define COLAMD_SUB_VERSION 7
#define COLAMD_SUBSUB_VERSION 1
#define COLAMD_VERSION \
        COLAMD_VERSION_CODE(COLAMD_MAIN_VERSION, COLAMD_SUB_VERSION)

#define COLAMD_KNOBS 20
#define COLAMD_STATS 20
#define COLAMD_DENSE_ROW 0
#define COLAMD_DENSE_COL 1
#define COLAMD_AGGRESSIVE 2
#define COLAMD_DEFRAG_COUNT 2
#define COLAMD_STATUS 3
#define COLAMD_INFO1 4
#define COLAMD_INFO2 5
#define COLAMD_INFO3 6

#define COLAMD_OK                            (0)
#define COLAMD_OK_BUT_JUMBLED                (1)
#define COLAMD_ERROR_A_not_present           (-1)
#define COLAMD_ERROR_p_not_present           (-2)
#define COLAMD_ERROR_nrow_negative           (-3)
#define COLAMD_ERROR_ncol_negative           (-4)
#define COLAMD_ERROR_nnz_negative            (-5)
#define COLAMD_ERROR_p0_nonzero              (-6)
#define COLAMD_ERROR_A_too_small             (-7)
#define COLAMD_ERROR_col_length_negative     (-8)
#define COLAMD_ERROR_row_index_out_of_bounds (-9)
#define COLAMD_ERROR_out_of_memory           (-10)
#define COLAMD_ERROR_internal_error          (-999)

#define colamd_recommended _glp_colamd_recommended
size_t colamd_recommended(int nnz, int n_row, int n_col);

#define colamd_set_defaults _glp_colamd_set_defaults
void colamd_set_defaults(double knobs [COLAMD_KNOBS]);

#define colamd _glp_colamd
int colamd(int n_row, int n_col, int Alen, int A[], int p[],
      double knobs[COLAMD_KNOBS], int stats[COLAMD_STATS]);

#define symamd _glp_symamd
int symamd(int n, int A[], int p[], int perm[],
      double knobs[COLAMD_KNOBS], int stats[COLAMD_STATS],
      void *(*allocate)(size_t, size_t), void(*release)(void *));

#define colamd_report _glp_colamd_report
void colamd_report(int stats[COLAMD_STATS]);

#define symamd_report _glp_symamd_report
void symamd_report(int stats[COLAMD_STATS]);

#define colamd_printf xprintf

#endif









#define AMD_DATE "May 31, 2007"
#define AMD_VERSION_CODE(main, sub) ((main) * 1000 + (sub))
#define AMD_MAIN_VERSION 2
#define AMD_SUB_VERSION 2
#define AMD_SUBSUB_VERSION 0
#define AMD_VERSION AMD_VERSION_CODE(AMD_MAIN_VERSION, AMD_SUB_VERSION)

#define AMD_CONTROL 5
#define AMD_INFO 20

#define AMD_DENSE 0
#define AMD_AGGRESSIVE 1

#define AMD_DEFAULT_DENSE 10.0
#define AMD_DEFAULT_AGGRESSIVE 1

#define AMD_STATUS         0
#define AMD_N              1
#define AMD_NZ             2
#define AMD_SYMMETRY       3
#define AMD_NZDIAG         4
#define AMD_NZ_A_PLUS_AT   5
#define AMD_NDENSE         6
#define AMD_MEMORY         7
#define AMD_NCMPA          8
#define AMD_LNZ            9
#define AMD_NDIV           10
#define AMD_NMULTSUBS_LDL  11
#define AMD_NMULTSUBS_LU   12
#define AMD_DMAX           13

#define AMD_OK             0
#define AMD_OUT_OF_MEMORY  (-1)
#define AMD_INVALID        (-2)
#define AMD_OK_BUT_JUMBLED 1










/* ========================================================================== */
/* === int or UF_long ======================================================= */
/* ========================================================================== */

#if 0 /* by mao */
/* define UF_long */
#include "UFconfig.h"
#endif

#ifdef DLONG

#define Int UF_long
#define ID  UF_long_id
#define Int_MAX UF_long_max

#define COLAMD_recommended colamd_l_recommended
#define COLAMD_set_defaults colamd_l_set_defaults
#define COLAMD_MAIN colamd_l
#define SYMAMD_MAIN symamd_l
#define COLAMD_report colamd_l_report
#define SYMAMD_report symamd_l_report

#else

#define Int int
#define ID "%d"
#define Int_MAX INT_MAX

#define COLAMD_recommended colamd_recommended
#define COLAMD_set_defaults colamd_set_defaults
#define COLAMD_MAIN colamd
#define SYMAMD_MAIN symamd
#define COLAMD_report colamd_report
#define SYMAMD_report symamd_report

#endif

/* ========================================================================== */
/* === Row and Column structures ============================================ */
/* ========================================================================== */

/* User code that makes use of the colamd/symamd routines need not directly */
/* reference these structures.  They are used only for colamd_recommended. */

typedef struct Colamd_Col_struct
{
    Int start ;         /* index for A of first row in this column, or DEAD */
                        /* if column is dead */
    Int length ;        /* number of rows in this column */
    union
    {
        Int thickness ; /* number of original columns represented by this */
                        /* col, if the column is alive */
        Int parent ;    /* parent in parent tree super-column structure, if */
                        /* the column is dead */
    } shared1 ;
    union
    {
        Int score ;     /* the score used to maintain heap, if col is alive */
        Int order ;     /* pivot ordering of this column, if col is dead */
    } shared2 ;
    union
    {
        Int headhash ;  /* head of a hash bucket, if col is at the head of */
                        /* a degree list */
        Int hash ;      /* hash value, if col is not in a degree list */
        Int prev ;      /* previous column in degree list, if col is in a */
                        /* degree list (but not at the head of a degree list) */
    } shared3 ;
    union
    {
        Int degree_next ;       /* next column, if col is in a degree list */
        Int hash_next ;         /* next column, if col is in a hash list */
    } shared4 ;

} Colamd_Col ;

typedef struct Colamd_Row_struct
{
    Int start ;         /* index for A of first col in this row */
    Int length ;        /* number of principal columns in this row */
    union
    {
        Int degree ;    /* number of principal & non-principal columns in row */
        Int p ;         /* used as a row pointer in init_rows_cols () */
    } shared1 ;
    union
    {
        Int mark ;      /* for computing set differences and marking dead rows*/
        Int first_column ;/* first column in row (used in garbage collection) */
    } shared2 ;

} Colamd_Row ;

/* ========================================================================== */
/* === Definitions ========================================================== */
/* ========================================================================== */

/* Routines are either PUBLIC (user-callable) or PRIVATE (not user-callable) */
#define PUBLIC
#define PRIVATE static

#define DENSE_DEGREE(alpha,n) \
    ((Int) MAX (16.0, (alpha) * sqrt ((double) (n))))

#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#define MIN(a,b) (((a) < (b)) ? (a) : (b))

#define ONES_COMPLEMENT(r) (-(r)-1)

/* -------------------------------------------------------------------------- */
/* Change for version 2.1:  define TRUE and FALSE only if not yet defined */
/* -------------------------------------------------------------------------- */

#ifndef TRUE
#define TRUE (1)
#endif

#ifndef FALSE
#define FALSE (0)
#endif

/* -------------------------------------------------------------------------- */

#define EMPTY   (-1)

/* Row and column status */
#define ALIVE   (0)
#define DEAD    (-1)

/* Column status */
#define DEAD_PRINCIPAL          (-1)
#define DEAD_NON_PRINCIPAL      (-2)

/* Macros for row and column status update and checking. */
#define ROW_IS_DEAD(r)                  ROW_IS_MARKED_DEAD (Row[r].shared2.mark)
#define ROW_IS_MARKED_DEAD(row_mark)    (row_mark < ALIVE)
#define ROW_IS_ALIVE(r)                 (Row [r].shared2.mark >= ALIVE)
#define COL_IS_DEAD(c)                  (Col [c].start < ALIVE)
#define COL_IS_ALIVE(c)                 (Col [c].start >= ALIVE)
#define COL_IS_DEAD_PRINCIPAL(c)        (Col [c].start == DEAD_PRINCIPAL)
#define KILL_ROW(r)                     { Row [r].shared2.mark = DEAD ; }
#define KILL_PRINCIPAL_COL(c)           { Col [c].start = DEAD_PRINCIPAL ; }
#define KILL_NON_PRINCIPAL_COL(c)       { Col [c].start = DEAD_NON_PRINCIPAL ; }

/* ========================================================================== */
/* === Colamd reporting mechanism =========================================== */
/* ========================================================================== */

#if defined (MATLAB_MEX_FILE) || defined (MATHWORKS)
/* In MATLAB, matrices are 1-based to the user, but 0-based internally */
#define INDEX(i) ((i)+1)
#else
/* In C, matrices are 0-based and indices are reported as such in *_report */
#define INDEX(i) (i)
#endif

/* All output goes through the PRINTF macro.  */
#define PRINTF(params) { if (colamd_printf != NULL) (void) colamd_printf params ; }

/* ========================================================================== */
/* === Prototypes of PRIVATE routines ======================================= */
/* ========================================================================== */

PRIVATE Int init_rows_cols
(
    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int A [],
    Int p [],
    Int stats [COLAMD_STATS]
) ;

PRIVATE void init_scoring
(
    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int A [],
    Int head [],
    double knobs [COLAMD_KNOBS],
    Int *p_n_row2,
    Int *p_n_col2,
    Int *p_max_deg
) ;

PRIVATE Int find_ordering
(
    Int n_row,
    Int n_col,
    Int Alen,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int A [],
    Int head [],
    Int n_col2,
    Int max_deg,
    Int pfree,
    Int aggressive
) ;

PRIVATE void order_children
(
    Int n_col,
    Colamd_Col Col [],
    Int p []
) ;

PRIVATE void detect_super_cols
(

#ifndef NDEBUG
    Int n_col,
    Colamd_Row Row [],
#endif /* NDEBUG */

    Colamd_Col Col [],
    Int A [],
    Int head [],
    Int row_start,
    Int row_length
) ;

PRIVATE Int garbage_collection
(
    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int A [],
    Int *pfree
) ;

PRIVATE Int clear_mark
(
    Int tag_mark,
    Int max_mark,
    Int n_row,
    Colamd_Row Row []
) ;

PRIVATE void print_report
(
    char *method,
    Int stats [COLAMD_STATS]
) ;

/* ========================================================================== */
/* === Debugging prototypes and definitions ================================= */
/* ========================================================================== */

#ifndef NDEBUG

#if 0 /* by mao */
#include <assert.h>
#endif

/* colamd_debug is the *ONLY* global variable, and is only */
/* present when debugging */

PRIVATE Int colamd_debug = 0 ;  /* debug print level */

#define DEBUG0(params) { PRINTF (params) ; }
#define DEBUG1(params) { if (colamd_debug >= 1) PRINTF (params) ; }
#define DEBUG2(params) { if (colamd_debug >= 2) PRINTF (params) ; }
#define DEBUG3(params) { if (colamd_debug >= 3) PRINTF (params) ; }
#define DEBUG4(params) { if (colamd_debug >= 4) PRINTF (params) ; }

#if 0 /* by mao */
#ifdef MATLAB_MEX_FILE
#define ASSERT(expression) (mxAssert ((expression), ""))
#else
#define ASSERT(expression) (assert (expression))
#endif /* MATLAB_MEX_FILE */
#else
#define ASSERT xassert
#endif

PRIVATE void colamd_get_debug   /* gets the debug print level from getenv */
(
    char *method
) ;

PRIVATE void debug_deg_lists
(
    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int head [],
    Int min_score,
    Int should,
    Int max_deg
) ;

PRIVATE void debug_mark
(
    Int n_row,
    Colamd_Row Row [],
    Int tag_mark,
    Int max_mark
) ;

PRIVATE void debug_matrix
(
    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int A []
) ;

PRIVATE void debug_structures
(
    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int A [],
    Int n_col2
) ;

#else /* NDEBUG */

/* === No debugging ========================================================= */

#define DEBUG0(params) ;
#define DEBUG1(params) ;
#define DEBUG2(params) ;
#define DEBUG3(params) ;
#define DEBUG4(params) ;

#define ASSERT(expression)

#endif /* NDEBUG */

/* ========================================================================== */
/* === USER-CALLABLE ROUTINES: ============================================== */
/* ========================================================================== */

/* ========================================================================== */
/* === colamd_recommended =================================================== */
/* ========================================================================== */

/*
    The colamd_recommended routine returns the suggested size for Alen.  This
    value has been determined to provide good balance between the number of
    garbage collections and the memory requirements for colamd.  If any
    argument is negative, or if integer overflow occurs, a 0 is returned as an
    error condition.  2*nnz space is required for the row and column
    indices of the matrix. COLAMD_C (n_col) + COLAMD_R (n_row) space is
    required for the Col and Row arrays, respectively, which are internal to
    colamd (roughly 6*n_col + 4*n_row).  An additional n_col space is the
    minimal amount of "elbow room", and nnz/5 more space is recommended for
    run time efficiency.

    Alen is approximately 2.2*nnz + 7*n_col + 4*n_row + 10.

    This function is not needed when using symamd.
*/

/* add two values of type size_t, and check for integer overflow */
static size_t t_add (size_t a, size_t b, int *ok)
{
    (*ok) = (*ok) && ((a + b) >= MAX (a,b)) ;
    return ((*ok) ? (a + b) : 0) ;
}

/* compute a*k where k is a small integer, and check for integer overflow */
static size_t t_mult (size_t a, size_t k, int *ok)
{
    size_t i, s = 0 ;
    for (i = 0 ; i < k ; i++)
    {
        s = t_add (s, a, ok) ;
    }
    return (s) ;
}

/* size of the Col and Row structures */
#define COLAMD_C(n_col,ok) \
    ((t_mult (t_add (n_col, 1, ok), sizeof (Colamd_Col), ok) / sizeof (Int)))

#define COLAMD_R(n_row,ok) \
    ((t_mult (t_add (n_row, 1, ok), sizeof (Colamd_Row), ok) / sizeof (Int)))


PUBLIC size_t COLAMD_recommended        /* returns recommended value of Alen. */
(
    /* === Parameters ======================================================= */

    Int nnz,                    /* number of nonzeros in A */
    Int n_row,                  /* number of rows in A */
    Int n_col                   /* number of columns in A */
)
{
    size_t s, c, r ;
    int ok = TRUE ;
    if (nnz < 0 || n_row < 0 || n_col < 0)
    {
        return (0) ;
    }
    s = t_mult (nnz, 2, &ok) ;      /* 2*nnz */
    c = COLAMD_C (n_col, &ok) ;     /* size of column structures */
    r = COLAMD_R (n_row, &ok) ;     /* size of row structures */
    s = t_add (s, c, &ok) ;
    s = t_add (s, r, &ok) ;
    s = t_add (s, n_col, &ok) ;     /* elbow room */
    s = t_add (s, nnz/5, &ok) ;     /* elbow room */
    ok = ok && (s < Int_MAX) ;
    return (ok ? s : 0) ;
}


/* ========================================================================== */
/* === colamd_set_defaults ================================================== */
/* ========================================================================== */

/*
    The colamd_set_defaults routine sets the default values of the user-
    controllable parameters for colamd and symamd:

        Colamd: rows with more than max (16, knobs [0] * sqrt (n_col))
        entries are removed prior to ordering.  Columns with more than
        max (16, knobs [1] * sqrt (MIN (n_row,n_col))) entries are removed
        prior to ordering, and placed last in the output column ordering.

        Symamd: Rows and columns with more than max (16, knobs [0] * sqrt (n))
        entries are removed prior to ordering, and placed last in the
        output ordering.

        knobs [0]       dense row control

        knobs [1]       dense column control

        knobs [2]       if nonzero, do aggresive absorption

        knobs [3..19]   unused, but future versions might use this

*/

PUBLIC void COLAMD_set_defaults
(
    /* === Parameters ======================================================= */

    double knobs [COLAMD_KNOBS]         /* knob array */
)
{
    /* === Local variables ================================================== */

    Int i ;

    if (!knobs)
    {
        return ;                        /* no knobs to initialize */
    }
    for (i = 0 ; i < COLAMD_KNOBS ; i++)
    {
        knobs [i] = 0 ;
    }
    knobs [COLAMD_DENSE_ROW] = 10 ;
    knobs [COLAMD_DENSE_COL] = 10 ;
    knobs [COLAMD_AGGRESSIVE] = TRUE ;  /* default: do aggressive absorption*/
}


/* ========================================================================== */
/* === symamd =============================================================== */
/* ========================================================================== */

PUBLIC Int SYMAMD_MAIN                  /* return TRUE if OK, FALSE otherwise */
(
    /* === Parameters ======================================================= */

    Int n,                              /* number of rows and columns of A */
    Int A [],                           /* row indices of A */
    Int p [],                           /* column pointers of A */
    Int perm [],                        /* output permutation, size n+1 */
    double knobs [COLAMD_KNOBS],        /* parameters (uses defaults if NULL) */
    Int stats [COLAMD_STATS],           /* output statistics and error codes */
    void * (*allocate) (size_t, size_t),
                                        /* pointer to calloc (ANSI C) or */
                                        /* mxCalloc (for MATLAB mexFunction) */
    void (*release) (void *)
                                        /* pointer to free (ANSI C) or */
                                        /* mxFree (for MATLAB mexFunction) */
)
{
    /* === Local variables ================================================== */

    Int *count ;                /* length of each column of M, and col pointer*/
    Int *mark ;                 /* mark array for finding duplicate entries */
    Int *M ;                    /* row indices of matrix M */
    size_t Mlen ;               /* length of M */
    Int n_row ;                 /* number of rows in M */
    Int nnz ;                   /* number of entries in A */
    Int i ;                     /* row index of A */
    Int j ;                     /* column index of A */
    Int k ;                     /* row index of M */
    Int mnz ;                   /* number of nonzeros in M */
    Int pp ;                    /* index into a column of A */
    Int last_row ;              /* last row seen in the current column */
    Int length ;                /* number of nonzeros in a column */

    double cknobs [COLAMD_KNOBS] ;              /* knobs for colamd */
    double default_knobs [COLAMD_KNOBS] ;       /* default knobs for colamd */

#ifndef NDEBUG
    colamd_get_debug ("symamd") ;
#endif /* NDEBUG */

    /* === Check the input arguments ======================================== */

    if (!stats)
    {
        DEBUG0 (("symamd: stats not present\n")) ;
        return (FALSE) ;
    }
    for (i = 0 ; i < COLAMD_STATS ; i++)
    {
        stats [i] = 0 ;
    }
    stats [COLAMD_STATUS] = COLAMD_OK ;
    stats [COLAMD_INFO1] = -1 ;
    stats [COLAMD_INFO2] = -1 ;

    if (!A)
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_A_not_present ;
        DEBUG0 (("symamd: A not present\n")) ;
        return (FALSE) ;
    }

    if (!p)             /* p is not present */
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_p_not_present ;
        DEBUG0 (("symamd: p not present\n")) ;
        return (FALSE) ;
    }

    if (n < 0)          /* n must be >= 0 */
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_ncol_negative ;
        stats [COLAMD_INFO1] = n ;
        DEBUG0 (("symamd: n negative %d\n", n)) ;
        return (FALSE) ;
    }

    nnz = p [n] ;
    if (nnz < 0)        /* nnz must be >= 0 */
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_nnz_negative ;
        stats [COLAMD_INFO1] = nnz ;
        DEBUG0 (("symamd: number of entries negative %d\n", nnz)) ;
        return (FALSE) ;
    }

    if (p [0] != 0)
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_p0_nonzero ;
        stats [COLAMD_INFO1] = p [0] ;
        DEBUG0 (("symamd: p[0] not zero %d\n", p [0])) ;
        return (FALSE) ;
    }

    /* === If no knobs, set default knobs =================================== */

    if (!knobs)
    {
        COLAMD_set_defaults (default_knobs) ;
        knobs = default_knobs ;
    }

    /* === Allocate count and mark ========================================== */

    count = (Int *) ((*allocate) (n+1, sizeof (Int))) ;
    if (!count)
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_out_of_memory ;
        DEBUG0 (("symamd: allocate count (size %d) failed\n", n+1)) ;
        return (FALSE) ;
    }

    mark = (Int *) ((*allocate) (n+1, sizeof (Int))) ;
    if (!mark)
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_out_of_memory ;
        (*release) ((void *) count) ;
        DEBUG0 (("symamd: allocate mark (size %d) failed\n", n+1)) ;
        return (FALSE) ;
    }

    /* === Compute column counts of M, check if A is valid ================== */

    stats [COLAMD_INFO3] = 0 ;  /* number of duplicate or unsorted row indices*/

    for (i = 0 ; i < n ; i++)
    {
        mark [i] = -1 ;
    }

    for (j = 0 ; j < n ; j++)
    {
        last_row = -1 ;

        length = p [j+1] - p [j] ;
        if (length < 0)
        {
            /* column pointers must be non-decreasing */
            stats [COLAMD_STATUS] = COLAMD_ERROR_col_length_negative ;
            stats [COLAMD_INFO1] = j ;
            stats [COLAMD_INFO2] = length ;
            (*release) ((void *) count) ;
            (*release) ((void *) mark) ;
            DEBUG0 (("symamd: col %d negative length %d\n", j, length)) ;
            return (FALSE) ;
        }

        for (pp = p [j] ; pp < p [j+1] ; pp++)
        {
            i = A [pp] ;
            if (i < 0 || i >= n)
            {
                /* row index i, in column j, is out of bounds */
                stats [COLAMD_STATUS] = COLAMD_ERROR_row_index_out_of_bounds ;
                stats [COLAMD_INFO1] = j ;
                stats [COLAMD_INFO2] = i ;
                stats [COLAMD_INFO3] = n ;
                (*release) ((void *) count) ;
                (*release) ((void *) mark) ;
                DEBUG0 (("symamd: row %d col %d out of bounds\n", i, j)) ;
                return (FALSE) ;
            }

            if (i <= last_row || mark [i] == j)
            {
                /* row index is unsorted or repeated (or both), thus col */
                /* is jumbled.  This is a notice, not an error condition. */
                stats [COLAMD_STATUS] = COLAMD_OK_BUT_JUMBLED ;
                stats [COLAMD_INFO1] = j ;
                stats [COLAMD_INFO2] = i ;
                (stats [COLAMD_INFO3]) ++ ;
                DEBUG1 (("symamd: row %d col %d unsorted/duplicate\n", i, j)) ;
            }

            if (i > j && mark [i] != j)
            {
                /* row k of M will contain column indices i and j */
                count [i]++ ;
                count [j]++ ;
            }

            /* mark the row as having been seen in this column */
            mark [i] = j ;

            last_row = i ;
        }
    }

    /* v2.4: removed free(mark) */

    /* === Compute column pointers of M ===================================== */

    /* use output permutation, perm, for column pointers of M */
    perm [0] = 0 ;
    for (j = 1 ; j <= n ; j++)
    {
        perm [j] = perm [j-1] + count [j-1] ;
    }
    for (j = 0 ; j < n ; j++)
    {
        count [j] = perm [j] ;
    }

    /* === Construct M ====================================================== */

    mnz = perm [n] ;
    n_row = mnz / 2 ;
    Mlen = COLAMD_recommended (mnz, n_row, n) ;
    M = (Int *) ((*allocate) (Mlen, sizeof (Int))) ;
    DEBUG0 (("symamd: M is %d-by-%d with %d entries, Mlen = %g\n",
        n_row, n, mnz, (double) Mlen)) ;

    if (!M)
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_out_of_memory ;
        (*release) ((void *) count) ;
        (*release) ((void *) mark) ;
        DEBUG0 (("symamd: allocate M (size %g) failed\n", (double) Mlen)) ;
        return (FALSE) ;
    }

    k = 0 ;

    if (stats [COLAMD_STATUS] == COLAMD_OK)
    {
        /* Matrix is OK */
        for (j = 0 ; j < n ; j++)
        {
            ASSERT (p [j+1] - p [j] >= 0) ;
            for (pp = p [j] ; pp < p [j+1] ; pp++)
            {
                i = A [pp] ;
                ASSERT (i >= 0 && i < n) ;
                if (i > j)
                {
                    /* row k of M contains column indices i and j */
                    M [count [i]++] = k ;
                    M [count [j]++] = k ;
                    k++ ;
                }
            }
        }
    }
    else
    {
        /* Matrix is jumbled.  Do not add duplicates to M.  Unsorted cols OK. */
        DEBUG0 (("symamd: Duplicates in A.\n")) ;
        for (i = 0 ; i < n ; i++)
        {
            mark [i] = -1 ;
        }
        for (j = 0 ; j < n ; j++)
        {
            ASSERT (p [j+1] - p [j] >= 0) ;
            for (pp = p [j] ; pp < p [j+1] ; pp++)
            {
                i = A [pp] ;
                ASSERT (i >= 0 && i < n) ;
                if (i > j && mark [i] != j)
                {
                    /* row k of M contains column indices i and j */
                    M [count [i]++] = k ;
                    M [count [j]++] = k ;
                    k++ ;
                    mark [i] = j ;
                }
            }
        }
        /* v2.4: free(mark) moved below */
    }

    /* count and mark no longer needed */
    (*release) ((void *) count) ;
    (*release) ((void *) mark) ;        /* v2.4: free (mark) moved here */
    ASSERT (k == n_row) ;

    /* === Adjust the knobs for M =========================================== */

    for (i = 0 ; i < COLAMD_KNOBS ; i++)
    {
        cknobs [i] = knobs [i] ;
    }

    /* there are no dense rows in M */
    cknobs [COLAMD_DENSE_ROW] = -1 ;
    cknobs [COLAMD_DENSE_COL] = knobs [COLAMD_DENSE_ROW] ;

    /* === Order the columns of M =========================================== */

    /* v2.4: colamd cannot fail here, so the error check is removed */
    (void) COLAMD_MAIN (n_row, n, (Int) Mlen, M, perm, cknobs, stats) ;

    /* Note that the output permutation is now in perm */

    /* === get the statistics for symamd from colamd ======================== */

    /* a dense column in colamd means a dense row and col in symamd */
    stats [COLAMD_DENSE_ROW] = stats [COLAMD_DENSE_COL] ;

    /* === Free M =========================================================== */

    (*release) ((void *) M) ;
    DEBUG0 (("symamd: done.\n")) ;
    return (TRUE) ;

}

/* ========================================================================== */
/* === colamd =============================================================== */
/* ========================================================================== */

/*
    The colamd routine computes a column ordering Q of a sparse matrix
    A such that the LU factorization P(AQ) = LU remains sparse, where P is
    selected via partial pivoting.   The routine can also be viewed as
    providing a permutation Q such that the Cholesky factorization
    (AQ)'(AQ) = LL' remains sparse.
*/

PUBLIC Int COLAMD_MAIN          /* returns TRUE if successful, FALSE otherwise*/
(
    /* === Parameters ======================================================= */

    Int n_row,                  /* number of rows in A */
    Int n_col,                  /* number of columns in A */
    Int Alen,                   /* length of A */
    Int A [],                   /* row indices of A */
    Int p [],                   /* pointers to columns in A */
    double knobs [COLAMD_KNOBS],/* parameters (uses defaults if NULL) */
    Int stats [COLAMD_STATS]    /* output statistics and error codes */
)
{
    /* === Local variables ================================================== */

    Int i ;                     /* loop index */
    Int nnz ;                   /* nonzeros in A */
    size_t Row_size ;           /* size of Row [], in integers */
    size_t Col_size ;           /* size of Col [], in integers */
    size_t need ;               /* minimum required length of A */
    Colamd_Row *Row ;           /* pointer into A of Row [0..n_row] array */
    Colamd_Col *Col ;           /* pointer into A of Col [0..n_col] array */
    Int n_col2 ;                /* number of non-dense, non-empty columns */
    Int n_row2 ;                /* number of non-dense, non-empty rows */
    Int ngarbage ;              /* number of garbage collections performed */
    Int max_deg ;               /* maximum row degree */
    double default_knobs [COLAMD_KNOBS] ;       /* default knobs array */
    Int aggressive ;            /* do aggressive absorption */
    int ok ;

#ifndef NDEBUG
    colamd_get_debug ("colamd") ;
#endif /* NDEBUG */

    /* === Check the input arguments ======================================== */

    if (!stats)
    {
        DEBUG0 (("colamd: stats not present\n")) ;
        return (FALSE) ;
    }
    for (i = 0 ; i < COLAMD_STATS ; i++)
    {
        stats [i] = 0 ;
    }
    stats [COLAMD_STATUS] = COLAMD_OK ;
    stats [COLAMD_INFO1] = -1 ;
    stats [COLAMD_INFO2] = -1 ;

    if (!A)             /* A is not present */
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_A_not_present ;
        DEBUG0 (("colamd: A not present\n")) ;
        return (FALSE) ;
    }

    if (!p)             /* p is not present */
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_p_not_present ;
        DEBUG0 (("colamd: p not present\n")) ;
        return (FALSE) ;
    }

    if (n_row < 0)      /* n_row must be >= 0 */
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_nrow_negative ;
        stats [COLAMD_INFO1] = n_row ;
        DEBUG0 (("colamd: nrow negative %d\n", n_row)) ;
        return (FALSE) ;
    }

    if (n_col < 0)      /* n_col must be >= 0 */
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_ncol_negative ;
        stats [COLAMD_INFO1] = n_col ;
        DEBUG0 (("colamd: ncol negative %d\n", n_col)) ;
        return (FALSE) ;
    }

    nnz = p [n_col] ;
    if (nnz < 0)        /* nnz must be >= 0 */
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_nnz_negative ;
        stats [COLAMD_INFO1] = nnz ;
        DEBUG0 (("colamd: number of entries negative %d\n", nnz)) ;
        return (FALSE) ;
    }

    if (p [0] != 0)
    {
        stats [COLAMD_STATUS] = COLAMD_ERROR_p0_nonzero ;
        stats [COLAMD_INFO1] = p [0] ;
        DEBUG0 (("colamd: p[0] not zero %d\n", p [0])) ;
        return (FALSE) ;
    }

    /* === If no knobs, set default knobs =================================== */

    if (!knobs)
    {
        COLAMD_set_defaults (default_knobs) ;
        knobs = default_knobs ;
    }

    aggressive = (knobs [COLAMD_AGGRESSIVE] != FALSE) ;

    /* === Allocate the Row and Col arrays from array A ===================== */

    ok = TRUE ;
    Col_size = COLAMD_C (n_col, &ok) ;      /* size of Col array of structs */
    Row_size = COLAMD_R (n_row, &ok) ;      /* size of Row array of structs */

    /* need = 2*nnz + n_col + Col_size + Row_size ; */
    need = t_mult (nnz, 2, &ok) ;
    need = t_add (need, n_col, &ok) ;
    need = t_add (need, Col_size, &ok) ;
    need = t_add (need, Row_size, &ok) ;

    if (!ok || need > (size_t) Alen || need > Int_MAX)
    {
        /* not enough space in array A to perform the ordering */
        stats [COLAMD_STATUS] = COLAMD_ERROR_A_too_small ;
        stats [COLAMD_INFO1] = need ;
        stats [COLAMD_INFO2] = Alen ;
        DEBUG0 (("colamd: Need Alen >= %d, given only Alen = %d\n", need,Alen));
        return (FALSE) ;
    }

    Alen -= Col_size + Row_size ;
    Col = (Colamd_Col *) &A [Alen] ;
    Row = (Colamd_Row *) &A [Alen + Col_size] ;

    /* === Construct the row and column data structures ===================== */

    if (!init_rows_cols (n_row, n_col, Row, Col, A, p, stats))
    {
        /* input matrix is invalid */
        DEBUG0 (("colamd: Matrix invalid\n")) ;
        return (FALSE) ;
    }

    /* === Initialize scores, kill dense rows/columns ======================= */

    init_scoring (n_row, n_col, Row, Col, A, p, knobs,
        &n_row2, &n_col2, &max_deg) ;

    /* === Order the supercolumns =========================================== */

    ngarbage = find_ordering (n_row, n_col, Alen, Row, Col, A, p,
        n_col2, max_deg, 2*nnz, aggressive) ;

    /* === Order the non-principal columns ================================== */

    order_children (n_col, Col, p) ;

    /* === Return statistics in stats ======================================= */

    stats [COLAMD_DENSE_ROW] = n_row - n_row2 ;
    stats [COLAMD_DENSE_COL] = n_col - n_col2 ;
    stats [COLAMD_DEFRAG_COUNT] = ngarbage ;
    DEBUG0 (("colamd: done.\n")) ;
    return (TRUE) ;
}


/* ========================================================================== */
/* === colamd_report ======================================================== */
/* ========================================================================== */

PUBLIC void COLAMD_report
(
    Int stats [COLAMD_STATS]
)
{
    print_report ("colamd", stats) ;
}


/* ========================================================================== */
/* === symamd_report ======================================================== */
/* ========================================================================== */

PUBLIC void SYMAMD_report
(
    Int stats [COLAMD_STATS]
)
{
    print_report ("symamd", stats) ;
}



/* ========================================================================== */
/* === NON-USER-CALLABLE ROUTINES: ========================================== */
/* ========================================================================== */

/* There are no user-callable routines beyond this point in the file */


/* ========================================================================== */
/* === init_rows_cols ======================================================= */
/* ========================================================================== */

/*
    Takes the column form of the matrix in A and creates the row form of the
    matrix.  Also, row and column attributes are stored in the Col and Row
    structs.  If the columns are un-sorted or contain duplicate row indices,
    this routine will also sort and remove duplicate row indices from the
    column form of the matrix.  Returns FALSE if the matrix is invalid,
    TRUE otherwise.  Not user-callable.
*/

PRIVATE Int init_rows_cols      /* returns TRUE if OK, or FALSE otherwise */
(
    /* === Parameters ======================================================= */

    Int n_row,                  /* number of rows of A */
    Int n_col,                  /* number of columns of A */
    Colamd_Row Row [],          /* of size n_row+1 */
    Colamd_Col Col [],          /* of size n_col+1 */
    Int A [],                   /* row indices of A, of size Alen */
    Int p [],                   /* pointers to columns in A, of size n_col+1 */
    Int stats [COLAMD_STATS]    /* colamd statistics */
)
{
    /* === Local variables ================================================== */

    Int col ;                   /* a column index */
    Int row ;                   /* a row index */
    Int *cp ;                   /* a column pointer */
    Int *cp_end ;               /* a pointer to the end of a column */
    Int *rp ;                   /* a row pointer */
    Int *rp_end ;               /* a pointer to the end of a row */
    Int last_row ;              /* previous row */

    /* === Initialize columns, and check column pointers ==================== */

    for (col = 0 ; col < n_col ; col++)
    {
        Col [col].start = p [col] ;
        Col [col].length = p [col+1] - p [col] ;

        if (Col [col].length < 0)
        {
            /* column pointers must be non-decreasing */
            stats [COLAMD_STATUS] = COLAMD_ERROR_col_length_negative ;
            stats [COLAMD_INFO1] = col ;
            stats [COLAMD_INFO2] = Col [col].length ;
            DEBUG0 (("colamd: col %d length %d < 0\n", col, Col [col].length)) ;
            return (FALSE) ;
        }

        Col [col].shared1.thickness = 1 ;
        Col [col].shared2.score = 0 ;
        Col [col].shared3.prev = EMPTY ;
        Col [col].shared4.degree_next = EMPTY ;
    }

    /* p [0..n_col] no longer needed, used as "head" in subsequent routines */

    /* === Scan columns, compute row degrees, and check row indices ========= */

    stats [COLAMD_INFO3] = 0 ;  /* number of duplicate or unsorted row indices*/

    for (row = 0 ; row < n_row ; row++)
    {
        Row [row].length = 0 ;
        Row [row].shared2.mark = -1 ;
    }

    for (col = 0 ; col < n_col ; col++)
    {
        last_row = -1 ;

        cp = &A [p [col]] ;
        cp_end = &A [p [col+1]] ;

        while (cp < cp_end)
        {
            row = *cp++ ;

            /* make sure row indices within range */
            if (row < 0 || row >= n_row)
            {
                stats [COLAMD_STATUS] = COLAMD_ERROR_row_index_out_of_bounds ;
                stats [COLAMD_INFO1] = col ;
                stats [COLAMD_INFO2] = row ;
                stats [COLAMD_INFO3] = n_row ;
                DEBUG0 (("colamd: row %d col %d out of bounds\n", row, col)) ;
                return (FALSE) ;
            }

            if (row <= last_row || Row [row].shared2.mark == col)
            {
                /* row index are unsorted or repeated (or both), thus col */
                /* is jumbled.  This is a notice, not an error condition. */
                stats [COLAMD_STATUS] = COLAMD_OK_BUT_JUMBLED ;
                stats [COLAMD_INFO1] = col ;
                stats [COLAMD_INFO2] = row ;
                (stats [COLAMD_INFO3]) ++ ;
                DEBUG1 (("colamd: row %d col %d unsorted/duplicate\n",row,col));
            }

            if (Row [row].shared2.mark != col)
            {
                Row [row].length++ ;
            }
            else
            {
                /* this is a repeated entry in the column, */
                /* it will be removed */
                Col [col].length-- ;
            }

            /* mark the row as having been seen in this column */
            Row [row].shared2.mark = col ;

            last_row = row ;
        }
    }

    /* === Compute row pointers ============================================= */

    /* row form of the matrix starts directly after the column */
    /* form of matrix in A */
    Row [0].start = p [n_col] ;
    Row [0].shared1.p = Row [0].start ;
    Row [0].shared2.mark = -1 ;
    for (row = 1 ; row < n_row ; row++)
    {
        Row [row].start = Row [row-1].start + Row [row-1].length ;
        Row [row].shared1.p = Row [row].start ;
        Row [row].shared2.mark = -1 ;
    }

    /* === Create row form ================================================== */

    if (stats [COLAMD_STATUS] == COLAMD_OK_BUT_JUMBLED)
    {
        /* if cols jumbled, watch for repeated row indices */
        for (col = 0 ; col < n_col ; col++)
        {
            cp = &A [p [col]] ;
            cp_end = &A [p [col+1]] ;
            while (cp < cp_end)
            {
                row = *cp++ ;
                if (Row [row].shared2.mark != col)
                {
                    A [(Row [row].shared1.p)++] = col ;
                    Row [row].shared2.mark = col ;
                }
            }
        }
    }
    else
    {
        /* if cols not jumbled, we don't need the mark (this is faster) */
        for (col = 0 ; col < n_col ; col++)
        {
            cp = &A [p [col]] ;
            cp_end = &A [p [col+1]] ;
            while (cp < cp_end)
            {
                A [(Row [*cp++].shared1.p)++] = col ;
            }
        }
    }

    /* === Clear the row marks and set row degrees ========================== */

    for (row = 0 ; row < n_row ; row++)
    {
        Row [row].shared2.mark = 0 ;
        Row [row].shared1.degree = Row [row].length ;
    }

    /* === See if we need to re-create columns ============================== */

    if (stats [COLAMD_STATUS] == COLAMD_OK_BUT_JUMBLED)
    {
        DEBUG0 (("colamd: reconstructing column form, matrix jumbled\n")) ;

#ifndef NDEBUG
        /* make sure column lengths are correct */
        for (col = 0 ; col < n_col ; col++)
        {
            p [col] = Col [col].length ;
        }
        for (row = 0 ; row < n_row ; row++)
        {
            rp = &A [Row [row].start] ;
            rp_end = rp + Row [row].length ;
            while (rp < rp_end)
            {
                p [*rp++]-- ;
            }
        }
        for (col = 0 ; col < n_col ; col++)
        {
            ASSERT (p [col] == 0) ;
        }
        /* now p is all zero (different than when debugging is turned off) */
#endif /* NDEBUG */

        /* === Compute col pointers ========================================= */

        /* col form of the matrix starts at A [0]. */
        /* Note, we may have a gap between the col form and the row */
        /* form if there were duplicate entries, if so, it will be */
        /* removed upon the first garbage collection */
        Col [0].start = 0 ;
        p [0] = Col [0].start ;
        for (col = 1 ; col < n_col ; col++)
        {
            /* note that the lengths here are for pruned columns, i.e. */
            /* no duplicate row indices will exist for these columns */
            Col [col].start = Col [col-1].start + Col [col-1].length ;
            p [col] = Col [col].start ;
        }

        /* === Re-create col form =========================================== */

        for (row = 0 ; row < n_row ; row++)
        {
            rp = &A [Row [row].start] ;
            rp_end = rp + Row [row].length ;
            while (rp < rp_end)
            {
                A [(p [*rp++])++] = row ;
            }
        }
    }

    /* === Done.  Matrix is not (or no longer) jumbled ====================== */

    return (TRUE) ;
}


/* ========================================================================== */
/* === init_scoring ========================================================= */
/* ========================================================================== */

/*
    Kills dense or empty columns and rows, calculates an initial score for
    each column, and places all columns in the degree lists.  Not user-callable.
*/

PRIVATE void init_scoring
(
    /* === Parameters ======================================================= */

    Int n_row,                  /* number of rows of A */
    Int n_col,                  /* number of columns of A */
    Colamd_Row Row [],          /* of size n_row+1 */
    Colamd_Col Col [],          /* of size n_col+1 */
    Int A [],                   /* column form and row form of A */
    Int head [],                /* of size n_col+1 */
    double knobs [COLAMD_KNOBS],/* parameters */
    Int *p_n_row2,              /* number of non-dense, non-empty rows */
    Int *p_n_col2,              /* number of non-dense, non-empty columns */
    Int *p_max_deg              /* maximum row degree */
)
{
    /* === Local variables ================================================== */

    Int c ;                     /* a column index */
    Int r, row ;                /* a row index */
    Int *cp ;                   /* a column pointer */
    Int deg ;                   /* degree of a row or column */
    Int *cp_end ;               /* a pointer to the end of a column */
    Int *new_cp ;               /* new column pointer */
    Int col_length ;            /* length of pruned column */
    Int score ;                 /* current column score */
    Int n_col2 ;                /* number of non-dense, non-empty columns */
    Int n_row2 ;                /* number of non-dense, non-empty rows */
    Int dense_row_count ;       /* remove rows with more entries than this */
    Int dense_col_count ;       /* remove cols with more entries than this */
    Int min_score ;             /* smallest column score */
    Int max_deg ;               /* maximum row degree */
    Int next_col ;              /* Used to add to degree list.*/

#ifndef NDEBUG
    Int debug_count ;           /* debug only. */
#endif /* NDEBUG */

    /* === Extract knobs ==================================================== */

    /* Note: if knobs contains a NaN, this is undefined: */
    if (knobs [COLAMD_DENSE_ROW] < 0)
    {
        /* only remove completely dense rows */
        dense_row_count = n_col-1 ;
    }
    else
    {
        dense_row_count = DENSE_DEGREE (knobs [COLAMD_DENSE_ROW], n_col) ;
    }
    if (knobs [COLAMD_DENSE_COL] < 0)
    {
        /* only remove completely dense columns */
        dense_col_count = n_row-1 ;
    }
    else
    {
        dense_col_count =
            DENSE_DEGREE (knobs [COLAMD_DENSE_COL], MIN (n_row, n_col)) ;
    }

    DEBUG1 (("colamd: densecount: %d %d\n", dense_row_count, dense_col_count)) ;
    max_deg = 0 ;
    n_col2 = n_col ;
    n_row2 = n_row ;

    /* === Kill empty columns =============================================== */

    /* Put the empty columns at the end in their natural order, so that LU */
    /* factorization can proceed as far as possible. */
    for (c = n_col-1 ; c >= 0 ; c--)
    {
        deg = Col [c].length ;
        if (deg == 0)
        {
            /* this is a empty column, kill and order it last */
            Col [c].shared2.order = --n_col2 ;
            KILL_PRINCIPAL_COL (c) ;
        }
    }
    DEBUG1 (("colamd: null columns killed: %d\n", n_col - n_col2)) ;

    /* === Kill dense columns =============================================== */

    /* Put the dense columns at the end, in their natural order */
    for (c = n_col-1 ; c >= 0 ; c--)
    {
        /* skip any dead columns */
        if (COL_IS_DEAD (c))
        {
            continue ;
        }
        deg = Col [c].length ;
        if (deg > dense_col_count)
        {
            /* this is a dense column, kill and order it last */
            Col [c].shared2.order = --n_col2 ;
            /* decrement the row degrees */
            cp = &A [Col [c].start] ;
            cp_end = cp + Col [c].length ;
            while (cp < cp_end)
            {
                Row [*cp++].shared1.degree-- ;
            }
            KILL_PRINCIPAL_COL (c) ;
        }
    }
    DEBUG1 (("colamd: Dense and null columns killed: %d\n", n_col - n_col2)) ;

    /* === Kill dense and empty rows ======================================== */

    for (r = 0 ; r < n_row ; r++)
    {
        deg = Row [r].shared1.degree ;
        ASSERT (deg >= 0 && deg <= n_col) ;
        if (deg > dense_row_count || deg == 0)
        {
            /* kill a dense or empty row */
            KILL_ROW (r) ;
            --n_row2 ;
        }
        else
        {
            /* keep track of max degree of remaining rows */
            max_deg = MAX (max_deg, deg) ;
        }
    }
    DEBUG1 (("colamd: Dense and null rows killed: %d\n", n_row - n_row2)) ;

    /* === Compute initial column scores ==================================== */

    /* At this point the row degrees are accurate.  They reflect the number */
    /* of "live" (non-dense) columns in each row.  No empty rows exist. */
    /* Some "live" columns may contain only dead rows, however.  These are */
    /* pruned in the code below. */

    /* now find the initial matlab score for each column */
    for (c = n_col-1 ; c >= 0 ; c--)
    {
        /* skip dead column */
        if (COL_IS_DEAD (c))
        {
            continue ;
        }
        score = 0 ;
        cp = &A [Col [c].start] ;
        new_cp = cp ;
        cp_end = cp + Col [c].length ;
        while (cp < cp_end)
        {
            /* get a row */
            row = *cp++ ;
            /* skip if dead */
            if (ROW_IS_DEAD (row))
            {
                continue ;
            }
            /* compact the column */
            *new_cp++ = row ;
            /* add row's external degree */
            score += Row [row].shared1.degree - 1 ;
            /* guard against integer overflow */
            score = MIN (score, n_col) ;
        }
        /* determine pruned column length */
        col_length = (Int) (new_cp - &A [Col [c].start]) ;
        if (col_length == 0)
        {
            /* a newly-made null column (all rows in this col are "dense" */
            /* and have already been killed) */
            DEBUG2 (("Newly null killed: %d\n", c)) ;
            Col [c].shared2.order = --n_col2 ;
            KILL_PRINCIPAL_COL (c) ;
        }
        else
        {
            /* set column length and set score */
            ASSERT (score >= 0) ;
            ASSERT (score <= n_col) ;
            Col [c].length = col_length ;
            Col [c].shared2.score = score ;
        }
    }
    DEBUG1 (("colamd: Dense, null, and newly-null columns killed: %d\n",
        n_col-n_col2)) ;

    /* At this point, all empty rows and columns are dead.  All live columns */
    /* are "clean" (containing no dead rows) and simplicial (no supercolumns */
    /* yet).  Rows may contain dead columns, but all live rows contain at */
    /* least one live column. */

#ifndef NDEBUG
    debug_structures (n_row, n_col, Row, Col, A, n_col2) ;
#endif /* NDEBUG */

    /* === Initialize degree lists ========================================== */

#ifndef NDEBUG
    debug_count = 0 ;
#endif /* NDEBUG */

    /* clear the hash buckets */
    for (c = 0 ; c <= n_col ; c++)
    {
        head [c] = EMPTY ;
    }
    min_score = n_col ;
    /* place in reverse order, so low column indices are at the front */
    /* of the lists.  This is to encourage natural tie-breaking */
    for (c = n_col-1 ; c >= 0 ; c--)
    {
        /* only add principal columns to degree lists */
        if (COL_IS_ALIVE (c))
        {
            DEBUG4 (("place %d score %d minscore %d ncol %d\n",
                c, Col [c].shared2.score, min_score, n_col)) ;

            /* === Add columns score to DList =============================== */

            score = Col [c].shared2.score ;

            ASSERT (min_score >= 0) ;
            ASSERT (min_score <= n_col) ;
            ASSERT (score >= 0) ;
            ASSERT (score <= n_col) ;
            ASSERT (head [score] >= EMPTY) ;

            /* now add this column to dList at proper score location */
            next_col = head [score] ;
            Col [c].shared3.prev = EMPTY ;
            Col [c].shared4.degree_next = next_col ;

            /* if there already was a column with the same score, set its */
            /* previous pointer to this new column */
            if (next_col != EMPTY)
            {
                Col [next_col].shared3.prev = c ;
            }
            head [score] = c ;

            /* see if this score is less than current min */
            min_score = MIN (min_score, score) ;

#ifndef NDEBUG
            debug_count++ ;
#endif /* NDEBUG */

        }
    }

#ifndef NDEBUG
    DEBUG1 (("colamd: Live cols %d out of %d, non-princ: %d\n",
        debug_count, n_col, n_col-debug_count)) ;
    ASSERT (debug_count == n_col2) ;
    debug_deg_lists (n_row, n_col, Row, Col, head, min_score, n_col2, max_deg) ;
#endif /* NDEBUG */

    /* === Return number of remaining columns, and max row degree =========== */

    *p_n_col2 = n_col2 ;
    *p_n_row2 = n_row2 ;
    *p_max_deg = max_deg ;
}


/* ========================================================================== */
/* === find_ordering ======================================================== */
/* ========================================================================== */

/*
    Order the principal columns of the supercolumn form of the matrix
    (no supercolumns on input).  Uses a minimum approximate column minimum
    degree ordering method.  Not user-callable.
*/

PRIVATE Int find_ordering       /* return the number of garbage collections */
(
    /* === Parameters ======================================================= */

    Int n_row,                  /* number of rows of A */
    Int n_col,                  /* number of columns of A */
    Int Alen,                   /* size of A, 2*nnz + n_col or larger */
    Colamd_Row Row [],          /* of size n_row+1 */
    Colamd_Col Col [],          /* of size n_col+1 */
    Int A [],                   /* column form and row form of A */
    Int head [],                /* of size n_col+1 */
    Int n_col2,                 /* Remaining columns to order */
    Int max_deg,                /* Maximum row degree */
    Int pfree,                  /* index of first free slot (2*nnz on entry) */
    Int aggressive
)
{
    /* === Local variables ================================================== */

    Int k ;                     /* current pivot ordering step */
    Int pivot_col ;             /* current pivot column */
    Int *cp ;                   /* a column pointer */
    Int *rp ;                   /* a row pointer */
    Int pivot_row ;             /* current pivot row */
    Int *new_cp ;               /* modified column pointer */
    Int *new_rp ;               /* modified row pointer */
    Int pivot_row_start ;       /* pointer to start of pivot row */
    Int pivot_row_degree ;      /* number of columns in pivot row */
    Int pivot_row_length ;      /* number of supercolumns in pivot row */
    Int pivot_col_score ;       /* score of pivot column */
    Int needed_memory ;         /* free space needed for pivot row */
    Int *cp_end ;               /* pointer to the end of a column */
    Int *rp_end ;               /* pointer to the end of a row */
    Int row ;                   /* a row index */
    Int col ;                   /* a column index */
    Int max_score ;             /* maximum possible score */
    Int cur_score ;             /* score of current column */
    unsigned Int hash ;         /* hash value for supernode detection */
    Int head_column ;           /* head of hash bucket */
    Int first_col ;             /* first column in hash bucket */
    Int tag_mark ;              /* marker value for mark array */
    Int row_mark ;              /* Row [row].shared2.mark */
    Int set_difference ;        /* set difference size of row with pivot row */
    Int min_score ;             /* smallest column score */
    Int col_thickness ;         /* "thickness" (no. of columns in a supercol) */
    Int max_mark ;              /* maximum value of tag_mark */
    Int pivot_col_thickness ;   /* number of columns represented by pivot col */
    Int prev_col ;              /* Used by Dlist operations. */
    Int next_col ;              /* Used by Dlist operations. */
    Int ngarbage ;              /* number of garbage collections performed */

#ifndef NDEBUG
    Int debug_d ;               /* debug loop counter */
    Int debug_step = 0 ;        /* debug loop counter */
#endif /* NDEBUG */

    /* === Initialization and clear mark ==================================== */

    max_mark = INT_MAX - n_col ;        /* INT_MAX defined in <limits.h> */
    tag_mark = clear_mark (0, max_mark, n_row, Row) ;
    min_score = 0 ;
    ngarbage = 0 ;
    DEBUG1 (("colamd: Ordering, n_col2=%d\n", n_col2)) ;

    /* === Order the columns ================================================ */

    for (k = 0 ; k < n_col2 ; /* 'k' is incremented below */)
    {

#ifndef NDEBUG
        if (debug_step % 100 == 0)
        {
            DEBUG2 (("\n...       Step k: %d out of n_col2: %d\n", k, n_col2)) ;
        }
        else
        {
            DEBUG3 (("\n----------Step k: %d out of n_col2: %d\n", k, n_col2)) ;
        }
        debug_step++ ;
        debug_deg_lists (n_row, n_col, Row, Col, head,
                min_score, n_col2-k, max_deg) ;
        debug_matrix (n_row, n_col, Row, Col, A) ;
#endif /* NDEBUG */

        /* === Select pivot column, and order it ============================ */

        /* make sure degree list isn't empty */
        ASSERT (min_score >= 0) ;
        ASSERT (min_score <= n_col) ;
        ASSERT (head [min_score] >= EMPTY) ;

#ifndef NDEBUG
        for (debug_d = 0 ; debug_d < min_score ; debug_d++)
        {
            ASSERT (head [debug_d] == EMPTY) ;
        }
#endif /* NDEBUG */

        /* get pivot column from head of minimum degree list */
        while (head [min_score] == EMPTY && min_score < n_col)
        {
            min_score++ ;
        }
        pivot_col = head [min_score] ;
        ASSERT (pivot_col >= 0 && pivot_col <= n_col) ;
        next_col = Col [pivot_col].shared4.degree_next ;
        head [min_score] = next_col ;
        if (next_col != EMPTY)
        {
            Col [next_col].shared3.prev = EMPTY ;
        }

        ASSERT (COL_IS_ALIVE (pivot_col)) ;

        /* remember score for defrag check */
        pivot_col_score = Col [pivot_col].shared2.score ;

        /* the pivot column is the kth column in the pivot order */
        Col [pivot_col].shared2.order = k ;

        /* increment order count by column thickness */
        pivot_col_thickness = Col [pivot_col].shared1.thickness ;
        k += pivot_col_thickness ;
        ASSERT (pivot_col_thickness > 0) ;
        DEBUG3 (("Pivot col: %d thick %d\n", pivot_col, pivot_col_thickness)) ;

        /* === Garbage_collection, if necessary ============================= */

        needed_memory = MIN (pivot_col_score, n_col - k) ;
        if (pfree + needed_memory >= Alen)
        {
            pfree = garbage_collection (n_row, n_col, Row, Col, A, &A [pfree]) ;
            ngarbage++ ;
            /* after garbage collection we will have enough */
            ASSERT (pfree + needed_memory < Alen) ;
            /* garbage collection has wiped out the Row[].shared2.mark array */
            tag_mark = clear_mark (0, max_mark, n_row, Row) ;

#ifndef NDEBUG
            debug_matrix (n_row, n_col, Row, Col, A) ;
#endif /* NDEBUG */
        }

        /* === Compute pivot row pattern ==================================== */

        /* get starting location for this new merged row */
        pivot_row_start = pfree ;

        /* initialize new row counts to zero */
        pivot_row_degree = 0 ;

        /* tag pivot column as having been visited so it isn't included */
        /* in merged pivot row */
        Col [pivot_col].shared1.thickness = -pivot_col_thickness ;

        /* pivot row is the union of all rows in the pivot column pattern */
        cp = &A [Col [pivot_col].start] ;
        cp_end = cp + Col [pivot_col].length ;
        while (cp < cp_end)
        {
            /* get a row */
            row = *cp++ ;
            DEBUG4 (("Pivot col pattern %d %d\n", ROW_IS_ALIVE (row), row)) ;
            /* skip if row is dead */
            if (ROW_IS_ALIVE (row))
            {
                rp = &A [Row [row].start] ;
                rp_end = rp + Row [row].length ;
                while (rp < rp_end)
                {
                    /* get a column */
                    col = *rp++ ;
                    /* add the column, if alive and untagged */
                    col_thickness = Col [col].shared1.thickness ;
                    if (col_thickness > 0 && COL_IS_ALIVE (col))
                    {
                        /* tag column in pivot row */
                        Col [col].shared1.thickness = -col_thickness ;
                        ASSERT (pfree < Alen) ;
                        /* place column in pivot row */
                        A [pfree++] = col ;
                        pivot_row_degree += col_thickness ;
                    }
                }
            }
        }

        /* clear tag on pivot column */
        Col [pivot_col].shared1.thickness = pivot_col_thickness ;
        max_deg = MAX (max_deg, pivot_row_degree) ;

#ifndef NDEBUG
        DEBUG3 (("check2\n")) ;
        debug_mark (n_row, Row, tag_mark, max_mark) ;
#endif /* NDEBUG */

        /* === Kill all rows used to construct pivot row ==================== */

        /* also kill pivot row, temporarily */
        cp = &A [Col [pivot_col].start] ;
        cp_end = cp + Col [pivot_col].length ;
        while (cp < cp_end)
        {
            /* may be killing an already dead row */
            row = *cp++ ;
            DEBUG3 (("Kill row in pivot col: %d\n", row)) ;
            KILL_ROW (row) ;
        }

        /* === Select a row index to use as the new pivot row =============== */

        pivot_row_length = pfree - pivot_row_start ;
        if (pivot_row_length > 0)
        {
            /* pick the "pivot" row arbitrarily (first row in col) */
            pivot_row = A [Col [pivot_col].start] ;
            DEBUG3 (("Pivotal row is %d\n", pivot_row)) ;
        }
        else
        {
            /* there is no pivot row, since it is of zero length */
            pivot_row = EMPTY ;
            ASSERT (pivot_row_length == 0) ;
        }
        ASSERT (Col [pivot_col].length > 0 || pivot_row_length == 0) ;

        /* === Approximate degree computation =============================== */

        /* Here begins the computation of the approximate degree.  The column */
        /* score is the sum of the pivot row "length", plus the size of the */
        /* set differences of each row in the column minus the pattern of the */
        /* pivot row itself.  The column ("thickness") itself is also */
        /* excluded from the column score (we thus use an approximate */
        /* external degree). */

        /* The time taken by the following code (compute set differences, and */
        /* add them up) is proportional to the size of the data structure */
        /* being scanned - that is, the sum of the sizes of each column in */
        /* the pivot row.  Thus, the amortized time to compute a column score */
        /* is proportional to the size of that column (where size, in this */
        /* context, is the column "length", or the number of row indices */
        /* in that column).  The number of row indices in a column is */
        /* monotonically non-decreasing, from the length of the original */
        /* column on input to colamd. */

        /* === Compute set differences ====================================== */

        DEBUG3 (("** Computing set differences phase. **\n")) ;

        /* pivot row is currently dead - it will be revived later. */

        DEBUG3 (("Pivot row: ")) ;
        /* for each column in pivot row */
        rp = &A [pivot_row_start] ;
        rp_end = rp + pivot_row_length ;
        while (rp < rp_end)
        {
            col = *rp++ ;
            ASSERT (COL_IS_ALIVE (col) && col != pivot_col) ;
            DEBUG3 (("Col: %d\n", col)) ;

            /* clear tags used to construct pivot row pattern */
            col_thickness = -Col [col].shared1.thickness ;
            ASSERT (col_thickness > 0) ;
            Col [col].shared1.thickness = col_thickness ;

            /* === Remove column from degree list =========================== */

            cur_score = Col [col].shared2.score ;
            prev_col = Col [col].shared3.prev ;
            next_col = Col [col].shared4.degree_next ;
            ASSERT (cur_score >= 0) ;
            ASSERT (cur_score <= n_col) ;
            ASSERT (cur_score >= EMPTY) ;
            if (prev_col == EMPTY)
            {
                head [cur_score] = next_col ;
            }
            else
            {
                Col [prev_col].shared4.degree_next = next_col ;
            }
            if (next_col != EMPTY)
            {
                Col [next_col].shared3.prev = prev_col ;
            }

            /* === Scan the column ========================================== */

            cp = &A [Col [col].start] ;
            cp_end = cp + Col [col].length ;
            while (cp < cp_end)
            {
                /* get a row */
                row = *cp++ ;
                row_mark = Row [row].shared2.mark ;
                /* skip if dead */
                if (ROW_IS_MARKED_DEAD (row_mark))
                {
                    continue ;
                }
                ASSERT (row != pivot_row) ;
                set_difference = row_mark - tag_mark ;
                /* check if the row has been seen yet */
                if (set_difference < 0)
                {
                    ASSERT (Row [row].shared1.degree <= max_deg) ;
                    set_difference = Row [row].shared1.degree ;
                }
                /* subtract column thickness from this row's set difference */
                set_difference -= col_thickness ;
                ASSERT (set_difference >= 0) ;
                /* absorb this row if the set difference becomes zero */
                if (set_difference == 0 && aggressive)
                {
                    DEBUG3 (("aggressive absorption. Row: %d\n", row)) ;
                    KILL_ROW (row) ;
                }
                else
                {
                    /* save the new mark */
                    Row [row].shared2.mark = set_difference + tag_mark ;
                }
            }
        }

#ifndef NDEBUG
        debug_deg_lists (n_row, n_col, Row, Col, head,
                min_score, n_col2-k-pivot_row_degree, max_deg) ;
#endif /* NDEBUG */

        /* === Add up set differences for each column ======================= */

        DEBUG3 (("** Adding set differences phase. **\n")) ;

        /* for each column in pivot row */
        rp = &A [pivot_row_start] ;
        rp_end = rp + pivot_row_length ;
        while (rp < rp_end)
        {
            /* get a column */
            col = *rp++ ;
            ASSERT (COL_IS_ALIVE (col) && col != pivot_col) ;
            hash = 0 ;
            cur_score = 0 ;
            cp = &A [Col [col].start] ;
            /* compact the column */
            new_cp = cp ;
            cp_end = cp + Col [col].length ;

            DEBUG4 (("Adding set diffs for Col: %d.\n", col)) ;

            while (cp < cp_end)
            {
                /* get a row */
                row = *cp++ ;
                ASSERT(row >= 0 && row < n_row) ;
                row_mark = Row [row].shared2.mark ;
                /* skip if dead */
                if (ROW_IS_MARKED_DEAD (row_mark))
                {
                    DEBUG4 ((" Row %d, dead\n", row)) ;
                    continue ;
                }
                DEBUG4 ((" Row %d, set diff %d\n", row, row_mark-tag_mark));
                ASSERT (row_mark >= tag_mark) ;
                /* compact the column */
                *new_cp++ = row ;
                /* compute hash function */
                hash += row ;
                /* add set difference */
                cur_score += row_mark - tag_mark ;
                /* integer overflow... */
                cur_score = MIN (cur_score, n_col) ;
            }

            /* recompute the column's length */
            Col [col].length = (Int) (new_cp - &A [Col [col].start]) ;

            /* === Further mass elimination ================================= */

            if (Col [col].length == 0)
            {
                DEBUG4 (("further mass elimination. Col: %d\n", col)) ;
                /* nothing left but the pivot row in this column */
                KILL_PRINCIPAL_COL (col) ;
                pivot_row_degree -= Col [col].shared1.thickness ;
                ASSERT (pivot_row_degree >= 0) ;
                /* order it */
                Col [col].shared2.order = k ;
                /* increment order count by column thickness */
                k += Col [col].shared1.thickness ;
            }
            else
            {
                /* === Prepare for supercolumn detection ==================== */

                DEBUG4 (("Preparing supercol detection for Col: %d.\n", col)) ;

                /* save score so far */
                Col [col].shared2.score = cur_score ;

                /* add column to hash table, for supercolumn detection */
                hash %= n_col + 1 ;

                DEBUG4 ((" Hash = %d, n_col = %d.\n", hash, n_col)) ;
                ASSERT (((Int) hash) <= n_col) ;

                head_column = head [hash] ;
                if (head_column > EMPTY)
                {
                    /* degree list "hash" is non-empty, use prev (shared3) of */
                    /* first column in degree list as head of hash bucket */
                    first_col = Col [head_column].shared3.headhash ;
                    Col [head_column].shared3.headhash = col ;
                }
                else
                {
                    /* degree list "hash" is empty, use head as hash bucket */
                    first_col = - (head_column + 2) ;
                    head [hash] = - (col + 2) ;
                }
                Col [col].shared4.hash_next = first_col ;

                /* save hash function in Col [col].shared3.hash */
                Col [col].shared3.hash = (Int) hash ;
                ASSERT (COL_IS_ALIVE (col)) ;
            }
        }

        /* The approximate external column degree is now computed.  */

        /* === Supercolumn detection ======================================== */

        DEBUG3 (("** Supercolumn detection phase. **\n")) ;

        detect_super_cols (

#ifndef NDEBUG
                n_col, Row,
#endif /* NDEBUG */

                Col, A, head, pivot_row_start, pivot_row_length) ;

        /* === Kill the pivotal column ====================================== */

        KILL_PRINCIPAL_COL (pivot_col) ;

        /* === Clear mark =================================================== */

        tag_mark = clear_mark (tag_mark+max_deg+1, max_mark, n_row, Row) ;

#ifndef NDEBUG
        DEBUG3 (("check3\n")) ;
        debug_mark (n_row, Row, tag_mark, max_mark) ;
#endif /* NDEBUG */

        /* === Finalize the new pivot row, and column scores ================ */

        DEBUG3 (("** Finalize scores phase. **\n")) ;

        /* for each column in pivot row */
        rp = &A [pivot_row_start] ;
        /* compact the pivot row */
        new_rp = rp ;
        rp_end = rp + pivot_row_length ;
        while (rp < rp_end)
        {
            col = *rp++ ;
            /* skip dead columns */
            if (COL_IS_DEAD (col))
            {
                continue ;
            }
            *new_rp++ = col ;
            /* add new pivot row to column */
            A [Col [col].start + (Col [col].length++)] = pivot_row ;

            /* retrieve score so far and add on pivot row's degree. */
            /* (we wait until here for this in case the pivot */
            /* row's degree was reduced due to mass elimination). */
            cur_score = Col [col].shared2.score + pivot_row_degree ;

            /* calculate the max possible score as the number of */
            /* external columns minus the 'k' value minus the */
            /* columns thickness */
            max_score = n_col - k - Col [col].shared1.thickness ;

            /* make the score the external degree of the union-of-rows */
            cur_score -= Col [col].shared1.thickness ;

            /* make sure score is less or equal than the max score */
            cur_score = MIN (cur_score, max_score) ;
            ASSERT (cur_score >= 0) ;

            /* store updated score */
            Col [col].shared2.score = cur_score ;

            /* === Place column back in degree list ========================= */

            ASSERT (min_score >= 0) ;
            ASSERT (min_score <= n_col) ;
            ASSERT (cur_score >= 0) ;
            ASSERT (cur_score <= n_col) ;
            ASSERT (head [cur_score] >= EMPTY) ;
            next_col = head [cur_score] ;
            Col [col].shared4.degree_next = next_col ;
            Col [col].shared3.prev = EMPTY ;
            if (next_col != EMPTY)
            {
                Col [next_col].shared3.prev = col ;
            }
            head [cur_score] = col ;

            /* see if this score is less than current min */
            min_score = MIN (min_score, cur_score) ;

        }

#ifndef NDEBUG
        debug_deg_lists (n_row, n_col, Row, Col, head,
                min_score, n_col2-k, max_deg) ;
#endif /* NDEBUG */

        /* === Resurrect the new pivot row ================================== */

        if (pivot_row_degree > 0)
        {
            /* update pivot row length to reflect any cols that were killed */
            /* during super-col detection and mass elimination */
            Row [pivot_row].start  = pivot_row_start ;
            Row [pivot_row].length = (Int) (new_rp - &A[pivot_row_start]) ;
            ASSERT (Row [pivot_row].length > 0) ;
            Row [pivot_row].shared1.degree = pivot_row_degree ;
            Row [pivot_row].shared2.mark = 0 ;
            /* pivot row is no longer dead */

            DEBUG1 (("Resurrect Pivot_row %d deg: %d\n",
                        pivot_row, pivot_row_degree)) ;
        }
    }

    /* === All principal columns have now been ordered ====================== */

    return (ngarbage) ;
}


/* ========================================================================== */
/* === order_children ======================================================= */
/* ========================================================================== */

/*
    The find_ordering routine has ordered all of the principal columns (the
    representatives of the supercolumns).  The non-principal columns have not
    yet been ordered.  This routine orders those columns by walking up the
    parent tree (a column is a child of the column which absorbed it).  The
    final permutation vector is then placed in p [0 ... n_col-1], with p [0]
    being the first column, and p [n_col-1] being the last.  It doesn't look
    like it at first glance, but be assured that this routine takes time linear
    in the number of columns.  Although not immediately obvious, the time
    taken by this routine is O (n_col), that is, linear in the number of
    columns.  Not user-callable.
*/

PRIVATE void order_children
(
    /* === Parameters ======================================================= */

    Int n_col,                  /* number of columns of A */
    Colamd_Col Col [],          /* of size n_col+1 */
    Int p []                    /* p [0 ... n_col-1] is the column permutation*/
)
{
    /* === Local variables ================================================== */

    Int i ;                     /* loop counter for all columns */
    Int c ;                     /* column index */
    Int parent ;                /* index of column's parent */
    Int order ;                 /* column's order */

    /* === Order each non-principal column ================================== */

    for (i = 0 ; i < n_col ; i++)
    {
        /* find an un-ordered non-principal column */
        ASSERT (COL_IS_DEAD (i)) ;
        if (!COL_IS_DEAD_PRINCIPAL (i) && Col [i].shared2.order == EMPTY)
        {
            parent = i ;
            /* once found, find its principal parent */
            do
            {
                parent = Col [parent].shared1.parent ;
            } while (!COL_IS_DEAD_PRINCIPAL (parent)) ;

            /* now, order all un-ordered non-principal columns along path */
            /* to this parent.  collapse tree at the same time */
            c = i ;
            /* get order of parent */
            order = Col [parent].shared2.order ;

            do
            {
                ASSERT (Col [c].shared2.order == EMPTY) ;

                /* order this column */
                Col [c].shared2.order = order++ ;
                /* collaps tree */
                Col [c].shared1.parent = parent ;

                /* get immediate parent of this column */
                c = Col [c].shared1.parent ;

                /* continue until we hit an ordered column.  There are */
                /* guarranteed not to be anymore unordered columns */
                /* above an ordered column */
            } while (Col [c].shared2.order == EMPTY) ;

            /* re-order the super_col parent to largest order for this group */
            Col [parent].shared2.order = order ;
        }
    }

    /* === Generate the permutation ========================================= */

    for (c = 0 ; c < n_col ; c++)
    {
        p [Col [c].shared2.order] = c ;
    }
}


/* ========================================================================== */
/* === detect_super_cols ==================================================== */
/* ========================================================================== */

/*
    Detects supercolumns by finding matches between columns in the hash buckets.
    Check amongst columns in the set A [row_start ... row_start + row_length-1].
    The columns under consideration are currently *not* in the degree lists,
    and have already been placed in the hash buckets.

    The hash bucket for columns whose hash function is equal to h is stored
    as follows:

        if head [h] is >= 0, then head [h] contains a degree list, so:

                head [h] is the first column in degree bucket h.
                Col [head [h]].headhash gives the first column in hash bucket h.

        otherwise, the degree list is empty, and:

                -(head [h] + 2) is the first column in hash bucket h.

    For a column c in a hash bucket, Col [c].shared3.prev is NOT a "previous
    column" pointer.  Col [c].shared3.hash is used instead as the hash number
    for that column.  The value of Col [c].shared4.hash_next is the next column
    in the same hash bucket.

    Assuming no, or "few" hash collisions, the time taken by this routine is
    linear in the sum of the sizes (lengths) of each column whose score has
    just been computed in the approximate degree computation.
    Not user-callable.
*/

PRIVATE void detect_super_cols
(
    /* === Parameters ======================================================= */

#ifndef NDEBUG
    /* these two parameters are only needed when debugging is enabled: */
    Int n_col,                  /* number of columns of A */
    Colamd_Row Row [],          /* of size n_row+1 */
#endif /* NDEBUG */

    Colamd_Col Col [],          /* of size n_col+1 */
    Int A [],                   /* row indices of A */
    Int head [],                /* head of degree lists and hash buckets */
    Int row_start,              /* pointer to set of columns to check */
    Int row_length              /* number of columns to check */
)
{
    /* === Local variables ================================================== */

    Int hash ;                  /* hash value for a column */
    Int *rp ;                   /* pointer to a row */
    Int c ;                     /* a column index */
    Int super_c ;               /* column index of the column to absorb into */
    Int *cp1 ;                  /* column pointer for column super_c */
    Int *cp2 ;                  /* column pointer for column c */
    Int length ;                /* length of column super_c */
    Int prev_c ;                /* column preceding c in hash bucket */
    Int i ;                     /* loop counter */
    Int *rp_end ;               /* pointer to the end of the row */
    Int col ;                   /* a column index in the row to check */
    Int head_column ;           /* first column in hash bucket or degree list */
    Int first_col ;             /* first column in hash bucket */

    /* === Consider each column in the row ================================== */

    rp = &A [row_start] ;
    rp_end = rp + row_length ;
    while (rp < rp_end)
    {
        col = *rp++ ;
        if (COL_IS_DEAD (col))
        {
            continue ;
        }

        /* get hash number for this column */
        hash = Col [col].shared3.hash ;
        ASSERT (hash <= n_col) ;

        /* === Get the first column in this hash bucket ===================== */

        head_column = head [hash] ;
        if (head_column > EMPTY)
        {
            first_col = Col [head_column].shared3.headhash ;
        }
        else
        {
            first_col = - (head_column + 2) ;
        }

        /* === Consider each column in the hash bucket ====================== */

        for (super_c = first_col ; super_c != EMPTY ;
            super_c = Col [super_c].shared4.hash_next)
        {
            ASSERT (COL_IS_ALIVE (super_c)) ;
            ASSERT (Col [super_c].shared3.hash == hash) ;
            length = Col [super_c].length ;

            /* prev_c is the column preceding column c in the hash bucket */
            prev_c = super_c ;

            /* === Compare super_c with all columns after it ================ */

            for (c = Col [super_c].shared4.hash_next ;
                 c != EMPTY ; c = Col [c].shared4.hash_next)
            {
                ASSERT (c != super_c) ;
                ASSERT (COL_IS_ALIVE (c)) ;
                ASSERT (Col [c].shared3.hash == hash) ;

                /* not identical if lengths or scores are different */
                if (Col [c].length != length ||
                    Col [c].shared2.score != Col [super_c].shared2.score)
                {
                    prev_c = c ;
                    continue ;
                }

                /* compare the two columns */
                cp1 = &A [Col [super_c].start] ;
                cp2 = &A [Col [c].start] ;

                for (i = 0 ; i < length ; i++)
                {
                    /* the columns are "clean" (no dead rows) */
                    ASSERT (ROW_IS_ALIVE (*cp1))  ;
                    ASSERT (ROW_IS_ALIVE (*cp2))  ;
                    /* row indices will same order for both supercols, */
                    /* no gather scatter nessasary */
                    if (*cp1++ != *cp2++)
                    {
                        break ;
                    }
                }

                /* the two columns are different if the for-loop "broke" */
                if (i != length)
                {
                    prev_c = c ;
                    continue ;
                }

                /* === Got it!  two columns are identical =================== */

                ASSERT (Col [c].shared2.score == Col [super_c].shared2.score) ;

                Col [super_c].shared1.thickness += Col [c].shared1.thickness ;
                Col [c].shared1.parent = super_c ;
                KILL_NON_PRINCIPAL_COL (c) ;
                /* order c later, in order_children() */
                Col [c].shared2.order = EMPTY ;
                /* remove c from hash bucket */
                Col [prev_c].shared4.hash_next = Col [c].shared4.hash_next ;
            }
        }

        /* === Empty this hash bucket ======================================= */

        if (head_column > EMPTY)
        {
            /* corresponding degree list "hash" is not empty */
            Col [head_column].shared3.headhash = EMPTY ;
        }
        else
        {
            /* corresponding degree list "hash" is empty */
            head [hash] = EMPTY ;
        }
    }
}


/* ========================================================================== */
/* === garbage_collection =================================================== */
/* ========================================================================== */

/*
    Defragments and compacts columns and rows in the workspace A.  Used when
    all avaliable memory has been used while performing row merging.  Returns
    the index of the first free position in A, after garbage collection.  The
    time taken by this routine is linear is the size of the array A, which is
    itself linear in the number of nonzeros in the input matrix.
    Not user-callable.
*/

PRIVATE Int garbage_collection  /* returns the new value of pfree */
(
    /* === Parameters ======================================================= */

    Int n_row,                  /* number of rows */
    Int n_col,                  /* number of columns */
    Colamd_Row Row [],          /* row info */
    Colamd_Col Col [],          /* column info */
    Int A [],                   /* A [0 ... Alen-1] holds the matrix */
    Int *pfree                  /* &A [0] ... pfree is in use */
)
{
    /* === Local variables ================================================== */

    Int *psrc ;                 /* source pointer */
    Int *pdest ;                /* destination pointer */
    Int j ;                     /* counter */
    Int r ;                     /* a row index */
    Int c ;                     /* a column index */
    Int length ;                /* length of a row or column */

#ifndef NDEBUG
    Int debug_rows ;
    DEBUG2 (("Defrag..\n")) ;
    for (psrc = &A[0] ; psrc < pfree ; psrc++) ASSERT (*psrc >= 0) ;
    debug_rows = 0 ;
#endif /* NDEBUG */

    /* === Defragment the columns =========================================== */

    pdest = &A[0] ;
    for (c = 0 ; c < n_col ; c++)
    {
        if (COL_IS_ALIVE (c))
        {
            psrc = &A [Col [c].start] ;

            /* move and compact the column */
            ASSERT (pdest <= psrc) ;
            Col [c].start = (Int) (pdest - &A [0]) ;
            length = Col [c].length ;
            for (j = 0 ; j < length ; j++)
            {
                r = *psrc++ ;
                if (ROW_IS_ALIVE (r))
                {
                    *pdest++ = r ;
                }
            }
            Col [c].length = (Int) (pdest - &A [Col [c].start]) ;
        }
    }

    /* === Prepare to defragment the rows =================================== */

    for (r = 0 ; r < n_row ; r++)
    {
        if (ROW_IS_DEAD (r) || (Row [r].length == 0))
        {
            /* This row is already dead, or is of zero length.  Cannot compact
             * a row of zero length, so kill it.  NOTE: in the current version,
             * there are no zero-length live rows.  Kill the row (for the first
             * time, or again) just to be safe. */
            KILL_ROW (r) ;
        }
        else
        {
            /* save first column index in Row [r].shared2.first_column */
            psrc = &A [Row [r].start] ;
            Row [r].shared2.first_column = *psrc ;
            ASSERT (ROW_IS_ALIVE (r)) ;
            /* flag the start of the row with the one's complement of row */
            *psrc = ONES_COMPLEMENT (r) ;
#ifndef NDEBUG
            debug_rows++ ;
#endif /* NDEBUG */
        }
    }

    /* === Defragment the rows ============================================== */

    psrc = pdest ;
    while (psrc < pfree)
    {
        /* find a negative number ... the start of a row */
        if (*psrc++ < 0)
        {
            psrc-- ;
            /* get the row index */
            r = ONES_COMPLEMENT (*psrc) ;
            ASSERT (r >= 0 && r < n_row) ;
            /* restore first column index */
            *psrc = Row [r].shared2.first_column ;
            ASSERT (ROW_IS_ALIVE (r)) ;
            ASSERT (Row [r].length > 0) ;
            /* move and compact the row */
            ASSERT (pdest <= psrc) ;
            Row [r].start = (Int) (pdest - &A [0]) ;
            length = Row [r].length ;
            for (j = 0 ; j < length ; j++)
            {
                c = *psrc++ ;
                if (COL_IS_ALIVE (c))
                {
                    *pdest++ = c ;
                }
            }
            Row [r].length = (Int) (pdest - &A [Row [r].start]) ;
            ASSERT (Row [r].length > 0) ;
#ifndef NDEBUG
            debug_rows-- ;
#endif /* NDEBUG */
        }
    }
    /* ensure we found all the rows */
    ASSERT (debug_rows == 0) ;

    /* === Return the new value of pfree ==================================== */

    return ((Int) (pdest - &A [0])) ;
}


/* ========================================================================== */
/* === clear_mark =========================================================== */
/* ========================================================================== */

/*
    Clears the Row [].shared2.mark array, and returns the new tag_mark.
    Return value is the new tag_mark.  Not user-callable.
*/

PRIVATE Int clear_mark  /* return the new value for tag_mark */
(
    /* === Parameters ======================================================= */

    Int tag_mark,       /* new value of tag_mark */
    Int max_mark,       /* max allowed value of tag_mark */

    Int n_row,          /* number of rows in A */
    Colamd_Row Row []   /* Row [0 ... n_row-1].shared2.mark is set to zero */
)
{
    /* === Local variables ================================================== */

    Int r ;

    if (tag_mark <= 0 || tag_mark >= max_mark)
    {
        for (r = 0 ; r < n_row ; r++)
        {
            if (ROW_IS_ALIVE (r))
            {
                Row [r].shared2.mark = 0 ;
            }
        }
        tag_mark = 1 ;
    }

    return (tag_mark) ;
}


/* ========================================================================== */
/* === print_report ========================================================= */
/* ========================================================================== */

PRIVATE void print_report
(
    char *method,
    Int stats [COLAMD_STATS]
)
{

    Int i1, i2, i3 ;

    PRINTF (("\n%s version %d.%d, %s: ", method,
            COLAMD_MAIN_VERSION, COLAMD_SUB_VERSION, COLAMD_DATE)) ;

    if (!stats)
    {
        PRINTF (("No statistics available.\n")) ;
        return ;
    }

    i1 = stats [COLAMD_INFO1] ;
    i2 = stats [COLAMD_INFO2] ;
    i3 = stats [COLAMD_INFO3] ;

    if (stats [COLAMD_STATUS] >= 0)
    {
        PRINTF (("OK.  ")) ;
    }
    else
    {
        PRINTF (("ERROR.  ")) ;
    }

    switch (stats [COLAMD_STATUS])
    {

        case COLAMD_OK_BUT_JUMBLED:

            PRINTF(("Matrix has unsorted or duplicate row indices.\n")) ;

            PRINTF(("%s: number of duplicate or out-of-order row indices: %d\n",
            method, i3)) ;

            PRINTF(("%s: last seen duplicate or out-of-order row index:   %d\n",
            method, INDEX (i2))) ;

            PRINTF(("%s: last seen in column:                             %d",
            method, INDEX (i1))) ;

            /* no break - fall through to next case instead */

        case COLAMD_OK:

            PRINTF(("\n")) ;

            PRINTF(("%s: number of dense or empty rows ignored:           %d\n",
            method, stats [COLAMD_DENSE_ROW])) ;

            PRINTF(("%s: number of dense or empty columns ignored:        %d\n",
            method, stats [COLAMD_DENSE_COL])) ;

            PRINTF(("%s: number of garbage collections performed:         %d\n",
            method, stats [COLAMD_DEFRAG_COUNT])) ;
            break ;

        case COLAMD_ERROR_A_not_present:

            PRINTF(("Array A (row indices of matrix) not present.\n")) ;
            break ;

        case COLAMD_ERROR_p_not_present:

            PRINTF(("Array p (column pointers for matrix) not present.\n")) ;
            break ;

        case COLAMD_ERROR_nrow_negative:

            PRINTF(("Invalid number of rows (%d).\n", i1)) ;
            break ;

        case COLAMD_ERROR_ncol_negative:

            PRINTF(("Invalid number of columns (%d).\n", i1)) ;
            break ;

        case COLAMD_ERROR_nnz_negative:

            PRINTF(("Invalid number of nonzero entries (%d).\n", i1)) ;
            break ;

        case COLAMD_ERROR_p0_nonzero:

            PRINTF(("Invalid column pointer, p [0] = %d, must be zero.\n", i1));
            break ;

        case COLAMD_ERROR_A_too_small:

            PRINTF(("Array A too small.\n")) ;
            PRINTF(("        Need Alen >= %d, but given only Alen = %d.\n",
            i1, i2)) ;
            break ;

        case COLAMD_ERROR_col_length_negative:

            PRINTF
            (("Column %d has a negative number of nonzero entries (%d).\n",
            INDEX (i1), i2)) ;
            break ;

        case COLAMD_ERROR_row_index_out_of_bounds:

            PRINTF
            (("Row index (row %d) out of bounds (%d to %d) in column %d.\n",
            INDEX (i2), INDEX (0), INDEX (i3-1), INDEX (i1))) ;
            break ;

        case COLAMD_ERROR_out_of_memory:

            PRINTF(("Out of memory.\n")) ;
            break ;

        /* v2.4: internal-error case deleted */
    }
}




/* ========================================================================== */
/* === colamd debugging routines ============================================ */
/* ========================================================================== */


/* ========================================================================== */
/* === debug_structures ===================================================== */
/* ========================================================================== */

/*
    At this point, all empty rows and columns are dead.  All live columns
    are "clean" (containing no dead rows) and simplicial (no supercolumns
    yet).  Rows may contain dead columns, but all live rows contain at
    least one live column.
*/

PRIVATE void debug_structures
(
    /* === Parameters ======================================================= */

    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int A [],
    Int n_col2
)
{
    /* === Local variables ================================================== */

    Int i ;
    Int c ;
    Int *cp ;
    Int *cp_end ;
    Int len ;
    Int score ;
    Int r ;
    Int *rp ;
    Int *rp_end ;
    Int deg ;

    /* === Check A, Row, and Col ============================================ */

    for (c = 0 ; c < n_col ; c++)
    {
        if (COL_IS_ALIVE (c))
        {
            len = Col [c].length ;
            score = Col [c].shared2.score ;
            DEBUG4 (("initial live col %5d %5d %5d\n", c, len, score)) ;
            ASSERT (len > 0) ;
            ASSERT (score >= 0) ;
            ASSERT (Col [c].shared1.thickness == 1) ;
            cp = &A [Col [c].start] ;
            cp_end = cp + len ;
            while (cp < cp_end)
            {
                r = *cp++ ;
                ASSERT (ROW_IS_ALIVE (r)) ;
            }
        }
        else
        {
            i = Col [c].shared2.order ;
            ASSERT (i >= n_col2 && i < n_col) ;
        }
    }

    for (r = 0 ; r < n_row ; r++)
    {
        if (ROW_IS_ALIVE (r))
        {
            i = 0 ;
            len = Row [r].length ;
            deg = Row [r].shared1.degree ;
            ASSERT (len > 0) ;
            ASSERT (deg > 0) ;
            rp = &A [Row [r].start] ;
            rp_end = rp + len ;
            while (rp < rp_end)
            {
                c = *rp++ ;
                if (COL_IS_ALIVE (c))
                {
                    i++ ;
                }
            }
            ASSERT (i > 0) ;
        }
    }
}


/* ========================================================================== */
/* === debug_deg_lists ====================================================== */
/* ========================================================================== */

/*
    Prints the contents of the degree lists.  Counts the number of columns
    in the degree list and compares it to the total it should have.  Also
    checks the row degrees.
*/

PRIVATE void debug_deg_lists
(
    /* === Parameters ======================================================= */

    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int head [],
    Int min_score,
    Int should,
    Int max_deg
)
{
    /* === Local variables ================================================== */

    Int deg ;
    Int col ;
    Int have ;
    Int row ;

    /* === Check the degree lists =========================================== */

    if (n_col > 10000 && colamd_debug <= 0)
    {
        return ;
    }
    have = 0 ;
    DEBUG4 (("Degree lists: %d\n", min_score)) ;
    for (deg = 0 ; deg <= n_col ; deg++)
    {
        col = head [deg] ;
        if (col == EMPTY)
        {
            continue ;
        }
        DEBUG4 (("%d:", deg)) ;
        while (col != EMPTY)
        {
            DEBUG4 ((" %d", col)) ;
            have += Col [col].shared1.thickness ;
            ASSERT (COL_IS_ALIVE (col)) ;
            col = Col [col].shared4.degree_next ;
        }
        DEBUG4 (("\n")) ;
    }
    DEBUG4 (("should %d have %d\n", should, have)) ;
    ASSERT (should == have) ;

    /* === Check the row degrees ============================================ */

    if (n_row > 10000 && colamd_debug <= 0)
    {
        return ;
    }
    for (row = 0 ; row < n_row ; row++)
    {
        if (ROW_IS_ALIVE (row))
        {
            ASSERT (Row [row].shared1.degree <= max_deg) ;
        }
    }
}


/* ========================================================================== */
/* === debug_mark =========================================================== */
/* ========================================================================== */

/*
    Ensures that the tag_mark is less that the maximum and also ensures that
    each entry in the mark array is less than the tag mark.
*/

PRIVATE void debug_mark
(
    /* === Parameters ======================================================= */

    Int n_row,
    Colamd_Row Row [],
    Int tag_mark,
    Int max_mark
)
{
    /* === Local variables ================================================== */

    Int r ;

    /* === Check the Row marks ============================================== */

    ASSERT (tag_mark > 0 && tag_mark <= max_mark) ;
    if (n_row > 10000 && colamd_debug <= 0)
    {
        return ;
    }
    for (r = 0 ; r < n_row ; r++)
    {
        ASSERT (Row [r].shared2.mark < tag_mark) ;
    }
}


/* ========================================================================== */
/* === debug_matrix ========================================================= */
/* ========================================================================== */

/*
    Prints out the contents of the columns and the rows.
*/

PRIVATE void debug_matrix
(
    /* === Parameters ======================================================= */

    Int n_row,
    Int n_col,
    Colamd_Row Row [],
    Colamd_Col Col [],
    Int A []
)
{
    /* === Local variables ================================================== */

    Int r ;
    Int c ;
    Int *rp ;
    Int *rp_end ;
    Int *cp ;
    Int *cp_end ;

    /* === Dump the rows and columns of the matrix ========================== */

    if (colamd_debug < 3)
    {
        return ;
    }
    DEBUG3 (("DUMP MATRIX:\n")) ;
    for (r = 0 ; r < n_row ; r++)
    {
        DEBUG3 (("Row %d alive? %d\n", r, ROW_IS_ALIVE (r))) ;
        if (ROW_IS_DEAD (r))
        {
            continue ;
        }
        DEBUG3 (("start %d length %d degree %d\n",
                Row [r].start, Row [r].length, Row [r].shared1.degree)) ;
        rp = &A [Row [r].start] ;
        rp_end = rp + Row [r].length ;
        while (rp < rp_end)
        {
            c = *rp++ ;
            DEBUG4 (("  %d col %d\n", COL_IS_ALIVE (c), c)) ;
        }
    }

    for (c = 0 ; c < n_col ; c++)
    {
        DEBUG3 (("Col %d alive? %d\n", c, COL_IS_ALIVE (c))) ;
        if (COL_IS_DEAD (c))
        {
            continue ;
        }
        DEBUG3 (("start %d length %d shared1 %d shared2 %d\n",
                Col [c].start, Col [c].length,
                Col [c].shared1.thickness, Col [c].shared2.score)) ;
        cp = &A [Col [c].start] ;
        cp_end = cp + Col [c].length ;
        while (cp < cp_end)
        {
            r = *cp++ ;
            DEBUG4 (("  %d row %d\n", ROW_IS_ALIVE (r), r)) ;
        }
    }
}

PRIVATE void colamd_get_debug
(
    char *method
)
{
    FILE *f ;
    colamd_debug = 0 ;          /* no debug printing */
    f = fopen ("debug", "r") ;
    if (f == (FILE *) NULL)
    {
        colamd_debug = 0 ;
    }
    else
    {
        fscanf (f, "%d", &colamd_debug) ;
        fclose (f) ;
    }
    DEBUG0 (("%s: debug version, D = %d (THIS WILL BE SLOW!)\n",
        method, colamd_debug)) ;
}


#define amd_order _glp_amd_order
int amd_order(int n, const int Ap[], const int Ai[], int P[],
      double Control[], double Info[]);

#define amd_2 _glp_amd_2
void amd_2(int n, int Pe[], int Iw[], int Len[], int iwlen, int pfree,
      int Nv[], int Next[], int Last[], int Head[], int Elen[],
      int Degree[], int W[], double Control[], double Info[]);

#define amd_valid _glp_amd_valid
int amd_valid(int n_row, int n_col, const int Ap[], const int Ai[]);

#define amd_defaults _glp_amd_defaults
void amd_defaults(double Control[]);

#define amd_control _glp_amd_control
void amd_control(double Control[]);

#define amd_info _glp_amd_info
void amd_info(double Info[]);


/* AMD will be exceedingly slow when running in debug mode. */
#if 1
#define NDEBUG
#endif

#define _GLPSTD_STDIO

#define Int int
#define ID "%d"
#define Int_MAX INT_MAX

#if 0 /* 15/II-2012 */
/* now this macro is defined in glpenv.h; besides, the definiton below
   depends on implementation, because size_t is an unsigned type */
#define SIZE_T_MAX ((size_t)(-1))
#endif

#define EMPTY (-1)
#define FLIP(i) (-(i)-2)
#define UNFLIP(i) ((i < EMPTY) ? FLIP (i) : (i))

#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#define MIN(a,b) (((a) < (b)) ? (a) : (b))

#define IMPLIES(p, q) (!(p) || (q))

#define GLOBAL

#define AMD_order amd_order
#define AMD_defaults amd_defaults
#define AMD_control amd_control
#define AMD_info amd_info
#define AMD_1 amd_1
#define AMD_2 amd_2
#define AMD_valid amd_valid
#define AMD_aat amd_aat
#define AMD_postorder amd_postorder
#define AMD_post_tree amd_post_tree
#define AMD_dump amd_dump
#define AMD_debug amd_debug
#define AMD_debug_init amd_debug_init
#define AMD_preprocess amd_preprocess

#define amd_malloc xmalloc
#if 0 /* 24/V-2009 */
#define amd_free xfree
#else
#define amd_free(ptr) { if ((ptr) != NULL) xfree(ptr); }
#endif
#define amd_printf xprintf

#define PRINTF(params) { amd_printf params; }

#ifndef NDEBUG
#define ASSERT(expr) xassert(expr)
#define AMD_DEBUG0(params) { PRINTF(params); }
#define AMD_DEBUG1(params) { if (AMD_debug >= 1) PRINTF(params); }
#define AMD_DEBUG2(params) { if (AMD_debug >= 2) PRINTF(params); }
#define AMD_DEBUG3(params) { if (AMD_debug >= 3) PRINTF(params); }
#define AMD_DEBUG4(params) { if (AMD_debug >= 4) PRINTF(params); }
#else
#define ASSERT(expression)
#define AMD_DEBUG0(params)
#define AMD_DEBUG1(params)
#define AMD_DEBUG2(params)
#define AMD_DEBUG3(params)
#define AMD_DEBUG4(params)
#endif

#define amd_aat _glp_amd_aat
size_t AMD_aat(Int n, const Int Ap[], const Int Ai[], Int Len[],
      Int Tp[], double Info[]);

#define amd_1 _glp_amd_1
void AMD_1(Int n, const Int Ap[], const Int Ai[], Int P[], Int Pinv[],
      Int Len[], Int slen, Int S[], double Control[], double Info[]);

#define amd_postorder _glp_amd_postorder
void AMD_postorder(Int nn, Int Parent[], Int Npiv[], Int Fsize[],
      Int Order[], Int Child[], Int Sibling[], Int Stack[]);

#define amd_post_tree _glp_amd_post_tree
#ifndef NDEBUG
Int AMD_post_tree(Int root, Int k, Int Child[], const Int Sibling[],
      Int Order[], Int Stack[], Int nn);
#else
Int AMD_post_tree(Int root, Int k, Int Child[], const Int Sibling[],
      Int Order[], Int Stack[]);
#endif

#define amd_preprocess _glp_amd_preprocess
void AMD_preprocess(Int n, const Int Ap[], const Int Ai[], Int Rp[],
      Int Ri[], Int W[], Int Flag[]);

#define amd_debug _glp_amd_debug
extern Int AMD_debug;

#define amd_debug_init _glp_amd_debug_init
void AMD_debug_init(char *s);

#define amd_dump _glp_amd_dump
void AMD_dump(Int n, Int Pe[], Int Iw[], Int Len[], Int iwlen,
      Int pfree, Int Nv[], Int Next[], Int Last[], Int Head[],
      Int Elen[], Int Degree[], Int W[], Int nel);


GLOBAL void AMD_defaults
(
    double Control [ ]
)
{
    Int i ;

    if (Control != (double *) NULL)
    {
        for (i = 0 ; i < AMD_CONTROL ; i++)
        {
            Control [i] = 0 ;
        }
        Control [AMD_DENSE] = AMD_DEFAULT_DENSE ;
        Control [AMD_AGGRESSIVE] = AMD_DEFAULT_AGGRESSIVE ;
    }
}

/***********************************************************************
*  FULL-VECTOR STORAGE
*
*  For a sparse vector x having n elements, ne of which are non-zero,
*  the full-vector storage format uses two arrays x_ind and x_vec, which
*  are set up as follows:
*
*  x_ind is an integer array of length [1+ne]. Location x_ind[0] is
*  not used, and locations x_ind[1], ..., x_ind[ne] contain indices of
*  non-zero elements in vector x.
*
*  x_vec is a floating-point array of length [1+n]. Location x_vec[0]
*  is not used, and locations x_vec[1], ..., x_vec[n] contain numeric
*  values of ALL elements in vector x, including its zero elements.
*
*  Let, for example, the following sparse vector x be given:
*
*     (0, 1, 0, 0, 2, 3, 0, 4)
*
*  Then the arrays are:
*
*     x_ind = { X; 2, 5, 6, 8 }
*
*     x_vec = { X; 0, 1, 0, 0, 2, 3, 0, 4 }
*
*  COMPRESSED-VECTOR STORAGE
*
*  For a sparse vector x having n elements, ne of which are non-zero,
*  the compressed-vector storage format uses two arrays x_ind and x_vec,
*  which are set up as follows:
*
*  x_ind is an integer array of length [1+ne]. Location x_ind[0] is
*  not used, and locations x_ind[1], ..., x_ind[ne] contain indices of
*  non-zero elements in vector x.
*
*  x_vec is a floating-point array of length [1+ne]. Location x_vec[0]
*  is not used, and locations x_vec[1], ..., x_vec[ne] contain numeric
*  values of corresponding non-zero elements in vector x.
*
*  Let, for example, the following sparse vector x be given:
*
*     (0, 1, 0, 0, 2, 3, 0, 4)
*
*  Then the arrays are:
*
*     x_ind = { X; 2, 5, 6, 8 }
*
*     x_vec = { X; 1, 2, 3, 4 }
*
*  STORAGE-BY-ROWS
*
*  For a sparse matrix A, which has m rows, n columns, and ne non-zero
*  elements the storage-by-rows format uses three arrays A_ptr, A_ind,
*  and A_val, which are set up as follows:
*
*  A_ptr is an integer array of length [1+m+1] also called "row pointer
*  array". It contains the relative starting positions of each row of A
*  in the arrays A_ind and A_val, i.e. element A_ptr[i], 1 <= i <= m,
*  indicates where row i begins in the arrays A_ind and A_val. If all
*  elements in row i are zero, then A_ptr[i] = A_ptr[i+1]. Location
*  A_ptr[0] is not used, location A_ptr[1] must contain 1, and location
*  A_ptr[m+1] must contain ne+1 that indicates the position after the
*  last element in the arrays A_ind and A_val.
*
*  A_ind is an integer array of length [1+ne]. Location A_ind[0] is not
*  used, and locations A_ind[1], ..., A_ind[ne] contain column indices
*  of (non-zero) elements in matrix A.
*
*  A_val is a floating-point array of length [1+ne]. Location A_val[0]
*  is not used, and locations A_val[1], ..., A_val[ne] contain numeric
*  values of non-zero elements in matrix A.
*
*  Non-zero elements of matrix A are stored contiguously, and the rows
*  of matrix A are stored consecutively from 1 to m in the arrays A_ind
*  and A_val. The elements in each row of A may be stored in any order
*  in A_ind and A_val. Note that elements with duplicate column indices
*  are not allowed.
*
*  Let, for example, the following sparse matrix A be given:
*
*     | 11  . 13  .  .  . |
*     | 21 22  . 24  .  . |
*     |  . 32 33  .  .  . |
*     |  .  . 43 44  . 46 |
*     |  .  .  .  .  .  . |
*     | 61 62  .  .  . 66 |
*
*  Then the arrays are:
*
*     A_ptr = { X; 1, 3, 6, 8, 11, 11; 14 }
*
*     A_ind = { X;  1,  3;  4,  2,  1;  2,  3;  4,  3,  6;  1,  2,  6 }
*
*     A_val = { X; 11, 13; 24, 22, 21; 32, 33; 44, 43, 46; 61, 62, 66 }
*
*  PERMUTATION MATRICES
*
*  Let P be a permutation matrix of the order n. It is represented as
*  an integer array P_per of length [1+n+n] as follows: if p[i,j] = 1,
*  then P_per[i] = j and P_per[n+j] = i. Location P_per[0] is not used.
*
*  Let A' = P*A. If i-th row of A corresponds to i'-th row of A', then
*  P_per[i'] = i and P_per[n+i] = i'.
*
*  References:
*
*  1. Gustavson F.G. Some basic techniques for solving sparse systems of
*     linear equations. In Rose and Willoughby (1972), pp. 41-52.
*
*  2. Basic Linear Algebra Subprograms Technical (BLAST) Forum Standard.
*     University of Tennessee (2001). */

#define check_fvs _glp_mat_check_fvs
int check_fvs(int n, int nnz, int ind[], double vec[]);
/* check sparse vector in full-vector storage format */

#define check_pattern _glp_mat_check_pattern
int check_pattern(int m, int n, int A_ptr[], int A_ind[]);
/* check pattern of sparse matrix */

#define transpose _glp_mat_transpose
void transpose(int m, int n, int A_ptr[], int A_ind[], double A_val[],
      int AT_ptr[], int AT_ind[], double AT_val[]);
/* transpose sparse matrix */

#define adat_symbolic _glp_mat_adat_symbolic
int *adat_symbolic(int m, int n, int P_per[], int A_ptr[], int A_ind[],
      int S_ptr[]);
/* compute S = P*A*D*A'*P' (symbolic phase) */

#define adat_numeric _glp_mat_adat_numeric
void adat_numeric(int m, int n, int P_per[],
      int A_ptr[], int A_ind[], double A_val[], double D_diag[],
      int S_ptr[], int S_ind[], double S_val[], double S_diag[]);
/* compute S = P*A*D*A'*P' (numeric phase) */

#define min_degree _glp_mat_min_degree
void min_degree(int n, int A_ptr[], int A_ind[], int P_per[]);
/* minimum degree ordering */

#define amd_order1 _glp_mat_amd_order1
void amd_order1(int n, int A_ptr[], int A_ind[], int P_per[]);
/* approximate minimum degree ordering (AMD) */

#define symamd_ord _glp_mat_symamd_ord
void symamd_ord(int n, int A_ptr[], int A_ind[], int P_per[]);
/* approximate minimum degree ordering (SYMAMD) */

#define chol_symbolic _glp_mat_chol_symbolic
int *chol_symbolic(int n, int A_ptr[], int A_ind[], int U_ptr[]);
/* compute Cholesky factorization (symbolic phase) */

#define chol_numeric _glp_mat_chol_numeric
int chol_numeric(int n,
      int A_ptr[], int A_ind[], double A_val[], double A_diag[],
      int U_ptr[], int U_ind[], double U_val[], double U_diag[]);
/* compute Cholesky factorization (numeric phase) */

#define u_solve _glp_mat_u_solve
void u_solve(int n, int U_ptr[], int U_ind[], double U_val[],
      double U_diag[], double x[]);
/* solve upper triangular system U*x = b */

#define ut_solve _glp_mat_ut_solve
void ut_solve(int n, int U_ptr[], int U_ind[], double U_val[],
      double U_diag[], double x[]);
/* solve lower triangular system U'*x = b */


/*----------------------------------------------------------------------
-- check_fvs - check sparse vector in full-vector storage format.
--
-- SYNOPSIS
--
-- #include "glpmat.h"
-- int check_fvs(int n, int nnz, int ind[], double vec[]);
--
-- DESCRIPTION
--
-- The routine check_fvs checks if a given vector of dimension n in
-- full-vector storage format has correct representation.
--
-- RETURNS
--
-- The routine returns one of the following codes:
--
-- 0 - the vector is correct;
-- 1 - the number of elements (n) is negative;
-- 2 - the number of non-zero elements (nnz) is negative;
-- 3 - some element index is out of range;
-- 4 - some element index is duplicate;
-- 5 - some non-zero element is out of pattern. */

int check_fvs(int n, int nnz, int ind[], double vec[])
{     int i, t, ret, *flag = NULL;
      /* check the number of elements */
      if (n < 0)
      {  ret = 1;
         goto done;
      }
      /* check the number of non-zero elements */
      if (nnz < 0)
      {  ret = 2;
         goto done;
      }
      /* check vector indices */
      flag = xcalloc(1+n, sizeof(int));
      for (i = 1; i <= n; i++) flag[i] = 0;
      for (t = 1; t <= nnz; t++)
      {  i = ind[t];
         if (!(1 <= i && i <= n))
         {  ret = 3;
            goto done;
         }
         if (flag[i])
         {  ret = 4;
            goto done;
         }
         flag[i] = 1;
      }
      /* check vector elements */
      for (i = 1; i <= n; i++)
      {  if (!flag[i] && vec[i] != 0.0)
         {  ret = 5;
            goto done;
         }
      }
      /* the vector is ok */
      ret = 0;
done: if (flag != NULL) xfree(flag);
      return ret;
}

/*----------------------------------------------------------------------
-- check_pattern - check pattern of sparse matrix.
--
-- SYNOPSIS
--
-- #include "glpmat.h"
-- int check_pattern(int m, int n, int A_ptr[], int A_ind[]);
--
-- DESCRIPTION
--
-- The routine check_pattern checks the pattern of a given mxn matrix
-- in storage-by-rows format.
--
-- RETURNS
--
-- The routine returns one of the following codes:
--
-- 0 - the pattern is correct;
-- 1 - the number of rows (m) is negative;
-- 2 - the number of columns (n) is negative;
-- 3 - A_ptr[1] is not 1;
-- 4 - some column index is out of range;
-- 5 - some column indices are duplicate. */

int check_pattern(int m, int n, int A_ptr[], int A_ind[])
{     int i, j, ptr, ret, *flag = NULL;
      /* check the number of rows */
      if (m < 0)
      {  ret = 1;
         goto done;
      }
      /* check the number of columns */
      if (n < 0)
      {  ret = 2;
         goto done;
      }
      /* check location A_ptr[1] */
      if (A_ptr[1] != 1)
      {  ret = 3;
         goto done;
      }
      /* check row patterns */
      flag = xcalloc(1+n, sizeof(int));
      for (j = 1; j <= n; j++) flag[j] = 0;
      for (i = 1; i <= m; i++)
      {  /* check pattern of row i */
         for (ptr = A_ptr[i]; ptr < A_ptr[i+1]; ptr++)
         {  j = A_ind[ptr];
            /* check column index */
            if (!(1 <= j && j <= n))
            {  ret = 4;
               goto done;
            }
            /* check for duplication */
            if (flag[j])
            {  ret = 5;
               goto done;
            }
            flag[j] = 1;
         }
         /* clear flags */
         for (ptr = A_ptr[i]; ptr < A_ptr[i+1]; ptr++)
         {  j = A_ind[ptr];
            flag[j] = 0;
         }
      }
      /* the pattern is ok */
      ret = 0;
done: if (flag != NULL) xfree(flag);
      return ret;
}

/*----------------------------------------------------------------------
-- transpose - transpose sparse matrix.
--
-- *Synopsis*
--
-- #include "glpmat.h"
-- void transpose(int m, int n, int A_ptr[], int A_ind[],
--    double A_val[], int AT_ptr[], int AT_ind[], double AT_val[]);
--
-- *Description*
--
-- For a given mxn sparse matrix A the routine transpose builds a nxm
-- sparse matrix A' which is a matrix transposed to A.
--
-- The arrays A_ptr, A_ind, and A_val specify a given mxn matrix A to
-- be transposed in storage-by-rows format. The parameter A_val can be
-- NULL, in which case numeric values are not copied. The arrays A_ptr,
-- A_ind, and A_val are not changed on exit.
--
-- On entry the arrays AT_ptr, AT_ind, and AT_val must be allocated,
-- but their content is ignored. On exit the routine stores a resultant
-- nxm matrix A' in these arrays in storage-by-rows format. Note that
-- if the parameter A_val is NULL, the array AT_val is not used.
--
-- The routine transpose has a side effect that elements in rows of the
-- resultant matrix A' follow in ascending their column indices. */

void transpose(int m, int n, int A_ptr[], int A_ind[], double A_val[],
      int AT_ptr[], int AT_ind[], double AT_val[])
{     int i, j, t, beg, end, pos, len;
      /* determine row lengths of resultant matrix */
      for (j = 1; j <= n; j++) AT_ptr[j] = 0;
      for (i = 1; i <= m; i++)
      {  beg = A_ptr[i], end = A_ptr[i+1];
         for (t = beg; t < end; t++) AT_ptr[A_ind[t]]++;
      }
      /* set up row pointers of resultant matrix */
      pos = 1;
      for (j = 1; j <= n; j++)
         len = AT_ptr[j], pos += len, AT_ptr[j] = pos;
      AT_ptr[n+1] = pos;
      /* build resultant matrix */
      for (i = m; i >= 1; i--)
      {  beg = A_ptr[i], end = A_ptr[i+1];
         for (t = beg; t < end; t++)
         {  pos = --AT_ptr[A_ind[t]];
            AT_ind[pos] = i;
            if (A_val != NULL) AT_val[pos] = A_val[t];
         }
      }
      return;
}

/*----------------------------------------------------------------------
-- adat_symbolic - compute S = P*A*D*A'*P' (symbolic phase).
--
-- *Synopsis*
--
-- #include "glpmat.h"
-- int *adat_symbolic(int m, int n, int P_per[], int A_ptr[],
--    int A_ind[], int S_ptr[]);
--
-- *Description*
--
-- The routine adat_symbolic implements the symbolic phase to compute
-- symmetric matrix S = P*A*D*A'*P', where P is a permutation matrix,
-- A is a given sparse matrix, D is a diagonal matrix, A' is a matrix
-- transposed to A, P' is an inverse of P.
--
-- The parameter m is the number of rows in A and the order of P.
--
-- The parameter n is the number of columns in A and the order of D.
--
-- The array P_per specifies permutation matrix P. It is not changed on
-- exit.
--
-- The arrays A_ptr and A_ind specify the pattern of matrix A. They are
-- not changed on exit.
--
-- On exit the routine stores the pattern of upper triangular part of
-- matrix S without diagonal elements in the arrays S_ptr and S_ind in
-- storage-by-rows format. The array S_ptr should be allocated on entry,
-- however, its content is ignored. The array S_ind is allocated by the
-- routine itself which returns a pointer to it.
--
-- *Returns*
--
-- The routine returns a pointer to the array S_ind. */

int *adat_symbolic(int m, int n, int P_per[], int A_ptr[], int A_ind[],
      int S_ptr[])
{     int i, j, t, ii, jj, tt, k, size, len;
      int *S_ind, *AT_ptr, *AT_ind, *ind, *map, *temp;
      /* build the pattern of A', which is a matrix transposed to A, to
         efficiently access A in column-wise manner */
      AT_ptr = xcalloc(1+n+1, sizeof(int));
      AT_ind = xcalloc(A_ptr[m+1], sizeof(int));
      transpose(m, n, A_ptr, A_ind, NULL, AT_ptr, AT_ind, NULL);
      /* allocate the array S_ind */
      size = A_ptr[m+1] - 1;
      if (size < m) size = m;
      S_ind = xcalloc(1+size, sizeof(int));
      /* allocate and initialize working arrays */
      ind = xcalloc(1+m, sizeof(int));
      map = xcalloc(1+m, sizeof(int));
      for (jj = 1; jj <= m; jj++) map[jj] = 0;
      /* compute pattern of S; note that symbolically S = B*B', where
         B = P*A, B' is matrix transposed to B */
      S_ptr[1] = 1;
      for (ii = 1; ii <= m; ii++)
      {  /* compute pattern of ii-th row of S */
         len = 0;
         i = P_per[ii]; /* i-th row of A = ii-th row of B */
         for (t = A_ptr[i]; t < A_ptr[i+1]; t++)
         {  k = A_ind[t];
            /* walk through k-th column of A */
            for (tt = AT_ptr[k]; tt < AT_ptr[k+1]; tt++)
            {  j = AT_ind[tt];
               jj = P_per[m+j]; /* j-th row of A = jj-th row of B */
               /* a[i,k] != 0 and a[j,k] != 0 ergo s[ii,jj] != 0 */
               if (ii < jj && !map[jj]) ind[++len] = jj, map[jj] = 1;
            }
         }
         /* now (ind) is pattern of ii-th row of S */
         S_ptr[ii+1] = S_ptr[ii] + len;
         /* at least (S_ptr[ii+1] - 1) locations should be available in
            the array S_ind */
         if (S_ptr[ii+1] - 1 > size)
         {  temp = S_ind;
            size += size;
            S_ind = xcalloc(1+size, sizeof(int));
            memcpy(&S_ind[1], &temp[1], (S_ptr[ii] - 1) * sizeof(int));
            xfree(temp);
         }
         xassert(S_ptr[ii+1] - 1 <= size);
         /* (ii-th row of S) := (ind) */
         memcpy(&S_ind[S_ptr[ii]], &ind[1], len * sizeof(int));
         /* clear the row pattern map */
         for (t = 1; t <= len; t++) map[ind[t]] = 0;
      }
      /* free working arrays */
      xfree(AT_ptr);
      xfree(AT_ind);
      xfree(ind);
      xfree(map);
      /* reallocate the array S_ind to free unused locations */
      temp = S_ind;
      size = S_ptr[m+1] - 1;
      S_ind = xcalloc(1+size, sizeof(int));
      memcpy(&S_ind[1], &temp[1], size * sizeof(int));
      xfree(temp);
      return S_ind;
}

/*----------------------------------------------------------------------
-- adat_numeric - compute S = P*A*D*A'*P' (numeric phase).
--
-- *Synopsis*
--
-- #include "glpmat.h"
-- void adat_numeric(int m, int n, int P_per[],
--    int A_ptr[], int A_ind[], double A_val[], double D_diag[],
--    int S_ptr[], int S_ind[], double S_val[], double S_diag[]);
--
-- *Description*
--
-- The routine adat_numeric implements the numeric phase to compute
-- symmetric matrix S = P*A*D*A'*P', where P is a permutation matrix,
-- A is a given sparse matrix, D is a diagonal matrix, A' is a matrix
-- transposed to A, P' is an inverse of P.
--
-- The parameter m is the number of rows in A and the order of P.
--
-- The parameter n is the number of columns in A and the order of D.
--
-- The matrix P is specified in the array P_per, which is not changed
-- on exit.
--
-- The matrix A is specified in the arrays A_ptr, A_ind, and A_val in
-- storage-by-rows format. These arrays are not changed on exit.
--
-- Diagonal elements of the matrix D are specified in the array D_diag,
-- where D_diag[0] is not used, D_diag[i] = d[i,i] for i = 1, ..., n.
-- The array D_diag is not changed on exit.
--
-- The pattern of the upper triangular part of the matrix S without
-- diagonal elements (previously computed by the routine adat_symbolic)
-- is specified in the arrays S_ptr and S_ind, which are not changed on
-- exit. Numeric values of non-diagonal elements of S are stored in
-- corresponding locations of the array S_val, and values of diagonal
-- elements of S are stored in locations S_diag[1], ..., S_diag[n]. */

void adat_numeric(int m, int n, int P_per[],
      int A_ptr[], int A_ind[], double A_val[], double D_diag[],
      int S_ptr[], int S_ind[], double S_val[], double S_diag[])
{     int i, j, t, ii, jj, tt, beg, end, beg1, end1, k;
      double sum, *work;
      work = xcalloc(1+n, sizeof(double));
      for (j = 1; j <= n; j++) work[j] = 0.0;
      /* compute S = B*D*B', where B = P*A, B' is a matrix transposed
         to B */
      for (ii = 1; ii <= m; ii++)
      {  i = P_per[ii]; /* i-th row of A = ii-th row of B */
         /* (work) := (i-th row of A) */
         beg = A_ptr[i], end = A_ptr[i+1];
         for (t = beg; t < end; t++)
            work[A_ind[t]] = A_val[t];
         /* compute ii-th row of S */
         beg = S_ptr[ii], end = S_ptr[ii+1];
         for (t = beg; t < end; t++)
         {  jj = S_ind[t];
            j = P_per[jj]; /* j-th row of A = jj-th row of B */
            /* s[ii,jj] := sum a[i,k] * d[k,k] * a[j,k] */
            sum = 0.0;
            beg1 = A_ptr[j], end1 = A_ptr[j+1];
            for (tt = beg1; tt < end1; tt++)
            {  k = A_ind[tt];
               sum += work[k] * D_diag[k] * A_val[tt];
            }
            S_val[t] = sum;
         }
         /* s[ii,ii] := sum a[i,k] * d[k,k] * a[i,k] */
         sum = 0.0;
         beg = A_ptr[i], end = A_ptr[i+1];
         for (t = beg; t < end; t++)
         {  k = A_ind[t];
            sum += A_val[t] * D_diag[k] * A_val[t];
            work[k] = 0.0;
         }
         S_diag[ii] = sum;
      }
      xfree(work);
      return;
}

/*----------------------------------------------------------------------
-- min_degree - minimum degree ordering.
--
-- *Synopsis*
--
-- #include "glpmat.h"
-- void min_degree(int n, int A_ptr[], int A_ind[], int P_per[]);
--
-- *Description*
--
-- The routine min_degree uses the minimum degree ordering algorithm
-- to find a permutation matrix P for a given sparse symmetric positive
-- matrix A which minimizes the number of non-zeros in upper triangular
-- factor U for Cholesky factorization P*A*P' = U'*U.
--
-- The parameter n is the order of matrices A and P.
--
-- The pattern of the given matrix A is specified on entry in the arrays
-- A_ptr and A_ind in storage-by-rows format. Only the upper triangular
-- part without diagonal elements (which all are assumed to be non-zero)
-- should be specified as if A were upper triangular. The arrays A_ptr
-- and A_ind are not changed on exit.
--
-- The permutation matrix P is stored by the routine in the array P_per
-- on exit.
--
-- *Algorithm*
--
-- The routine min_degree is based on some subroutines from the package
-- SPARSPAK (see comments in the module glpqmd). */
#define genqmd _glp_genqmd
void genqmd(int *neqns, int xadj[], int adjncy[], int perm[],
      int invp[], int deg[], int marker[], int rchset[], int nbrhd[],
      int qsize[], int qlink[], int *nofsub);
/* GENeral Quotient Minimum Degree algorithm */


void min_degree(int n, int A_ptr[], int A_ind[], int P_per[])
{     int i, j, ne, t, pos, len;
      int *xadj, *adjncy, *deg, *marker, *rchset, *nbrhd, *qsize,
         *qlink, nofsub;
      /* determine number of non-zeros in complete pattern */
      ne = A_ptr[n+1] - 1;
      ne += ne;
      /* allocate working arrays */
      xadj = xcalloc(1+n+1, sizeof(int));
      adjncy = xcalloc(1+ne, sizeof(int));
      deg = xcalloc(1+n, sizeof(int));
      marker = xcalloc(1+n, sizeof(int));
      rchset = xcalloc(1+n, sizeof(int));
      nbrhd = xcalloc(1+n, sizeof(int));
      qsize = xcalloc(1+n, sizeof(int));
      qlink = xcalloc(1+n, sizeof(int));
      /* determine row lengths in complete pattern */
      for (i = 1; i <= n; i++) xadj[i] = 0;
      for (i = 1; i <= n; i++)
      {  for (t = A_ptr[i]; t < A_ptr[i+1]; t++)
         {  j = A_ind[t];
            xassert(i < j && j <= n);
            xadj[i]++, xadj[j]++;
         }
      }
      /* set up row pointers for complete pattern */
      pos = 1;
      for (i = 1; i <= n; i++)
         len = xadj[i], pos += len, xadj[i] = pos;
      xadj[n+1] = pos;
      xassert(pos - 1 == ne);
      /* construct complete pattern */
      for (i = 1; i <= n; i++)
      {  for (t = A_ptr[i]; t < A_ptr[i+1]; t++)
         {  j = A_ind[t];
            adjncy[--xadj[i]] = j, adjncy[--xadj[j]] = i;
         }
      }
      /* call the main minimimum degree ordering routine */
      genqmd(&n, xadj, adjncy, P_per, P_per + n, deg, marker, rchset,
         nbrhd, qsize, qlink, &nofsub);
      /* make sure that permutation matrix P is correct */
      for (i = 1; i <= n; i++)
      {  j = P_per[i];
         xassert(1 <= j && j <= n);
         xassert(P_per[n+j] == i);
      }
      /* free working arrays */
      xfree(xadj);
      xfree(adjncy);
      xfree(deg);
      xfree(marker);
      xfree(rchset);
      xfree(nbrhd);
      xfree(qsize);
      xfree(qlink);
      return;
}

/**********************************************************************/

void amd_order1(int n, int A_ptr[], int A_ind[], int P_per[])
{     /* approximate minimum degree ordering (AMD) */
      int k, ret;
      double Control[AMD_CONTROL], Info[AMD_INFO];
      /* get the default parameters */
      amd_defaults(Control);
#if 0
      /* and print them */
      amd_control(Control);
#endif
      /* make all indices 0-based */
      for (k = 1; k < A_ptr[n+1]; k++) A_ind[k]--;
      for (k = 1; k <= n+1; k++) A_ptr[k]--;
      /* call the ordering routine */
      ret = amd_order(n, &A_ptr[1], &A_ind[1], &P_per[1], Control, Info)
         ;
#if 0
      amd_info(Info);
#endif
      xassert(ret == AMD_OK || ret == AMD_OK_BUT_JUMBLED);
      /* retsore 1-based indices */
      for (k = 1; k <= n+1; k++) A_ptr[k]++;
      for (k = 1; k < A_ptr[n+1]; k++) A_ind[k]++;
      /* patch up permutation matrix */
      memset(&P_per[n+1], 0, n * sizeof(int));
      for (k = 1; k <= n; k++)
      {  P_per[k]++;
         xassert(1 <= P_per[k] && P_per[k] <= n);
         xassert(P_per[n+P_per[k]] == 0);
         P_per[n+P_per[k]] = k;
      }
      return;
}

/**********************************************************************/

static void *allocate(size_t n, size_t size)
{     void *ptr;
      ptr = xcalloc(n, size);
      memset(ptr, 0, n * size);
      return ptr;
}

static void release(void *ptr)
{     xfree(ptr);
      return;
}

void symamd_ord(int n, int A_ptr[], int A_ind[], int P_per[])
{     /* approximate minimum degree ordering (SYMAMD) */
      int k, ok;
      int stats[COLAMD_STATS];
      /* make all indices 0-based */
      for (k = 1; k < A_ptr[n+1]; k++) A_ind[k]--;
      for (k = 1; k <= n+1; k++) A_ptr[k]--;
      /* call the ordering routine */
      ok = symamd(n, &A_ind[1], &A_ptr[1], &P_per[1], NULL, stats,
         allocate, release);
#if 0
      symamd_report(stats);
#endif
      xassert(ok);
      /* restore 1-based indices */
      for (k = 1; k <= n+1; k++) A_ptr[k]++;
      for (k = 1; k < A_ptr[n+1]; k++) A_ind[k]++;
      /* patch up permutation matrix */
      memset(&P_per[n+1], 0, n * sizeof(int));
      for (k = 1; k <= n; k++)
      {  P_per[k]++;
         xassert(1 <= P_per[k] && P_per[k] <= n);
         xassert(P_per[n+P_per[k]] == 0);
         P_per[n+P_per[k]] = k;
      }
      return;
}

/*----------------------------------------------------------------------
-- chol_symbolic - compute Cholesky factorization (symbolic phase).
--
-- *Synopsis*
--
-- #include "glpmat.h"
-- int *chol_symbolic(int n, int A_ptr[], int A_ind[], int U_ptr[]);
--
-- *Description*
--
-- The routine chol_symbolic implements the symbolic phase of Cholesky
-- factorization A = U'*U, where A is a given sparse symmetric positive
-- definite matrix, U is a resultant upper triangular factor, U' is a
-- matrix transposed to U.
--
-- The parameter n is the order of matrices A and U.
--
-- The pattern of the given matrix A is specified on entry in the arrays
-- A_ptr and A_ind in storage-by-rows format. Only the upper triangular
-- part without diagonal elements (which all are assumed to be non-zero)
-- should be specified as if A were upper triangular. The arrays A_ptr
-- and A_ind are not changed on exit.
--
-- The pattern of the matrix U without diagonal elements (which all are
-- assumed to be non-zero) is stored on exit from the routine in the
-- arrays U_ptr and U_ind in storage-by-rows format. The array U_ptr
-- should be allocated on entry, however, its content is ignored. The
-- array U_ind is allocated by the routine which returns a pointer to it
-- on exit.
--
-- *Returns*
--
-- The routine returns a pointer to the array U_ind.
--
-- *Method*
--
-- The routine chol_symbolic computes the pattern of the matrix U in a
-- row-wise manner. No pivoting is used.
--
-- It is known that to compute the pattern of row k of the matrix U we
-- need to merge the pattern of row k of the matrix A and the patterns
-- of each row i of U, where u[i,k] is non-zero (these rows are already
-- computed and placed above row k).
--
-- However, to reduce the number of rows to be merged the routine uses
-- an advanced algorithm proposed in:
--
-- D.J.Rose, R.E.Tarjan, and G.S.Lueker. Algorithmic aspects of vertex
-- elimination on graphs. SIAM J. Comput. 5, 1976, 266-83.
--
-- The authors of the cited paper show that we have the same result if
-- we merge row k of the matrix A and such rows of the matrix U (among
-- rows 1, ..., k-1) whose leftmost non-diagonal non-zero element is
-- placed in k-th column. This feature signficantly reduces the number
-- of rows to be merged, especially on the final steps, where rows of
-- the matrix U become quite dense.
--
-- To determine rows, which should be merged on k-th step, for a fixed
-- time the routine uses linked lists of row numbers of the matrix U.
-- Location head[k] contains the number of a first row, whose leftmost
-- non-diagonal non-zero element is placed in column k, and location
-- next[i] contains the number of a next row with the same property as
-- row i. */

int *chol_symbolic(int n, int A_ptr[], int A_ind[], int U_ptr[])
{     int i, j, k, t, len, size, beg, end, min_j, *U_ind, *head, *next,
         *ind, *map, *temp;
      /* initially we assume that on computing the pattern of U fill-in
         will double the number of non-zeros in A */
      size = A_ptr[n+1] - 1;
      if (size < n) size = n;
      size += size;
      U_ind = xcalloc(1+size, sizeof(int));
      /* allocate and initialize working arrays */
      head = xcalloc(1+n, sizeof(int));
      for (i = 1; i <= n; i++) head[i] = 0;
      next = xcalloc(1+n, sizeof(int));
      ind = xcalloc(1+n, sizeof(int));
      map = xcalloc(1+n, sizeof(int));
      for (j = 1; j <= n; j++) map[j] = 0;
      /* compute the pattern of matrix U */
      U_ptr[1] = 1;
      for (k = 1; k <= n; k++)
      {  /* compute the pattern of k-th row of U, which is the union of
            k-th row of A and those rows of U (among 1, ..., k-1) whose
            leftmost non-diagonal non-zero is placed in k-th column */
         /* (ind) := (k-th row of A) */
         len = A_ptr[k+1] - A_ptr[k];
         memcpy(&ind[1], &A_ind[A_ptr[k]], len * sizeof(int));
         for (t = 1; t <= len; t++)
         {  j = ind[t];
            xassert(k < j && j <= n);
            map[j] = 1;
         }
         /* walk through rows of U whose leftmost non-diagonal non-zero
            is placed in k-th column */
         for (i = head[k]; i != 0; i = next[i])
         {  /* (ind) := (ind) union (i-th row of U) */
            beg = U_ptr[i], end = U_ptr[i+1];
            for (t = beg; t < end; t++)
            {  j = U_ind[t];
               if (j > k && !map[j]) ind[++len] = j, map[j] = 1;
            }
         }
         /* now (ind) is the pattern of k-th row of U */
         U_ptr[k+1] = U_ptr[k] + len;
         /* at least (U_ptr[k+1] - 1) locations should be available in
            the array U_ind */
         if (U_ptr[k+1] - 1 > size)
         {  temp = U_ind;
            size += size;
            U_ind = xcalloc(1+size, sizeof(int));
            memcpy(&U_ind[1], &temp[1], (U_ptr[k] - 1) * sizeof(int));
            xfree(temp);
         }
         xassert(U_ptr[k+1] - 1 <= size);
         /* (k-th row of U) := (ind) */
         memcpy(&U_ind[U_ptr[k]], &ind[1], len * sizeof(int));
         /* determine column index of leftmost non-diagonal non-zero in
            k-th row of U and clear the row pattern map */
         min_j = n + 1;
         for (t = 1; t <= len; t++)
         {  j = ind[t], map[j] = 0;
            if (min_j > j) min_j = j;
         }
         /* include k-th row into corresponding linked list */
         if (min_j <= n) next[k] = head[min_j], head[min_j] = k;
      }
      /* free working arrays */
      xfree(head);
      xfree(next);
      xfree(ind);
      xfree(map);
      /* reallocate the array U_ind to free unused locations */
      temp = U_ind;
      size = U_ptr[n+1] - 1;
      U_ind = xcalloc(1+size, sizeof(int));
      memcpy(&U_ind[1], &temp[1], size * sizeof(int));
      xfree(temp);
      return U_ind;
}

/*----------------------------------------------------------------------
-- chol_numeric - compute Cholesky factorization (numeric phase).
--
-- *Synopsis*
--
-- #include "glpmat.h"
-- int chol_numeric(int n,
--    int A_ptr[], int A_ind[], double A_val[], double A_diag[],
--    int U_ptr[], int U_ind[], double U_val[], double U_diag[]);
--
-- *Description*
--
-- The routine chol_symbolic implements the numeric phase of Cholesky
-- factorization A = U'*U, where A is a given sparse symmetric positive
-- definite matrix, U is a resultant upper triangular factor, U' is a
-- matrix transposed to U.
--
-- The parameter n is the order of matrices A and U.
--
-- Upper triangular part of the matrix A without diagonal elements is
-- specified in the arrays A_ptr, A_ind, and A_val in storage-by-rows
-- format. Diagonal elements of A are specified in the array A_diag,
-- where A_diag[0] is not used, A_diag[i] = a[i,i] for i = 1, ..., n.
-- The arrays A_ptr, A_ind, A_val, and A_diag are not changed on exit.
--
-- The pattern of the matrix U without diagonal elements (previously
-- computed with the routine chol_symbolic) is specified in the arrays
-- U_ptr and U_ind, which are not changed on exit. Numeric values of
-- non-diagonal elements of U are stored in corresponding locations of
-- the array U_val, and values of diagonal elements of U are stored in
-- locations U_diag[1], ..., U_diag[n].
--
-- *Returns*
--
-- The routine returns the number of non-positive diagonal elements of
-- the matrix U which have been replaced by a huge positive number (see
-- the method description below). Zero return code means the matrix A
-- has been successfully factorized.
--
-- *Method*
--
-- The routine chol_numeric computes the matrix U in a row-wise manner
-- using standard gaussian elimination technique. No pivoting is used.
--
-- Initially the routine sets U = A, and before k-th elimination step
-- the matrix U is the following:
--
--       1       k         n
--    1  x x x x x x x x x x
--       . x x x x x x x x x
--       . . x x x x x x x x
--       . . . x x x x x x x
--    k  . . . . * * * * * *
--       . . . . * * * * * *
--       . . . . * * * * * *
--       . . . . * * * * * *
--       . . . . * * * * * *
--    n  . . . . * * * * * *
--
-- where 'x' are elements of already computed rows, '*' are elements of
-- the active submatrix. (Note that the lower triangular part of the
-- active submatrix being symmetric is not stored and diagonal elements
-- are stored separately in the array U_diag.)
--
-- The matrix A is assumed to be positive definite. However, if it is
-- close to semi-definite, on some elimination step a pivot u[k,k] may
-- happen to be non-positive due to round-off errors. In this case the
-- routine uses a technique proposed in:
--
-- S.J.Wright. The Cholesky factorization in interior-point and barrier
-- methods. Preprint MCS-P600-0596, Mathematics and Computer Science
-- Division, Argonne National Laboratory, Argonne, Ill., May 1996.
--
-- The routine just replaces non-positive u[k,k] by a huge positive
-- number. This involves non-diagonal elements in k-th row of U to be
-- close to zero that, in turn, involves k-th component of a solution
-- vector to be close to zero. Note, however, that this technique works
-- only if the system A*x = b is consistent. */

int chol_numeric(int n,
      int A_ptr[], int A_ind[], double A_val[], double A_diag[],
      int U_ptr[], int U_ind[], double U_val[], double U_diag[])
{     int i, j, k, t, t1, beg, end, beg1, end1, count = 0;
      double ukk, uki, *work;
      work = xcalloc(1+n, sizeof(double));
      for (j = 1; j <= n; j++) work[j] = 0.0;
      /* U := (upper triangle of A) */
      /* note that the upper traingle of A is a subset of U */
      for (i = 1; i <= n; i++)
      {  beg = A_ptr[i], end = A_ptr[i+1];
         for (t = beg; t < end; t++)
            j = A_ind[t], work[j] = A_val[t];
         beg = U_ptr[i], end = U_ptr[i+1];
         for (t = beg; t < end; t++)
            j = U_ind[t], U_val[t] = work[j], work[j] = 0.0;
         U_diag[i] = A_diag[i];
      }
      /* main elimination loop */
      for (k = 1; k <= n; k++)
      {  /* transform k-th row of U */
         ukk = U_diag[k];
         if (ukk > 0.0)
            U_diag[k] = ukk = sqrt(ukk);
         else
            U_diag[k] = ukk = DBL_MAX, count++;
         /* (work) := (transformed k-th row) */
         beg = U_ptr[k], end = U_ptr[k+1];
         for (t = beg; t < end; t++)
            work[U_ind[t]] = (U_val[t] /= ukk);
         /* transform other rows of U */
         for (t = beg; t < end; t++)
         {  i = U_ind[t];
            xassert(i > k);
            /* (i-th row) := (i-th row) - u[k,i] * (k-th row) */
            uki = work[i];
            beg1 = U_ptr[i], end1 = U_ptr[i+1];
            for (t1 = beg1; t1 < end1; t1++)
               U_val[t1] -= uki * work[U_ind[t1]];
            U_diag[i] -= uki * uki;
         }
         /* (work) := 0 */
         for (t = beg; t < end; t++)
            work[U_ind[t]] = 0.0;
      }
      xfree(work);
      return count;
}

/*----------------------------------------------------------------------
-- u_solve - solve upper triangular system U*x = b.
--
-- *Synopsis*
--
-- #include "glpmat.h"
-- void u_solve(int n, int U_ptr[], int U_ind[], double U_val[],
--    double U_diag[], double x[]);
--
-- *Description*
--
-- The routine u_solve solves an linear system U*x = b, where U is an
-- upper triangular matrix.
--
-- The parameter n is the order of matrix U.
--
-- The matrix U without diagonal elements is specified in the arrays
-- U_ptr, U_ind, and U_val in storage-by-rows format. Diagonal elements
-- of U are specified in the array U_diag, where U_diag[0] is not used,
-- U_diag[i] = u[i,i] for i = 1, ..., n. All these four arrays are not
-- changed on exit.
--
-- The right-hand side vector b is specified on entry in the array x,
-- where x[0] is not used, and x[i] = b[i] for i = 1, ..., n. On exit
-- the routine stores computed components of the vector of unknowns x
-- in the array x in the same manner. */

void u_solve(int n, int U_ptr[], int U_ind[], double U_val[],
      double U_diag[], double x[])
{     int i, t, beg, end;
      double temp;
      for (i = n; i >= 1; i--)
      {  temp = x[i];
         beg = U_ptr[i], end = U_ptr[i+1];
         for (t = beg; t < end; t++)
            temp -= U_val[t] * x[U_ind[t]];
         xassert(U_diag[i] != 0.0);
         x[i] = temp / U_diag[i];
      }
      return;
}

/*----------------------------------------------------------------------
-- ut_solve - solve lower triangular system U'*x = b.
--
-- *Synopsis*
--
-- #include "glpmat.h"
-- void ut_solve(int n, int U_ptr[], int U_ind[], double U_val[],
--    double U_diag[], double x[]);
--
-- *Description*
--
-- The routine ut_solve solves an linear system U'*x = b, where U is a
-- matrix transposed to an upper triangular matrix.
--
-- The parameter n is the order of matrix U.
--
-- The matrix U without diagonal elements is specified in the arrays
-- U_ptr, U_ind, and U_val in storage-by-rows format. Diagonal elements
-- of U are specified in the array U_diag, where U_diag[0] is not used,
-- U_diag[i] = u[i,i] for i = 1, ..., n. All these four arrays are not
-- changed on exit.
--
-- The right-hand side vector b is specified on entry in the array x,
-- where x[0] is not used, and x[i] = b[i] for i = 1, ..., n. On exit
-- the routine stores computed components of the vector of unknowns x
-- in the array x in the same manner. */

void ut_solve(int n, int U_ptr[], int U_ind[], double U_val[],
      double U_diag[], double x[])
{     int i, t, beg, end;
      double temp;
      for (i = 1; i <= n; i++)
      {  xassert(U_diag[i] != 0.0);
         temp = (x[i] /= U_diag[i]);
         if (temp == 0.0) continue;
         beg = U_ptr[i], end = U_ptr[i+1];
         for (t = beg; t < end; t++)
            x[U_ind[t]] -= U_val[t] * temp;
      }
      return;
}














/***********************************************************************
*  NAME
*
*  fp2rat - convert floating-point number to rational number
*
*  SYNOPSIS
*
*  #include "misc.h"
*  int fp2rat(double x, double eps, double *p, double *q);
*
*  DESCRIPTION
*
*  Given a floating-point number 0 <= x < 1 the routine fp2rat finds
*  its "best" rational approximation p / q, where p >= 0 and q > 0 are
*  integer numbers, such that |x - p / q| <= eps.
*
*  RETURNS
*
*  The routine fp2rat returns the number of iterations used to achieve
*  the specified precision eps.
*
*  EXAMPLES
*
*  For x = sqrt(2) - 1 = 0.414213562373095 and eps = 1e-6 the routine
*  gives p = 408 and q = 985, where 408 / 985 = 0.414213197969543.
*
*  BACKGROUND
*
*  It is well known that every positive real number x can be expressed
*  as the following continued fraction:
*
*     x = b[0] + a[1]
*                ------------------------
*                b[1] + a[2]
*                       -----------------
*                       b[2] + a[3]
*                              ----------
*                              b[3] + ...
*
*  where:
*
*     a[k] = 1,                  k = 0, 1, 2, ...
*
*     b[k] = floor(x[k]),        k = 0, 1, 2, ...
*
*     x[0] = x,
*
*     x[k] = 1 / frac(x[k-1]),   k = 1, 2, 3, ...
*
*  To find the "best" rational approximation of x the routine computes
*  partial fractions f[k] by dropping after k terms as follows:
*
*     f[k] = A[k] / B[k],
*
*  where:
*
*     A[-1] = 1,   A[0] = b[0],   B[-1] = 0,   B[0] = 1,
*
*     A[k] = b[k] * A[k-1] + a[k] * A[k-2],
*
*     B[k] = b[k] * B[k-1] + a[k] * B[k-2].
*
*  Once the condition
*
*     |x - f[k]| <= eps
*
*  has been satisfied, the routine reports p = A[k] and q = B[k] as the
*  final answer.
*
*  In the table below here is some statistics obtained for one million
*  random numbers uniformly distributed in the range [0, 1).
*
*      eps      max p   mean p      max q    mean q  max k   mean k
*     -------------------------------------------------------------
*     1e-1          8      1.6          9       3.2    3      1.4
*     1e-2         98      6.2         99      12.4    5      2.4
*     1e-3        997     20.7        998      41.5    8      3.4
*     1e-4       9959     66.6       9960     133.5   10      4.4
*     1e-5      97403    211.7      97404     424.2   13      5.3
*     1e-6     479669    669.9     479670    1342.9   15      6.3
*     1e-7    1579030   2127.3    3962146    4257.8   16      7.3
*     1e-8   26188823   6749.4   26188824   13503.4   19      8.2
*
*  REFERENCES
*
*  W. B. Jones and W. J. Thron, "Continued Fractions: Analytic Theory
*  and Applications," Encyclopedia on Mathematics and Its Applications,
*  Addison-Wesley, 1980. */

int fp2rat(double x, double eps, double *p, double *q)
{     int k;
      double xk, Akm1, Ak, Bkm1, Bk, ak, bk, fk, temp;
      xassert(0.0 <= x && x < 1.0);
      for (k = 0; ; k++)
      {  xassert(k <= 100);
         if (k == 0)
         {  /* x[0] = x */
            xk = x;
            /* A[-1] = 1 */
            Akm1 = 1.0;
            /* A[0] = b[0] = floor(x[0]) = 0 */
            Ak = 0.0;
            /* B[-1] = 0 */
            Bkm1 = 0.0;
            /* B[0] = 1 */
            Bk = 1.0;
         }
         else
         {  /* x[k] = 1 / frac(x[k-1]) */
            temp = xk - floor(xk);
            xassert(temp != 0.0);
            xk = 1.0 / temp;
            /* a[k] = 1 */
            ak = 1.0;
            /* b[k] = floor(x[k]) */
            bk = floor(xk);
            /* A[k] = b[k] * A[k-1] + a[k] * A[k-2] */
            temp = bk * Ak + ak * Akm1;
            Akm1 = Ak, Ak = temp;
            /* B[k] = b[k] * B[k-1] + a[k] * B[k-2] */
            temp = bk * Bk + ak * Bkm1;
            Bkm1 = Bk, Bk = temp;
         }
         /* f[k] = A[k] / B[k] */
         fk = Ak / Bk;
#if 0
         print("%.*g / %.*g = %.*g",
            DBL_DIG, Ak, DBL_DIG, Bk, DBL_DIG, fk);
#endif
         if (fabs(x - fk) <= eps)
            break;
      }
      *p = Ak;
      *q = Bk;
      return k;
}





static void show_progress(SSX *ssx, int phase)
{     /* this auxiliary routine displays information about progress of
         the search */
      int i, def = 0;
      for (i = 1; i <= ssx->m; i++)
         if (ssx->type[ssx->Q_col[i]] == SSX_FX) def++;
      xprintf("%s%6d:   %s = %22.15g   (%d)\n", phase == 1 ? " " : "*",
         ssx->it_cnt, phase == 1 ? "infsum" : "objval",
         mpq_get_d(ssx->bbar[0]), def);
#if 0
      ssx->tm_lag = utime();
#else
      ssx->tm_lag = xtime();
#endif
      return;
}

/*----------------------------------------------------------------------
// ssx_phase_I - find primal feasible solution.
//
// This routine implements phase I of the primal simplex method.
//
// On exit the routine returns one of the following codes:
//
// 0 - feasible solution found;
// 1 - problem has no feasible solution;
// 2 - iterations limit exceeded;
// 3 - time limit exceeded.
----------------------------------------------------------------------*/

int ssx_phase_I(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      int *type = ssx->type;
      mpq_t *lb = ssx->lb;
      mpq_t *ub = ssx->ub;
      mpq_t *coef = ssx->coef;
      int *A_ptr = ssx->A_ptr;
      int *A_ind = ssx->A_ind;
      mpq_t *A_val = ssx->A_val;
      int *Q_col = ssx->Q_col;
      mpq_t *bbar = ssx->bbar;
      mpq_t *pi = ssx->pi;
      mpq_t *cbar = ssx->cbar;
      int *orig_type, orig_dir;
      mpq_t *orig_lb, *orig_ub, *orig_coef;
      int i, k, ret;
      /* save components of the original LP problem, which are changed
         by the routine */
      orig_type = xcalloc(1+m+n, sizeof(int));
      orig_lb = xcalloc(1+m+n, sizeof(mpq_t));
      orig_ub = xcalloc(1+m+n, sizeof(mpq_t));
      orig_coef = xcalloc(1+m+n, sizeof(mpq_t));
      for (k = 1; k <= m+n; k++)
      {  orig_type[k] = type[k];
         mpq_init(orig_lb[k]);
         mpq_set(orig_lb[k], lb[k]);
         mpq_init(orig_ub[k]);
         mpq_set(orig_ub[k], ub[k]);
      }
      orig_dir = ssx->dir;
      for (k = 0; k <= m+n; k++)
      {  mpq_init(orig_coef[k]);
         mpq_set(orig_coef[k], coef[k]);
      }
      /* build an artificial basic solution, which is primal feasible,
         and also build an auxiliary objective function to minimize the
         sum of infeasibilities for the original problem */
      ssx->dir = SSX_MIN;
      for (k = 0; k <= m+n; k++) mpq_set_si(coef[k], 0, 1);
      mpq_set_si(bbar[0], 0, 1);
      for (i = 1; i <= m; i++)
      {  int t;
         k = Q_col[i]; /* x[k] = xB[i] */
         t = type[k];
         if (t == SSX_LO || t == SSX_DB || t == SSX_FX)
         {  /* in the original problem x[k] has lower bound */
            if (mpq_cmp(bbar[i], lb[k]) < 0)
            {  /* which is violated */
               type[k] = SSX_UP;
               mpq_set(ub[k], lb[k]);
               mpq_set_si(lb[k], 0, 1);
               mpq_set_si(coef[k], -1, 1);
               mpq_add(bbar[0], bbar[0], ub[k]);
               mpq_sub(bbar[0], bbar[0], bbar[i]);
            }
         }
         if (t == SSX_UP || t == SSX_DB || t == SSX_FX)
         {  /* in the original problem x[k] has upper bound */
            if (mpq_cmp(bbar[i], ub[k]) > 0)
            {  /* which is violated */
               type[k] = SSX_LO;
               mpq_set(lb[k], ub[k]);
               mpq_set_si(ub[k], 0, 1);
               mpq_set_si(coef[k], +1, 1);
               mpq_add(bbar[0], bbar[0], bbar[i]);
               mpq_sub(bbar[0], bbar[0], lb[k]);
            }
         }
      }
      /* now the initial basic solution should be primal feasible due
         to changes of bounds of some basic variables, which turned to
         implicit artifical variables */
      /* compute simplex multipliers and reduced costs */
      ssx_eval_pi(ssx);
      ssx_eval_cbar(ssx);
      /* display initial progress of the search */
      show_progress(ssx, 1);
      /* main loop starts here */
      for (;;)
      {  /* display current progress of the search */
#if 0
         if (utime() - ssx->tm_lag >= ssx->out_frq - 0.001)
#else
         if (xdifftime(xtime(), ssx->tm_lag) >= ssx->out_frq - 0.001)
#endif
            show_progress(ssx, 1);
         /* we do not need to wait until all artificial variables have
            left the basis */
         if (mpq_sgn(bbar[0]) == 0)
         {  /* the sum of infeasibilities is zero, therefore the current
               solution is primal feasible for the original problem */
            ret = 0;
            break;
         }
         /* check if the iterations limit has been exhausted */
         if (ssx->it_lim == 0)
         {  ret = 2;
            break;
         }
         /* check if the time limit has been exhausted */
#if 0
         if (ssx->tm_lim >= 0.0 && ssx->tm_lim <= utime() - ssx->tm_beg)
#else
         if (ssx->tm_lim >= 0.0 &&
             ssx->tm_lim <= xdifftime(xtime(), ssx->tm_beg))
#endif
         {  ret = 3;
            break;
         }
         /* choose non-basic variable xN[q] */
         ssx_chuzc(ssx);
         /* if xN[q] cannot be chosen, the sum of infeasibilities is
            minimal but non-zero; therefore the original problem has no
            primal feasible solution */
         if (ssx->q == 0)
         {  ret = 1;
            break;
         }
         /* compute q-th column of the simplex table */
         ssx_eval_col(ssx);
         /* choose basic variable xB[p] */
         ssx_chuzr(ssx);
         /* the sum of infeasibilities cannot be negative, therefore
            the auxiliary lp problem cannot have unbounded solution */
         xassert(ssx->p != 0);
         /* update values of basic variables */
         ssx_update_bbar(ssx);
         if (ssx->p > 0)
         {  /* compute p-th row of the inverse inv(B) */
            ssx_eval_rho(ssx);
            /* compute p-th row of the simplex table */
            ssx_eval_row(ssx);
            xassert(mpq_cmp(ssx->aq[ssx->p], ssx->ap[ssx->q]) == 0);
            /* update simplex multipliers */
            ssx_update_pi(ssx);
            /* update reduced costs of non-basic variables */
            ssx_update_cbar(ssx);
         }
         /* xB[p] is leaving the basis; if it is implicit artificial
            variable, the corresponding residual vanishes; therefore
            bounds of this variable should be restored to the original
            values */
         if (ssx->p > 0)
         {  k = Q_col[ssx->p]; /* x[k] = xB[p] */
            if (type[k] != orig_type[k])
            {  /* x[k] is implicit artificial variable */
               type[k] = orig_type[k];
               mpq_set(lb[k], orig_lb[k]);
               mpq_set(ub[k], orig_ub[k]);
               xassert(ssx->p_stat == SSX_NL || ssx->p_stat == SSX_NU);
               ssx->p_stat = (ssx->p_stat == SSX_NL ? SSX_NU : SSX_NL);
               if (type[k] == SSX_FX) ssx->p_stat = SSX_NS;
               /* nullify the objective coefficient at x[k] */
               mpq_set_si(coef[k], 0, 1);
               /* since coef[k] has been changed, we need to compute
                  new reduced cost of x[k], which it will have in the
                  adjacent basis */
               /* the formula d[j] = cN[j] - pi' * N[j] is used (note
                  that the vector pi is not changed, because it depends
                  on objective coefficients at basic variables, but in
                  the adjacent basis, for which the vector pi has been
                  just recomputed, x[k] is non-basic) */
               if (k <= m)
               {  /* x[k] is auxiliary variable */
                  mpq_neg(cbar[ssx->q], pi[k]);
               }
               else
               {  /* x[k] is structural variable */
                  int ptr;
                  mpq_t temp;
                  mpq_init(temp);
                  mpq_set_si(cbar[ssx->q], 0, 1);
                  for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)
                  {  mpq_mul(temp, pi[A_ind[ptr]], A_val[ptr]);
                     mpq_add(cbar[ssx->q], cbar[ssx->q], temp);
                  }
                  mpq_clear(temp);
               }
            }
         }
         /* jump to the adjacent vertex of the polyhedron */
         ssx_change_basis(ssx);
         /* one simplex iteration has been performed */
         if (ssx->it_lim > 0) ssx->it_lim--;
         ssx->it_cnt++;
      }
      /* display final progress of the search */
      show_progress(ssx, 1);
      /* restore components of the original problem, which were changed
         by the routine */
      for (k = 1; k <= m+n; k++)
      {  type[k] = orig_type[k];
         mpq_set(lb[k], orig_lb[k]);
         mpq_clear(orig_lb[k]);
         mpq_set(ub[k], orig_ub[k]);
         mpq_clear(orig_ub[k]);
      }
      ssx->dir = orig_dir;
      for (k = 0; k <= m+n; k++)
      {  mpq_set(coef[k], orig_coef[k]);
         mpq_clear(orig_coef[k]);
      }
      xfree(orig_type);
      xfree(orig_lb);
      xfree(orig_ub);
      xfree(orig_coef);
      /* return to the calling program */
      return ret;
}

/*----------------------------------------------------------------------
// ssx_phase_II - find optimal solution.
//
// This routine implements phase II of the primal simplex method.
//
// On exit the routine returns one of the following codes:
//
// 0 - optimal solution found;
// 1 - problem has unbounded solution;
// 2 - iterations limit exceeded;
// 3 - time limit exceeded.
----------------------------------------------------------------------*/

int ssx_phase_II(SSX *ssx)
{     int ret;
      /* display initial progress of the search */
      show_progress(ssx, 2);
      /* main loop starts here */
      for (;;)
      {  /* display current progress of the search */
#if 0
         if (utime() - ssx->tm_lag >= ssx->out_frq - 0.001)
#else
         if (xdifftime(xtime(), ssx->tm_lag) >= ssx->out_frq - 0.001)
#endif
            show_progress(ssx, 2);
         /* check if the iterations limit has been exhausted */
         if (ssx->it_lim == 0)
         {  ret = 2;
            break;
         }
         /* check if the time limit has been exhausted */
#if 0
         if (ssx->tm_lim >= 0.0 && ssx->tm_lim <= utime() - ssx->tm_beg)
#else
         if (ssx->tm_lim >= 0.0 &&
             ssx->tm_lim <= xdifftime(xtime(), ssx->tm_beg))
#endif
         {  ret = 3;
            break;
         }
         /* choose non-basic variable xN[q] */
         ssx_chuzc(ssx);
         /* if xN[q] cannot be chosen, the current basic solution is
            dual feasible and therefore optimal */
         if (ssx->q == 0)
         {  ret = 0;
            break;
         }
         /* compute q-th column of the simplex table */
         ssx_eval_col(ssx);
         /* choose basic variable xB[p] */
         ssx_chuzr(ssx);
         /* if xB[p] cannot be chosen, the problem has no dual feasible
            solution (i.e. unbounded) */
         if (ssx->p == 0)
         {  ret = 1;
            break;
         }
         /* update values of basic variables */
         ssx_update_bbar(ssx);
         if (ssx->p > 0)
         {  /* compute p-th row of the inverse inv(B) */
            ssx_eval_rho(ssx);
            /* compute p-th row of the simplex table */
            ssx_eval_row(ssx);
            xassert(mpq_cmp(ssx->aq[ssx->p], ssx->ap[ssx->q]) == 0);
#if 0
            /* update simplex multipliers */
            ssx_update_pi(ssx);
#endif
            /* update reduced costs of non-basic variables */
            ssx_update_cbar(ssx);
         }
         /* jump to the adjacent vertex of the polyhedron */
         ssx_change_basis(ssx);
         /* one simplex iteration has been performed */
         if (ssx->it_lim > 0) ssx->it_lim--;
         ssx->it_cnt++;
      }
      /* display final progress of the search */
      show_progress(ssx, 2);
      /* return to the calling program */
      return ret;
}

/*----------------------------------------------------------------------
// ssx_driver - base driver to exact simplex method.
//
// This routine is a base driver to a version of the primal simplex
// method using exact (bignum) arithmetic.
//
// On exit the routine returns one of the following codes:
//
// 0 - optimal solution found;
// 1 - problem has no feasible solution;
// 2 - problem has unbounded solution;
// 3 - iterations limit exceeded (phase I);
// 4 - iterations limit exceeded (phase II);
// 5 - time limit exceeded (phase I);
// 6 - time limit exceeded (phase II);
// 7 - initial basis matrix is exactly singular.
----------------------------------------------------------------------*/

int ssx_driver(SSX *ssx)
{     int m = ssx->m;
      int *type = ssx->type;
      mpq_t *lb = ssx->lb;
      mpq_t *ub = ssx->ub;
      int *Q_col = ssx->Q_col;
      mpq_t *bbar = ssx->bbar;
      int i, k, ret;
      ssx->tm_beg = xtime();
      /* factorize the initial basis matrix */
      if (ssx_factorize(ssx))
      {  xprintf("Initial basis matrix is singular\n");
         ret = 7;
         goto done;
      }
      /* compute values of basic variables */
      ssx_eval_bbar(ssx);
      /* check if the initial basic solution is primal feasible */
      for (i = 1; i <= m; i++)
      {  int t;
         k = Q_col[i]; /* x[k] = xB[i] */
         t = type[k];
         if (t == SSX_LO || t == SSX_DB || t == SSX_FX)
         {  /* x[k] has lower bound */
            if (mpq_cmp(bbar[i], lb[k]) < 0)
            {  /* which is violated */
               break;
            }
         }
         if (t == SSX_UP || t == SSX_DB || t == SSX_FX)
         {  /* x[k] has upper bound */
            if (mpq_cmp(bbar[i], ub[k]) > 0)
            {  /* which is violated */
               break;
            }
         }
      }
      if (i > m)
      {  /* no basic variable violates its bounds */
         ret = 0;
         goto skip;
      }
      /* phase I: find primal feasible solution */
      ret = ssx_phase_I(ssx);
      switch (ret)
      {  case 0:
            ret = 0;
            break;
         case 1:
            xprintf("PROBLEM HAS NO FEASIBLE SOLUTION\n");
            ret = 1;
            break;
         case 2:
            xprintf("ITERATIONS LIMIT EXCEEDED; SEARCH TERMINATED\n");
            ret = 3;
            break;
         case 3:
            xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
            ret = 5;
            break;
         default:
            xassert(ret != ret);
      }
      /* compute values of basic variables (actually only the objective
         value needs to be computed) */
      ssx_eval_bbar(ssx);
skip: /* compute simplex multipliers */
      ssx_eval_pi(ssx);
      /* compute reduced costs of non-basic variables */
      ssx_eval_cbar(ssx);
      /* if phase I failed, do not start phase II */
      if (ret != 0) goto done;
      /* phase II: find optimal solution */
      ret = ssx_phase_II(ssx);
      switch (ret)
      {  case 0:
            xprintf("OPTIMAL SOLUTION FOUND\n");
            ret = 0;
            break;
         case 1:
            xprintf("PROBLEM HAS UNBOUNDED SOLUTION\n");
            ret = 2;
            break;
         case 2:
            xprintf("ITERATIONS LIMIT EXCEEDED; SEARCH TERMINATED\n");
            ret = 4;
            break;
         case 3:
            xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
            ret = 6;
            break;
         default:
            xassert(ret != ret);
      }
done: /* decrease the time limit by the spent amount of time */
      if (ssx->tm_lim >= 0.0)
#if 0
      {  ssx->tm_lim -= utime() - ssx->tm_beg;
#else
      {  ssx->tm_lim -= xdifftime(xtime(), ssx->tm_beg);
#endif
         if (ssx->tm_lim < 0.0) ssx->tm_lim = 0.0;
      }
      return ret;
}


/*----------------------------------------------------------------------
// ssx_create - create simplex solver workspace.
//
// This routine creates the workspace used by simplex solver routines,
// and returns a pointer to it.
//
// Parameters m, n, and nnz specify, respectively, the number of rows,
// columns, and non-zero constraint coefficients.
//
// This routine only allocates the memory for the workspace components,
// so the workspace needs to be saturated by data. */

SSX *ssx_create(int m, int n, int nnz)
{     SSX *ssx;
      int i, j, k;
      if (m < 1)
         xfault("ssx_create: m = %d; invalid number of rows\n", m);
      if (n < 1)
         xfault("ssx_create: n = %d; invalid number of columns\n", n);
      if (nnz < 0)
         xfault("ssx_create: nnz = %d; invalid number of non-zero const"
            "raint coefficients\n", nnz);
      ssx = xmalloc(sizeof(SSX));
      ssx->m = m;
      ssx->n = n;
      ssx->type = xcalloc(1+m+n, sizeof(int));
      ssx->lb = xcalloc(1+m+n, sizeof(mpq_t));
      for (k = 1; k <= m+n; k++) mpq_init(ssx->lb[k]);
      ssx->ub = xcalloc(1+m+n, sizeof(mpq_t));
      for (k = 1; k <= m+n; k++) mpq_init(ssx->ub[k]);
      ssx->coef = xcalloc(1+m+n, sizeof(mpq_t));
      for (k = 0; k <= m+n; k++) mpq_init(ssx->coef[k]);
      ssx->A_ptr = xcalloc(1+n+1, sizeof(int));
      ssx->A_ptr[n+1] = nnz+1;
      ssx->A_ind = xcalloc(1+nnz, sizeof(int));
      ssx->A_val = xcalloc(1+nnz, sizeof(mpq_t));
      for (k = 1; k <= nnz; k++) mpq_init(ssx->A_val[k]);
      ssx->stat = xcalloc(1+m+n, sizeof(int));
      ssx->Q_row = xcalloc(1+m+n, sizeof(int));
      ssx->Q_col = xcalloc(1+m+n, sizeof(int));
      ssx->binv = bfx_create_binv();
      ssx->bbar = xcalloc(1+m, sizeof(mpq_t));
      for (i = 0; i <= m; i++) mpq_init(ssx->bbar[i]);
      ssx->pi = xcalloc(1+m, sizeof(mpq_t));
      for (i = 1; i <= m; i++) mpq_init(ssx->pi[i]);
      ssx->cbar = xcalloc(1+n, sizeof(mpq_t));
      for (j = 1; j <= n; j++) mpq_init(ssx->cbar[j]);
      ssx->rho = xcalloc(1+m, sizeof(mpq_t));
      for (i = 1; i <= m; i++) mpq_init(ssx->rho[i]);
      ssx->ap = xcalloc(1+n, sizeof(mpq_t));
      for (j = 1; j <= n; j++) mpq_init(ssx->ap[j]);
      ssx->aq = xcalloc(1+m, sizeof(mpq_t));
      for (i = 1; i <= m; i++) mpq_init(ssx->aq[i]);
      mpq_init(ssx->delta);
      return ssx;
}

/*----------------------------------------------------------------------
// ssx_factorize - factorize the current basis matrix.
//
// This routine computes factorization of the current basis matrix B
// and returns the singularity flag. If the matrix B is non-singular,
// the flag is zero, otherwise non-zero. */

static int basis_col(void *info, int j, int ind[], mpq_t val[])
{     /* this auxiliary routine provides row indices and numeric values
         of non-zero elements in j-th column of the matrix B */
      SSX *ssx = info;
      int m = ssx->m;
      int n = ssx->n;
      int *A_ptr = ssx->A_ptr;
      int *A_ind = ssx->A_ind;
      mpq_t *A_val = ssx->A_val;
      int *Q_col = ssx->Q_col;
      int k, len, ptr;
      xassert(1 <= j && j <= m);
      k = Q_col[j]; /* x[k] = xB[j] */
      xassert(1 <= k && k <= m+n);
      /* j-th column of the matrix B is k-th column of the augmented
         constraint matrix (I | -A) */
      if (k <= m)
      {  /* it is a column of the unity matrix I */
         len = 1, ind[1] = k, mpq_set_si(val[1], 1, 1);
      }
      else
      {  /* it is a column of the original constraint matrix -A */
         len = 0;
         for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)
         {  len++;
            ind[len] = A_ind[ptr];
            mpq_neg(val[len], A_val[ptr]);
         }
      }
      return len;
}

int ssx_factorize(SSX *ssx)
{     int ret;
      ret = bfx_factorize(ssx->binv, ssx->m, basis_col, ssx);
      return ret;
}

/*----------------------------------------------------------------------
// ssx_get_xNj - determine value of non-basic variable.
//
// This routine determines the value of non-basic variable xN[j] in the
// current basic solution defined as follows:
//
//    0,             if xN[j] is free variable
//    lN[j],         if xN[j] is on its lower bound
//    uN[j],         if xN[j] is on its upper bound
//    lN[j] = uN[j], if xN[j] is fixed variable
//
// where lN[j] and uN[j] are lower and upper bounds of xN[j]. */

void ssx_get_xNj(SSX *ssx, int j, mpq_t x)
{     int m = ssx->m;
      int n = ssx->n;
      mpq_t *lb = ssx->lb;
      mpq_t *ub = ssx->ub;
      int *stat = ssx->stat;
      int *Q_col = ssx->Q_col;
      int k;
      xassert(1 <= j && j <= n);
      k = Q_col[m+j]; /* x[k] = xN[j] */
      xassert(1 <= k && k <= m+n);
      switch (stat[k])
      {  case SSX_NL:
            /* xN[j] is on its lower bound */
            mpq_set(x, lb[k]); break;
         case SSX_NU:
            /* xN[j] is on its upper bound */
            mpq_set(x, ub[k]); break;
         case SSX_NF:
            /* xN[j] is free variable */
            mpq_set_si(x, 0, 1); break;
         case SSX_NS:
            /* xN[j] is fixed variable */
            mpq_set(x, lb[k]); break;
         default:
            xassert(stat != stat);
      }
      return;
}

/*----------------------------------------------------------------------
// ssx_eval_bbar - compute values of basic variables.
//
// This routine computes values of basic variables xB in the current
// basic solution as follows:
//
//    beta = - inv(B) * N * xN,
//
// where B is the basis matrix, N is the matrix of non-basic columns,
// xN is a vector of current values of non-basic variables. */

void ssx_eval_bbar(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      mpq_t *coef = ssx->coef;
      int *A_ptr = ssx->A_ptr;
      int *A_ind = ssx->A_ind;
      mpq_t *A_val = ssx->A_val;
      int *Q_col = ssx->Q_col;
      mpq_t *bbar = ssx->bbar;
      int i, j, k, ptr;
      mpq_t x, temp;
      mpq_init(x);
      mpq_init(temp);
      /* bbar := 0 */
      for (i = 1; i <= m; i++)
         mpq_set_si(bbar[i], 0, 1);
      /* bbar := - N * xN = - N[1] * xN[1] - ... - N[n] * xN[n] */
      for (j = 1; j <= n; j++)
      {  ssx_get_xNj(ssx, j, x);
         if (mpq_sgn(x) == 0) continue;
         k = Q_col[m+j]; /* x[k] = xN[j] */
         if (k <= m)
         {  /* N[j] is a column of the unity matrix I */
            mpq_sub(bbar[k], bbar[k], x);
         }
         else
         {  /* N[j] is a column of the original constraint matrix -A */
            for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)
            {  mpq_mul(temp, A_val[ptr], x);
               mpq_add(bbar[A_ind[ptr]], bbar[A_ind[ptr]], temp);
            }
         }
      }
      /* bbar := inv(B) * bbar */
      bfx_ftran(ssx->binv, bbar, 0);
#if 1
      /* compute value of the objective function */
      /* bbar[0] := c[0] */
      mpq_set(bbar[0], coef[0]);
      /* bbar[0] := bbar[0] + sum{i in B} cB[i] * xB[i] */
      for (i = 1; i <= m; i++)
      {  k = Q_col[i]; /* x[k] = xB[i] */
         if (mpq_sgn(coef[k]) == 0) continue;
         mpq_mul(temp, coef[k], bbar[i]);
         mpq_add(bbar[0], bbar[0], temp);
      }
      /* bbar[0] := bbar[0] + sum{j in N} cN[j] * xN[j] */
      for (j = 1; j <= n; j++)
      {  k = Q_col[m+j]; /* x[k] = xN[j] */
         if (mpq_sgn(coef[k]) == 0) continue;
         ssx_get_xNj(ssx, j, x);
         mpq_mul(temp, coef[k], x);
         mpq_add(bbar[0], bbar[0], temp);
      }
#endif
      mpq_clear(x);
      mpq_clear(temp);
      return;
}

/*----------------------------------------------------------------------
// ssx_eval_pi - compute values of simplex multipliers.
//
// This routine computes values of simplex multipliers (shadow prices)
// pi in the current basic solution as follows:
//
//    pi = inv(B') * cB,
//
// where B' is a matrix transposed to the basis matrix B, cB is a vector
// of objective coefficients at basic variables xB. */

void ssx_eval_pi(SSX *ssx)
{     int m = ssx->m;
      mpq_t *coef = ssx->coef;
      int *Q_col = ssx->Q_col;
      mpq_t *pi = ssx->pi;
      int i;
      /* pi := cB */
      for (i = 1; i <= m; i++) mpq_set(pi[i], coef[Q_col[i]]);
      /* pi := inv(B') * cB */
      bfx_btran(ssx->binv, pi);
      return;
}

/*----------------------------------------------------------------------
// ssx_eval_dj - compute reduced cost of non-basic variable.
//
// This routine computes reduced cost d[j] of non-basic variable xN[j]
// in the current basic solution as follows:
//
//    d[j] = cN[j] - N[j] * pi,
//
// where cN[j] is an objective coefficient at xN[j], N[j] is a column
// of the augmented constraint matrix (I | -A) corresponding to xN[j],
// pi is the vector of simplex multipliers (shadow prices). */

void ssx_eval_dj(SSX *ssx, int j, mpq_t dj)
{     int m = ssx->m;
      int n = ssx->n;
      mpq_t *coef = ssx->coef;
      int *A_ptr = ssx->A_ptr;
      int *A_ind = ssx->A_ind;
      mpq_t *A_val = ssx->A_val;
      int *Q_col = ssx->Q_col;
      mpq_t *pi = ssx->pi;
      int k, ptr, end;
      mpq_t temp;
      mpq_init(temp);
      xassert(1 <= j && j <= n);
      k = Q_col[m+j]; /* x[k] = xN[j] */
      xassert(1 <= k && k <= m+n);
      /* j-th column of the matrix N is k-th column of the augmented
         constraint matrix (I | -A) */
      if (k <= m)
      {  /* it is a column of the unity matrix I */
         mpq_sub(dj, coef[k], pi[k]);
      }
      else
      {  /* it is a column of the original constraint matrix -A */
         mpq_set(dj, coef[k]);
         for (ptr = A_ptr[k-m], end = A_ptr[k-m+1]; ptr < end; ptr++)
         {  mpq_mul(temp, A_val[ptr], pi[A_ind[ptr]]);
            mpq_add(dj, dj, temp);
         }
      }
      mpq_clear(temp);
      return;
}

/*----------------------------------------------------------------------
// ssx_eval_cbar - compute reduced costs of all non-basic variables.
//
// This routine computes the vector of reduced costs pi in the current
// basic solution for all non-basic variables, including fixed ones. */

void ssx_eval_cbar(SSX *ssx)
{     int n = ssx->n;
      mpq_t *cbar = ssx->cbar;
      int j;
      for (j = 1; j <= n; j++)
         ssx_eval_dj(ssx, j, cbar[j]);
      return;
}

/*----------------------------------------------------------------------
// ssx_eval_rho - compute p-th row of the inverse.
//
// This routine computes p-th row of the matrix inv(B), where B is the
// current basis matrix.
//
// p-th row of the inverse is computed using the following formula:
//
//    rho = inv(B') * e[p],
//
// where B' is a matrix transposed to B, e[p] is a unity vector, which
// contains one in p-th position. */

void ssx_eval_rho(SSX *ssx)
{     int m = ssx->m;
      int p = ssx->p;
      mpq_t *rho = ssx->rho;
      int i;
      xassert(1 <= p && p <= m);
      /* rho := 0 */
      for (i = 1; i <= m; i++) mpq_set_si(rho[i], 0, 1);
      /* rho := e[p] */
      mpq_set_si(rho[p], 1, 1);
      /* rho := inv(B') * rho */
      bfx_btran(ssx->binv, rho);
      return;
}

/*----------------------------------------------------------------------
// ssx_eval_row - compute pivot row of the simplex table.
//
// This routine computes p-th (pivot) row of the current simplex table
// A~ = - inv(B) * N using the following formula:
//
//    A~[p] = - N' * inv(B') * e[p] = - N' * rho[p],
//
// where N' is a matrix transposed to the matrix N, rho[p] is p-th row
// of the inverse inv(B). */

void ssx_eval_row(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      int *A_ptr = ssx->A_ptr;
      int *A_ind = ssx->A_ind;
      mpq_t *A_val = ssx->A_val;
      int *Q_col = ssx->Q_col;
      mpq_t *rho = ssx->rho;
      mpq_t *ap = ssx->ap;
      int j, k, ptr;
      mpq_t temp;
      mpq_init(temp);
      for (j = 1; j <= n; j++)
      {  /* ap[j] := - N'[j] * rho (inner product) */
         k = Q_col[m+j]; /* x[k] = xN[j] */
         if (k <= m)
            mpq_neg(ap[j], rho[k]);
         else
         {  mpq_set_si(ap[j], 0, 1);
            for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)
            {  mpq_mul(temp, A_val[ptr], rho[A_ind[ptr]]);
               mpq_add(ap[j], ap[j], temp);
            }
         }
      }
      mpq_clear(temp);
      return;
}

/*----------------------------------------------------------------------
// ssx_eval_col - compute pivot column of the simplex table.
//
// This routine computes q-th (pivot) column of the current simplex
// table A~ = - inv(B) * N using the following formula:
//
//    A~[q] = - inv(B) * N[q],
//
// where N[q] is q-th column of the matrix N corresponding to chosen
// non-basic variable xN[q]. */

void ssx_eval_col(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      int *A_ptr = ssx->A_ptr;
      int *A_ind = ssx->A_ind;
      mpq_t *A_val = ssx->A_val;
      int *Q_col = ssx->Q_col;
      int q = ssx->q;
      mpq_t *aq = ssx->aq;
      int i, k, ptr;
      xassert(1 <= q && q <= n);
      /* aq := 0 */
      for (i = 1; i <= m; i++) mpq_set_si(aq[i], 0, 1);
      /* aq := N[q] */
      k = Q_col[m+q]; /* x[k] = xN[q] */
      if (k <= m)
      {  /* N[q] is a column of the unity matrix I */
         mpq_set_si(aq[k], 1, 1);
      }
      else
      {  /* N[q] is a column of the original constraint matrix -A */
         for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)
            mpq_neg(aq[A_ind[ptr]], A_val[ptr]);
      }
      /* aq := inv(B) * aq */
      bfx_ftran(ssx->binv, aq, 1);
      /* aq := - aq */
      for (i = 1; i <= m; i++) mpq_neg(aq[i], aq[i]);
      return;
}

/*----------------------------------------------------------------------
// ssx_chuzc - choose pivot column.
//
// This routine chooses non-basic variable xN[q] whose reduced cost
// indicates possible improving of the objective function to enter it
// in the basis.
//
// Currently the standard (textbook) pricing is used, i.e. that
// non-basic variable is preferred which has greatest reduced cost (in
// magnitude).
//
// If xN[q] has been chosen, the routine stores its number q and also
// sets the flag q_dir that indicates direction in which xN[q] has to
// change (+1 means increasing, -1 means decreasing).
//
// If the choice cannot be made, because the current basic solution is
// dual feasible, the routine sets the number q to 0. */

void ssx_chuzc(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      int dir = (ssx->dir == SSX_MIN ? +1 : -1);
      int *Q_col = ssx->Q_col;
      int *stat = ssx->stat;
      mpq_t *cbar = ssx->cbar;
      int j, k, s, q, q_dir;
      double best, temp;
      /* nothing is chosen so far */
      q = 0, q_dir = 0, best = 0.0;
      /* look through the list of non-basic variables */
      for (j = 1; j <= n; j++)
      {  k = Q_col[m+j]; /* x[k] = xN[j] */
         s = dir * mpq_sgn(cbar[j]);
         if ((stat[k] == SSX_NF || stat[k] == SSX_NL) && s < 0 ||
             (stat[k] == SSX_NF || stat[k] == SSX_NU) && s > 0)
         {  /* reduced cost of xN[j] indicates possible improving of
               the objective function */
            temp = fabs(mpq_get_d(cbar[j]));
            xassert(temp != 0.0);
            if (q == 0 || best < temp)
               q = j, q_dir = - s, best = temp;
         }
      }
      ssx->q = q, ssx->q_dir = q_dir;
      return;
}

/*----------------------------------------------------------------------
// ssx_chuzr - choose pivot row.
//
// This routine looks through elements of q-th column of the simplex
// table and chooses basic variable xB[p] which should leave the basis.
//
// The choice is based on the standard (textbook) ratio test.
//
// If xB[p] has been chosen, the routine stores its number p and also
// sets its non-basic status p_stat which should be assigned to xB[p]
// when it has left the basis and become xN[q].
//
// Special case p < 0 means that xN[q] is double-bounded variable and
// it reaches its opposite bound before any basic variable does that,
// so the current basis remains unchanged.
//
// If the choice cannot be made, because xN[q] can infinitely change in
// the feasible direction, the routine sets the number p to 0. */

void ssx_chuzr(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      int *type = ssx->type;
      mpq_t *lb = ssx->lb;
      mpq_t *ub = ssx->ub;
      int *Q_col = ssx->Q_col;
      mpq_t *bbar = ssx->bbar;
      int q = ssx->q;
      mpq_t *aq = ssx->aq;
      int q_dir = ssx->q_dir;
      int i, k, s, t, p, p_stat;
      mpq_t teta, temp;
      mpq_init(teta);
      mpq_init(temp);
      xassert(1 <= q && q <= n);
      xassert(q_dir == +1 || q_dir == -1);
      /* nothing is chosen so far */
      p = 0, p_stat = 0;
      /* look through the list of basic variables */
      for (i = 1; i <= m; i++)
      {  s = q_dir * mpq_sgn(aq[i]);
         if (s < 0)
         {  /* xB[i] decreases */
            k = Q_col[i]; /* x[k] = xB[i] */
            t = type[k];
            if (t == SSX_LO || t == SSX_DB || t == SSX_FX)
            {  /* xB[i] has finite lower bound */
               mpq_sub(temp, bbar[i], lb[k]);
               mpq_div(temp, temp, aq[i]);
               mpq_abs(temp, temp);
               if (p == 0 || mpq_cmp(teta, temp) > 0)
               {  p = i;
                  p_stat = (t == SSX_FX ? SSX_NS : SSX_NL);
                  mpq_set(teta, temp);
               }
            }
         }
         else if (s > 0)
         {  /* xB[i] increases */
            k = Q_col[i]; /* x[k] = xB[i] */
            t = type[k];
            if (t == SSX_UP || t == SSX_DB || t == SSX_FX)
            {  /* xB[i] has finite upper bound */
               mpq_sub(temp, bbar[i], ub[k]);
               mpq_div(temp, temp, aq[i]);
               mpq_abs(temp, temp);
               if (p == 0 || mpq_cmp(teta, temp) > 0)
               {  p = i;
                  p_stat = (t == SSX_FX ? SSX_NS : SSX_NU);
                  mpq_set(teta, temp);
               }
            }
         }
         /* if something has been chosen and the ratio test indicates
            exact degeneracy, the search can be finished */
         if (p != 0 && mpq_sgn(teta) == 0) break;
      }
      /* if xN[q] is double-bounded, check if it can reach its opposite
         bound before any basic variable */
      k = Q_col[m+q]; /* x[k] = xN[q] */
      if (type[k] == SSX_DB)
      {  mpq_sub(temp, ub[k], lb[k]);
         if (p == 0 || mpq_cmp(teta, temp) > 0)
         {  p = -1;
            p_stat = -1;
            mpq_set(teta, temp);
         }
      }
      ssx->p = p;
      ssx->p_stat = p_stat;
      /* if xB[p] has been chosen, determine its actual change in the
         adjacent basis (it has the same sign as q_dir) */
      if (p != 0)
      {  xassert(mpq_sgn(teta) >= 0);
         if (q_dir > 0)
            mpq_set(ssx->delta, teta);
         else
            mpq_neg(ssx->delta, teta);
      }
      mpq_clear(teta);
      mpq_clear(temp);
      return;
}

/*----------------------------------------------------------------------
// ssx_update_bbar - update values of basic variables.
//
// This routine recomputes the current values of basic variables for
// the adjacent basis.
//
// The simplex table for the current basis is the following:
//
//    xB[i] = sum{j in 1..n} alfa[i,j] * xN[q],  i = 1,...,m
//
// therefore
//
//    delta xB[i] = alfa[i,q] * delta xN[q],  i = 1,...,m
//
// where delta xN[q] = xN.new[q] - xN[q] is the change of xN[q] in the
// adjacent basis, and delta xB[i] = xB.new[i] - xB[i] is the change of
// xB[i]. This gives formulae for recomputing values of xB[i]:
//
//    xB.new[p] = xN[q] + delta xN[q]
//
// (because xN[q] becomes xB[p] in the adjacent basis), and
//
//    xB.new[i] = xB[i] + alfa[i,q] * delta xN[q],  i != p
//
// for other basic variables. */

void ssx_update_bbar(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      mpq_t *bbar = ssx->bbar;
      mpq_t *cbar = ssx->cbar;
      int p = ssx->p;
      int q = ssx->q;
      mpq_t *aq = ssx->aq;
      int i;
      mpq_t temp;
      mpq_init(temp);
      xassert(1 <= q && q <= n);
      if (p < 0)
      {  /* xN[q] is double-bounded and goes to its opposite bound */
         /* nop */;
      }
      else
      {  /* xN[q] becomes xB[p] in the adjacent basis */
         /* xB.new[p] = xN[q] + delta xN[q] */
         xassert(1 <= p && p <= m);
         ssx_get_xNj(ssx, q, temp);
         mpq_add(bbar[p], temp, ssx->delta);
      }
      /* update values of other basic variables depending on xN[q] */
      for (i = 1; i <= m; i++)
      {  if (i == p) continue;
         /* xB.new[i] = xB[i] + alfa[i,q] * delta xN[q] */
         if (mpq_sgn(aq[i]) == 0) continue;
         mpq_mul(temp, aq[i], ssx->delta);
         mpq_add(bbar[i], bbar[i], temp);
      }
#if 1
      /* update value of the objective function */
      /* z.new = z + d[q] * delta xN[q] */
      mpq_mul(temp, cbar[q], ssx->delta);
      mpq_add(bbar[0], bbar[0], temp);
#endif
      mpq_clear(temp);
      return;
}

/*----------------------------------------------------------------------
-- ssx_update_pi - update simplex multipliers.
--
-- This routine recomputes the vector of simplex multipliers for the
-- adjacent basis. */

void ssx_update_pi(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      mpq_t *pi = ssx->pi;
      mpq_t *cbar = ssx->cbar;
      int p = ssx->p;
      int q = ssx->q;
      mpq_t *aq = ssx->aq;
      mpq_t *rho = ssx->rho;
      int i;
      mpq_t new_dq, temp;
      mpq_init(new_dq);
      mpq_init(temp);
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n);
      /* compute d[q] in the adjacent basis */
      mpq_div(new_dq, cbar[q], aq[p]);
      /* update the vector of simplex multipliers */
      for (i = 1; i <= m; i++)
      {  if (mpq_sgn(rho[i]) == 0) continue;
         mpq_mul(temp, new_dq, rho[i]);
         mpq_sub(pi[i], pi[i], temp);
      }
      mpq_clear(new_dq);
      mpq_clear(temp);
      return;
}

/*----------------------------------------------------------------------
// ssx_update_cbar - update reduced costs of non-basic variables.
//
// This routine recomputes the vector of reduced costs of non-basic
// variables for the adjacent basis. */

void ssx_update_cbar(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      mpq_t *cbar = ssx->cbar;
      int p = ssx->p;
      int q = ssx->q;
      mpq_t *ap = ssx->ap;
      int j;
      mpq_t temp;
      mpq_init(temp);
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n);
      /* compute d[q] in the adjacent basis */
      /* d.new[q] = d[q] / alfa[p,q] */
      mpq_div(cbar[q], cbar[q], ap[q]);
      /* update reduced costs of other non-basic variables */
      for (j = 1; j <= n; j++)
      {  if (j == q) continue;
         /* d.new[j] = d[j] - (alfa[p,j] / alfa[p,q]) * d[q] */
         if (mpq_sgn(ap[j]) == 0) continue;
         mpq_mul(temp, ap[j], cbar[q]);
         mpq_sub(cbar[j], cbar[j], temp);
      }
      mpq_clear(temp);
      return;
}

/*----------------------------------------------------------------------
// ssx_change_basis - change current basis to adjacent one.
//
// This routine changes the current basis to the adjacent one swapping
// basic variable xB[p] and non-basic variable xN[q]. */

void ssx_change_basis(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      int *type = ssx->type;
      int *stat = ssx->stat;
      int *Q_row = ssx->Q_row;
      int *Q_col = ssx->Q_col;
      int p = ssx->p;
      int q = ssx->q;
      int p_stat = ssx->p_stat;
      int k, kp, kq;
      if (p < 0)
      {  /* special case: xN[q] goes to its opposite bound */
         xassert(1 <= q && q <= n);
         k = Q_col[m+q]; /* x[k] = xN[q] */
         xassert(type[k] == SSX_DB);
         switch (stat[k])
         {  case SSX_NL:
               stat[k] = SSX_NU;
               break;
            case SSX_NU:
               stat[k] = SSX_NL;
               break;
            default:
               xassert(stat != stat);
         }
      }
      else
      {  /* xB[p] leaves the basis, xN[q] enters the basis */
         xassert(1 <= p && p <= m);
         xassert(1 <= q && q <= n);
         kp = Q_col[p];   /* x[kp] = xB[p] */
         kq = Q_col[m+q]; /* x[kq] = xN[q] */
         /* check non-basic status of xB[p] which becomes xN[q] */
         switch (type[kp])
         {  case SSX_FR:
               xassert(p_stat == SSX_NF);
               break;
            case SSX_LO:
               xassert(p_stat == SSX_NL);
               break;
            case SSX_UP:
               xassert(p_stat == SSX_NU);
               break;
            case SSX_DB:
               xassert(p_stat == SSX_NL || p_stat == SSX_NU);
               break;
            case SSX_FX:
               xassert(p_stat == SSX_NS);
               break;
            default:
               xassert(type != type);
         }
         /* swap xB[p] and xN[q] */
         stat[kp] = (char)p_stat, stat[kq] = SSX_BS;
         Q_row[kp] = m+q, Q_row[kq] = p;
         Q_col[p] = kq, Q_col[m+q] = kp;
         /* update factorization of the basis matrix */
         if (bfx_update(ssx->binv, p))
         {  if (ssx_factorize(ssx))
               xassert(("Internal error: basis matrix is singular", 0));
         }
      }
      return;
}

/*----------------------------------------------------------------------
// ssx_delete - delete simplex solver workspace.
//
// This routine deletes the simplex solver workspace freeing all the
// memory allocated to this object. */

void ssx_delete(SSX *ssx)
{     int m = ssx->m;
      int n = ssx->n;
      int nnz = ssx->A_ptr[n+1]-1;
      int i, j, k;
      xfree(ssx->type);
      for (k = 1; k <= m+n; k++) mpq_clear(ssx->lb[k]);
      xfree(ssx->lb);
      for (k = 1; k <= m+n; k++) mpq_clear(ssx->ub[k]);
      xfree(ssx->ub);
      for (k = 0; k <= m+n; k++) mpq_clear(ssx->coef[k]);
      xfree(ssx->coef);
      xfree(ssx->A_ptr);
      xfree(ssx->A_ind);
      for (k = 1; k <= nnz; k++) mpq_clear(ssx->A_val[k]);
      xfree(ssx->A_val);
      xfree(ssx->stat);
      xfree(ssx->Q_row);
      xfree(ssx->Q_col);
      bfx_delete_binv(ssx->binv);
      for (i = 0; i <= m; i++) mpq_clear(ssx->bbar[i]);
      xfree(ssx->bbar);
      for (i = 1; i <= m; i++) mpq_clear(ssx->pi[i]);
      xfree(ssx->pi);
      for (j = 1; j <= n; j++) mpq_clear(ssx->cbar[j]);
      xfree(ssx->cbar);
      for (i = 1; i <= m; i++) mpq_clear(ssx->rho[i]);
      xfree(ssx->rho);
      for (j = 1; j <= n; j++) mpq_clear(ssx->ap[j]);
      xfree(ssx->ap);
      for (i = 1; i <= m; i++) mpq_clear(ssx->aq[i]);
      xfree(ssx->aq);
      mpq_clear(ssx->delta);
      xfree(ssx);
      return;
}








#define ITER_MAX 100
/* maximal number of iterations */

struct csa2
{     /* common storage area */
      /*--------------------------------------------------------------*/
      /* LP data */
      int m;
      /* number of rows (equality constraints) */
      int n;
      /* number of columns (structural variables) */
      int *A_ptr; /* int A_ptr[1+m+1]; */
      int *A_ind; /* int A_ind[A_ptr[m+1]]; */
      double *A_val; /* double A_val[A_ptr[m+1]]; */
      /* mxn-matrix A in storage-by-rows format */
      double *b; /* double b[1+m]; */
      /* m-vector b of right-hand sides */
      double *c; /* double c[1+n]; */
      /* n-vector c of objective coefficients; c[0] is constant term of
         the objective function */
      /*--------------------------------------------------------------*/
      /* LP solution */
      double *x; /* double x[1+n]; */
      double *y; /* double y[1+m]; */
      double *z; /* double z[1+n]; */
      /* current point in primal-dual space; the best point on exit */
      /*--------------------------------------------------------------*/
      /* control parameters */
      const glp_iptcp *parm;
      /*--------------------------------------------------------------*/
      /* working arrays and variables */
      double *D; /* double D[1+n]; */
      /* diagonal nxn-matrix D = X*inv(Z), where X = diag(x[j]) and
         Z = diag(z[j]) */
      int *P; /* int P[1+m+m]; */
      /* permutation mxm-matrix P used to minimize fill-in in Cholesky
         factorization */
      int *S_ptr; /* int S_ptr[1+m+1]; */
      int *S_ind; /* int S_ind[S_ptr[m+1]]; */
      double *S_val; /* double S_val[S_ptr[m+1]]; */
      double *S_diag; /* double S_diag[1+m]; */
      /* symmetric mxm-matrix S = P*A*D*A'*P' whose upper triangular
         part without diagonal elements is stored in S_ptr, S_ind, and
         S_val in storage-by-rows format, diagonal elements are stored
         in S_diag */
      int *U_ptr; /* int U_ptr[1+m+1]; */
      int *U_ind; /* int U_ind[U_ptr[m+1]]; */
      double *U_val; /* double U_val[U_ptr[m+1]]; */
      double *U_diag; /* double U_diag[1+m]; */
      /* upper triangular mxm-matrix U defining Cholesky factorization
         S = U'*U; its non-diagonal elements are stored in U_ptr, U_ind,
         U_val in storage-by-rows format, diagonal elements are stored
         in U_diag */
      int iter;
      /* iteration number (0, 1, 2, ...); iter = 0 corresponds to the
         initial point */
      double obj;
      /* current value of the objective function */
      double rpi;
      /* relative primal infeasibility rpi = ||A*x-b||/(1+||b||) */
      double rdi;
      /* relative dual infeasibility rdi = ||A'*y+z-c||/(1+||c||) */
      double gap;
      /* primal-dual gap = |c'*x-b'*y|/(1+|c'*x|) which is a relative
         difference between primal and dual objective functions */
      double phi;
      /* merit function phi = ||A*x-b||/max(1,||b||) +
                            + ||A'*y+z-c||/max(1,||c||) +
                            + |c'*x-b'*y|/max(1,||b||,||c||) */
      double mu;
      /* duality measure mu = x'*z/n (used as barrier parameter) */
      double rmu;
      /* rmu = max(||A*x-b||,||A'*y+z-c||)/mu */
      double rmu0;
      /* the initial value of rmu on iteration 0 */
      double *phi_min; /* double phi_min[1+ITER_MAX]; */
      /* phi_min[k] = min(phi[k]), where phi[k] is the value of phi on
         k-th iteration, 0 <= k <= iter */
      int best_iter;
      /* iteration number, on which the value of phi reached its best
         (minimal) value */
      double *best_x; /* double best_x[1+n]; */
      double *best_y; /* double best_y[1+m]; */
      double *best_z; /* double best_z[1+n]; */
      /* best point (in the sense of the merit function phi) which has
         been reached on iteration iter_best */
      double best_obj;
      /* objective value at the best point */
      double *dx_aff; /* double dx_aff[1+n]; */
      double *dy_aff; /* double dy_aff[1+m]; */
      double *dz_aff; /* double dz_aff[1+n]; */
      /* affine scaling direction */
      double alfa_aff_p, alfa_aff_d;
      /* maximal primal and dual stepsizes in affine scaling direction,
         on which x and z are still non-negative */
      double mu_aff;
      /* duality measure mu_aff = x_aff'*z_aff/n in the boundary point
         x_aff' = x+alfa_aff_p*dx_aff, z_aff' = z+alfa_aff_d*dz_aff */
      double sigma;
      /* Mehrotra's heuristic parameter (0 <= sigma <= 1) */
      double *dx_cc; /* double dx_cc[1+n]; */
      double *dy_cc; /* double dy_cc[1+m]; */
      double *dz_cc; /* double dz_cc[1+n]; */
      /* centering corrector direction */
      double *dx; /* double dx[1+n]; */
      double *dy; /* double dy[1+m]; */
      double *dz; /* double dz[1+n]; */
      /* final combined direction dx = dx_aff+dx_cc, dy = dy_aff+dy_cc,
         dz = dz_aff+dz_cc */
      double alfa_max_p;
      double alfa_max_d;
      /* maximal primal and dual stepsizes in combined direction, on
         which x and z are still non-negative */
};

/***********************************************************************
*  initialize - allocate and initialize common storage area
*
*  This routine allocates and initializes the common storage area (CSA)
*  used by interior-point method routines. */

static void initialize2(struct csa2 *csa)
{     int m = csa->m;
      int n = csa->n;
      int i;
      if (csa->parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Matrix A has %d non-zeros\n", csa->A_ptr[m+1]-1);
      csa->D = xcalloc(1+n, sizeof(double));
      /* P := I */
      csa->P = xcalloc(1+m+m, sizeof(int));
      for (i = 1; i <= m; i++) csa->P[i] = csa->P[m+i] = i;
      /* S := A*A', symbolically */
      csa->S_ptr = xcalloc(1+m+1, sizeof(int));
      csa->S_ind = adat_symbolic(m, n, csa->P, csa->A_ptr, csa->A_ind,
         csa->S_ptr);
      if (csa->parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Matrix S = A*A' has %d non-zeros (upper triangle)\n",
            csa->S_ptr[m+1]-1 + m);
      /* determine P using specified ordering algorithm */
      if (csa->parm->ord_alg == GLP_ORD_NONE)
      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
            xprintf("Original ordering is being used\n");
         for (i = 1; i <= m; i++)
            csa->P[i] = csa->P[m+i] = i;
      }
      else if (csa->parm->ord_alg == GLP_ORD_QMD)
      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
            xprintf("Minimum degree ordering (QMD)...\n");
         min_degree(m, csa->S_ptr, csa->S_ind, csa->P);
      }
      else if (csa->parm->ord_alg == GLP_ORD_AMD)
      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
            xprintf("Approximate minimum degree ordering (AMD)...\n");
         amd_order1(m, csa->S_ptr, csa->S_ind, csa->P);
      }
      else if (csa->parm->ord_alg == GLP_ORD_SYMAMD)
      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
            xprintf("Approximate minimum degree ordering (SYMAMD)...\n")
               ;
         symamd_ord(m, csa->S_ptr, csa->S_ind, csa->P);
      }
      else
         xassert(csa != csa);
      /* S := P*A*A'*P', symbolically */
      xfree(csa->S_ind);
      csa->S_ind = adat_symbolic(m, n, csa->P, csa->A_ptr, csa->A_ind,
         csa->S_ptr);
      csa->S_val = xcalloc(csa->S_ptr[m+1], sizeof(double));
      csa->S_diag = xcalloc(1+m, sizeof(double));
      /* compute Cholesky factorization S = U'*U, symbolically */
      if (csa->parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Computing Cholesky factorization S = L*L'...\n");
      csa->U_ptr = xcalloc(1+m+1, sizeof(int));
      csa->U_ind = chol_symbolic(m, csa->S_ptr, csa->S_ind, csa->U_ptr);
      if (csa->parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Matrix L has %d non-zeros\n", csa->U_ptr[m+1]-1 + m);
      csa->U_val = xcalloc(csa->U_ptr[m+1], sizeof(double));
      csa->U_diag = xcalloc(1+m, sizeof(double));
      csa->iter = 0;
      csa->obj = 0.0;
      csa->rpi = 0.0;
      csa->rdi = 0.0;
      csa->gap = 0.0;
      csa->phi = 0.0;
      csa->mu = 0.0;
      csa->rmu = 0.0;
      csa->rmu0 = 0.0;
      csa->phi_min = xcalloc(1+ITER_MAX, sizeof(double));
      csa->best_iter = 0;
      csa->best_x = xcalloc(1+n, sizeof(double));
      csa->best_y = xcalloc(1+m, sizeof(double));
      csa->best_z = xcalloc(1+n, sizeof(double));
      csa->best_obj = 0.0;
      csa->dx_aff = xcalloc(1+n, sizeof(double));
      csa->dy_aff = xcalloc(1+m, sizeof(double));
      csa->dz_aff = xcalloc(1+n, sizeof(double));
      csa->alfa_aff_p = 0.0;
      csa->alfa_aff_d = 0.0;
      csa->mu_aff = 0.0;
      csa->sigma = 0.0;
      csa->dx_cc = xcalloc(1+n, sizeof(double));
      csa->dy_cc = xcalloc(1+m, sizeof(double));
      csa->dz_cc = xcalloc(1+n, sizeof(double));
      csa->dx = csa->dx_aff;
      csa->dy = csa->dy_aff;
      csa->dz = csa->dz_aff;
      csa->alfa_max_p = 0.0;
      csa->alfa_max_d = 0.0;
      return;
}

/***********************************************************************
*  A_by_vec - compute y = A*x
*
*  This routine computes matrix-vector product y = A*x, where A is the
*  constraint matrix. */

static void A_by_vec(struct csa2 *csa, double x[], double y[])
{     /* compute y = A*x */
      int m = csa->m;
      int *A_ptr = csa->A_ptr;
      int *A_ind = csa->A_ind;
      double *A_val = csa->A_val;
      int i, t, beg, end;
      double temp;
      for (i = 1; i <= m; i++)
      {  temp = 0.0;
         beg = A_ptr[i], end = A_ptr[i+1];
         for (t = beg; t < end; t++) temp += A_val[t] * x[A_ind[t]];
         y[i] = temp;
      }
      return;
}

/***********************************************************************
*  AT_by_vec - compute y = A'*x
*
*  This routine computes matrix-vector product y = A'*x, where A' is a
*  matrix transposed to the constraint matrix A. */

static void AT_by_vec(struct csa2 *csa, double x[], double y[])
{     /* compute y = A'*x, where A' is transposed to A */
      int m = csa->m;
      int n = csa->n;
      int *A_ptr = csa->A_ptr;
      int *A_ind = csa->A_ind;
      double *A_val = csa->A_val;
      int i, j, t, beg, end;
      double temp;
      for (j = 1; j <= n; j++) y[j] = 0.0;
      for (i = 1; i <= m; i++)
      {  temp = x[i];
         if (temp == 0.0) continue;
         beg = A_ptr[i], end = A_ptr[i+1];
         for (t = beg; t < end; t++) y[A_ind[t]] += A_val[t] * temp;
      }
      return;
}

/***********************************************************************
*  decomp_NE - numeric factorization of matrix S = P*A*D*A'*P'
*
*  This routine implements numeric phase of Cholesky factorization of
*  the matrix S = P*A*D*A'*P', which is a permuted matrix of the normal
*  equation system. Matrix D is assumed to be already computed. */

static void decomp_NE(struct csa2 *csa)
{     adat_numeric(csa->m, csa->n, csa->P, csa->A_ptr, csa->A_ind,
         csa->A_val, csa->D, csa->S_ptr, csa->S_ind, csa->S_val,
         csa->S_diag);
      chol_numeric(csa->m, csa->S_ptr, csa->S_ind, csa->S_val,
         csa->S_diag, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag);
      return;
}

/***********************************************************************
*  solve_NE - solve normal equation system
*
*  This routine solves the normal equation system:
*
*     A*D*A'*y = h.
*
*  It is assumed that the matrix A*D*A' has been previously factorized
*  by the routine decomp_NE.
*
*  On entry the array y contains the vector of right-hand sides h. On
*  exit this array contains the computed vector of unknowns y.
*
*  Once the vector y has been computed the routine checks for numeric
*  stability. If the residual vector:
*
*     r = A*D*A'*y - h
*
*  is relatively small, the routine returns zero, otherwise non-zero is
*  returned. */

static int solve_NE(struct csa2 *csa, double y[])
{     int m = csa->m;
      int n = csa->n;
      int *P = csa->P;
      int i, j, ret = 0;
      double *h, *r, *w;
      /* save vector of right-hand sides h */
      h = xcalloc(1+m, sizeof(double));
      for (i = 1; i <= m; i++) h[i] = y[i];
      /* solve normal equation system (A*D*A')*y = h */
      /* since S = P*A*D*A'*P' = U'*U, then A*D*A' = P'*U'*U*P, so we
         have inv(A*D*A') = P'*inv(U)*inv(U')*P */
      /* w := P*h */
      w = xcalloc(1+m, sizeof(double));
      for (i = 1; i <= m; i++) w[i] = y[P[i]];
      /* w := inv(U')*w */
      ut_solve(m, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag, w);
      /* w := inv(U)*w */
      u_solve(m, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag, w);
      /* y := P'*w */
      for (i = 1; i <= m; i++) y[i] = w[P[m+i]];
      xfree(w);
      /* compute residual vector r = A*D*A'*y - h */
      r = xcalloc(1+m, sizeof(double));
      /* w := A'*y */
      w = xcalloc(1+n, sizeof(double));
      AT_by_vec(csa, y, w);
      /* w := D*w */
      for (j = 1; j <= n; j++) w[j] *= csa->D[j];
      /* r := A*w */
      A_by_vec(csa, w, r);
      xfree(w);
      /* r := r - h */
      for (i = 1; i <= m; i++) r[i] -= h[i];
      /* check for numeric stability */
      for (i = 1; i <= m; i++)
      {  if (fabs(r[i]) / (1.0 + fabs(h[i])) > 1e-4)
         {  ret = 1;
            break;
         }
      }
      xfree(h);
      xfree(r);
      return ret;
}

/***********************************************************************
*  solve_NS - solve Newtonian system
*
*  This routine solves the Newtonian system:
*
*     A*dx               = p
*
*           A'*dy +   dz = q
*
*     Z*dx        + X*dz = r
*
*  where X = diag(x[j]), Z = diag(z[j]), by reducing it to the normal
*  equation system:
*
*     (A*inv(Z)*X*A')*dy = A*inv(Z)*(X*q-r)+p
*
*  (it is assumed that the matrix A*inv(Z)*X*A' has been factorized by
*  the routine decomp_NE).
*
*  Once vector dy has been computed the routine computes vectors dx and
*  dz as follows:
*
*     dx = inv(Z)*(X*(A'*dy-q)+r)
*
*     dz = inv(X)*(r-Z*dx)
*
*  The routine solve_NS returns the same code which was reported by the
*  routine solve_NE (see above). */

static int solve_NS(struct csa2 *csa, double p[], double q[], double r[],
      double dx[], double dy[], double dz[])
{     int m = csa->m;
      int n = csa->n;
      double *x = csa->x;
      double *z = csa->z;
      int i, j, ret;
      double *w = dx;
      /* compute the vector of right-hand sides A*inv(Z)*(X*q-r)+p for
         the normal equation system */
      for (j = 1; j <= n; j++)
         w[j] = (x[j] * q[j] - r[j]) / z[j];
      A_by_vec(csa, w, dy);
      for (i = 1; i <= m; i++) dy[i] += p[i];
      /* solve the normal equation system to compute vector dy */
      ret = solve_NE(csa, dy);
      /* compute vectors dx and dz */
      AT_by_vec(csa, dy, dx);
      for (j = 1; j <= n; j++)
      {  dx[j] = (x[j] * (dx[j] - q[j]) + r[j]) / z[j];
         dz[j] = (r[j] - z[j] * dx[j]) / x[j];
      }
      return ret;
}

/***********************************************************************
*  initial_point - choose initial point using Mehrotra's heuristic
*
*  This routine chooses a starting point using a heuristic proposed in
*  the paper:
*
*  S. Mehrotra. On the implementation of a primal-dual interior point
*  method. SIAM J. on Optim., 2(4), pp. 575-601, 1992.
*
*  The starting point x in the primal space is chosen as a solution of
*  the following least squares problem:
*
*     minimize    ||x||
*
*     subject to  A*x = b
*
*  which can be computed explicitly as follows:
*
*     x = A'*inv(A*A')*b
*
*  Similarly, the starting point (y, z) in the dual space is chosen as
*  a solution of the following least squares problem:
*
*     minimize    ||z||
*
*     subject to  A'*y + z = c
*
*  which can be computed explicitly as follows:
*
*     y = inv(A*A')*A*c
*
*     z = c - A'*y
*
*  However, some components of the vectors x and z may be non-positive
*  or close to zero, so the routine uses a Mehrotra's heuristic to find
*  a more appropriate starting point. */

static void initial_point(struct csa2 *csa)
{     int m = csa->m;
      int n = csa->n;
      double *b = csa->b;
      double *c = csa->c;
      double *x = csa->x;
      double *y = csa->y;
      double *z = csa->z;
      double *D = csa->D;
      int i, j;
      double dp, dd, ex, ez, xz;
      /* factorize A*A' */
      for (j = 1; j <= n; j++) D[j] = 1.0;
      decomp_NE(csa);
      /* x~ = A'*inv(A*A')*b */
      for (i = 1; i <= m; i++) y[i] = b[i];
      solve_NE(csa, y);
      AT_by_vec(csa, y, x);
      /* y~ = inv(A*A')*A*c */
      A_by_vec(csa, c, y);
      solve_NE(csa, y);
      /* z~ = c - A'*y~ */
      AT_by_vec(csa, y,z);
      for (j = 1; j <= n; j++) z[j] = c[j] - z[j];
      /* use Mehrotra's heuristic in order to choose more appropriate
         starting point with positive components of vectors x and z */
      dp = dd = 0.0;
      for (j = 1; j <= n; j++)
      {  if (dp < -1.5 * x[j]) dp = -1.5 * x[j];
         if (dd < -1.5 * z[j]) dd = -1.5 * z[j];
      }
      /* note that b = 0 involves x = 0, and c = 0 involves y = 0 and
         z = 0, so we need to be careful */
      if (dp == 0.0) dp = 1.5;
      if (dd == 0.0) dd = 1.5;
      ex = ez = xz = 0.0;
      for (j = 1; j <= n; j++)
      {  ex += (x[j] + dp);
         ez += (z[j] + dd);
         xz += (x[j] + dp) * (z[j] + dd);
      }
      dp += 0.5 * (xz / ez);
      dd += 0.5 * (xz / ex);
      for (j = 1; j <= n; j++)
      {  x[j] += dp;
         z[j] += dd;
         xassert(x[j] > 0.0 && z[j] > 0.0);
      }
      return;
}

/***********************************************************************
*  basic_info - perform basic computations at the current point
*
*  This routine computes the following quantities at the current point:
*
*  1) value of the objective function:
*
*     F = c'*x + c[0]
*
*  2) relative primal infeasibility:
*
*     rpi = ||A*x-b|| / (1+||b||)
*
*  3) relative dual infeasibility:
*
*     rdi = ||A'*y+z-c|| / (1+||c||)
*
*  4) primal-dual gap (relative difference between the primal and the
*     dual objective function values):
*
*     gap = |c'*x-b'*y| / (1+|c'*x|)
*
*  5) merit function:
*
*     phi = ||A*x-b|| / max(1,||b||) + ||A'*y+z-c|| / max(1,||c||) +
*
*         + |c'*x-b'*y| / max(1,||b||,||c||)
*
*  6) duality measure:
*
*     mu = x'*z / n
*
*  7) the ratio of infeasibility to mu:
*
*     rmu = max(||A*x-b||,||A'*y+z-c||) / mu
*
*  where ||*|| denotes euclidian norm, *' denotes transposition. */

static void basic_info(struct csa2 *csa)
{     int m = csa->m;
      int n = csa->n;
      double *b = csa->b;
      double *c = csa->c;
      double *x = csa->x;
      double *y = csa->y;
      double *z = csa->z;
      int i, j;
      double norm1, bnorm, norm2, cnorm, cx, by, *work, temp;
      /* compute value of the objective function */
      temp = c[0];
      for (j = 1; j <= n; j++) temp += c[j] * x[j];
      csa->obj = temp;
      /* norm1 = ||A*x-b|| */
      work = xcalloc(1+m, sizeof(double));
      A_by_vec(csa, x, work);
      norm1 = 0.0;
      for (i = 1; i <= m; i++)
         norm1 += (work[i] - b[i]) * (work[i] - b[i]);
      norm1 = sqrt(norm1);
      xfree(work);
      /* bnorm = ||b|| */
      bnorm = 0.0;
      for (i = 1; i <= m; i++) bnorm += b[i] * b[i];
      bnorm = sqrt(bnorm);
      /* compute relative primal infeasibility */
      csa->rpi = norm1 / (1.0 + bnorm);
      /* norm2 = ||A'*y+z-c|| */
      work = xcalloc(1+n, sizeof(double));
      AT_by_vec(csa, y, work);
      norm2 = 0.0;
      for (j = 1; j <= n; j++)
         norm2 += (work[j] + z[j] - c[j]) * (work[j] + z[j] - c[j]);
      norm2 = sqrt(norm2);
      xfree(work);
      /* cnorm = ||c|| */
      cnorm = 0.0;
      for (j = 1; j <= n; j++) cnorm += c[j] * c[j];
      cnorm = sqrt(cnorm);
      /* compute relative dual infeasibility */
      csa->rdi = norm2 / (1.0 + cnorm);
      /* by = b'*y */
      by = 0.0;
      for (i = 1; i <= m; i++) by += b[i] * y[i];
      /* cx = c'*x */
      cx = 0.0;
      for (j = 1; j <= n; j++) cx += c[j] * x[j];
      /* compute primal-dual gap */
      csa->gap = fabs(cx - by) / (1.0 + fabs(cx));
      /* compute merit function */
      csa->phi = 0.0;
      csa->phi += norm1 / (bnorm > 1.0 ? bnorm : 1.0);
      csa->phi += norm2 / (cnorm > 1.0 ? cnorm : 1.0);
      temp = 1.0;
      if (temp < bnorm) temp = bnorm;
      if (temp < cnorm) temp = cnorm;
      csa->phi += fabs(cx - by) / temp;
      /* compute duality measure */
      temp = 0.0;
      for (j = 1; j <= n; j++) temp += x[j] * z[j];
      csa->mu = temp / (double)n;
      /* compute the ratio of infeasibility to mu */
      csa->rmu = (norm1 > norm2 ? norm1 : norm2) / csa->mu;
      return;
}

/***********************************************************************
*  make_step - compute next point using Mehrotra's technique
*
*  This routine computes the next point using the predictor-corrector
*  technique proposed in the paper:
*
*  S. Mehrotra. On the implementation of a primal-dual interior point
*  method. SIAM J. on Optim., 2(4), pp. 575-601, 1992.
*
*  At first, the routine computes so called affine scaling (predictor)
*  direction (dx_aff,dy_aff,dz_aff) which is a solution of the system:
*
*     A*dx_aff                       = b - A*x
*
*               A'*dy_aff +   dz_aff = c - A'*y - z
*
*     Z*dx_aff            + X*dz_aff = - X*Z*e
*
*  where (x,y,z) is the current point, X = diag(x[j]), Z = diag(z[j]),
*  e = (1,...,1)'.
*
*  Then, the routine computes the centering parameter sigma, using the
*  following Mehrotra's heuristic:
*
*     alfa_aff_p = inf{0 <= alfa <= 1 | x+alfa*dx_aff >= 0}
*
*     alfa_aff_d = inf{0 <= alfa <= 1 | z+alfa*dz_aff >= 0}
*
*     mu_aff = (x+alfa_aff_p*dx_aff)'*(z+alfa_aff_d*dz_aff)/n
*
*     sigma = (mu_aff/mu)^3
*
*  where alfa_aff_p is the maximal stepsize along the affine scaling
*  direction in the primal space, alfa_aff_d is the maximal stepsize
*  along the same direction in the dual space.
*
*  After determining sigma the routine computes so called centering
*  (corrector) direction (dx_cc,dy_cc,dz_cc) which is the solution of
*  the system:
*
*     A*dx_cc                     = 0
*
*              A'*dy_cc +   dz_cc = 0
*
*     Z*dx_cc           + X*dz_cc = sigma*mu*e - X*Z*e
*
*  Finally, the routine computes the combined direction
*
*     (dx,dy,dz) = (dx_aff,dy_aff,dz_aff) + (dx_cc,dy_cc,dz_cc)
*
*  and determines maximal primal and dual stepsizes along the combined
*  direction:
*
*     alfa_max_p = inf{0 <= alfa <= 1 | x+alfa*dx >= 0}
*
*     alfa_max_d = inf{0 <= alfa <= 1 | z+alfa*dz >= 0}
*
*  In order to prevent the next point to be too close to the boundary
*  of the positive ortant, the routine decreases maximal stepsizes:
*
*     alfa_p = gamma_p * alfa_max_p
*
*     alfa_d = gamma_d * alfa_max_d
*
*  where gamma_p and gamma_d are scaling factors, and computes the next
*  point:
*
*     x_new = x + alfa_p * dx
*
*     y_new = y + alfa_d * dy
*
*     z_new = z + alfa_d * dz
*
*  which becomes the current point on the next iteration. */

static int make_step(struct csa2 *csa)
{     int m = csa->m;
      int n = csa->n;
      double *b = csa->b;
      double *c = csa->c;
      double *x = csa->x;
      double *y = csa->y;
      double *z = csa->z;
      double *dx_aff = csa->dx_aff;
      double *dy_aff = csa->dy_aff;
      double *dz_aff = csa->dz_aff;
      double *dx_cc = csa->dx_cc;
      double *dy_cc = csa->dy_cc;
      double *dz_cc = csa->dz_cc;
      double *dx = csa->dx;
      double *dy = csa->dy;
      double *dz = csa->dz;
      int i, j, ret = 0;
      double temp, gamma_p, gamma_d, *p, *q, *r;
      /* allocate working arrays */
      p = xcalloc(1+m, sizeof(double));
      q = xcalloc(1+n, sizeof(double));
      r = xcalloc(1+n, sizeof(double));
      /* p = b - A*x */
      A_by_vec(csa, x, p);
      for (i = 1; i <= m; i++) p[i] = b[i] - p[i];
      /* q = c - A'*y - z */
      AT_by_vec(csa, y,q);
      for (j = 1; j <= n; j++) q[j] = c[j] - q[j] - z[j];
      /* r = - X * Z * e */
      for (j = 1; j <= n; j++) r[j] = - x[j] * z[j];
      /* solve the first Newtonian system */
      if (solve_NS(csa, p, q, r, dx_aff, dy_aff, dz_aff))
      {  ret = 1;
         goto done;
      }
      /* alfa_aff_p = inf{0 <= alfa <= 1 | x + alfa*dx_aff >= 0} */
      /* alfa_aff_d = inf{0 <= alfa <= 1 | z + alfa*dz_aff >= 0} */
      csa->alfa_aff_p = csa->alfa_aff_d = 1.0;
      for (j = 1; j <= n; j++)
      {  if (dx_aff[j] < 0.0)
         {  temp = - x[j] / dx_aff[j];
            if (csa->alfa_aff_p > temp) csa->alfa_aff_p = temp;
         }
         if (dz_aff[j] < 0.0)
         {  temp = - z[j] / dz_aff[j];
            if (csa->alfa_aff_d > temp) csa->alfa_aff_d = temp;
         }
      }
      /* mu_aff = (x+alfa_aff_p*dx_aff)' * (z+alfa_aff_d*dz_aff) / n */
      temp = 0.0;
      for (j = 1; j <= n; j++)
         temp += (x[j] + csa->alfa_aff_p * dx_aff[j]) *
                 (z[j] + csa->alfa_aff_d * dz_aff[j]);
      csa->mu_aff = temp / (double)n;
      /* sigma = (mu_aff/mu)^3 */
      temp = csa->mu_aff / csa->mu;
      csa->sigma = temp * temp * temp;
      /* p = 0 */
      for (i = 1; i <= m; i++) p[i] = 0.0;
      /* q = 0 */
      for (j = 1; j <= n; j++) q[j] = 0.0;
      /* r = sigma * mu * e - X * Z * e */
      for (j = 1; j <= n; j++)
         r[j] = csa->sigma * csa->mu - dx_aff[j] * dz_aff[j];
      /* solve the second Newtonian system with the same coefficients
         but with altered right-hand sides */
      if (solve_NS(csa, p, q, r, dx_cc, dy_cc, dz_cc))
      {  ret = 1;
         goto done;
      }
      /* (dx,dy,dz) = (dx_aff,dy_aff,dz_aff) + (dx_cc,dy_cc,dz_cc) */
      for (j = 1; j <= n; j++) dx[j] = dx_aff[j] + dx_cc[j];
      for (i = 1; i <= m; i++) dy[i] = dy_aff[i] + dy_cc[i];
      for (j = 1; j <= n; j++) dz[j] = dz_aff[j] + dz_cc[j];
      /* alfa_max_p = inf{0 <= alfa <= 1 | x + alfa*dx >= 0} */
      /* alfa_max_d = inf{0 <= alfa <= 1 | z + alfa*dz >= 0} */
      csa->alfa_max_p = csa->alfa_max_d = 1.0;
      for (j = 1; j <= n; j++)
      {  if (dx[j] < 0.0)
         {  temp = - x[j] / dx[j];
            if (csa->alfa_max_p > temp) csa->alfa_max_p = temp;
         }
         if (dz[j] < 0.0)
         {  temp = - z[j] / dz[j];
            if (csa->alfa_max_d > temp) csa->alfa_max_d = temp;
         }
      }
      /* determine scale factors (not implemented yet) */
      gamma_p = 0.90;
      gamma_d = 0.90;
      /* compute the next point */
      for (j = 1; j <= n; j++)
      {  x[j] += gamma_p * csa->alfa_max_p * dx[j];
         xassert(x[j] > 0.0);
      }
      for (i = 1; i <= m; i++)
         y[i] += gamma_d * csa->alfa_max_d * dy[i];
      for (j = 1; j <= n; j++)
      {  z[j] += gamma_d * csa->alfa_max_d * dz[j];
         xassert(z[j] > 0.0);
      }
done: /* free working arrays */
      xfree(p);
      xfree(q);
      xfree(r);
      return ret;
}

/***********************************************************************
*  terminate - deallocate common storage area
*
*  This routine frees all memory allocated to the common storage area
*  used by interior-point method routines. */

static void terminate(struct csa2 *csa)
{     xfree(csa->D);
      xfree(csa->P);
      xfree(csa->S_ptr);
      xfree(csa->S_ind);
      xfree(csa->S_val);
      xfree(csa->S_diag);
      xfree(csa->U_ptr);
      xfree(csa->U_ind);
      xfree(csa->U_val);
      xfree(csa->U_diag);
      xfree(csa->phi_min);
      xfree(csa->best_x);
      xfree(csa->best_y);
      xfree(csa->best_z);
      xfree(csa->dx_aff);
      xfree(csa->dy_aff);
      xfree(csa->dz_aff);
      xfree(csa->dx_cc);
      xfree(csa->dy_cc);
      xfree(csa->dz_cc);
      return;
}

/***********************************************************************
*  ipm_main - main interior-point method routine
*
*  This is a main routine of the primal-dual interior-point method.
*
*  The routine ipm_main returns one of the following codes:
*
*  0 - optimal solution found;
*  1 - problem has no feasible (primal or dual) solution;
*  2 - no convergence;
*  3 - iteration limit exceeded;
*  4 - numeric instability on solving Newtonian system.
*
*  In case of non-zero return code the routine returns the best point,
*  which has been reached during optimization. */

static int ipm_main(struct csa2 *csa)
{     int m = csa->m;
      int n = csa->n;
      int i, j, status;
      double temp;
      /* choose initial point using Mehrotra's heuristic */
      if (csa->parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Guessing initial point...\n");
      initial_point(csa);
      /* main loop starts here */
      if (csa->parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Optimization begins...\n");
      for (;;)
      {  /* perform basic computations at the current point */
         basic_info(csa);
         /* save initial value of rmu */
         if (csa->iter == 0) csa->rmu0 = csa->rmu;
         /* accumulate values of min(phi[k]) and save the best point */
         xassert(csa->iter <= ITER_MAX);
         if (csa->iter == 0 || csa->phi_min[csa->iter-1] > csa->phi)
         {  csa->phi_min[csa->iter] = csa->phi;
            csa->best_iter = csa->iter;
            for (j = 1; j <= n; j++) csa->best_x[j] = csa->x[j];
            for (i = 1; i <= m; i++) csa->best_y[i] = csa->y[i];
            for (j = 1; j <= n; j++) csa->best_z[j] = csa->z[j];
            csa->best_obj = csa->obj;
         }
         else
            csa->phi_min[csa->iter] = csa->phi_min[csa->iter-1];
         /* display information at the current point */
         if (csa->parm->msg_lev >= GLP_MSG_ON)
            xprintf("%3d: obj = %17.9e; rpi = %8.1e; rdi = %8.1e; gap ="
               " %8.1e\n", csa->iter, csa->obj, csa->rpi, csa->rdi,
               csa->gap);
         /* check if the current point is optimal */
         if (csa->rpi < 1e-8 && csa->rdi < 1e-8 && csa->gap < 1e-8)
         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("OPTIMAL SOLUTION FOUND\n");
            status = 0;
            break;
         }
         /* check if the problem has no feasible solution */
         temp = 1e5 * csa->phi_min[csa->iter];
         if (temp < 1e-8) temp = 1e-8;
         if (csa->phi >= temp)
         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("PROBLEM HAS NO FEASIBLE PRIMAL/DUAL SOLUTION\n")
                  ;
            status = 1;
            break;
         }
         /* check for very slow convergence or divergence */
         if (((csa->rpi >= 1e-8 || csa->rdi >= 1e-8) && csa->rmu /
               csa->rmu0 >= 1e6) ||
               (csa->iter >= 30 && csa->phi_min[csa->iter] >= 0.5 *
               csa->phi_min[csa->iter - 30]))
         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("NO CONVERGENCE; SEARCH TERMINATED\n");
            status = 2;
            break;
         }
         /* check for maximal number of iterations */
         if (csa->iter == ITER_MAX)
         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
            status = 3;
            break;
         }
         /* start the next iteration */
         csa->iter++;
         /* factorize normal equation system */
         for (j = 1; j <= n; j++) csa->D[j] = csa->x[j] / csa->z[j];
         decomp_NE(csa);
         /* compute the next point using Mehrotra's predictor-corrector
            technique */
         if (make_step(csa))
         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("NUMERIC INSTABILITY; SEARCH TERMINATED\n");
            status = 4;
            break;
         }
      }
      /* restore the best point */
      if (status != 0)
      {  for (j = 1; j <= n; j++) csa->x[j] = csa->best_x[j];
         for (i = 1; i <= m; i++) csa->y[i] = csa->best_y[i];
         for (j = 1; j <= n; j++) csa->z[j] = csa->best_z[j];
         if (csa->parm->msg_lev >= GLP_MSG_ALL)
            xprintf("Best point %17.9e was reached on iteration %d\n",
               csa->best_obj, csa->best_iter);
      }
      /* return to the calling program */
      return status;
}

/***********************************************************************
*  NAME
*
*  ipm_solve - core LP solver based on the interior-point method
*
*  SYNOPSIS
*
*  #include "glpipm.h"
*  int ipm_solve(glp_prob *P, const glp_iptcp *parm);
*
*  DESCRIPTION
*
*  The routine ipm_solve is a core LP solver based on the primal-dual
*  interior-point method.
*
*  The routine assumes the following standard formulation of LP problem
*  to be solved:
*
*     minimize
*
*        F = c[0] + c[1]*x[1] + c[2]*x[2] + ... + c[n]*x[n]
*
*     subject to linear constraints
*
*        a[1,1]*x[1] + a[1,2]*x[2] + ... + a[1,n]*x[n] = b[1]
*
*        a[2,1]*x[1] + a[2,2]*x[2] + ... + a[2,n]*x[n] = b[2]
*
*              . . . . . .
*
*        a[m,1]*x[1] + a[m,2]*x[2] + ... + a[m,n]*x[n] = b[m]
*
*     and non-negative variables
*
*        x[1] >= 0, x[2] >= 0, ..., x[n] >= 0
*
*  where:
*  F                    is the objective function;
*  x[1], ..., x[n]      are (structural) variables;
*  c[0]                 is a constant term of the objective function;
*  c[1], ..., c[n]      are objective coefficients;
*  a[1,1], ..., a[m,n]  are constraint coefficients;
*  b[1], ..., b[n]      are right-hand sides.
*
*  The solution is three vectors x, y, and z, which are stored by the
*  routine in the arrays x, y, and z, respectively. These vectors
*  correspond to the best primal-dual point found during optimization.
*  They are approximate solution of the following system (which is the
*  Karush-Kuhn-Tucker optimality conditions):
*
*     A*x      = b      (primal feasibility condition)
*
*     A'*y + z = c      (dual feasibility condition)
*
*     x'*z     = 0      (primal-dual complementarity condition)
*
*     x >= 0, z >= 0    (non-negativity condition)
*
*  where:
*  x[1], ..., x[n]      are primal (structural) variables;
*  y[1], ..., y[m]      are dual variables (Lagrange multipliers) for
*                       equality constraints;
*  z[1], ..., z[n]      are dual variables (Lagrange multipliers) for
*                       non-negativity constraints.
*
*  RETURNS
*
*  0  LP has been successfully solved.
*
*  GLP_ENOCVG
*     No convergence.
*
*  GLP_EITLIM
*     Iteration limit exceeded.
*
*  GLP_EINSTAB
*     Numeric instability on solving Newtonian system.
*
*  In case of non-zero return code the routine returns the best point,
*  which has been reached during optimization. */

int ipm_solve(glp_prob *P, const glp_iptcp *parm)
{     struct csa2 _dsa, *csa = &_dsa;
      int m = P->m;
      int n = P->n;
      int nnz = P->nnz;
      GLPROW *row;
      GLPCOL *col;
      GLPAIJ *aij;
      int i, j, loc, ret, *A_ind, *A_ptr;
      double dir, *A_val, *b, *c, *x, *y, *z;
      xassert(m > 0);
      xassert(n > 0);
      /* allocate working arrays */
      A_ptr = xcalloc(1+m+1, sizeof(int));
      A_ind = xcalloc(1+nnz, sizeof(int));
      A_val = xcalloc(1+nnz, sizeof(double));
      b = xcalloc(1+m, sizeof(double));
      c = xcalloc(1+n, sizeof(double));
      x = xcalloc(1+n, sizeof(double));
      y = xcalloc(1+m, sizeof(double));
      z = xcalloc(1+n, sizeof(double));
      /* prepare rows and constraint coefficients */
      loc = 1;
      for (i = 1; i <= m; i++)
      {  row = P->row[i];
         xassert(row->type == GLP_FX);
         b[i] = row->lb * row->rii;
         A_ptr[i] = loc;
         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
         {  A_ind[loc] = aij->col->j;
            A_val[loc] = row->rii * aij->val * aij->col->sjj;
            loc++;
         }
      }
      A_ptr[m+1] = loc;
      xassert(loc-1 == nnz);
      /* prepare columns and objective coefficients */
      if (P->dir == GLP_MIN)
         dir = +1.0;
      else if (P->dir == GLP_MAX)
         dir = -1.0;
      else
         xassert(P != P);
      c[0] = dir * P->c0;
      for (j = 1; j <= n; j++)
      {  col = P->col[j];
         xassert(col->type == GLP_LO && col->lb == 0.0);
         c[j] = dir * col->coef * col->sjj;
      }
      /* allocate and initialize the common storage area */
      csa->m = m;
      csa->n = n;
      csa->A_ptr = A_ptr;
      csa->A_ind = A_ind;
      csa->A_val = A_val;
      csa->b = b;
      csa->c = c;
      csa->x = x;
      csa->y = y;
      csa->z = z;
      csa->parm = parm;
      initialize2(csa);
      /* solve LP with the interior-point method */
      ret = ipm_main(csa);
      /* deallocate the common storage area */
      terminate(csa);
      /* determine solution status */
      if (ret == 0)
      {  /* optimal solution found */
         P->ipt_stat = GLP_OPT;
         ret = 0;
      }
      else if (ret == 1)
      {  /* problem has no feasible (primal or dual) solution */
         P->ipt_stat = GLP_NOFEAS;
         ret = 0;
      }
      else if (ret == 2)
      {  /* no convergence */
         P->ipt_stat = GLP_INFEAS;
         ret = GLP_ENOCVG;
      }
      else if (ret == 3)
      {  /* iteration limit exceeded */
         P->ipt_stat = GLP_INFEAS;
         ret = GLP_EITLIM;
      }
      else if (ret == 4)
      {  /* numeric instability on solving Newtonian system */
         P->ipt_stat = GLP_INFEAS;
         ret = GLP_EINSTAB;
      }
      else
         xassert(ret != ret);
      /* store row solution components */
      for (i = 1; i <= m; i++)
      {  row = P->row[i];
         row->pval = row->lb;
         row->dval = dir * y[i] * row->rii;
      }
      /* store column solution components */
      P->ipt_obj = P->c0;
      for (j = 1; j <= n; j++)
      {  col = P->col[j];
         col->pval = x[j] * col->sjj;
         col->dval = dir * z[j] / col->sjj;
         P->ipt_obj += col->coef * col->pval;
      }
      /* free working arrays */
      xfree(A_ptr);
      xfree(A_ind);
      xfree(A_val);
      xfree(b);
      xfree(c);
      xfree(x);
      xfree(y);
      xfree(z);
      return ret;
} 

/* glpios07.c (mixed cover cut generator) */

/***********************************************************************
*  This code is part of GLPK (GNU Linear Programming Kit).
*
*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
*  2009, 2010, 2011, 2013 Andrew Makhorin, Department for Applied
*  Informatics, Moscow Aviation Institute, Moscow, Russia. All rights
*  reserved. E-mail: <mao@gnu.org>.
*
*  GLPK is free software: you can redistribute it and/or modify it
*  under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  GLPK is distributed in the hope that it will be useful, but WITHOUT
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
*  License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/


/*----------------------------------------------------------------------
-- COVER INEQUALITIES
--
-- Consider the set of feasible solutions to 0-1 knapsack problem:
--
--    sum a[j]*x[j] <= b,                                            (1)
--  j in J
--
--    x[j] is binary,                                                (2)
--
-- where, wlog, we assume that a[j] > 0 (since 0-1 variables can be
-- complemented) and a[j] <= b (since a[j] > b implies x[j] = 0).
--
-- A set C within J is called a cover if
--
--    sum a[j] > b.                                                  (3)
--  j in C
--
-- For any cover C the inequality
--
--    sum x[j] <= |C| - 1                                            (4)
--  j in C
--
-- is called a cover inequality and is valid for (1)-(2).
--
-- MIXED COVER INEQUALITIES
--
-- Consider the set of feasible solutions to mixed knapsack problem:
--
--    sum a[j]*x[j] + y <= b,                                        (5)
--  j in J
--
--    x[j] is binary,                                                (6)
--
--    0 <= y <= u is continuous,                                     (7)
--
-- where again we assume that a[j] > 0.
--
-- Let C within J be some set. From (1)-(4) it follows that
--
--    sum a[j] > b - y                                               (8)
--  j in C
--
-- implies
--
--    sum x[j] <= |C| - 1.                                           (9)
--  j in C
--
-- Thus, we need to modify the inequality (9) in such a way that it be
-- a constraint only if the condition (8) is satisfied.
--
-- Consider the following inequality:
--
--    sum x[j] <= |C| - t.                                          (10)
--  j in C
--
-- If 0 < t <= 1, then (10) is equivalent to (9), because all x[j] are
-- binary variables. On the other hand, if t <= 0, (10) being satisfied
-- for any values of x[j] is not a constraint.
--
-- Let
--
--    t' = sum a[j] + y - b.                                        (11)
--       j in C
--
-- It is understood that the condition t' > 0 is equivalent to (8).
-- Besides, from (6)-(7) it follows that t' has an implied upper bound:
--
--    t'max = sum a[j] + u - b.                                     (12)
--          j in C
--
-- This allows to express the parameter t having desired properties:
--
--    t = t' / t'max.                                               (13)
--
-- In fact, t <= 1 by definition, and t > 0 being equivalent to t' > 0
-- is equivalent to (8).
--
-- Thus, the inequality (10), where t is given by formula (13) is valid
-- for (5)-(7).
--
-- Note that if u = 0, then y = 0, so t = 1, and the conditions (8) and
-- (10) is transformed to the conditions (3) and (4).
--
-- GENERATING MIXED COVER CUTS
--
-- To generate a mixed cover cut in the form (10) we need to find such
-- set C which satisfies to the inequality (8) and for which, in turn,
-- the inequality (10) is violated in the current point.
--
-- Substituting t from (13) to (10) gives:
--
--                        1
--    sum x[j] <= |C| - -----  (sum a[j] + y - b),                  (14)
--  j in C              t'max j in C
--
-- and finally we have the cut inequality in the standard form:
--
--    sum x[j] + alfa * y <= beta,                                  (15)
--  j in C
--
-- where:
--
--    alfa = 1 / t'max,                                             (16)
--
--    beta = |C| - alfa *  (sum a[j] - b).                          (17)
--                        j in C                                      */

#if 1
#define MAXTRY 1000
#else
#define MAXTRY 10000
#endif

static int cover2(int n, double a[], double b, double u, double x[],
      double y, int cov[], double *_alfa, double *_beta)
{     /* try to generate mixed cover cut using two-element cover */
      int i, j, try = 0, ret = 0;
      double eps, alfa, beta, temp, rmax = 0.001;
      eps = 0.001 * (1.0 + fabs(b));
      for (i = 0+1; i <= n; i++)
      for (j = i+1; j <= n; j++)
      {  /* C = {i, j} */
         try++;
         if (try > MAXTRY) goto done;
         /* check if condition (8) is satisfied */
         if (a[i] + a[j] + y > b + eps)
         {  /* compute parameters for inequality (15) */
            temp = a[i] + a[j] - b;
            alfa = 1.0 / (temp + u);
            beta = 2.0 - alfa * temp;
            /* compute violation of inequality (15) */
            temp = x[i] + x[j] + alfa * y - beta;
            /* choose C providing maximum violation */
            if (rmax < temp)
            {  rmax = temp;
               cov[1] = i;
               cov[2] = j;
               *_alfa = alfa;
               *_beta = beta;
               ret = 1;
            }
         }
      }
done: return ret;
}

static int cover3(int n, double a[], double b, double u, double x[],
      double y, int cov[], double *_alfa, double *_beta)
{     /* try to generate mixed cover cut using three-element cover */
      int i, j, k, try = 0, ret = 0;
      double eps, alfa, beta, temp, rmax = 0.001;
      eps = 0.001 * (1.0 + fabs(b));
      for (i = 0+1; i <= n; i++)
      for (j = i+1; j <= n; j++)
      for (k = j+1; k <= n; k++)
      {  /* C = {i, j, k} */
         try++;
         if (try > MAXTRY) goto done;
         /* check if condition (8) is satisfied */
         if (a[i] + a[j] + a[k] + y > b + eps)
         {  /* compute parameters for inequality (15) */
            temp = a[i] + a[j] + a[k] - b;
            alfa = 1.0 / (temp + u);
            beta = 3.0 - alfa * temp;
            /* compute violation of inequality (15) */
            temp = x[i] + x[j] + x[k] + alfa * y - beta;
            /* choose C providing maximum violation */
            if (rmax < temp)
            {  rmax = temp;
               cov[1] = i;
               cov[2] = j;
               cov[3] = k;
               *_alfa = alfa;
               *_beta = beta;
               ret = 1;
            }
         }
      }
done: return ret;
}

static int cover4(int n, double a[], double b, double u, double x[],
      double y, int cov[], double *_alfa, double *_beta)
{     /* try to generate mixed cover cut using four-element cover */
      int i, j, k, l, try = 0, ret = 0;
      double eps, alfa, beta, temp, rmax = 0.001;
      eps = 0.001 * (1.0 + fabs(b));
      for (i = 0+1; i <= n; i++)
      for (j = i+1; j <= n; j++)
      for (k = j+1; k <= n; k++)
      for (l = k+1; l <= n; l++)
      {  /* C = {i, j, k, l} */
         try++;
         if (try > MAXTRY) goto done;
         /* check if condition (8) is satisfied */
         if (a[i] + a[j] + a[k] + a[l] + y > b + eps)
         {  /* compute parameters for inequality (15) */
            temp = a[i] + a[j] + a[k] + a[l] - b;
            alfa = 1.0 / (temp + u);
            beta = 4.0 - alfa * temp;
            /* compute violation of inequality (15) */
            temp = x[i] + x[j] + x[k] + x[l] + alfa * y - beta;
            /* choose C providing maximum violation */
            if (rmax < temp)
            {  rmax = temp;
               cov[1] = i;
               cov[2] = j;
               cov[3] = k;
               cov[4] = l;
               *_alfa = alfa;
               *_beta = beta;
               ret = 1;
            }
         }
      }
done: return ret;
}

static int cover(int n, double a[], double b, double u, double x[],
      double y, int cov[], double *alfa, double *beta)
{     /* try to generate mixed cover cut;
         input (see (5)):
         n        is the number of binary variables;
         a[1:n]   are coefficients at binary variables;
         b        is the right-hand side;
         u        is upper bound of continuous variable;
         x[1:n]   are values of binary variables at current point;
         y        is value of continuous variable at current point;
         output (see (15), (16), (17)):
         cov[1:r] are indices of binary variables included in cover C,
                  where r is the set cardinality returned on exit;
         alfa     coefficient at continuous variable;
         beta     is the right-hand side; */
      int j;
      /* perform some sanity checks */
      xassert(n >= 2);
      for (j = 1; j <= n; j++) xassert(a[j] > 0.0);
#if 1 /* ??? */
      xassert(b > -1e-5);
#else
      xassert(b > 0.0);
#endif
      xassert(u >= 0.0);
      for (j = 1; j <= n; j++) xassert(0.0 <= x[j] && x[j] <= 1.0);
      xassert(0.0 <= y && y <= u);
      /* try to generate mixed cover cut */
      if (cover2(n, a, b, u, x, y, cov, alfa, beta)) return 2;
      if (cover3(n, a, b, u, x, y, cov, alfa, beta)) return 3;
      if (cover4(n, a, b, u, x, y, cov, alfa, beta)) return 4;
      return 0;
}

/*----------------------------------------------------------------------
-- lpx_cover_cut - generate mixed cover cut.
--
-- SYNOPSIS
--
-- int lpx_cover_cut(LPX *lp, int len, int ind[], double val[],
--    double work[]);
--
-- DESCRIPTION
--
-- The routine lpx_cover_cut generates a mixed cover cut for a given
-- row of the MIP problem.
--
-- The given row of the MIP problem should be explicitly specified in
-- the form:
--
--    sum{j in J} a[j]*x[j] <= b.                                    (1)
--
-- On entry indices (ordinal numbers) of structural variables, which
-- have non-zero constraint coefficients, should be placed in locations
-- ind[1], ..., ind[len], and corresponding constraint coefficients
-- should be placed in locations val[1], ..., val[len]. The right-hand
-- side b should be stored in location val[0].
--
-- The working array work should have at least nb locations, where nb
-- is the number of binary variables in (1).
--
-- The routine generates a mixed cover cut in the same form as (1) and
-- stores the cut coefficients and right-hand side in the same way as
-- just described above.
--
-- RETURNS
--
-- If the cutting plane has been successfully generated, the routine
-- returns 1 <= len' <= n, which is the number of non-zero coefficients
-- in the inequality constraint. Otherwise, the routine returns zero. */

static int lpx_cover_cut(glp_prob *lp, int len, int ind[],
      double val[], double work[])
{     int cov[1+4], j, k, nb, newlen, r;
      double f_min, f_max, alfa, beta, u, *x = work, y;
      /* substitute and remove fixed variables */
      newlen = 0;
      for (k = 1; k <= len; k++)
      {  j = ind[k];
         if (glp_get_col_type(lp, j) == GLP_FX)
            val[0] -= val[k] * glp_get_col_lb(lp, j);
         else
         {  newlen++;
            ind[newlen] = ind[k];
            val[newlen] = val[k];
         }
      }
      len = newlen;
      /* move binary variables to the beginning of the list so that
         elements 1, 2, ..., nb correspond to binary variables, and
         elements nb+1, nb+2, ..., len correspond to rest variables */
      nb = 0;
      for (k = 1; k <= len; k++)
      {  j = ind[k];
         if (glp_get_col_kind(lp, j) == GLP_BV)
         {  /* binary variable */
            int ind_k;
            double val_k;
            nb++;
            ind_k = ind[nb], val_k = val[nb];
            ind[nb] = ind[k], val[nb] = val[k];
            ind[k] = ind_k, val[k] = val_k;
         }
      }
      /* now the specified row has the form:
         sum a[j]*x[j] + sum a[j]*y[j] <= b,
         where x[j] are binary variables, y[j] are rest variables */
      /* at least two binary variables are needed */
      if (nb < 2) return 0;
      /* compute implied lower and upper bounds for sum a[j]*y[j] */
      f_min = f_max = 0.0;
      for (k = nb+1; k <= len; k++)
      {  j = ind[k];
         /* both bounds must be finite */
         if (glp_get_col_type(lp, j) != GLP_DB) return 0;
         if (val[k] > 0.0)
         {  f_min += val[k] * glp_get_col_lb(lp, j);
            f_max += val[k] * glp_get_col_ub(lp, j);
         }
         else
         {  f_min += val[k] * glp_get_col_ub(lp, j);
            f_max += val[k] * glp_get_col_lb(lp, j);
         }
      }
      /* sum a[j]*x[j] + sum a[j]*y[j] <= b ===>
         sum a[j]*x[j] + (sum a[j]*y[j] - f_min) <= b - f_min ===>
         sum a[j]*x[j] + y <= b - f_min,
         where y = sum a[j]*y[j] - f_min;
         note that 0 <= y <= u, u = f_max - f_min */
      /* determine upper bound of y */
      u = f_max - f_min;
      /* determine value of y at the current point */
      y = 0.0;
      for (k = nb+1; k <= len; k++)
      {  j = ind[k];
         y += val[k] * glp_get_col_prim(lp, j);
      }
      y -= f_min;
      if (y < 0.0) y = 0.0;
      if (y > u) y = u;
      /* modify the right-hand side b */
      val[0] -= f_min;
      /* now the transformed row has the form:
         sum a[j]*x[j] + y <= b, where 0 <= y <= u */
      /* determine values of x[j] at the current point */
      for (k = 1; k <= nb; k++)
      {  j = ind[k];
         x[k] = glp_get_col_prim(lp, j);
         if (x[k] < 0.0) x[k] = 0.0;
         if (x[k] > 1.0) x[k] = 1.0;
      }
      /* if a[j] < 0, replace x[j] by its complement 1 - x'[j] */
      for (k = 1; k <= nb; k++)
      {  if (val[k] < 0.0)
         {  ind[k] = - ind[k];
            val[k] = - val[k];
            val[0] += val[k];
            x[k] = 1.0 - x[k];
         }
      }
      /* try to generate a mixed cover cut for the transformed row */
      r = cover(nb, val, val[0], u, x, y, cov, &alfa, &beta);
      if (r == 0) return 0;
      xassert(2 <= r && r <= 4);
      /* now the cut is in the form:
         sum{j in C} x[j] + alfa * y <= beta */
      /* store the right-hand side beta */
      ind[0] = 0, val[0] = beta;
      /* restore the original ordinal numbers of x[j] */
      for (j = 1; j <= r; j++) cov[j] = ind[cov[j]];
      /* store cut coefficients at binary variables complementing back
         the variables having negative row coefficients */
      xassert(r <= nb);
      for (k = 1; k <= r; k++)
      {  if (cov[k] > 0)
         {  ind[k] = +cov[k];
            val[k] = +1.0;
         }
         else
         {  ind[k] = -cov[k];
            val[k] = -1.0;
            val[0] -= 1.0;
         }
      }
      /* substitute y = sum a[j]*y[j] - f_min */
      for (k = nb+1; k <= len; k++)
      {  r++;
         ind[r] = ind[k];
         val[r] = alfa * val[k];
      }
      val[0] += alfa * f_min;
      xassert(r <= len);
      len = r;
      return len;
}

/*----------------------------------------------------------------------
-- lpx_eval_row - compute explictily specified row.
--
-- SYNOPSIS
--
-- double lpx_eval_row(LPX *lp, int len, int ind[], double val[]);
--
-- DESCRIPTION
--
-- The routine lpx_eval_row computes the primal value of an explicitly
-- specified row using current values of structural variables.
--
-- The explicitly specified row may be thought as a linear form:
--
--    y = a[1]*x[m+1] + a[2]*x[m+2] + ... + a[n]*x[m+n],
--
-- where y is an auxiliary variable for this row, a[j] are coefficients
-- of the linear form, x[m+j] are structural variables.
--
-- On entry column indices and numerical values of non-zero elements of
-- the row should be stored in locations ind[1], ..., ind[len] and
-- val[1], ..., val[len], where len is the number of non-zero elements.
-- The array ind and val are not changed on exit.
--
-- RETURNS
--
-- The routine returns a computed value of y, the auxiliary variable of
-- the specified row. */

static double lpx_eval_row(glp_prob *lp, int len, int ind[],
      double val[])
{     int n = glp_get_num_cols(lp);
      int j, k;
      double sum = 0.0;
      if (len < 0)
         xerror("lpx_eval_row: len = %d; invalid row length\n", len);
      for (k = 1; k <= len; k++)
      {  j = ind[k];
         if (!(1 <= j && j <= n))
            xerror("lpx_eval_row: j = %d; column number out of range\n",
               j);
         sum += val[k] * glp_get_col_prim(lp, j);
      }
      return sum;
}

/***********************************************************************
*  NAME
*
*  ios_cov_gen - generate mixed cover cuts
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  void ios_cov_gen(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine ios_cov_gen generates mixed cover cuts for the current
*  point and adds them to the cut pool. */

void ios_cov_gen(glp_tree *tree)
{     glp_prob *prob = tree->mip;
      int m = glp_get_num_rows(prob);
      int n = glp_get_num_cols(prob);
      int i, k, type, kase, len, *ind;
      double r, *val, *work;
      xassert(glp_get_status(prob) == GLP_OPT);
      /* allocate working arrays */
      ind = xcalloc(1+n, sizeof(int));
      val = xcalloc(1+n, sizeof(double));
      work = xcalloc(1+n, sizeof(double));
      /* look through all rows */
      for (i = 1; i <= m; i++)
      for (kase = 1; kase <= 2; kase++)
      {  type = glp_get_row_type(prob, i);
         if (kase == 1)
         {  /* consider rows of '<=' type */
            if (!(type == GLP_UP || type == GLP_DB)) continue;
            len = glp_get_mat_row(prob, i, ind, val);
            val[0] = glp_get_row_ub(prob, i);
         }
         else
         {  /* consider rows of '>=' type */
            if (!(type == GLP_LO || type == GLP_DB)) continue;
            len = glp_get_mat_row(prob, i, ind, val);
            for (k = 1; k <= len; k++) val[k] = - val[k];
            val[0] = - glp_get_row_lb(prob, i);
         }
         /* generate mixed cover cut:
            sum{j in J} a[j] * x[j] <= b */
         len = lpx_cover_cut(prob, len, ind, val, work);
         if (len == 0) continue;
         /* at the current point the cut inequality is violated, i.e.
            sum{j in J} a[j] * x[j] - b > 0 */
         r = lpx_eval_row(prob, len, ind, val) - val[0];
         if (r < 1e-3) continue;
         /* add the cut to the cut pool */
         glp_ios_add_row(tree, NULL, GLP_RF_COV, 0, len, ind, val,
            GLP_UP, val[0]);
      }
      /* free working arrays */
      xfree(ind);
      xfree(val);
      xfree(work);
      return;
}

/* eof */



/* glpios01.c */

/***********************************************************************
*  This code is part of GLPK (GNU Linear Programming Kit).
*
*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
*  2009, 2010, 2011, 2013 Andrew Makhorin, Department for Applied
*  Informatics, Moscow Aviation Institute, Moscow, Russia. All rights
*  reserved. E-mail: <mao@gnu.org>.
*
*  GLPK is free software: you can redistribute it and/or modify it
*  under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  GLPK is distributed in the hope that it will be useful, but WITHOUT
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
*  License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/


static int lpx_eval_tab_row(glp_prob *lp, int k, int ind[],
      double val[])
{     /* compute row of the simplex tableau */
      return glp_eval_tab_row(lp, k, ind, val);
}

static int lpx_dual_ratio_test(glp_prob *lp, int len, const int ind[],
      const double val[], int how, double tol)
{     /* perform dual ratio test */
      int piv;
      piv = glp_dual_rtest(lp, len, ind, val, how, tol);
      xassert(0 <= piv && piv <= len);
      return piv == 0 ? 0 : ind[piv];
}

/***********************************************************************
*  NAME
*
*  ios_create_tree - create branch-and-bound tree
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  glp_tree *ios_create_tree(glp_prob *mip, const glp_iocp *parm);
*
*  DESCRIPTION
*
*  The routine ios_create_tree creates the branch-and-bound tree.
*
*  Being created the tree consists of the only root subproblem whose
*  reference number is 1. Note that initially the root subproblem is in
*  frozen state and therefore needs to be revived.
*
*  RETURNS
*
*  The routine returns a pointer to the tree created. */

static IOSNPD *new_node(glp_tree *tree, IOSNPD *parent);

glp_tree *ios_create_tree(glp_prob *mip, const glp_iocp *parm)
{     int m = mip->m;
      int n = mip->n;
      glp_tree *tree;
      int i, j;
      xassert(mip->tree == NULL);
      mip->tree = tree = xmalloc(sizeof(glp_tree));
      tree->pool = dmp_create_pool();
      tree->n = n;
      /* save original problem components */
      tree->orig_m = m;
      tree->orig_type = xcalloc(1+m+n, sizeof(char));
      tree->orig_lb = xcalloc(1+m+n, sizeof(double));
      tree->orig_ub = xcalloc(1+m+n, sizeof(double));
      tree->orig_stat = xcalloc(1+m+n, sizeof(char));
      tree->orig_prim = xcalloc(1+m+n, sizeof(double));
      tree->orig_dual = xcalloc(1+m+n, sizeof(double));
      for (i = 1; i <= m; i++)
      {  GLPROW *row = mip->row[i];
         tree->orig_type[i] = (char)row->type;
         tree->orig_lb[i] = row->lb;
         tree->orig_ub[i] = row->ub;
         tree->orig_stat[i] = (char)row->stat;
         tree->orig_prim[i] = row->prim;
         tree->orig_dual[i] = row->dual;
      }
      for (j = 1; j <= n; j++)
      {  GLPCOL *col = mip->col[j];
         tree->orig_type[m+j] = (char)col->type;
         tree->orig_lb[m+j] = col->lb;
         tree->orig_ub[m+j] = col->ub;
         tree->orig_stat[m+j] = (char)col->stat;
         tree->orig_prim[m+j] = col->prim;
         tree->orig_dual[m+j] = col->dual;
      }
      tree->orig_obj = mip->obj_val;
      /* initialize the branch-and-bound tree */
      tree->nslots = 0;
      tree->avail = 0;
      tree->slot = NULL;
      tree->head = tree->tail = NULL;
      tree->a_cnt = tree->n_cnt = tree->t_cnt = 0;
      /* the root subproblem is not solved yet, so its final components
         are unknown so far */
      tree->root_m = 0;
      tree->root_type = NULL;
      tree->root_lb = tree->root_ub = NULL;
      tree->root_stat = NULL;
      /* the current subproblem does not exist yet */
      tree->curr = NULL;
      tree->mip = mip;
      /*tree->solved = 0;*/
      tree->non_int = xcalloc(1+n, sizeof(char));
      memset(&tree->non_int[1], 0, n);
      /* arrays to save parent subproblem components will be allocated
         later */
      tree->pred_m = tree->pred_max = 0;
      tree->pred_type = NULL;
      tree->pred_lb = tree->pred_ub = NULL;
      tree->pred_stat = NULL;
      /* cut generator */
      tree->local = ios_create_pool(tree);
      /*tree->first_attempt = 1;*/
      /*tree->max_added_cuts = 0;*/
      /*tree->min_eff = 0.0;*/
      /*tree->miss = 0;*/
      /*tree->just_selected = 0;*/
      tree->mir_gen = NULL;
      tree->clq_gen = NULL;
      /*tree->round = 0;*/
#if 0
      /* create the conflict graph */
      tree->n_ref = xcalloc(1+n, sizeof(int));
      memset(&tree->n_ref[1], 0, n * sizeof(int));
      tree->c_ref = xcalloc(1+n, sizeof(int));
      memset(&tree->c_ref[1], 0, n * sizeof(int));
      tree->g = scg_create_graph(0);
      tree->j_ref = xcalloc(1+tree->g->n_max, sizeof(int));
#endif
      /* pseudocost branching */
      tree->pcost = NULL;
      tree->iwrk = xcalloc(1+n, sizeof(int));
      tree->dwrk = xcalloc(1+n, sizeof(double));
      /* initialize control parameters */
      tree->parm = parm;
      tree->tm_beg = xtime();
#if 0 /* 10/VI-2013 */
      tree->tm_lag = xlset(0);
#else
      tree->tm_lag = 0.0;
#endif
      tree->sol_cnt = 0;
#if 1 /* 11/VII-2013 */
      tree->P = NULL;
      tree->npp = NULL;
      tree->save_sol = parm->save_sol;
      tree->save_cnt = 0;
#endif
      /* initialize advanced solver interface */
      tree->reason = 0;
      tree->reopt = 0;
      tree->reinv = 0;
      tree->br_var = 0;
      tree->br_sel = 0;
      tree->child = 0;
      tree->next_p = 0;
      /*tree->btrack = NULL;*/
      tree->stop = 0;
      /* create the root subproblem, which initially is identical to
         the original MIP */
      new_node(tree, NULL);
      return tree;
}

/***********************************************************************
*  NAME
*
*  ios_revive_node - revive specified subproblem
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  void ios_revive_node(glp_tree *tree, int p);
*
*  DESCRIPTION
*
*  The routine ios_revive_node revives the specified subproblem, whose
*  reference number is p, and thereby makes it the current subproblem.
*  Note that the specified subproblem must be active. Besides, if the
*  current subproblem already exists, it must be frozen before reviving
*  another subproblem. */

void ios_revive_node(glp_tree *tree, int p)
{     glp_prob *mip = tree->mip;
      IOSNPD *node, *root;
      /* obtain pointer to the specified subproblem */
      xassert(1 <= p && p <= tree->nslots);
      node = tree->slot[p].node;
      xassert(node != NULL);
      /* the specified subproblem must be active */
      xassert(node->count == 0);
      /* the current subproblem must not exist */
      xassert(tree->curr == NULL);
      /* the specified subproblem becomes current */
      tree->curr = node;
      /*tree->solved = 0;*/
      /* obtain pointer to the root subproblem */
      root = tree->slot[1].node;
      xassert(root != NULL);
      /* at this point problem object components correspond to the root
         subproblem, so if the root subproblem should be revived, there
         is nothing more to do */
      if (node == root) goto done;
      xassert(mip->m == tree->root_m);
      /* build path from the root to the current node */
      node->temp = NULL;
      for (node = node; node != NULL; node = node->up)
      {  if (node->up == NULL)
            xassert(node == root);
         else
            node->up->temp = node;
      }
      /* go down from the root to the current node and make necessary
         changes to restore components of the current subproblem */
      for (node = root; node != NULL; node = node->temp)
      {  int m = mip->m;
         int n = mip->n;
         /* if the current node is reached, the problem object at this
            point corresponds to its parent, so save attributes of rows
            and columns for the parent subproblem */
         if (node->temp == NULL)
         {  int i, j;
            tree->pred_m = m;
            /* allocate/reallocate arrays, if necessary */
            if (tree->pred_max < m + n)
            {  int new_size = m + n + 100;
               if (tree->pred_type != NULL) xfree(tree->pred_type);
               if (tree->pred_lb != NULL) xfree(tree->pred_lb);
               if (tree->pred_ub != NULL) xfree(tree->pred_ub);
               if (tree->pred_stat != NULL) xfree(tree->pred_stat);
               tree->pred_max = new_size;
               tree->pred_type = xcalloc(1+new_size, sizeof(char));
               tree->pred_lb = xcalloc(1+new_size, sizeof(double));
               tree->pred_ub = xcalloc(1+new_size, sizeof(double));
               tree->pred_stat = xcalloc(1+new_size, sizeof(char));
            }
            /* save row attributes */
            for (i = 1; i <= m; i++)
            {  GLPROW *row = mip->row[i];
               tree->pred_type[i] = (char)row->type;
               tree->pred_lb[i] = row->lb;
               tree->pred_ub[i] = row->ub;
               tree->pred_stat[i] = (char)row->stat;
            }
            /* save column attributes */
            for (j = 1; j <= n; j++)
            {  GLPCOL *col = mip->col[j];
               tree->pred_type[mip->m+j] = (char)col->type;
               tree->pred_lb[mip->m+j] = col->lb;
               tree->pred_ub[mip->m+j] = col->ub;
               tree->pred_stat[mip->m+j] = (char)col->stat;
            }
         }
         /* change bounds of rows and columns */
         {  IOSBND *b;
            for (b = node->b_ptr; b != NULL; b = b->next)
            {  if (b->k <= m)
                  glp_set_row_bnds(mip, b->k, b->type, b->lb, b->ub);
               else
                  glp_set_col_bnds(mip, b->k-m, b->type, b->lb, b->ub);
            }
         }
         /* change statuses of rows and columns */
         {  IOSTAT *s;
            for (s = node->s_ptr; s != NULL; s = s->next)
            {  if (s->k <= m)
                  glp_set_row_stat(mip, s->k, s->stat);
               else
                  glp_set_col_stat(mip, s->k-m, s->stat);
            }
         }
         /* add new rows */
         if (node->r_ptr != NULL)
         {  IOSROW *r;
            IOSAIJ *a;
            int i, len, *ind;
            double *val;
            ind = xcalloc(1+n, sizeof(int));
            val = xcalloc(1+n, sizeof(double));
            for (r = node->r_ptr; r != NULL; r = r->next)
            {  i = glp_add_rows(mip, 1);
               glp_set_row_name(mip, i, r->name);
#if 1 /* 20/IX-2008 */
               xassert(mip->row[i]->level == 0);
               mip->row[i]->level = node->level;
               mip->row[i]->origin = r->origin;
               mip->row[i]->klass = r->klass;
#endif
               glp_set_row_bnds(mip, i, r->type, r->lb, r->ub);
               len = 0;
               for (a = r->ptr; a != NULL; a = a->next)
                  len++, ind[len] = a->j, val[len] = a->val;
               glp_set_mat_row(mip, i, len, ind, val);
               glp_set_rii(mip, i, r->rii);
               glp_set_row_stat(mip, i, r->stat);
            }
            xfree(ind);
            xfree(val);
         }
#if 0
         /* add new edges to the conflict graph */
         /* add new cliques to the conflict graph */
         /* (not implemented yet) */
         xassert(node->own_nn == 0);
         xassert(node->own_nc == 0);
         xassert(node->e_ptr == NULL);
#endif
      }
      /* the specified subproblem has been revived */
      node = tree->curr;
      /* delete its bound change list */
      while (node->b_ptr != NULL)
      {  IOSBND *b;
         b = node->b_ptr;
         node->b_ptr = b->next;
         dmp_free_atom(tree->pool, b, sizeof(IOSBND));
      }
      /* delete its status change list */
      while (node->s_ptr != NULL)
      {  IOSTAT *s;
         s = node->s_ptr;
         node->s_ptr = s->next;
         dmp_free_atom(tree->pool, s, sizeof(IOSTAT));
      }
#if 1 /* 20/XI-2009 */
      /* delete its row addition list (additional rows may appear, for
         example, due to branching on GUB constraints */
      while (node->r_ptr != NULL)
      {  IOSROW *r;
         r = node->r_ptr;
         node->r_ptr = r->next;
         xassert(r->name == NULL);
         while (r->ptr != NULL)
         {  IOSAIJ *a;
            a = r->ptr;
            r->ptr = a->next;
            dmp_free_atom(tree->pool, a, sizeof(IOSAIJ));
         }
         dmp_free_atom(tree->pool, r, sizeof(IOSROW));
      }
#endif
done: return;
}

/***********************************************************************
*  NAME
*
*  ios_freeze_node - freeze current subproblem
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  void ios_freeze_node(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine ios_freeze_node freezes the current subproblem. */

void ios_freeze_node(glp_tree *tree)
{     glp_prob *mip = tree->mip;
      int m = mip->m;
      int n = mip->n;
      IOSNPD *node;
      /* obtain pointer to the current subproblem */
      node = tree->curr;
      xassert(node != NULL);
      if (node->up == NULL)
      {  /* freeze the root subproblem */
         int k;
         xassert(node->p == 1);
         xassert(tree->root_m == 0);
         xassert(tree->root_type == NULL);
         xassert(tree->root_lb == NULL);
         xassert(tree->root_ub == NULL);
         xassert(tree->root_stat == NULL);
         tree->root_m = m;
         tree->root_type = xcalloc(1+m+n, sizeof(char));
         tree->root_lb = xcalloc(1+m+n, sizeof(double));
         tree->root_ub = xcalloc(1+m+n, sizeof(double));
         tree->root_stat = xcalloc(1+m+n, sizeof(char));
         for (k = 1; k <= m+n; k++)
         {  if (k <= m)
            {  GLPROW *row = mip->row[k];
               tree->root_type[k] = (char)row->type;
               tree->root_lb[k] = row->lb;
               tree->root_ub[k] = row->ub;
               tree->root_stat[k] = (char)row->stat;
            }
            else
            {  GLPCOL *col = mip->col[k-m];
               tree->root_type[k] = (char)col->type;
               tree->root_lb[k] = col->lb;
               tree->root_ub[k] = col->ub;
               tree->root_stat[k] = (char)col->stat;
            }
         }
      }
      else
      {  /* freeze non-root subproblem */
         int root_m = tree->root_m;
         int pred_m = tree->pred_m;
         int i, j, k;
         xassert(pred_m <= m);
         /* build change lists for rows and columns which exist in the
            parent subproblem */
         xassert(node->b_ptr == NULL);
         xassert(node->s_ptr == NULL);
         for (k = 1; k <= pred_m + n; k++)
         {  int pred_type, pred_stat, type, stat;
            double pred_lb, pred_ub, lb, ub;
            /* determine attributes in the parent subproblem */
            pred_type = tree->pred_type[k];
            pred_lb = tree->pred_lb[k];
            pred_ub = tree->pred_ub[k];
            pred_stat = tree->pred_stat[k];
            /* determine attributes in the current subproblem */
            if (k <= pred_m)
            {  GLPROW *row = mip->row[k];
               type = row->type;
               lb = row->lb;
               ub = row->ub;
               stat = row->stat;
            }
            else
            {  GLPCOL *col = mip->col[k - pred_m];
               type = col->type;
               lb = col->lb;
               ub = col->ub;
               stat = col->stat;
            }
            /* save type and bounds of a row/column, if changed */
            if (!(pred_type == type && pred_lb == lb && pred_ub == ub))
            {  IOSBND *b;
               b = dmp_get_atom(tree->pool, sizeof(IOSBND));
               b->k = k;
               b->type = (unsigned char)type;
               b->lb = lb;
               b->ub = ub;
               b->next = node->b_ptr;
               node->b_ptr = b;
            }
            /* save status of a row/column, if changed */
            if (pred_stat != stat)
            {  IOSTAT *s;
               s = dmp_get_atom(tree->pool, sizeof(IOSTAT));
               s->k = k;
               s->stat = (unsigned char)stat;
               s->next = node->s_ptr;
               node->s_ptr = s;
            }
         }
         /* save new rows added to the current subproblem */
         xassert(node->r_ptr == NULL);
         if (pred_m < m)
         {  int i, len, *ind;
            double *val;
            ind = xcalloc(1+n, sizeof(int));
            val = xcalloc(1+n, sizeof(double));
            for (i = m; i > pred_m; i--)
            {  GLPROW *row = mip->row[i];
               IOSROW *r;
               const char *name;
               r = dmp_get_atom(tree->pool, sizeof(IOSROW));
               name = glp_get_row_name(mip, i);
               if (name == NULL)
                  r->name = NULL;
               else
               {  r->name = dmp_get_atom(tree->pool, strlen(name)+1);
                  strcpy(r->name, name);
               }
#if 1 /* 20/IX-2008 */
               r->origin = row->origin;
               r->klass = row->klass;
#endif
               r->type = (unsigned char)row->type;
               r->lb = row->lb;
               r->ub = row->ub;
               r->ptr = NULL;
               len = glp_get_mat_row(mip, i, ind, val);
               for (k = 1; k <= len; k++)
               {  IOSAIJ *a;
                  a = dmp_get_atom(tree->pool, sizeof(IOSAIJ));
                  a->j = ind[k];
                  a->val = val[k];
                  a->next = r->ptr;
                  r->ptr = a;
               }
               r->rii = row->rii;
               r->stat = (unsigned char)row->stat;
               r->next = node->r_ptr;
               node->r_ptr = r;
            }
            xfree(ind);
            xfree(val);
         }
         /* remove all rows missing in the root subproblem */
         if (m != root_m)
         {  int nrs, *num;
            nrs = m - root_m;
            xassert(nrs > 0);
            num = xcalloc(1+nrs, sizeof(int));
            for (i = 1; i <= nrs; i++) num[i] = root_m + i;
            glp_del_rows(mip, nrs, num);
            xfree(num);
         }
         m = mip->m;
         /* and restore attributes of all rows and columns for the root
            subproblem */
         xassert(m == root_m);
         for (i = 1; i <= m; i++)
         {  glp_set_row_bnds(mip, i, tree->root_type[i],
               tree->root_lb[i], tree->root_ub[i]);
            glp_set_row_stat(mip, i, tree->root_stat[i]);
         }
         for (j = 1; j <= n; j++)
         {  glp_set_col_bnds(mip, j, tree->root_type[m+j],
               tree->root_lb[m+j], tree->root_ub[m+j]);
            glp_set_col_stat(mip, j, tree->root_stat[m+j]);
         }
#if 1
         /* remove all edges and cliques missing in the conflict graph
            for the root subproblem */
         /* (not implemented yet) */
#endif
      }
      /* the current subproblem has been frozen */
      tree->curr = NULL;
      return;
}

/***********************************************************************
*  NAME
*
*  ios_clone_node - clone specified subproblem
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  void ios_clone_node(glp_tree *tree, int p, int nnn, int ref[]);
*
*  DESCRIPTION
*
*  The routine ios_clone_node clones the specified subproblem, whose
*  reference number is p, creating its nnn exact copies. Note that the
*  specified subproblem must be active and must be in the frozen state
*  (i.e. it must not be the current subproblem).
*
*  Each clone, an exact copy of the specified subproblem, becomes a new
*  active subproblem added to the end of the active list. After cloning
*  the specified subproblem becomes inactive.
*
*  The reference numbers of clone subproblems are stored to locations
*  ref[1], ..., ref[nnn]. */

static int get_slot(glp_tree *tree)
{     int p;
      /* if no free slots are available, increase the room */
      if (tree->avail == 0)
      {  int nslots = tree->nslots;
         IOSLOT *save = tree->slot;
         if (nslots == 0)
            tree->nslots = 20;
         else
         {  tree->nslots = nslots + nslots;
            xassert(tree->nslots > nslots);
         }
         tree->slot = xcalloc(1+tree->nslots, sizeof(IOSLOT));
         if (save != NULL)
         {  memcpy(&tree->slot[1], &save[1], nslots * sizeof(IOSLOT));
            xfree(save);
         }
         /* push more free slots into the stack */
         for (p = tree->nslots; p > nslots; p--)
         {  tree->slot[p].node = NULL;
            tree->slot[p].next = tree->avail;
            tree->avail = p;
         }
      }
      /* pull a free slot from the stack */
      p = tree->avail;
      tree->avail = tree->slot[p].next;
      xassert(tree->slot[p].node == NULL);
      tree->slot[p].next = 0;
      return p;
}

static IOSNPD *new_node(glp_tree *tree, IOSNPD *parent)
{     IOSNPD *node;
      int p;
      /* pull a free slot for the new node */
      p = get_slot(tree);
      /* create descriptor of the new subproblem */
      node = dmp_get_atom(tree->pool, sizeof(IOSNPD));
      tree->slot[p].node = node;
      node->p = p;
      node->up = parent;
      node->level = (parent == NULL ? 0 : parent->level + 1);
      node->count = 0;
      node->b_ptr = NULL;
      node->s_ptr = NULL;
      node->r_ptr = NULL;
      node->solved = 0;
#if 0
      node->own_nn = node->own_nc = 0;
      node->e_ptr = NULL;
#endif
#if 1 /* 04/X-2008 */
      node->lp_obj = (parent == NULL ? (tree->mip->dir == GLP_MIN ?
         -DBL_MAX : +DBL_MAX) : parent->lp_obj);
#endif
      node->bound = (parent == NULL ? (tree->mip->dir == GLP_MIN ?
         -DBL_MAX : +DBL_MAX) : parent->bound);
      node->br_var = 0;
      node->br_val = 0.0;
      node->ii_cnt = 0;
      node->ii_sum = 0.0;
#if 1 /* 30/XI-2009 */
      node->changed = 0;
#endif
      if (tree->parm->cb_size == 0)
         node->data = NULL;
      else
      {  node->data = dmp_get_atom(tree->pool, tree->parm->cb_size);
         memset(node->data, 0, tree->parm->cb_size);
      }
      node->temp = NULL;
      node->prev = tree->tail;
      node->next = NULL;
      /* add the new subproblem to the end of the active list */
      if (tree->head == NULL)
         tree->head = node;
      else
         tree->tail->next = node;
      tree->tail = node;
      tree->a_cnt++;
      tree->n_cnt++;
      tree->t_cnt++;
      /* increase the number of child subproblems */
      if (parent == NULL)
         xassert(p == 1);
      else
         parent->count++;
      return node;
}

void ios_clone_node(glp_tree *tree, int p, int nnn, int ref[])
{     IOSNPD *node;
      int k;
      /* obtain pointer to the subproblem to be cloned */
      xassert(1 <= p && p <= tree->nslots);
      node = tree->slot[p].node;
      xassert(node != NULL);
      /* the specified subproblem must be active */
      xassert(node->count == 0);
      /* and must be in the frozen state */
      xassert(tree->curr != node);
      /* remove the specified subproblem from the active list, because
         it becomes inactive */
      if (node->prev == NULL)
         tree->head = node->next;
      else
         node->prev->next = node->next;
      if (node->next == NULL)
         tree->tail = node->prev;
      else
         node->next->prev = node->prev;
      node->prev = node->next = NULL;
      tree->a_cnt--;
      /* create clone subproblems */
      xassert(nnn > 0);
      for (k = 1; k <= nnn; k++)
         ref[k] = new_node(tree, node)->p;
      return;
}

/***********************************************************************
*  NAME
*
*  ios_delete_node - delete specified subproblem
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  void ios_delete_node(glp_tree *tree, int p);
*
*  DESCRIPTION
*
*  The routine ios_delete_node deletes the specified subproblem, whose
*  reference number is p. The subproblem must be active and must be in
*  the frozen state (i.e. it must not be the current subproblem).
*
*  Note that deletion is performed recursively, i.e. if a subproblem to
*  be deleted is the only child of its parent, the parent subproblem is
*  also deleted, etc. */

void ios_delete_node(glp_tree *tree, int p)
{     IOSNPD *node, *temp;
      /* obtain pointer to the subproblem to be deleted */
      xassert(1 <= p && p <= tree->nslots);
      node = tree->slot[p].node;
      xassert(node != NULL);
      /* the specified subproblem must be active */
      xassert(node->count == 0);
      /* and must be in the frozen state */
      xassert(tree->curr != node);
      /* remove the specified subproblem from the active list, because
         it is gone from the tree */
      if (node->prev == NULL)
         tree->head = node->next;
      else
         node->prev->next = node->next;
      if (node->next == NULL)
         tree->tail = node->prev;
      else
         node->next->prev = node->prev;
      node->prev = node->next = NULL;
      tree->a_cnt--;
loop: /* recursive deletion starts here */
      /* delete the bound change list */
      {  IOSBND *b;
         while (node->b_ptr != NULL)
         {  b = node->b_ptr;
            node->b_ptr = b->next;
            dmp_free_atom(tree->pool, b, sizeof(IOSBND));
         }
      }
      /* delete the status change list */
      {  IOSTAT *s;
         while (node->s_ptr != NULL)
         {  s = node->s_ptr;
            node->s_ptr = s->next;
            dmp_free_atom(tree->pool, s, sizeof(IOSTAT));
         }
      }
      /* delete the row addition list */
      while (node->r_ptr != NULL)
      {  IOSROW *r;
         r = node->r_ptr;
         if (r->name != NULL)
            dmp_free_atom(tree->pool, r->name, strlen(r->name)+1);
         while (r->ptr != NULL)
         {  IOSAIJ *a;
            a = r->ptr;
            r->ptr = a->next;
            dmp_free_atom(tree->pool, a, sizeof(IOSAIJ));
         }
         node->r_ptr = r->next;
         dmp_free_atom(tree->pool, r, sizeof(IOSROW));
      }
#if 0
      /* delete the edge addition list */
      /* delete the clique addition list */
      /* (not implemented yet) */
      xassert(node->own_nn == 0);
      xassert(node->own_nc == 0);
      xassert(node->e_ptr == NULL);
#endif
      /* free application-specific data */
      if (tree->parm->cb_size == 0)
         xassert(node->data == NULL);
      else
         dmp_free_atom(tree->pool, node->data, tree->parm->cb_size);
      /* free the corresponding node slot */
      p = node->p;
      xassert(tree->slot[p].node == node);
      tree->slot[p].node = NULL;
      tree->slot[p].next = tree->avail;
      tree->avail = p;
      /* save pointer to the parent subproblem */
      temp = node->up;
      /* delete the subproblem descriptor */
      dmp_free_atom(tree->pool, node, sizeof(IOSNPD));
      tree->n_cnt--;
      /* take pointer to the parent subproblem */
      node = temp;
      if (node != NULL)
      {  /* the parent subproblem exists; decrease the number of its
            child subproblems */
         xassert(node->count > 0);
         node->count--;
         /* if now the parent subproblem has no childs, it also must be
            deleted */
         if (node->count == 0) goto loop;
      }
      return;
}

/***********************************************************************
*  NAME
*
*  ios_delete_tree - delete branch-and-bound tree
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  void ios_delete_tree(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine ios_delete_tree deletes the branch-and-bound tree, which
*  the parameter tree points to, and frees all the memory allocated to
*  this program object.
*
*  On exit components of the problem object are restored to correspond
*  to the original MIP passed to the routine ios_create_tree. */

void ios_delete_tree(glp_tree *tree)
{     glp_prob *mip = tree->mip;
      int i, j;
      int m = mip->m;
      int n = mip->n;
      xassert(mip->tree == tree);
      /* remove all additional rows */
      if (m != tree->orig_m)
      {  int nrs, *num;
         nrs = m - tree->orig_m;
         xassert(nrs > 0);
         num = xcalloc(1+nrs, sizeof(int));
         for (i = 1; i <= nrs; i++) num[i] = tree->orig_m + i;
         glp_del_rows(mip, nrs, num);
         xfree(num);
      }
      m = tree->orig_m;
      /* restore original attributes of rows and columns */
      xassert(m == tree->orig_m);
      xassert(n == tree->n);
      for (i = 1; i <= m; i++)
      {  glp_set_row_bnds(mip, i, tree->orig_type[i],
            tree->orig_lb[i], tree->orig_ub[i]);
         glp_set_row_stat(mip, i, tree->orig_stat[i]);
         mip->row[i]->prim = tree->orig_prim[i];
         mip->row[i]->dual = tree->orig_dual[i];
      }
      for (j = 1; j <= n; j++)
      {  glp_set_col_bnds(mip, j, tree->orig_type[m+j],
            tree->orig_lb[m+j], tree->orig_ub[m+j]);
         glp_set_col_stat(mip, j, tree->orig_stat[m+j]);
         mip->col[j]->prim = tree->orig_prim[m+j];
         mip->col[j]->dual = tree->orig_dual[m+j];
      }
      mip->pbs_stat = mip->dbs_stat = GLP_FEAS;
      mip->obj_val = tree->orig_obj;
      /* delete the branch-and-bound tree */
      xassert(tree->local != NULL);
      ios_delete_pool(tree, tree->local);
      dmp_delete_pool(tree->pool);
      xfree(tree->orig_type);
      xfree(tree->orig_lb);
      xfree(tree->orig_ub);
      xfree(tree->orig_stat);
      xfree(tree->orig_prim);
      xfree(tree->orig_dual);
      xfree(tree->slot);
      if (tree->root_type != NULL) xfree(tree->root_type);
      if (tree->root_lb != NULL) xfree(tree->root_lb);
      if (tree->root_ub != NULL) xfree(tree->root_ub);
      if (tree->root_stat != NULL) xfree(tree->root_stat);
      xfree(tree->non_int);
#if 0
      xfree(tree->n_ref);
      xfree(tree->c_ref);
      xfree(tree->j_ref);
#endif
      if (tree->pcost != NULL) ios_pcost_free(tree);
      xfree(tree->iwrk);
      xfree(tree->dwrk);
#if 0
      scg_delete_graph(tree->g);
#endif
      if (tree->pred_type != NULL) xfree(tree->pred_type);
      if (tree->pred_lb != NULL) xfree(tree->pred_lb);
      if (tree->pred_ub != NULL) xfree(tree->pred_ub);
      if (tree->pred_stat != NULL) xfree(tree->pred_stat);
#if 0
      xassert(tree->cut_gen == NULL);
#endif
      xassert(tree->mir_gen == NULL);
      xassert(tree->clq_gen == NULL);
      xfree(tree);
      mip->tree = NULL;
      return;
}

/***********************************************************************
*  NAME
*
*  ios_eval_degrad - estimate obj. degrad. for down- and up-branches
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  void ios_eval_degrad(glp_tree *tree, int j, double *dn, double *up);
*
*  DESCRIPTION
*
*  Given optimal basis to LP relaxation of the current subproblem the
*  routine ios_eval_degrad performs the dual ratio test to compute the
*  objective values in the adjacent basis for down- and up-branches,
*  which are stored in locations *dn and *up, assuming that x[j] is a
*  variable chosen to branch upon. */

void ios_eval_degrad(glp_tree *tree, int j, double *dn, double *up)
{     glp_prob *mip = tree->mip;
      int m = mip->m, n = mip->n;
      int len, kase, k, t, stat;
      double alfa, beta, gamma, delta, dz;
      int *ind = tree->iwrk;
      double *val = tree->dwrk;
      /* current basis must be optimal */
      xassert(glp_get_status(mip) == GLP_OPT);
      /* basis factorization must exist */
      xassert(glp_bf_exists(mip));
      /* obtain (fractional) value of x[j] in optimal basic solution
         to LP relaxation of the current subproblem */
      xassert(1 <= j && j <= n);
      beta = mip->col[j]->prim;
      /* since the value of x[j] is fractional, it is basic; compute
         corresponding row of the simplex table */
      len = lpx_eval_tab_row(mip, m+j, ind, val);
      /* kase < 0 means down-branch; kase > 0 means up-branch */
      for (kase = -1; kase <= +1; kase += 2)
      {  /* for down-branch we introduce new upper bound floor(beta)
            for x[j]; similarly, for up-branch we introduce new lower
            bound ceil(beta) for x[j]; in the current basis this new
            upper/lower bound is violated, so in the adjacent basis
            x[j] will leave the basis and go to its new upper/lower
            bound; we need to know which non-basic variable x[k] should
            enter the basis to keep dual feasibility */
#if 0 /* 23/XI-2009 */
         k = lpx_dual_ratio_test(mip, len, ind, val, kase, 1e-7);
#else
         k = lpx_dual_ratio_test(mip, len, ind, val, kase, 1e-9);
#endif
         /* if no variable has been chosen, current basis being primal
            infeasible due to the new upper/lower bound of x[j] is dual
            unbounded, therefore, LP relaxation to corresponding branch
            has no primal feasible solution */
         if (k == 0)
         {  if (mip->dir == GLP_MIN)
            {  if (kase < 0)
                  *dn = +DBL_MAX;
               else
                  *up = +DBL_MAX;
            }
            else if (mip->dir == GLP_MAX)
            {  if (kase < 0)
                  *dn = -DBL_MAX;
               else
                  *up = -DBL_MAX;
            }
            else
               xassert(mip != mip);
            continue;
         }
         xassert(1 <= k && k <= m+n);
         /* row of the simplex table corresponding to specified basic
            variable x[j] is the following:
               x[j] = ... + alfa * x[k] + ... ;
            we need to know influence coefficient, alfa, at non-basic
            variable x[k] chosen with the dual ratio test */
         for (t = 1; t <= len; t++)
            if (ind[t] == k) break;
         xassert(1 <= t && t <= len);
         alfa = val[t];
         /* determine status and reduced cost of variable x[k] */
         if (k <= m)
         {  stat = mip->row[k]->stat;
            gamma = mip->row[k]->dual;
         }
         else
         {  stat = mip->col[k-m]->stat;
            gamma = mip->col[k-m]->dual;
         }
         /* x[k] cannot be basic or fixed non-basic */
         xassert(stat == GLP_NL || stat == GLP_NU || stat == GLP_NF);
         /* if the current basis is dual degenerative, some reduced
            costs, which are close to zero, may have wrong sign due to
            round-off errors, so correct the sign of gamma */
         if (mip->dir == GLP_MIN)
         {  if (stat == GLP_NL && gamma < 0.0 ||
                stat == GLP_NU && gamma > 0.0 ||
                stat == GLP_NF) gamma = 0.0;
         }
         else if (mip->dir == GLP_MAX)
         {  if (stat == GLP_NL && gamma > 0.0 ||
                stat == GLP_NU && gamma < 0.0 ||
                stat == GLP_NF) gamma = 0.0;
         }
         else
            xassert(mip != mip);
         /* determine the change of x[j] in the adjacent basis:
            delta x[j] = new x[j] - old x[j] */
         delta = (kase < 0 ? floor(beta) : ceil(beta)) - beta;
         /* compute the change of x[k] in the adjacent basis:
            delta x[k] = new x[k] - old x[k] = delta x[j] / alfa */
         delta /= alfa;
         /* compute the change of the objective in the adjacent basis:
            delta z = new z - old z = gamma * delta x[k] */
         dz = gamma * delta;
         if (mip->dir == GLP_MIN)
            xassert(dz >= 0.0);
         else if (mip->dir == GLP_MAX)
            xassert(dz <= 0.0);
         else
            xassert(mip != mip);
         /* compute the new objective value in the adjacent basis:
            new z = old z + delta z */
         if (kase < 0)
            *dn = mip->obj_val + dz;
         else
            *up = mip->obj_val + dz;
      }
      /*xprintf("obj = %g; dn = %g; up = %g\n",
         mip->obj_val, *dn, *up);*/
      return;
}

/***********************************************************************
*  NAME
*
*  ios_round_bound - improve local bound by rounding
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  double ios_round_bound(glp_tree *tree, double bound);
*
*  RETURNS
*
*  For the given local bound for any integer feasible solution to the
*  current subproblem the routine ios_round_bound returns an improved
*  local bound for the same integer feasible solution.
*
*  BACKGROUND
*
*  Let the current subproblem has the following objective function:
*
*     z =   sum  c[j] * x[j] + s >= b,                               (1)
*         j in J
*
*  where J = {j: c[j] is non-zero and integer, x[j] is integer}, s is
*  the sum of terms corresponding to fixed variables, b is an initial
*  local bound (minimization).
*
*  From (1) it follows that:
*
*     d *  sum  (c[j] / d) * x[j] + s >= b,                          (2)
*        j in J
*
*  or, equivalently,
*
*     sum  (c[j] / d) * x[j] >= (b - s) / d = h,                     (3)
*   j in J
*
*  where d = gcd(c[j]). Since the left-hand side of (3) is integer,
*  h = (b - s) / d can be rounded up to the nearest integer:
*
*     h' = ceil(h) = (b' - s) / d,                                   (4)
*
*  that gives an rounded, improved local bound:
*
*     b' = d * h' + s.                                               (5)
*
*  In case of maximization '>=' in (1) should be replaced by '<=' that
*  leads to the following formula:
*
*     h' = floor(h) = (b' - s) / d,                                  (6)
*
*  which should used in the same way as (4).
*
*  NOTE: If b is a valid local bound for a child of the current
*        subproblem, b' is also valid for that child subproblem. */

double ios_round_bound(glp_tree *tree, double bound)
{     glp_prob *mip = tree->mip;
      int n = mip->n;
      int d, j, nn, *c = tree->iwrk;
      double s, h;
      /* determine c[j] and compute s */
      nn = 0, s = mip->c0, d = 0;
      for (j = 1; j <= n; j++)
      {  GLPCOL *col = mip->col[j];
         if (col->coef == 0.0) continue;
         if (col->type == GLP_FX)
         {  /* fixed variable */
            s += col->coef * col->prim;
         }
         else
         {  /* non-fixed variable */
            if (col->kind != GLP_IV) goto skip;
            if (col->coef != floor(col->coef)) goto skip;
            if (fabs(col->coef) <= (double)INT_MAX)
               c[++nn] = (int)fabs(col->coef);
            else
               d = 1;
         }
      }
      /* compute d = gcd(c[1],...c[nn]) */
      if (d == 0)
      {  if (nn == 0) goto skip;
         d = gcdn(nn, c);
      }
      xassert(d > 0);
      /* compute new local bound */
      if (mip->dir == GLP_MIN)
      {  if (bound != +DBL_MAX)
         {  h = (bound - s) / (double)d;
            if (h >= floor(h) + 0.001)
            {  /* round up */
               h = ceil(h);
               /*xprintf("d = %d; old = %g; ", d, bound);*/
               bound = (double)d * h + s;
               /*xprintf("new = %g\n", bound);*/
            }
         }
      }
      else if (mip->dir == GLP_MAX)
      {  if (bound != -DBL_MAX)
         {  h = (bound - s) / (double)d;
            if (h <= ceil(h) - 0.001)
            {  /* round down */
               h = floor(h);
               bound = (double)d * h + s;
            }
         }
      }
      else
         xassert(mip != mip);
skip: return bound;
}

/***********************************************************************
*  NAME
*
*  ios_is_hopeful - check if subproblem is hopeful
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  int ios_is_hopeful(glp_tree *tree, double bound);
*
*  DESCRIPTION
*
*  Given the local bound of a subproblem the routine ios_is_hopeful
*  checks if the subproblem can have an integer optimal solution which
*  is better than the best one currently known.
*
*  RETURNS
*
*  If the subproblem can have a better integer optimal solution, the
*  routine returns non-zero; otherwise, if the corresponding branch can
*  be pruned, the routine returns zero. */

int ios_is_hopeful(glp_tree *tree, double bound)
{     glp_prob *mip = tree->mip;
      int ret = 1;
      double eps;
      if (mip->mip_stat == GLP_FEAS)
      {  eps = tree->parm->tol_obj * (1.0 + fabs(mip->mip_obj));
         switch (mip->dir)
         {  case GLP_MIN:
               if (bound >= mip->mip_obj - eps) ret = 0;
               break;
            case GLP_MAX:
               if (bound <= mip->mip_obj + eps) ret = 0;
               break;
            default:
               xassert(mip != mip);
         }
      }
      else
      {  switch (mip->dir)
         {  case GLP_MIN:
               if (bound == +DBL_MAX) ret = 0;
               break;
            case GLP_MAX:
               if (bound == -DBL_MAX) ret = 0;
               break;
            default:
               xassert(mip != mip);
         }
      }
      return ret;
}

/***********************************************************************
*  NAME
*
*  ios_best_node - find active node with best local bound
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  int ios_best_node(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine ios_best_node finds an active node whose local bound is
*  best among other active nodes.
*
*  It is understood that the integer optimal solution of the original
*  mip problem cannot be better than the best bound, so the best bound
*  is an lower (minimization) or upper (maximization) global bound for
*  the original problem.
*
*  RETURNS
*
*  The routine ios_best_node returns the subproblem reference number
*  for the best node. However, if the tree is empty, it returns zero. */

int ios_best_node(glp_tree *tree)
{     IOSNPD *node, *best = NULL;
      switch (tree->mip->dir)
      {  case GLP_MIN:
            /* minimization */
            for (node = tree->head; node != NULL; node = node->next)
               if (best == NULL || best->bound > node->bound)
                  best = node;
            break;
         case GLP_MAX:
            /* maximization */
            for (node = tree->head; node != NULL; node = node->next)
               if (best == NULL || best->bound < node->bound)
                  best = node;
            break;
         default:
            xassert(tree != tree);
      }
      return best == NULL ? 0 : best->p;
}

/***********************************************************************
*  NAME
*
*  ios_relative_gap - compute relative mip gap
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  double ios_relative_gap(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine ios_relative_gap computes the relative mip gap using the
*  formula:
*
*     gap = |best_mip - best_bnd| / (|best_mip| + DBL_EPSILON),
*
*  where best_mip is the best integer feasible solution found so far,
*  best_bnd is the best (global) bound. If no integer feasible solution
*  has been found yet, rel_gap is set to DBL_MAX.
*
*  RETURNS
*
*  The routine ios_relative_gap returns the relative mip gap. */

double ios_relative_gap(glp_tree *tree)
{     glp_prob *mip = tree->mip;
      int p;
      double best_mip, best_bnd, gap;
      if (mip->mip_stat == GLP_FEAS)
      {  best_mip = mip->mip_obj;
         p = ios_best_node(tree);
         if (p == 0)
         {  /* the tree is empty */
            gap = 0.0;
         }
         else
         {  best_bnd = tree->slot[p].node->bound;
            gap = fabs(best_mip - best_bnd) / (fabs(best_mip) +
               DBL_EPSILON);
         }
      }
      else
      {  /* no integer feasible solution has been found yet */
         gap = DBL_MAX;
      }
      return gap;
}

/***********************************************************************
*  NAME
*
*  ios_solve_node - solve LP relaxation of current subproblem
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  int ios_solve_node(glp_tree *tree);
*
*  DESCRIPTION
*
*  The routine ios_solve_node re-optimizes LP relaxation of the current
*  subproblem using the dual simplex method.
*
*  RETURNS
*
*  The routine returns the code which is reported by glp_simplex. */

int ios_solve_node(glp_tree *tree)
{     glp_prob *mip = tree->mip;
      glp_smcp parm;
      int ret;
      /* the current subproblem must exist */
      xassert(tree->curr != NULL);
      /* set some control parameters */
      glp_init_smcp(&parm);
      switch (tree->parm->msg_lev)
      {  case GLP_MSG_OFF:
            parm.msg_lev = GLP_MSG_OFF; break;
         case GLP_MSG_ERR:
            parm.msg_lev = GLP_MSG_ERR; break;
         case GLP_MSG_ON:
         case GLP_MSG_ALL:
            parm.msg_lev = GLP_MSG_ON; break;
         case GLP_MSG_DBG:
            parm.msg_lev = GLP_MSG_ALL; break;
         default:
            xassert(tree != tree);
      }
      parm.meth = GLP_DUALP;
#if 1 /* 16/III-2016 */
      if (tree->parm->flip)
         parm.r_test = GLP_RT_FLIP;
#endif
      /* respect time limit */
      if (tree->parm->tm_lim < INT_MAX)
         parm.tm_lim = tree->parm->tm_lim - (glp_time() - tree->tm_beg);
      if (parm.tm_lim < 0)
         parm.tm_lim = 0;
      if (tree->parm->msg_lev < GLP_MSG_DBG)
         parm.out_dly = tree->parm->out_dly;
      else
         parm.out_dly = 0;
      /* if the incumbent objective value is already known, use it to
         prematurely terminate the dual simplex search */
      if (mip->mip_stat == GLP_FEAS)
      {  switch (tree->mip->dir)
         {  case GLP_MIN:
               parm.obj_ul = mip->mip_obj;
               break;
            case GLP_MAX:
               parm.obj_ll = mip->mip_obj;
               break;
            default:
               xassert(mip != mip);
         }
      }
      /* try to solve/re-optimize the LP relaxation */
      ret = glp_simplex(mip, &parm);
#if 1 /* 21/II-2016 by Chris */
      if (ret == GLP_EFAIL)
      {  /* retry with a new basis */
         glp_adv_basis(mip, 0);
         ret = glp_simplex(mip, &parm);
      }
#endif
      tree->curr->solved++;
#if 0
      xprintf("ret = %d; status = %d; pbs = %d; dbs = %d; some = %d\n",
         ret, glp_get_status(mip), mip->pbs_stat, mip->dbs_stat,
         mip->some);
      lpx_print_sol(mip, "sol");
#endif
      return ret;
}

/**********************************************************************/

IOSPOOL *ios_create_pool(glp_tree *tree)
{     /* create cut pool */
      IOSPOOL *pool;
#if 0
      pool = dmp_get_atom(tree->pool, sizeof(IOSPOOL));
#else
      xassert(tree == tree);
      pool = xmalloc(sizeof(IOSPOOL));
#endif
      pool->size = 0;
      pool->head = pool->tail = NULL;
      pool->ord = 0, pool->curr = NULL;
      return pool;
}

int ios_add_row(glp_tree *tree, IOSPOOL *pool,
      const char *name, int klass, int flags, int len, const int ind[],
      const double val[], int type, double rhs)
{     /* add row (constraint) to the cut pool */
      IOSCUT *cut;
      IOSAIJ *aij;
      int k;
      xassert(pool != NULL);
      cut = dmp_get_atom(tree->pool, sizeof(IOSCUT));
      if (name == NULL || name[0] == '\0')
         cut->name = NULL;
      else
      {  for (k = 0; name[k] != '\0'; k++)
         {  if (k == 256)
               xerror("glp_ios_add_row: cut name too long\n");
            if (iscntrl((unsigned char)name[k]))
               xerror("glp_ios_add_row: cut name contains invalid chara"
                  "cter(s)\n");
         }
         cut->name = dmp_get_atom(tree->pool, strlen(name)+1);
         strcpy(cut->name, name);
      }
      if (!(0 <= klass && klass <= 255))
         xerror("glp_ios_add_row: klass = %d; invalid cut class\n",
            klass);
      cut->klass = (unsigned char)klass;
      if (flags != 0)
         xerror("glp_ios_add_row: flags = %d; invalid cut flags\n",
            flags);
      cut->ptr = NULL;
      if (!(0 <= len && len <= tree->n))
         xerror("glp_ios_add_row: len = %d; invalid cut length\n",
            len);
      for (k = 1; k <= len; k++)
      {  aij = dmp_get_atom(tree->pool, sizeof(IOSAIJ));
         if (!(1 <= ind[k] && ind[k] <= tree->n))
            xerror("glp_ios_add_row: ind[%d] = %d; column index out of "
               "range\n", k, ind[k]);
         aij->j = ind[k];
         aij->val = val[k];
         aij->next = cut->ptr;
         cut->ptr = aij;
      }
      if (!(type == GLP_LO || type == GLP_UP || type == GLP_FX))
         xerror("glp_ios_add_row: type = %d; invalid cut type\n",
            type);
      cut->type = (unsigned char)type;
      cut->rhs = rhs;
      cut->prev = pool->tail;
      cut->next = NULL;
      if (cut->prev == NULL)
         pool->head = cut;
      else
         cut->prev->next = cut;
      pool->tail = cut;
      pool->size++;
      return pool->size;
}

IOSCUT *ios_find_row(IOSPOOL *pool, int i)
{     /* find row (constraint) in the cut pool */
      /* (smart linear search) */
      xassert(pool != NULL);
      xassert(1 <= i && i <= pool->size);
      if (pool->ord == 0)
      {  xassert(pool->curr == NULL);
         pool->ord = 1;
         pool->curr = pool->head;
      }
      xassert(pool->curr != NULL);
      if (i < pool->ord)
      {  if (i < pool->ord - i)
         {  pool->ord = 1;
            pool->curr = pool->head;
            while (pool->ord != i)
            {  pool->ord++;
               xassert(pool->curr != NULL);
               pool->curr = pool->curr->next;
            }
         }
         else
         {  while (pool->ord != i)
            {  pool->ord--;
               xassert(pool->curr != NULL);
               pool->curr = pool->curr->prev;
            }
         }
      }
      else if (i > pool->ord)
      {  if (i - pool->ord < pool->size - i)
         {  while (pool->ord != i)
            {  pool->ord++;
               xassert(pool->curr != NULL);
               pool->curr = pool->curr->next;
            }
         }
         else
         {  pool->ord = pool->size;
            pool->curr = pool->tail;
            while (pool->ord != i)
            {  pool->ord--;
               xassert(pool->curr != NULL);
               pool->curr = pool->curr->prev;
            }
         }
      }
      xassert(pool->ord == i);
      xassert(pool->curr != NULL);
      return pool->curr;
}

void ios_del_row(glp_tree *tree, IOSPOOL *pool, int i)
{     /* remove row (constraint) from the cut pool */
      IOSCUT *cut;
      IOSAIJ *aij;
      xassert(pool != NULL);
      if (!(1 <= i && i <= pool->size))
         xerror("glp_ios_del_row: i = %d; cut number out of range\n",
            i);
      cut = ios_find_row(pool, i);
      xassert(pool->curr == cut);
      if (cut->next != NULL)
         pool->curr = cut->next;
      else if (cut->prev != NULL)
         pool->ord--, pool->curr = cut->prev;
      else
         pool->ord = 0, pool->curr = NULL;
      if (cut->name != NULL)
         dmp_free_atom(tree->pool, cut->name, strlen(cut->name)+1);
      if (cut->prev == NULL)
      {  xassert(pool->head == cut);
         pool->head = cut->next;
      }
      else
      {  xassert(cut->prev->next == cut);
         cut->prev->next = cut->next;
      }
      if (cut->next == NULL)
      {  xassert(pool->tail == cut);
         pool->tail = cut->prev;
      }
      else
      {  xassert(cut->next->prev == cut);
         cut->next->prev = cut->prev;
      }
      while (cut->ptr != NULL)
      {  aij = cut->ptr;
         cut->ptr = aij->next;
         dmp_free_atom(tree->pool, aij, sizeof(IOSAIJ));
      }
      dmp_free_atom(tree->pool, cut, sizeof(IOSCUT));
      pool->size--;
      return;
}

void ios_clear_pool(glp_tree *tree, IOSPOOL *pool)
{     /* remove all rows (constraints) from the cut pool */
      xassert(pool != NULL);
      while (pool->head != NULL)
      {  IOSCUT *cut = pool->head;
         pool->head = cut->next;
         if (cut->name != NULL)
            dmp_free_atom(tree->pool, cut->name, strlen(cut->name)+1);
         while (cut->ptr != NULL)
         {  IOSAIJ *aij = cut->ptr;
            cut->ptr = aij->next;
            dmp_free_atom(tree->pool, aij, sizeof(IOSAIJ));
         }
         dmp_free_atom(tree->pool, cut, sizeof(IOSCUT));
      }
      pool->size = 0;
      pool->head = pool->tail = NULL;
      pool->ord = 0, pool->curr = NULL;
      return;
}

void ios_delete_pool(glp_tree *tree, IOSPOOL *pool)
{     /* delete cut pool */
      xassert(pool != NULL);
      ios_clear_pool(tree, pool);
      xfree(pool);
      return;
}

#if 1 /* 11/VII-2013 */

void ios_process_sol(glp_tree *T)
{     /* process integer feasible solution just found */
      if (T->npp != NULL)
      {  /* postprocess solution from transformed mip */
         npp_postprocess(T->npp, T->mip);
         /* store solution to problem passed to glp_intopt */
         npp_unload_sol(T->npp, T->P);
      }
      xassert(T->P != NULL);
      /* save solution to text file, if requested */
      if (T->save_sol != NULL)
      {  char *fn, *mark;
         fn = talloc(strlen(T->save_sol) + 50, char);
         mark = strrchr(T->save_sol, '*');
         if (mark == NULL)
            strcpy(fn, T->save_sol);
         else
         {  memcpy(fn, T->save_sol, mark - T->save_sol);
            fn[mark - T->save_sol] = '\0';
            sprintf(fn + strlen(fn), "%03d", ++(T->save_cnt));
            strcat(fn, &mark[1]);
         }
         glp_write_mip(T->P, fn);
         tfree(fn);
      }
      return;
}
#endif


/* glpios02.c (preprocess current subproblem) */

/***********************************************************************
*  This code is part of GLPK (GNU Linear Programming Kit).
*
*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
*  2009, 2010, 2011, 2013 Andrew Makhorin, Department for Applied
*  Informatics, Moscow Aviation Institute, Moscow, Russia. All rights
*  reserved. E-mail: <mao@gnu.org>.
*
*  GLPK is free software: you can redistribute it and/or modify it
*  under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  GLPK is distributed in the hope that it will be useful, but WITHOUT
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
*  License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/


/***********************************************************************
*  prepare_row_info - prepare row info to determine implied bounds
*
*  Given a row (linear form)
*
*      n
*     sum a[j] * x[j]                                                (1)
*     j=1
*
*  and bounds of columns (variables)
*
*     l[j] <= x[j] <= u[j]                                           (2)
*
*  this routine computes f_min, j_min, f_max, j_max needed to determine
*  implied bounds.
*
*  ALGORITHM
*
*  Let J+ = {j : a[j] > 0} and J- = {j : a[j] < 0}.
*
*  Parameters f_min and j_min are computed as follows:
*
*  1) if there is no x[k] such that k in J+ and l[k] = -inf or k in J-
*     and u[k] = +inf, then
*
*     f_min :=   sum   a[j] * l[j] +   sum   a[j] * u[j]
*              j in J+               j in J-
*                                                                    (3)
*     j_min := 0
*
*  2) if there is exactly one x[k] such that k in J+ and l[k] = -inf
*     or k in J- and u[k] = +inf, then
*
*     f_min :=   sum       a[j] * l[j] +   sum       a[j] * u[j]
*              j in J+\{k}               j in J-\{k}
*                                                                    (4)
*     j_min := k
*
*  3) if there are two or more x[k] such that k in J+ and l[k] = -inf
*     or k in J- and u[k] = +inf, then
*
*     f_min := -inf
*                                                                    (5)
*     j_min := 0
*
*  Parameters f_max and j_max are computed in a similar way as follows:
*
*  1) if there is no x[k] such that k in J+ and u[k] = +inf or k in J-
*     and l[k] = -inf, then
*
*     f_max :=   sum   a[j] * u[j] +   sum   a[j] * l[j]
*              j in J+               j in J-
*                                                                    (6)
*     j_max := 0
*
*  2) if there is exactly one x[k] such that k in J+ and u[k] = +inf
*     or k in J- and l[k] = -inf, then
*
*     f_max :=   sum       a[j] * u[j] +   sum       a[j] * l[j]
*              j in J+\{k}               j in J-\{k}
*                                                                    (7)
*     j_max := k
*
*  3) if there are two or more x[k] such that k in J+ and u[k] = +inf
*     or k in J- and l[k] = -inf, then
*
*     f_max := +inf
*                                                                    (8)
*     j_max := 0                                                      */

struct f_info
{     int j_min, j_max;
      double f_min, f_max;
};

static void prepare_row_info(int n, const double a[], const double l[], const double u[], struct f_info *f)
{     int j, j_min, j_max;
      double f_min, f_max;
      xassert(n >= 0);
      /* determine f_min and j_min */
      f_min = 0.0, j_min = 0;
      for (j = 1; j <= n; j++)
      {  if (a[j] > 0.0)
         {  if (l[j] == -DBL_MAX)
            {  if (j_min == 0)
                  j_min = j;
               else
               {  f_min = -DBL_MAX, j_min = 0;
                  break;
               }
            }
            else
               f_min += a[j] * l[j];
         }
         else if (a[j] < 0.0)
         {  if (u[j] == +DBL_MAX)
            {  if (j_min == 0)
                  j_min = j;
               else
               {  f_min = -DBL_MAX, j_min = 0;
                  break;
               }
            }
            else
               f_min += a[j] * u[j];
         }
         else
            xassert(a != a);
      }
      f->f_min = f_min, f->j_min = j_min;
      /* determine f_max and j_max */
      f_max = 0.0, j_max = 0;
      for (j = 1; j <= n; j++)
      {  if (a[j] > 0.0)
         {  if (u[j] == +DBL_MAX)
            {  if (j_max == 0)
                  j_max = j;
               else
               {  f_max = +DBL_MAX, j_max = 0;
                  break;
               }
            }
            else
               f_max += a[j] * u[j];
         }
         else if (a[j] < 0.0)
         {  if (l[j] == -DBL_MAX)
            {  if (j_max == 0)
                  j_max = j;
               else
               {  f_max = +DBL_MAX, j_max = 0;
                  break;
               }
            }
            else
               f_max += a[j] * l[j];
         }
         else
            xassert(a != a);
      }
      f->f_max = f_max, f->j_max = j_max;
      return;
}

/***********************************************************************
*  row_implied_bounds - determine row implied bounds
*
*  Given a row (linear form)
*
*      n
*     sum a[j] * x[j]
*     j=1
*
*  and bounds of columns (variables)
*
*     l[j] <= x[j] <= u[j]
*
*  this routine determines implied bounds of the row.
*
*  ALGORITHM
*
*  Let J+ = {j : a[j] > 0} and J- = {j : a[j] < 0}.
*
*  The implied lower bound of the row is computed as follows:
*
*     L' :=   sum   a[j] * l[j] +   sum   a[j] * u[j]                (9)
*           j in J+               j in J-
*
*  and as it follows from (3), (4), and (5):
*
*     L' := if j_min = 0 then f_min else -inf                       (10)
*
*  The implied upper bound of the row is computed as follows:
*
*     U' :=   sum   a[j] * u[j] +   sum   a[j] * l[j]               (11)
*           j in J+               j in J-
*
*  and as it follows from (6), (7), and (8):
*
*     U' := if j_max = 0 then f_max else +inf                       (12)
*
*  The implied bounds are stored in locations LL and UU. */

static void row_implied_bounds(const struct f_info *f, double *LL,
      double *UU)
{     *LL = (f->j_min == 0 ? f->f_min : -DBL_MAX);
      *UU = (f->j_max == 0 ? f->f_max : +DBL_MAX);
      return;
}

/***********************************************************************
*  col_implied_bounds - determine column implied bounds
*
*  Given a row (constraint)
*
*           n
*     L <= sum a[j] * x[j] <= U                                     (13)
*          j=1
*
*  and bounds of columns (variables)
*
*     l[j] <= x[j] <= u[j]
*
*  this routine determines implied bounds of variable x[k].
*
*  It is assumed that if L != -inf, the lower bound of the row can be
*  active, and if U != +inf, the upper bound of the row can be active.
*
*  ALGORITHM
*
*  From (13) it follows that
*
*     L <= sum a[j] * x[j] + a[k] * x[k] <= U
*          j!=k
*  or
*
*     L - sum a[j] * x[j] <= a[k] * x[k] <= U - sum a[j] * x[j]
*         j!=k                                  j!=k
*
*  Thus, if the row lower bound L can be active, implied lower bound of
*  term a[k] * x[k] can be determined as follows:
*
*     ilb(a[k] * x[k]) = min(L - sum a[j] * x[j]) =
*                                j!=k
*                                                                   (14)
*                      = L - max sum a[j] * x[j]
*                            j!=k
*
*  where, as it follows from (6), (7), and (8)
*
*                           / f_max - a[k] * u[k], j_max = 0, a[k] > 0
*                           |
*                           | f_max - a[k] * l[k], j_max = 0, a[k] < 0
*     max sum a[j] * x[j] = {
*         j!=k              | f_max,               j_max = k
*                           |
*                           \ +inf,                j_max != 0
*
*  and if the upper bound U can be active, implied upper bound of term
*  a[k] * x[k] can be determined as follows:
*
*     iub(a[k] * x[k]) = max(U - sum a[j] * x[j]) =
*                                j!=k
*                                                                   (15)
*                      = U - min sum a[j] * x[j]
*                            j!=k
*
*  where, as it follows from (3), (4), and (5)
*
*                           / f_min - a[k] * l[k], j_min = 0, a[k] > 0
*                           |
*                           | f_min - a[k] * u[k], j_min = 0, a[k] < 0
*     min sum a[j] * x[j] = {
*         j!=k              | f_min,               j_min = k
*                           |
*                           \ -inf,                j_min != 0
*
*  Since
*
*     ilb(a[k] * x[k]) <= a[k] * x[k] <= iub(a[k] * x[k])
*
*  implied lower and upper bounds of x[k] are determined as follows:
*
*     l'[k] := if a[k] > 0 then ilb / a[k] else ulb / a[k]          (16)
*
*     u'[k] := if a[k] > 0 then ulb / a[k] else ilb / a[k]          (17)
*
*  The implied bounds are stored in locations ll and uu. */

static void col_implied_bounds(const struct f_info *f, int n,
      const double a[], double L, double U, const double l[],
      const double u[], int k, double *ll, double *uu)
{     double ilb, iub;
      xassert(n >= 0);
      xassert(1 <= k && k <= n);
      /* determine implied lower bound of term a[k] * x[k] (14) */
      if (L == -DBL_MAX || f->f_max == +DBL_MAX)
         ilb = -DBL_MAX;
      else if (f->j_max == 0)
      {  if (a[k] > 0.0)
         {  xassert(u[k] != +DBL_MAX);
            ilb = L - (f->f_max - a[k] * u[k]);
         }
         else if (a[k] < 0.0)
         {  xassert(l[k] != -DBL_MAX);
            ilb = L - (f->f_max - a[k] * l[k]);
         }
         else
            xassert(a != a);
      }
      else if (f->j_max == k)
         ilb = L - f->f_max;
      else
         ilb = -DBL_MAX;
      /* determine implied upper bound of term a[k] * x[k] (15) */
      if (U == +DBL_MAX || f->f_min == -DBL_MAX)
         iub = +DBL_MAX;
      else if (f->j_min == 0)
      {  if (a[k] > 0.0)
         {  xassert(l[k] != -DBL_MAX);
            iub = U - (f->f_min - a[k] * l[k]);
         }
         else if (a[k] < 0.0)
         {  xassert(u[k] != +DBL_MAX);
            iub = U - (f->f_min - a[k] * u[k]);
         }
         else
            xassert(a != a);
      }
      else if (f->j_min == k)
         iub = U - f->f_min;
      else
         iub = +DBL_MAX;
      /* determine implied bounds of x[k] (16) and (17) */
#if 1
      /* do not use a[k] if it has small magnitude to prevent wrong
         implied bounds; for example, 1e-15 * x1 >= x2 + x3, where
         x1 >= -10, x2, x3 >= 0, would lead to wrong conclusion that
         x1 >= 0 */
      if (fabs(a[k]) < 1e-6)
         *ll = -DBL_MAX, *uu = +DBL_MAX; else
#endif
      if (a[k] > 0.0)
      {  *ll = (ilb == -DBL_MAX ? -DBL_MAX : ilb / a[k]);
         *uu = (iub == +DBL_MAX ? +DBL_MAX : iub / a[k]);
      }
      else if (a[k] < 0.0)
      {  *ll = (iub == +DBL_MAX ? -DBL_MAX : iub / a[k]);
         *uu = (ilb == -DBL_MAX ? +DBL_MAX : ilb / a[k]);
      }
      else
         xassert(a != a);
      return;
}

/***********************************************************************
*  check_row_bounds - check and relax original row bounds
*
*  Given a row (constraint)
*
*           n
*     L <= sum a[j] * x[j] <= U
*          j=1
*
*  and bounds of columns (variables)
*
*     l[j] <= x[j] <= u[j]
*
*  this routine checks the original row bounds L and U for feasibility
*  and redundancy. If the original lower bound L or/and upper bound U
*  cannot be active due to bounds of variables, the routine remove them
*  replacing by -inf or/and +inf, respectively.
*
*  If no primal infeasibility is detected, the routine returns zero,
*  otherwise non-zero. */

static int check_row_bounds(const struct f_info *f, double *L_,
      double *U_)
{     int ret = 0;
      double L = *L_, U = *U_, LL, UU;
      /* determine implied bounds of the row */
      row_implied_bounds(f, &LL, &UU);
      /* check if the original lower bound is infeasible */
      if (L != -DBL_MAX)
      {  double eps = 1e-3 * (1.0 + fabs(L));
         if (UU < L - eps)
         {  ret = 1;
            goto done;
         }
      }
      /* check if the original upper bound is infeasible */
      if (U != +DBL_MAX)
      {  double eps = 1e-3 * (1.0 + fabs(U));
         if (LL > U + eps)
         {  ret = 1;
            goto done;
         }
      }
      /* check if the original lower bound is redundant */
      if (L != -DBL_MAX)
      {  double eps = 1e-12 * (1.0 + fabs(L));
         if (LL > L - eps)
         {  /* it cannot be active, so remove it */
            *L_ = -DBL_MAX;
         }
      }
      /* check if the original upper bound is redundant */
      if (U != +DBL_MAX)
      {  double eps = 1e-12 * (1.0 + fabs(U));
         if (UU < U + eps)
         {  /* it cannot be active, so remove it */
            *U_ = +DBL_MAX;
         }
      }
done: return ret;
}

/***********************************************************************
*  check_col_bounds - check and tighten original column bounds
*
*  Given a row (constraint)
*
*           n
*     L <= sum a[j] * x[j] <= U
*          j=1
*
*  and bounds of columns (variables)
*
*     l[j] <= x[j] <= u[j]
*
*  for column (variable) x[j] this routine checks the original column
*  bounds l[j] and u[j] for feasibility and redundancy. If the original
*  lower bound l[j] or/and upper bound u[j] cannot be active due to
*  bounds of the constraint and other variables, the routine tighten
*  them replacing by corresponding implied bounds, if possible.
*
*  NOTE: It is assumed that if L != -inf, the row lower bound can be
*        active, and if U != +inf, the row upper bound can be active.
*
*  The flag means that variable x[j] is required to be integer.
*
*  New actual bounds for x[j] are stored in locations lj and uj.
*
*  If no primal infeasibility is detected, the routine returns zero,
*  otherwise non-zero. */

static int check_col_bounds(const struct f_info *f, int n,
      const double a[], double L, double U, const double l[],
      const double u[], int flag, int j, double *_lj, double *_uj)
{     int ret = 0;
      double lj, uj, ll, uu;
      xassert(n >= 0);
      xassert(1 <= j && j <= n);
      lj = l[j], uj = u[j];
      /* determine implied bounds of the column */
      col_implied_bounds(f, n, a, L, U, l, u, j, &ll, &uu);
      /* if x[j] is integral, round its implied bounds */
      if (flag)
      {  if (ll != -DBL_MAX)
            ll = (ll - floor(ll) < 1e-3 ? floor(ll) : ceil(ll));
         if (uu != +DBL_MAX)
            uu = (ceil(uu) - uu < 1e-3 ? ceil(uu) : floor(uu));
      }
      /* check if the original lower bound is infeasible */
      if (lj != -DBL_MAX)
      {  double eps = 1e-3 * (1.0 + fabs(lj));
         if (uu < lj - eps)
         {  ret = 1;
            goto done;
         }
      }
      /* check if the original upper bound is infeasible */
      if (uj != +DBL_MAX)
      {  double eps = 1e-3 * (1.0 + fabs(uj));
         if (ll > uj + eps)
         {  ret = 1;
            goto done;
         }
      }
      /* check if the original lower bound is redundant */
      if (ll != -DBL_MAX)
      {  double eps = 1e-3 * (1.0 + fabs(ll));
         if (lj < ll - eps)
         {  /* it cannot be active, so tighten it */
            lj = ll;
         }
      }
      /* check if the original upper bound is redundant */
      if (uu != +DBL_MAX)
      {  double eps = 1e-3 * (1.0 + fabs(uu));
         if (uj > uu + eps)
         {  /* it cannot be active, so tighten it */
            uj = uu;
         }
      }
      /* due to round-off errors it may happen that lj > uj (although
         lj < uj + eps, since no primal infeasibility is detected), so
         adjuct the new actual bounds to provide lj <= uj */
      if (!(lj == -DBL_MAX || uj == +DBL_MAX))
      {  double t1 = fabs(lj), t2 = fabs(uj);
         double eps = 1e-10 * (1.0 + (t1 <= t2 ? t1 : t2));
         if (lj > uj - eps)
         {  if (lj == l[j])
               uj = lj;
            else if (uj == u[j])
               lj = uj;
            else if (t1 <= t2)
               uj = lj;
            else
               lj = uj;
         }
      }
      *_lj = lj, *_uj = uj;
done: return ret;
}

/***********************************************************************
*  check_efficiency - check if change in column bounds is efficient
*
*  Given the original bounds of a column l and u and its new actual
*  bounds l' and u' (possibly tighten by the routine check_col_bounds)
*  this routine checks if the change in the column bounds is efficient
*  enough. If so, the routine returns non-zero, otherwise zero.
*
*  The flag means that the variable is required to be integer. */

static int check_efficiency(int flag, double l, double u, double ll,
      double uu)
{     int eff = 0;
      /* check efficiency for lower bound */
      if (l < ll)
      {  if (flag || l == -DBL_MAX)
            eff++;
         else
         {  double r;
            if (u == +DBL_MAX)
               r = 1.0 + fabs(l);
            else
               r = 1.0 + (u - l);
            if (ll - l >= 0.25 * r)
               eff++;
         }
      }
      /* check efficiency for upper bound */
      if (u > uu)
      {  if (flag || u == +DBL_MAX)
            eff++;
         else
         {  double r;
            if (l == -DBL_MAX)
               r = 1.0 + fabs(u);
            else
               r = 1.0 + (u - l);
            if (u - uu >= 0.25 * r)
               eff++;
         }
      }
      return eff;
}

/***********************************************************************
*  basic_preprocessing - perform basic preprocessing
*
*  This routine performs basic preprocessing of the specified MIP that
*  includes relaxing some row bounds and tightening some column bounds.
*
*  On entry the arrays L and U contains original row bounds, and the
*  arrays l and u contains original column bounds:
*
*  L[0] is the lower bound of the objective row;
*  L[i], i = 1,...,m, is the lower bound of i-th row;
*  U[0] is the upper bound of the objective row;
*  U[i], i = 1,...,m, is the upper bound of i-th row;
*  l[0] is not used;
*  l[j], j = 1,...,n, is the lower bound of j-th column;
*  u[0] is not used;
*  u[j], j = 1,...,n, is the upper bound of j-th column.
*
*  On exit the arrays L, U, l, and u contain new actual bounds of rows
*  and column in the same locations.
*
*  The parameters nrs and num specify an initial list of rows to be
*  processed:
*
*  nrs is the number of rows in the initial list, 0 <= nrs <= m+1;
*  num[0] is not used;
*  num[1,...,nrs] are row numbers (0 means the objective row).
*
*  The parameter max_pass specifies the maximal number of times that
*  each row can be processed, max_pass > 0.
*
*  If no primal infeasibility is detected, the routine returns zero,
*  otherwise non-zero. */

static int basic_preprocessing(glp_prob *mip, double L[], double U[],
      double l[], double u[], int nrs, const int num[], int max_pass)
{     int m = mip->m;
      int n = mip->n;
      struct f_info f;
      int i, j, k, len, size, ret = 0;
      int *ind, *list, *mark, *pass;
      double *val, *lb, *ub;
      xassert(0 <= nrs && nrs <= m+1);
      xassert(max_pass > 0);
      /* allocate working arrays */
      ind = xcalloc(1+n, sizeof(int));
      list = xcalloc(1+m+1, sizeof(int));
      mark = xcalloc(1+m+1, sizeof(int));
      memset(&mark[0], 0, (m+1) * sizeof(int));
      pass = xcalloc(1+m+1, sizeof(int));
      memset(&pass[0], 0, (m+1) * sizeof(int));
      val = xcalloc(1+n, sizeof(double));
      lb = xcalloc(1+n, sizeof(double));
      ub = xcalloc(1+n, sizeof(double));
      /* initialize the list of rows to be processed */
      size = 0;
      for (k = 1; k <= nrs; k++)
      {  i = num[k];
         xassert(0 <= i && i <= m);
         /* duplicate row numbers are not allowed */
         xassert(!mark[i]);
         list[++size] = i, mark[i] = 1;
      }
      xassert(size == nrs);
      /* process rows in the list until it becomes empty */
      while (size > 0)
      {  /* get a next row from the list */
         i = list[size--], mark[i] = 0;
         /* increase the row processing count */
         pass[i]++;
         /* if the row is free, skip it */
         if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;
         /* obtain coefficients of the row */
         len = 0;
         if (i == 0)
         {  for (j = 1; j <= n; j++)
            {  GLPCOL *col = mip->col[j];
               if (col->coef != 0.0)
                  len++, ind[len] = j, val[len] = col->coef;
            }
         }
         else
         {  GLPROW *row = mip->row[i];
            GLPAIJ *aij;
            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
               len++, ind[len] = aij->col->j, val[len] = aij->val;
         }
         /* determine lower and upper bounds of columns corresponding
            to non-zero row coefficients */
         for (k = 1; k <= len; k++)
            j = ind[k], lb[k] = l[j], ub[k] = u[j];
         /* prepare the row info to determine implied bounds */
         prepare_row_info(len, val, lb, ub, &f);
         /* check and relax bounds of the row */
         if (check_row_bounds(&f, &L[i], &U[i]))
         {  /* the feasible region is empty */
            ret = 1;
            goto done;
         }
         /* if the row became free, drop it */
         if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;
         /* process columns having non-zero coefficients in the row */
         for (k = 1; k <= len; k++)
         {  GLPCOL *col;
            int flag, eff;
            double ll, uu;
            /* take a next column in the row */
            j = ind[k], col = mip->col[j];
            flag = col->kind != GLP_CV;
            /* check and tighten bounds of the column */
            if (check_col_bounds(&f, len, val, L[i], U[i], lb, ub,
                flag, k, &ll, &uu))
            {  /* the feasible region is empty */
               ret = 1;
               goto done;
            }
            /* check if change in the column bounds is efficient */
            eff = check_efficiency(flag, l[j], u[j], ll, uu);
            /* set new actual bounds of the column */
            l[j] = ll, u[j] = uu;
            /* if the change is efficient, add all rows affected by the
               corresponding column, to the list */
            if (eff > 0)
            {  GLPAIJ *aij;
               for (aij = col->ptr; aij != NULL; aij = aij->c_next)
               {  int ii = aij->row->i;
                  /* if the row was processed maximal number of times,
                     skip it */
                  if (pass[ii] >= max_pass) continue;
                  /* if the row is free, skip it */
                  if (L[ii] == -DBL_MAX && U[ii] == +DBL_MAX) continue;
                  /* put the row into the list */
                  if (mark[ii] == 0)
                  {  xassert(size <= m);
                     list[++size] = ii, mark[ii] = 1;
                  }
               }
            }
         }
      }
done: /* free working arrays */
      xfree(ind);
      xfree(list);
      xfree(mark);
      xfree(pass);
      xfree(val);
      xfree(lb);
      xfree(ub);
      return ret;
}

/***********************************************************************
*  NAME
*
*  ios_preprocess_node - preprocess current subproblem
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  int ios_preprocess_node(glp_tree *tree, int max_pass);
*
*  DESCRIPTION
*
*  The routine ios_preprocess_node performs basic preprocessing of the
*  current subproblem.
*
*  RETURNS
*
*  If no primal infeasibility is detected, the routine returns zero,
*  otherwise non-zero. */

int ios_preprocess_node(glp_tree *tree, int max_pass)
{     glp_prob *mip = tree->mip;
      int m = mip->m;
      int n = mip->n;
      int i, j, nrs, *num, ret = 0;
      double *L, *U, *l, *u;
      /* the current subproblem must exist */
      xassert(tree->curr != NULL);
      /* determine original row bounds */
      L = xcalloc(1+m, sizeof(double));
      U = xcalloc(1+m, sizeof(double));
      switch (mip->mip_stat)
      {  case GLP_UNDEF:
            L[0] = -DBL_MAX, U[0] = +DBL_MAX;
            break;
         case GLP_FEAS:
            switch (mip->dir)
            {  case GLP_MIN:
                  L[0] = -DBL_MAX, U[0] = mip->mip_obj - mip->c0;
                  break;
               case GLP_MAX:
                  L[0] = mip->mip_obj - mip->c0, U[0] = +DBL_MAX;
                  break;
               default:
                  xassert(mip != mip);
            }
            break;
         default:
            xassert(mip != mip);
      }
      for (i = 1; i <= m; i++)
      {  L[i] = glp_get_row_lb(mip, i);
         U[i] = glp_get_row_ub(mip, i);
      }
      /* determine original column bounds */
      l = xcalloc(1+n, sizeof(double));
      u = xcalloc(1+n, sizeof(double));
      for (j = 1; j <= n; j++)
      {  l[j] = glp_get_col_lb(mip, j);
         u[j] = glp_get_col_ub(mip, j);
      }
      /* build the initial list of rows to be analyzed */
      nrs = m + 1;
      num = xcalloc(1+nrs, sizeof(int));
      for (i = 1; i <= nrs; i++) num[i] = i - 1;
      /* perform basic preprocessing */
      if (basic_preprocessing(mip , L, U, l, u, nrs, num, max_pass))
      {  ret = 1;
         goto done;
      }
      /* set new actual (relaxed) row bounds */
      for (i = 1; i <= m; i++)
      {  /* consider only non-active rows to keep dual feasibility */
         if (glp_get_row_stat(mip, i) == GLP_BS)
         {  if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)
               glp_set_row_bnds(mip, i, GLP_FR, 0.0, 0.0);
            else if (U[i] == +DBL_MAX)
               glp_set_row_bnds(mip, i, GLP_LO, L[i], 0.0);
            else if (L[i] == -DBL_MAX)
               glp_set_row_bnds(mip, i, GLP_UP, 0.0, U[i]);
         }
      }
      /* set new actual (tightened) column bounds */
      for (j = 1; j <= n; j++)
      {  int type;
         if (l[j] == -DBL_MAX && u[j] == +DBL_MAX)
            type = GLP_FR;
         else if (u[j] == +DBL_MAX)
            type = GLP_LO;
         else if (l[j] == -DBL_MAX)
            type = GLP_UP;
         else if (l[j] != u[j])
            type = GLP_DB;
         else
            type = GLP_FX;
         glp_set_col_bnds(mip, j, type, l[j], u[j]);
      }
done: /* free working arrays and return */
      xfree(L);
      xfree(U);
      xfree(l);
      xfree(u);
      xfree(num);
      return ret;
}

/* eof */



/* glpios03.c (branch-and-cut driver) */

/***********************************************************************
*  This code is part of GLPK (GNU Linear Programming Kit).
*
*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
*  2009, 2010, 2011, 2013 Andrew Makhorin, Department for Applied
*  Informatics, Moscow Aviation Institute, Moscow, Russia. All rights
*  reserved. E-mail: <mao@gnu.org>.
*
*  GLPK is free software: you can redistribute it and/or modify it
*  under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  GLPK is distributed in the hope that it will be useful, but WITHOUT
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
*  License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/


/***********************************************************************
*  show_progress - display current progress of the search
*
*  This routine displays some information about current progress of the
*  search.
*
*  The information includes:
*
*  the current number of iterations performed by the simplex solver;
*
*  the objective value for the best known integer feasible solution,
*  which is upper (minimization) or lower (maximization) global bound
*  for optimal solution of the original mip problem;
*
*  the best local bound for active nodes, which is lower (minimization)
*  or upper (maximization) global bound for optimal solution of the
*  original mip problem;
*
*  the relative mip gap, in percents;
*
*  the number of open (active) subproblems;
*
*  the number of completely explored subproblems, i.e. whose nodes have
*  been removed from the tree. */

static void show_progress1(glp_tree *T, int bingo)
{     int p;
      double temp;
      char best_mip[50], best_bound[50], *rho, rel_gap[50];
      /* format the best known integer feasible solution */
      if (T->mip->mip_stat == GLP_FEAS)
         sprintf(best_mip, "%17.9e", T->mip->mip_obj);
      else
         sprintf(best_mip, "%17s", "not found yet");
      /* determine reference number of an active subproblem whose local
         bound is best */
      p = ios_best_node(T);
      /* format the best bound */
      if (p == 0)
         sprintf(best_bound, "%17s", "tree is empty");
      else
      {  temp = T->slot[p].node->bound;
         if (temp == -DBL_MAX)
            sprintf(best_bound, "%17s", "-inf");
         else if (temp == +DBL_MAX)
            sprintf(best_bound, "%17s", "+inf");
         else
            sprintf(best_bound, "%17.9e", temp);
      }
      /* choose the relation sign between global bounds */
      if (T->mip->dir == GLP_MIN)
         rho = ">=";
      else if (T->mip->dir == GLP_MAX)
         rho = "<=";
      else
         xassert(T != T);
      /* format the relative mip gap */
      temp = ios_relative_gap(T);
      if (temp == 0.0)
         sprintf(rel_gap, "  0.0%%");
      else if (temp < 0.001)
         sprintf(rel_gap, "< 0.1%%");
      else if (temp <= 9.999)
         sprintf(rel_gap, "%5.1f%%", 100.0 * temp);
      else
         sprintf(rel_gap, "%6s", "");
      /* display progress of the search */
      xprintf("+%6d: %s %s %s %s %s (%d; %d)\n",
         T->mip->it_cnt, bingo ? ">>>>>" : "mip =", best_mip, rho,
         best_bound, rel_gap, T->a_cnt, T->t_cnt - T->n_cnt);
      T->tm_lag = xtime();
      return;
}

/***********************************************************************
*  is_branch_hopeful - check if specified branch is hopeful
*
*  This routine checks if the specified subproblem can have an integer
*  optimal solution which is better than the best known one.
*
*  The check is based on comparison of the local objective bound stored
*  in the subproblem descriptor and the incumbent objective value which
*  is the global objective bound.
*
*  If there is a chance that the specified subproblem can have a better
*  integer optimal solution, the routine returns non-zero. Otherwise, if
*  the corresponding branch can pruned, zero is returned. */

static int is_branch_hopeful(glp_tree *T, int p)
{     xassert(1 <= p && p <= T->nslots);
      xassert(T->slot[p].node != NULL);
      return ios_is_hopeful(T, T->slot[p].node->bound);
}

/***********************************************************************
*  check_integrality - check integrality of basic solution
*
*  This routine checks if the basic solution of LP relaxation of the
*  current subproblem satisfies to integrality conditions, i.e. that all
*  variables of integer kind have integral primal values. (The solution
*  is assumed to be optimal.)
*
*  For each variable of integer kind the routine computes the following
*  quantity:
*
*     ii(x[j]) = min(x[j] - floor(x[j]), ceil(x[j]) - x[j]),         (1)
*
*  which is a measure of the integer infeasibility (non-integrality) of
*  x[j] (for example, ii(2.1) = 0.1, ii(3.7) = 0.3, ii(5.0) = 0). It is
*  understood that 0 <= ii(x[j]) <= 0.5, and variable x[j] is integer
*  feasible if ii(x[j]) = 0. However, due to floating-point arithmetic
*  the routine checks less restrictive condition:
*
*     ii(x[j]) <= tol_int,                                           (2)
*
*  where tol_int is a given tolerance (small positive number) and marks
*  each variable which does not satisfy to (2) as integer infeasible by
*  setting its fractionality flag.
*
*  In order to characterize integer infeasibility of the basic solution
*  in the whole the routine computes two parameters: ii_cnt, which is
*  the number of variables with the fractionality flag set, and ii_sum,
*  which is the sum of integer infeasibilities (1). */

static void check_integrality(glp_tree *T)
{     glp_prob *mip = T->mip;
      int j, type, ii_cnt = 0;
      double lb, ub, x, temp1, temp2, ii_sum = 0.0;
      /* walk through the set of columns (structural variables) */
      for (j = 1; j <= mip->n; j++)
      {  GLPCOL *col = mip->col[j];
         T->non_int[j] = 0;
         /* if the column is not integer, skip it */
         if (col->kind != GLP_IV) continue;
         /* if the column is non-basic, it is integer feasible */
         if (col->stat != GLP_BS) continue;
         /* obtain the type and bounds of the column */
         type = col->type, lb = col->lb, ub = col->ub;
         /* obtain value of the column in optimal basic solution */
         x = col->prim;
         /* if the column's primal value is close to the lower bound,
            the column is integer feasible within given tolerance */
         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)
         {  temp1 = lb - T->parm->tol_int;
            temp2 = lb + T->parm->tol_int;
            if (temp1 <= x && x <= temp2) continue;
#if 0
            /* the lower bound must not be violated */
            xassert(x >= lb);
#else
            if (x < lb) continue;
#endif
         }
         /* if the column's primal value is close to the upper bound,
            the column is integer feasible within given tolerance */
         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)
         {  temp1 = ub - T->parm->tol_int;
            temp2 = ub + T->parm->tol_int;
            if (temp1 <= x && x <= temp2) continue;
#if 0
            /* the upper bound must not be violated */
            xassert(x <= ub);
#else
            if (x > ub) continue;
#endif
         }
         /* if the column's primal value is close to nearest integer,
            the column is integer feasible within given tolerance */
         temp1 = floor(x + 0.5) - T->parm->tol_int;
         temp2 = floor(x + 0.5) + T->parm->tol_int;
         if (temp1 <= x && x <= temp2) continue;
         /* otherwise the column is integer infeasible */
         T->non_int[j] = 1;
         /* increase the number of fractional-valued columns */
         ii_cnt++;
         /* compute the sum of integer infeasibilities */
         temp1 = x - floor(x);
         temp2 = ceil(x) - x;
         xassert(temp1 > 0.0 && temp2 > 0.0);
         ii_sum += (temp1 <= temp2 ? temp1 : temp2);
      }
      /* store ii_cnt and ii_sum to the current problem descriptor */
      xassert(T->curr != NULL);
      T->curr->ii_cnt = ii_cnt;
      T->curr->ii_sum = ii_sum;
      /* and also display these parameters */
      if (T->parm->msg_lev >= GLP_MSG_DBG)
      {  if (ii_cnt == 0)
            xprintf("There are no fractional columns\n");
         else if (ii_cnt == 1)
            xprintf("There is one fractional column, integer infeasibil"
               "ity is %.3e\n", ii_sum);
         else
            xprintf("There are %d fractional columns, integer infeasibi"
               "lity is %.3e\n", ii_cnt, ii_sum);
      }
      return;
}

/***********************************************************************
*  record_solution - record better integer feasible solution
*
*  This routine records optimal basic solution of LP relaxation of the
*  current subproblem, which being integer feasible is better than the
*  best known integer feasible solution. */

static void record_solution(glp_tree *T)
{     glp_prob *mip = T->mip;
      int i, j;
      mip->mip_stat = GLP_FEAS;
      mip->mip_obj = mip->obj_val;
      for (i = 1; i <= mip->m; i++)
      {  GLPROW *row = mip->row[i];
         row->mipx = row->prim;
      }
      for (j = 1; j <= mip->n; j++)
      {  GLPCOL *col = mip->col[j];
         if (col->kind == GLP_CV)
            col->mipx = col->prim;
         else if (col->kind == GLP_IV)
         {  /* value of the integer column must be integral */
            col->mipx = floor(col->prim + 0.5);
         }
         else
            xassert(col != col);
      }
      T->sol_cnt++;
      return;
}

/***********************************************************************
*  fix_by_red_cost - fix non-basic integer columns by reduced costs
*
*  This routine fixes some non-basic integer columns if their reduced
*  costs indicate that increasing (decreasing) the column at least by
*  one involves the objective value becoming worse than the incumbent
*  objective value. */

static void fix_by_red_cost(glp_tree *T)
{     glp_prob *mip = T->mip;
      int j, stat, fixed = 0;
      double obj, lb, ub, dj;
      /* the global bound must exist */
      xassert(T->mip->mip_stat == GLP_FEAS);
      /* basic solution of LP relaxation must be optimal */
      xassert(mip->pbs_stat == GLP_FEAS && mip->dbs_stat == GLP_FEAS);
      /* determine the objective function value */
      obj = mip->obj_val;
      /* walk through the column list */
      for (j = 1; j <= mip->n; j++)
      {  GLPCOL *col = mip->col[j];
         /* if the column is not integer, skip it */
         if (col->kind != GLP_IV) continue;
         /* obtain bounds of j-th column */
         lb = col->lb, ub = col->ub;
         /* and determine its status and reduced cost */
         stat = col->stat, dj = col->dual;
         /* analyze the reduced cost */
         switch (mip->dir)
         {  case GLP_MIN:
               /* minimization */
               if (stat == GLP_NL)
               {  /* j-th column is non-basic on its lower bound */
                  if (dj < 0.0) dj = 0.0;
                  if (obj + dj >= mip->mip_obj)
                     glp_set_col_bnds(mip, j, GLP_FX, lb, lb), fixed++;
               }
               else if (stat == GLP_NU)
               {  /* j-th column is non-basic on its upper bound */
                  if (dj > 0.0) dj = 0.0;
                  if (obj - dj >= mip->mip_obj)
                     glp_set_col_bnds(mip, j, GLP_FX, ub, ub), fixed++;
               }
               break;
            case GLP_MAX:
               /* maximization */
               if (stat == GLP_NL)
               {  /* j-th column is non-basic on its lower bound */
                  if (dj > 0.0) dj = 0.0;
                  if (obj + dj <= mip->mip_obj)
                     glp_set_col_bnds(mip, j, GLP_FX, lb, lb), fixed++;
               }
               else if (stat == GLP_NU)
               {  /* j-th column is non-basic on its upper bound */
                  if (dj < 0.0) dj = 0.0;
                  if (obj - dj <= mip->mip_obj)
                     glp_set_col_bnds(mip, j, GLP_FX, ub, ub), fixed++;
               }
               break;
            default:
               xassert(T != T);
         }
      }
      if (T->parm->msg_lev >= GLP_MSG_DBG)
      {  if (fixed == 0)
            /* nothing to say */;
         else if (fixed == 1)
            xprintf("One column has been fixed by reduced cost\n");
         else
            xprintf("%d columns have been fixed by reduced costs\n",
               fixed);
      }
      /* fixing non-basic columns on their current bounds does not
         change the basic solution */
      xassert(mip->pbs_stat == GLP_FEAS && mip->dbs_stat == GLP_FEAS);
      return;
}

/***********************************************************************
*  branch_on - perform branching on specified variable
*
*  This routine performs branching on j-th column (structural variable)
*  of the current subproblem. The specified column must be of integer
*  kind and must have a fractional value in optimal basic solution of
*  LP relaxation of the current subproblem (i.e. only columns for which
*  the flag non_int[j] is set are valid candidates to branch on).
*
*  Let x be j-th structural variable, and beta be its primal fractional
*  value in the current basic solution. Branching on j-th variable is
*  dividing the current subproblem into two new subproblems, which are
*  identical to the current subproblem with the following exception: in
*  the first subproblem that begins the down-branch x has a new upper
*  bound x <= floor(beta), and in the second subproblem that begins the
*  up-branch x has a new lower bound x >= ceil(beta).
*
*  Depending on estimation of local bounds for down- and up-branches
*  this routine returns the following:
*
*  0 - both branches have been created;
*  1 - one branch is hopeless and has been pruned, so now the current
*      subproblem is other branch;
*  2 - both branches are hopeless and have been pruned; new subproblem
*      selection is needed to continue the search. */

static int branch_on(glp_tree *T, int j, int next)
{     glp_prob *mip = T->mip;
      IOSNPD *node;
      int m = mip->m;
      int n = mip->n;
      int type, dn_type, up_type, dn_bad, up_bad, p, ret, clone[1+2];
      double lb, ub, beta, new_ub, new_lb, dn_lp, up_lp, dn_bnd, up_bnd;
      /* determine bounds and value of x[j] in optimal solution to LP
         relaxation of the current subproblem */
      xassert(1 <= j && j <= n);
      type = mip->col[j]->type;
      lb = mip->col[j]->lb;
      ub = mip->col[j]->ub;
      beta = mip->col[j]->prim;
      /* determine new bounds of x[j] for down- and up-branches */
      new_ub = floor(beta);
      new_lb = ceil(beta);
      switch (type)
      {  case GLP_FR:
            dn_type = GLP_UP;
            up_type = GLP_LO;
            break;
         case GLP_LO:
            xassert(lb <= new_ub);
            dn_type = (lb == new_ub ? GLP_FX : GLP_DB);
            xassert(lb + 1.0 <= new_lb);
            up_type = GLP_LO;
            break;
         case GLP_UP:
            xassert(new_ub <= ub - 1.0);
            dn_type = GLP_UP;
            xassert(new_lb <= ub);
            up_type = (new_lb == ub ? GLP_FX : GLP_DB);
            break;
         case GLP_DB:
            xassert(lb <= new_ub && new_ub <= ub - 1.0);
            dn_type = (lb == new_ub ? GLP_FX : GLP_DB);
            xassert(lb + 1.0 <= new_lb && new_lb <= ub);
            up_type = (new_lb == ub ? GLP_FX : GLP_DB);
            break;
         default:
            xassert(type != type);
      }
      /* compute local bounds to LP relaxation for both branches */
      ios_eval_degrad(T, j, &dn_lp, &up_lp);
      /* and improve them by rounding */
      dn_bnd = ios_round_bound(T, dn_lp);
      up_bnd = ios_round_bound(T, up_lp);
      /* check local bounds for down- and up-branches */
      dn_bad = !ios_is_hopeful(T, dn_bnd);
      up_bad = !ios_is_hopeful(T, up_bnd);
      if (dn_bad && up_bad)
      {  if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Both down- and up-branches are hopeless\n");
         ret = 2;
         goto done;
      }
      else if (up_bad)
      {  if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Up-branch is hopeless\n");
         glp_set_col_bnds(mip, j, dn_type, lb, new_ub);
         T->curr->lp_obj = dn_lp;
         if (mip->dir == GLP_MIN)
         {  if (T->curr->bound < dn_bnd)
                T->curr->bound = dn_bnd;
         }
         else if (mip->dir == GLP_MAX)
         {  if (T->curr->bound > dn_bnd)
                T->curr->bound = dn_bnd;
         }
         else
            xassert(mip != mip);
         ret = 1;
         goto done;
      }
      else if (dn_bad)
      {  if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Down-branch is hopeless\n");
         glp_set_col_bnds(mip, j, up_type, new_lb, ub);
         T->curr->lp_obj = up_lp;
         if (mip->dir == GLP_MIN)
         {  if (T->curr->bound < up_bnd)
                T->curr->bound = up_bnd;
         }
         else if (mip->dir == GLP_MAX)
         {  if (T->curr->bound > up_bnd)
                T->curr->bound = up_bnd;
         }
         else
            xassert(mip != mip);
         ret = 1;
         goto done;
      }
      /* both down- and up-branches seem to be hopeful */
      if (T->parm->msg_lev >= GLP_MSG_DBG)
         xprintf("Branching on column %d, primal value is %.9e\n",
            j, beta);
      /* determine the reference number of the current subproblem */
      xassert(T->curr != NULL);
      p = T->curr->p;
      T->curr->br_var = j;
      T->curr->br_val = beta;
      /* freeze the current subproblem */
      ios_freeze_node(T);
      /* create two clones of the current subproblem; the first clone
         begins the down-branch, the second one begins the up-branch */
      ios_clone_node(T, p, 2, clone);
      if (T->parm->msg_lev >= GLP_MSG_DBG)
         xprintf("Node %d begins down branch, node %d begins up branch "
            "\n", clone[1], clone[2]);
      /* set new upper bound of j-th column in the down-branch */
      node = T->slot[clone[1]].node;
      xassert(node != NULL);
      xassert(node->up != NULL);
      xassert(node->b_ptr == NULL);
      node->b_ptr = dmp_get_atom(T->pool, sizeof(IOSBND));
      node->b_ptr->k = m + j;
      node->b_ptr->type = (unsigned char)dn_type;
      node->b_ptr->lb = lb;
      node->b_ptr->ub = new_ub;
      node->b_ptr->next = NULL;
      node->lp_obj = dn_lp;
      if (mip->dir == GLP_MIN)
      {  if (node->bound < dn_bnd)
             node->bound = dn_bnd;
      }
      else if (mip->dir == GLP_MAX)
      {  if (node->bound > dn_bnd)
             node->bound = dn_bnd;
      }
      else
         xassert(mip != mip);
      /* set new lower bound of j-th column in the up-branch */
      node = T->slot[clone[2]].node;
      xassert(node != NULL);
      xassert(node->up != NULL);
      xassert(node->b_ptr == NULL);
      node->b_ptr = dmp_get_atom(T->pool, sizeof(IOSBND));
      node->b_ptr->k = m + j;
      node->b_ptr->type = (unsigned char)up_type;
      node->b_ptr->lb = new_lb;
      node->b_ptr->ub = ub;
      node->b_ptr->next = NULL;
      node->lp_obj = up_lp;
      if (mip->dir == GLP_MIN)
      {  if (node->bound < up_bnd)
             node->bound = up_bnd;
      }
      else if (mip->dir == GLP_MAX)
      {  if (node->bound > up_bnd)
             node->bound = up_bnd;
      }
      else
         xassert(mip != mip);
      /* suggest the subproblem to be solved next */
      xassert(T->child == 0);
      if (next == GLP_NO_BRNCH)
         T->child = 0;
      else if (next == GLP_DN_BRNCH)
         T->child = clone[1];
      else if (next == GLP_UP_BRNCH)
         T->child = clone[2];
      else
         xassert(next != next);
      ret = 0;
done: return ret;
}

/***********************************************************************
*  cleanup_the_tree - prune hopeless branches from the tree
*
*  This routine walks through the active list and checks the local
*  bound for every active subproblem. If the local bound indicates that
*  the subproblem cannot have integer optimal solution better than the
*  incumbent objective value, the routine deletes such subproblem that,
*  in turn, involves pruning the corresponding branch of the tree. */

static void cleanup_the_tree(glp_tree *T)
{     IOSNPD *node, *next_node;
      int count = 0;
      /* the global bound must exist */
      xassert(T->mip->mip_stat == GLP_FEAS);
      /* walk through the list of active subproblems */
      for (node = T->head; node != NULL; node = next_node)
      {  /* deleting some active problem node may involve deleting its
            parents recursively; however, all its parents being created
            *before* it are always *precede* it in the node list, so
            the next problem node is never affected by such deletion */
         next_node = node->next;
         /* if the branch is hopeless, prune it */
         if (!is_branch_hopeful(T, node->p))
            ios_delete_node(T, node->p), count++;
      }
      if (T->parm->msg_lev >= GLP_MSG_DBG)
      {  if (count == 1)
            xprintf("One hopeless branch has been pruned\n");
         else if (count > 1)
            xprintf("%d hopeless branches have been pruned\n", count);
      }
      return;
}

/***********************************************************************
*  round_heur - simple rounding heuristic
*
*  This routine attempts to guess an integer feasible solution by
*  simple rounding values of all integer variables in basic solution to
*  nearest integers. */

static int round_heur(glp_tree *T)
{     glp_prob *P = T->mip;
      /*int m = P->m;*/
      int n = P->n;
      int i, j, ret;
      double *x;
      /* compute rounded values of variables */
      x = talloc(1+n, double);
      for (j = 1; j <= n; j++)
      {  GLPCOL *col = P->col[j];
         if (col->kind == GLP_IV)
         {  /* integer variable */
            x[j] = floor(col->prim + 0.5);
         }
         else if (col->type == GLP_FX)
         {  /* fixed variable */
            x[j] = col->prim;
         }
         else
         {  /* non-integer non-fixed variable */
            ret = 3;
            goto done;
         }
      }
      /* check that no constraints are violated */
      for (i = 1; i <= T->orig_m; i++)
      {  int type = T->orig_type[i];
         GLPAIJ *aij;
         double sum;
         if (type == GLP_FR)
            continue;
         /* compute value of linear form */
         sum = 0.0;
         for (aij = P->row[i]->ptr; aij != NULL; aij = aij->r_next)
            sum += aij->val * x[aij->col->j];
         /* check lower bound */
         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)
         {  if (sum < T->orig_lb[i] - 1e-9)
            {  /* lower bound is violated */
               ret = 2;
               goto done;
            }
         }
         /* check upper bound */
         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)
         {  if (sum > T->orig_ub[i] + 1e-9)
            {  /* upper bound is violated */
               ret = 2;
               goto done;
            }
         }
      }
      /* rounded solution is integer feasible */
      if (glp_ios_heur_sol(T, x) == 0)
      {  /* solution is accepted */
         ret = 0;
      }
      else
      {  /* solution is rejected */
         ret = 1;
      }
done: tfree(x);
      return ret;
}

#if 0
#define round_heur round_heur2
static int round_heur(glp_tree *T)
{     glp_prob *lp;
      int *ind, ret, i, j, len;
      double *val;
      lp = glp_create_prob();
      ind = talloc(1+T->mip->n, int);
      val = talloc(1+T->mip->n, double);
      glp_add_rows(lp, T->orig_m);
      glp_add_cols(lp, T->n);
      for (i = 1; i <= T->orig_m; i++)
      {  glp_set_row_bnds(lp, i,
            T->orig_type[i], T->orig_lb[i], T->orig_ub[i]);
         len = glp_get_mat_row(T->mip, i, ind, val);
         glp_set_mat_row(lp, i, len, ind, val);
      }
      for (j = 1; j <= T->n; j++)
      {  GLPCOL *col = T->mip->col[j];
         glp_set_obj_coef(lp, j, col->coef);
         if (col->kind == GLP_IV)
         {  /* integer variable */
            glp_set_col_bnds(lp, j, GLP_FX, floor(col->prim + .5), 0);
         }
         else
         {  glp_set_col_bnds(lp, j, T->orig_type[T->orig_m+j],
               T->orig_lb[T->orig_m+j], T->orig_ub[T->orig_m+j]);
         }
      }
glp_term_out(GLP_OFF);
      glp_adv_basis(lp, 0);
      ret = glp_simplex(lp, NULL);
glp_term_out(GLP_ON);
      if (ret != 0)
      {  ret = 1;
         goto done;
      }
      if (glp_get_status(lp) != GLP_OPT)
      {  ret = 2;
         goto done;
      }
      for (j = 1; j <= lp->n; j++)
         val[j] = lp->col[j]->prim;
      if (glp_ios_heur_sol(T, val) == 0)
         ret = 0;
      else
         ret = 3;
done: glp_delete_prob(lp);
      tfree(ind);
      tfree(val);
      return ret;
}
#endif

/**********************************************************************/

#if 1 /* 08/III-2016 */
static void gmi_gen(glp_tree *T)
{     /* generate Gomory's mixed integer cuts */
      glp_prob *P, *pool;
      P = T->mip;
      pool = glp_create_prob();
      glp_add_cols(pool, P->n);
      glp_gmi_gen(P, pool, 50);
      if (pool->m > 0)
      {  int i, len, *ind;
         double *val;
         ind = xcalloc(1+P->n, sizeof(int));
         val = xcalloc(1+P->n, sizeof(double));
         for (i = 1; i <= pool->m; i++)
         {  len = glp_get_mat_row(pool, i, ind, val);
            glp_ios_add_row(T, NULL, GLP_RF_GMI, 0, len, ind, val,
               GLP_LO, pool->row[i]->lb);
         }
         xfree(ind);
         xfree(val);
      }
      glp_delete_prob(pool);
      return;
}
#endif

#if 1 /* 08/III-2016 */
static void mir_gen(glp_tree *T)
{     /* generate mixed integer rounding cuts */
      glp_prob *P, *pool;
      P = T->mip;
      pool = glp_create_prob();
      glp_add_cols(pool, P->n);
      glp_mir_gen(P, T->mir_gen, pool);
      if (pool->m > 0)
      {  int i, len, *ind;
         double *val;
         ind = xcalloc(1+P->n, sizeof(int));
         val = xcalloc(1+P->n, sizeof(double));
         for (i = 1; i <= pool->m; i++)
         {  len = glp_get_mat_row(pool, i, ind, val);
            glp_ios_add_row(T, NULL, GLP_RF_MIR, 0, len, ind, val,
               GLP_UP, pool->row[i]->ub);
         }
         xfree(ind);
         xfree(val);
      }
      glp_delete_prob(pool);
      return;
}
#endif

#if 1 /* 08/III-2016 */
static void clq_gen(glp_tree *T, glp_cfg *G)
{     /* generate clique cut from conflict graph */
      glp_prob *P = T->mip;
      int n = P->n;
      int len, *ind;
      double *val;
      ind = talloc(1+n, int);
      val = talloc(1+n, double);
      len = glp_clq_cut(T->mip, G, ind, val);
      if (len > 0)
         glp_ios_add_row(T, NULL, GLP_RF_CLQ, 0, len, ind, val, GLP_UP,
            val[0]);
      tfree(ind);
      tfree(val);
      return;
}
#endif

static void generate_cuts(glp_tree *T)
{     /* generate generic cuts with built-in generators */
      if (!(T->parm->mir_cuts == GLP_ON ||
            T->parm->gmi_cuts == GLP_ON ||
            T->parm->cov_cuts == GLP_ON ||
            T->parm->clq_cuts == GLP_ON)) goto done;
#if 1 /* 20/IX-2008 */
      {  int i, max_cuts, added_cuts;
         max_cuts = T->n;
         if (max_cuts < 1000) max_cuts = 1000;
         added_cuts = 0;
         for (i = T->orig_m+1; i <= T->mip->m; i++)
         {  if (T->mip->row[i]->origin == GLP_RF_CUT)
               added_cuts++;
         }
         /* xprintf("added_cuts = %d\n", added_cuts); */
         if (added_cuts >= max_cuts) goto done;
      }
#endif
      /* generate and add to POOL all cuts violated by x* */
      if (T->parm->gmi_cuts == GLP_ON)
      {  if (T->curr->changed < 7)
#if 0 /* 08/III-2016 */
            ios_gmi_gen(T);
#else
            gmi_gen(T);
#endif
      }
      if (T->parm->mir_cuts == GLP_ON)
      {  xassert(T->mir_gen != NULL);
#if 0 /* 08/III-2016 */
         ios_mir_gen(T, T->mir_gen);
#else
         mir_gen(T);
#endif
      }
      if (T->parm->cov_cuts == GLP_ON)
      {  /* cover cuts works well along with mir cuts */
         /*if (T->round <= 5)*/
            ios_cov_gen(T);
      }
      if (T->parm->clq_cuts == GLP_ON)
      {  if (T->clq_gen != NULL)
#if 0 /* 29/VI-2013 */
         {  if (T->curr->level == 0 && T->curr->changed < 50 ||
                T->curr->level >  0 && T->curr->changed < 5)
#else /* FIXME */
         {  if (T->curr->level == 0 && T->curr->changed < 500 ||
                T->curr->level >  0 && T->curr->changed < 50)
#endif
#if 0 /* 08/III-2016 */
               ios_clq_gen(T, T->clq_gen);
#else
               clq_gen(T, T->clq_gen);
#endif
         }
      }
done: return;
}

/**********************************************************************/

static void remove_cuts(glp_tree *T)
{     /* remove inactive cuts (some valueable globally valid cut might
         be saved in the global cut pool) */
      int i, cnt = 0, *num = NULL;
      xassert(T->curr != NULL);
      for (i = T->orig_m+1; i <= T->mip->m; i++)
      {  if (T->mip->row[i]->origin == GLP_RF_CUT &&
             T->mip->row[i]->level == T->curr->level &&
             T->mip->row[i]->stat == GLP_BS)
         {  if (num == NULL)
               num = xcalloc(1+T->mip->m, sizeof(int));
            num[++cnt] = i;
         }
      }
      if (cnt > 0)
      {  glp_del_rows(T->mip, cnt, num);
#if 0
         xprintf("%d inactive cut(s) removed\n", cnt);
#endif
         xfree(num);
         xassert(glp_factorize(T->mip) == 0);
      }
      return;
}

/**********************************************************************/

static void display_cut_info(glp_tree *T)
{     glp_prob *mip = T->mip;
      int i, gmi = 0, mir = 0, cov = 0, clq = 0, app = 0;
      for (i = mip->m; i > 0; i--)
      {  GLPROW *row;
         row = mip->row[i];
         /* if (row->level < T->curr->level) break; */
         if (row->origin == GLP_RF_CUT)
         {  if (row->klass == GLP_RF_GMI)
               gmi++;
            else if (row->klass == GLP_RF_MIR)
               mir++;
            else if (row->klass == GLP_RF_COV)
               cov++;
            else if (row->klass == GLP_RF_CLQ)
               clq++;
            else
               app++;
         }
      }
      xassert(T->curr != NULL);
      if (gmi + mir + cov + clq + app > 0)
      {  xprintf("Cuts on level %d:", T->curr->level);
         if (gmi > 0) xprintf(" gmi = %d;", gmi);
         if (mir > 0) xprintf(" mir = %d;", mir);
         if (cov > 0) xprintf(" cov = %d;", cov);
         if (clq > 0) xprintf(" clq = %d;", clq);
         if (app > 0) xprintf(" app = %d;", app);
         xprintf("\n");
      }
      return;
}

/***********************************************************************
*  NAME
*
*  ios_driver - branch-and-cut driver
*
*  SYNOPSIS
*
*  #include "glpios.h"
*  int ios_driver(glp_tree *T);
*
*  DESCRIPTION
*
*  The routine ios_driver is a branch-and-cut driver. It controls the
*  MIP solution process.
*
*  RETURNS
*
*  0  The MIP problem instance has been successfully solved. This code
*     does not necessarily mean that the solver has found optimal
*     solution. It only means that the solution process was successful.
*
*  GLP_EFAIL
*     The search was prematurely terminated due to the solver failure.
*
*  GLP_EMIPGAP
*     The search was prematurely terminated, because the relative mip
*     gap tolerance has been reached.
*
*  GLP_ETMLIM
*     The search was prematurely terminated, because the time limit has
*     been exceeded.
*
*  GLP_ESTOP
*     The search was prematurely terminated by application. */

int ios_driver(glp_tree *T)
{     int p, curr_p, p_stat, d_stat, ret;
#if 1 /* carry out to glp_tree */
      int pred_p = 0;
      /* if the current subproblem has been just created due to
         branching, pred_p is the reference number of its parent
         subproblem, otherwise pred_p is zero */
#endif
#if 1 /* 18/VII-2013 */
      int bad_cut;
      double old_obj;
#endif
#if 0 /* 10/VI-2013 */
      glp_long ttt = T->tm_beg;
#else
      double ttt = T->tm_beg;
#endif
#if 1 /* 27/II-2016 by Chris */
      int root_done = 0;
#endif
#if 0
      ((glp_iocp *)T->parm)->msg_lev = GLP_MSG_DBG;
#endif
#if 1 /* 16/III-2016 */
      if (((glp_iocp *)T->parm)->flip)
         xprintf("WARNING: LONG-STEP DUAL SIMPLEX WILL BE USED\n");
#endif
      /* on entry to the B&B driver it is assumed that the active list
         contains the only active (i.e. root) subproblem, which is the
         original MIP problem to be solved */
loop: /* main loop starts here */
      /* at this point the current subproblem does not exist */
      xassert(T->curr == NULL);
      /* if the active list is empty, the search is finished */
      if (T->head == NULL)
      {  if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Active list is empty!\n");
#if 0 /* 10/VI-2013 */
         xassert(dmp_in_use(T->pool).lo == 0);
#else
         xassert(dmp_in_use(T->pool) == 0);
#endif
         ret = 0;
         goto done;
      }
      /* select some active subproblem to continue the search */
      xassert(T->next_p == 0);
      /* let the application program select subproblem */
      if (T->parm->cb_func != NULL)
      {  xassert(T->reason == 0);
         T->reason = GLP_ISELECT;
         T->parm->cb_func(T, T->parm->cb_info);
         T->reason = 0;
         if (T->stop)
         {  ret = GLP_ESTOP;
            goto done;
         }
      }
      if (T->next_p != 0)
      {  /* the application program has selected something */
         ;
      }
      else if (T->a_cnt == 1)
      {  /* the only active subproblem exists, so select it */
         xassert(T->head->next == NULL);
         T->next_p = T->head->p;
      }
      else if (T->child != 0)
      {  /* select one of branching childs suggested by the branching
            heuristic */
         T->next_p = T->child;
      }
      else
      {  /* select active subproblem as specified by the backtracking
            technique option */
         T->next_p = ios_choose_node(T);
      }
      /* the active subproblem just selected becomes current */
      ios_revive_node(T, T->next_p);
      T->next_p = T->child = 0;
      /* invalidate pred_p, if it is not the reference number of the
         parent of the current subproblem */
      if (T->curr->up != NULL && T->curr->up->p != pred_p) pred_p = 0;
      /* determine the reference number of the current subproblem */
      p = T->curr->p;
      if (T->parm->msg_lev >= GLP_MSG_DBG)
      {  xprintf("-----------------------------------------------------"
            "-------------------\n");
         xprintf("Processing node %d at level %d\n", p, T->curr->level);
      }
#if 0
      if (p == 1)
         glp_write_lp(T->mip, NULL, "root.lp");
#endif
#if 1 /* 24/X-2015 */
      if (p == 1)
      {  if (T->parm->sr_heur == GLP_OFF)
         {  if (T->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("Simple rounding heuristic disabled\n");
         }
      }
#endif
      /* if it is the root subproblem, initialize cut generators */
      if (p == 1)
      {  if (T->parm->gmi_cuts == GLP_ON)
         {  if (T->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("Gomory's cuts enabled\n");
         }
         if (T->parm->mir_cuts == GLP_ON)
         {  if (T->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("MIR cuts enabled\n");
            xassert(T->mir_gen == NULL);
#if 0 /* 06/III-2016 */
            T->mir_gen = ios_mir_init(T);
#else
            T->mir_gen = glp_mir_init(T->mip);
#endif
         }
         if (T->parm->cov_cuts == GLP_ON)
         {  if (T->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("Cover cuts enabled\n");
         }
         if (T->parm->clq_cuts == GLP_ON)
         {  xassert(T->clq_gen == NULL);
            if (T->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("Clique cuts enabled\n");
#if 0 /* 08/III-2016 */
            T->clq_gen = ios_clq_init(T);
#else
            T->clq_gen = glp_cfg_init(T->mip);
#endif
         }
      }
#if 1 /* 18/VII-2013 */
      bad_cut = 0;
#endif
more: /* minor loop starts here */
      /* at this point the current subproblem needs either to be solved
         for the first time or re-optimized due to reformulation */
      /* display current progress of the search */
      if (T->parm->msg_lev >= GLP_MSG_DBG ||
          T->parm->msg_lev >= GLP_MSG_ON &&
        (double)(T->parm->out_frq - 1) <=
            1000.0 * xdifftime(xtime(), T->tm_lag))
         show_progress1(T, 0);
      if (T->parm->msg_lev >= GLP_MSG_ALL &&
            xdifftime(xtime(), ttt) >= 60.0)
#if 0 /* 16/II-2012 */
      {  glp_long total;
         glp_mem_usage(NULL, NULL, &total, NULL);
         xprintf("Time used: %.1f secs.  Memory used: %.1f Mb.\n",
            xdifftime(xtime(), T->tm_beg), xltod(total) / 1048576.0);
         ttt = xtime();
      }
#else
      {  size_t total;
         glp_mem_usage(NULL, NULL, &total, NULL);
         xprintf("Time used: %.1f secs.  Memory used: %.1f Mb.\n",
            xdifftime(xtime(), T->tm_beg), (double)total / 1048576.0);
         ttt = xtime();
      }
#endif
      /* check the mip gap */
      if (T->parm->mip_gap > 0.0 &&
          ios_relative_gap(T) <= T->parm->mip_gap)
      {  if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Relative gap tolerance reached; search terminated "
               "\n");
         ret = GLP_EMIPGAP;
         goto done;
      }
      /* check if the time limit has been exhausted */
      if (T->parm->tm_lim < INT_MAX &&
         (double)(T->parm->tm_lim - 1) <=
         1000.0 * xdifftime(xtime(), T->tm_beg))
      {  if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Time limit exhausted; search terminated\n");
         ret = GLP_ETMLIM;
         goto done;
      }
      /* let the application program preprocess the subproblem */
      if (T->parm->cb_func != NULL)
      {  xassert(T->reason == 0);
         T->reason = GLP_IPREPRO;
         T->parm->cb_func(T, T->parm->cb_info);
         T->reason = 0;
         if (T->stop)
         {  ret = GLP_ESTOP;
            goto done;
         }
      }
      /* perform basic preprocessing */
      if (T->parm->pp_tech == GLP_PP_NONE)
         ;
      else if (T->parm->pp_tech == GLP_PP_ROOT)
#if 0 /* 27/II-2016 by Chris */
      {  if (T->curr->level == 0)
#else
      {  if (!root_done)
#endif
         {  if (ios_preprocess_node(T, 100))
               goto fath;
         }
      }
      else if (T->parm->pp_tech == GLP_PP_ALL)
#if 0 /* 27/II-2016 by Chris */
      {  if (ios_preprocess_node(T, T->curr->level == 0 ? 100 : 10))
#else
      {  if (ios_preprocess_node(T, !root_done ? 100 : 10))
#endif
            goto fath;
      }
      else
         xassert(T != T);
      /* preprocessing may improve the global bound */
      if (!is_branch_hopeful(T, p))
      {  xprintf("*** not tested yet ***\n");
         goto fath;
      }
      /* solve LP relaxation of the current subproblem */
      if (T->parm->msg_lev >= GLP_MSG_DBG)
         xprintf("Solving LP relaxation...\n");
      ret = ios_solve_node(T);
      if (ret == GLP_ETMLIM)
         goto done;
      else if (!(ret == 0 || ret == GLP_EOBJLL || ret == GLP_EOBJUL))
      {  if (T->parm->msg_lev >= GLP_MSG_ERR)
            xprintf("ios_driver: unable to solve current LP relaxation;"
               " glp_simplex returned %d\n", ret);
         ret = GLP_EFAIL;
         goto done;
      }
      /* analyze status of the basic solution to LP relaxation found */
      p_stat = T->mip->pbs_stat;
      d_stat = T->mip->dbs_stat;
      if (p_stat == GLP_FEAS && d_stat == GLP_FEAS)
      {  /* LP relaxation has optimal solution */
         if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Found optimal solution to LP relaxation\n");
      }
      else if (d_stat == GLP_NOFEAS)
      {  /* LP relaxation has no dual feasible solution */
         /* since the current subproblem cannot have a larger feasible
            region than its parent, there is something wrong */
         if (T->parm->msg_lev >= GLP_MSG_ERR)
            xprintf("ios_driver: current LP relaxation has no dual feas"
               "ible solution\n");
         ret = GLP_EFAIL;
         goto done;
      }
      else if (p_stat == GLP_INFEAS && d_stat == GLP_FEAS)
      {  /* LP relaxation has no primal solution which is better than
            the incumbent objective value */
         xassert(T->mip->mip_stat == GLP_FEAS);
         if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("LP relaxation has no solution better than incumben"
               "t objective value\n");
         /* prune the branch */
         goto fath;
      }
      else if (p_stat == GLP_NOFEAS)
      {  /* LP relaxation has no primal feasible solution */
         if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("LP relaxation has no feasible solution\n");
         /* prune the branch */
         goto fath;
      }
      else
      {  /* other cases cannot appear */
         xassert(T->mip != T->mip);
      }
      /* at this point basic solution to LP relaxation of the current
         subproblem is optimal */
      xassert(p_stat == GLP_FEAS && d_stat == GLP_FEAS);
      xassert(T->curr != NULL);
      T->curr->lp_obj = T->mip->obj_val;
      /* thus, it defines a local bound to integer optimal solution of
         the current subproblem */
      {  double bound = T->mip->obj_val;
         /* some local bound to the current subproblem could be already
            set before, so we should only improve it */
         bound = ios_round_bound(T, bound);
         if (T->mip->dir == GLP_MIN)
         {  if (T->curr->bound < bound)
               T->curr->bound = bound;
         }
         else if (T->mip->dir == GLP_MAX)
         {  if (T->curr->bound > bound)
               T->curr->bound = bound;
         }
         else
            xassert(T->mip != T->mip);
         if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Local bound is %.9e\n", bound);
      }
      /* if the local bound indicates that integer optimal solution of
         the current subproblem cannot be better than the global bound,
         prune the branch */
      if (!is_branch_hopeful(T, p))
      {  if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("Current branch is hopeless and can be pruned\n");
         goto fath;
      }
      /* let the application program generate additional rows ("lazy"
         constraints) */
      xassert(T->reopt == 0);
      xassert(T->reinv == 0);
      if (T->parm->cb_func != NULL)
      {  xassert(T->reason == 0);
         T->reason = GLP_IROWGEN;
         T->parm->cb_func(T, T->parm->cb_info);
         T->reason = 0;
         if (T->stop)
         {  ret = GLP_ESTOP;
            goto done;
         }
         if (T->reopt)
         {  /* some rows were added; re-optimization is needed */
            T->reopt = T->reinv = 0;
            goto more;
         }
         if (T->reinv)
         {  /* no rows were added, however, some inactive rows were
               removed */
            T->reinv = 0;
            xassert(glp_factorize(T->mip) == 0);
         }
      }
      /* check if the basic solution is integer feasible */
      check_integrality(T);
      /* if the basic solution satisfies to all integrality conditions,
         it is a new, better integer feasible solution */
      if (T->curr->ii_cnt == 0)
      {  if (T->parm->msg_lev >= GLP_MSG_DBG)
            xprintf("New integer feasible solution found\n");
         if (T->parm->msg_lev >= GLP_MSG_ALL)
            display_cut_info(T);
         record_solution(T);
         if (T->parm->msg_lev >= GLP_MSG_ON)
            show_progress1(T, 1);
#if 1 /* 11/VII-2013 */
         ios_process_sol(T);
#endif
         /* make the application program happy */
         if (T->parm->cb_func != NULL)
         {  xassert(T->reason == 0);
            T->reason = GLP_IBINGO;
            T->parm->cb_func(T, T->parm->cb_info);
            T->reason = 0;
            if (T->stop)
            {  ret = GLP_ESTOP;
               goto done;
            }
         }
         /* since the current subproblem has been fathomed, prune its
            branch */
         goto fath;
      }
      /* at this point basic solution to LP relaxation of the current
         subproblem is optimal, but integer infeasible */
      /* try to fix some non-basic structural variables of integer kind
         on their current bounds due to reduced costs */
      if (T->mip->mip_stat == GLP_FEAS)
         fix_by_red_cost(T);
      /* let the application program try to find some solution to the
         original MIP with a primal heuristic */
      if (T->parm->cb_func != NULL)
      {  xassert(T->reason == 0);
         T->reason = GLP_IHEUR;
         T->parm->cb_func(T, T->parm->cb_info);
         T->reason = 0;
         if (T->stop)
         {  ret = GLP_ESTOP;
            goto done;
         }
         /* check if the current branch became hopeless */
         if (!is_branch_hopeful(T, p))
         {  if (T->parm->msg_lev >= GLP_MSG_DBG)
               xprintf("Current branch became hopeless and can be prune"
                  "d\n");
            goto fath;
         }
      }
      /* try to find solution with the feasibility pump heuristic */
#if 0 /* 27/II-2016 by Chris */
      if (T->parm->fp_heur)
#else
      if (T->parm->fp_heur && !root_done)
#endif
      {  xassert(T->reason == 0);
         T->reason = GLP_IHEUR;
         ios_feas_pump(T);
         T->reason = 0;
         /* check if the current branch became hopeless */
         if (!is_branch_hopeful(T, p))
         {  if (T->parm->msg_lev >= GLP_MSG_DBG)
               xprintf("Current branch became hopeless and can be prune"
                  "d\n");
            goto fath;
         }
      }
#if 1 /* 25/V-2013 */
      /* try to find solution with the proximity search heuristic */
#if 0 /* 27/II-2016 by Chris */
      if (T->parm->ps_heur)
#else
      if (T->parm->ps_heur && !root_done)
#endif
      {  xassert(T->reason == 0);
         T->reason = GLP_IHEUR;
         ios_proxy_heur(T);
         T->reason = 0;
         /* check if the current branch became hopeless */
         if (!is_branch_hopeful(T, p))
         {  if (T->parm->msg_lev >= GLP_MSG_DBG)
               xprintf("Current branch became hopeless and can be prune"
                  "d\n");
            goto fath;
         }
      }
#endif
#if 1 /* 24/X-2015 */
      /* try to find solution with a simple rounding heuristic */
      if (T->parm->sr_heur)
      {  xassert(T->reason == 0);
         T->reason = GLP_IHEUR;
         round_heur(T);
         T->reason = 0;
         /* check if the current branch became hopeless */
         if (!is_branch_hopeful(T, p))
         {  if (T->parm->msg_lev >= GLP_MSG_DBG)
               xprintf("Current branch became hopeless and can be prune"
                  "d\n");
            goto fath;
         }
      }
#endif
      /* it's time to generate cutting planes */
      xassert(T->local != NULL);
      xassert(T->local->size == 0);
      /* let the application program generate some cuts; note that it
         can add cuts either to the local cut pool or directly to the
         current subproblem */
      if (T->parm->cb_func != NULL)
      {  xassert(T->reason == 0);
         T->reason = GLP_ICUTGEN;
         T->parm->cb_func(T, T->parm->cb_info);
         T->reason = 0;
         if (T->stop)
         {  ret = GLP_ESTOP;
            goto done;
         }
      }
#if 1 /* 18/VII-2013 */
      if (T->curr->changed > 0)
      {  double degrad = fabs(T->curr->lp_obj - old_obj);
         if (degrad < 1e-4 * (1.0 + fabs(old_obj)))
            bad_cut++;
         else
            bad_cut = 0;
      }
      old_obj = T->curr->lp_obj;
#if 0 /* 27/II-2016 by Chris */
      if (bad_cut == 0 || (T->curr->level == 0 && bad_cut <= 3))
#else
      if (bad_cut == 0 || (!root_done && bad_cut <= 3))
#endif
#endif
      /* try to generate generic cuts with built-in generators
         (as suggested by Prof. Fischetti et al. the built-in cuts are
         not generated at each branching node; an intense attempt of
         generating new cuts is only made at the root node, and then
         a moderate effort is spent after each backtracking step) */
#if 0 /* 27/II-2016 by Chris */
      if (T->curr->level == 0 || pred_p == 0)
#else
      if (!root_done || pred_p == 0)
#endif
      {  xassert(T->reason == 0);
         T->reason = GLP_ICUTGEN;
         generate_cuts(T);
         T->reason = 0;
      }
      /* if the local cut pool is not empty, select useful cuts and add
         them to the current subproblem */
      if (T->local->size > 0)
      {  xassert(T->reason == 0);
         T->reason = GLP_ICUTGEN;
         ios_process_cuts(T);
         T->reason = 0;
      }
      /* clear the local cut pool */
      ios_clear_pool(T, T->local);
      /* perform re-optimization, if necessary */
      if (T->reopt)
      {  T->reopt = 0;
         T->curr->changed++;
         goto more;
      }
      /* no cuts were generated; remove inactive cuts */
      remove_cuts(T);
#if 0 /* 27/II-2016 by Chris */
      if (T->parm->msg_lev >= GLP_MSG_ALL && T->curr->level == 0)
#else
      if (T->parm->msg_lev >= GLP_MSG_ALL && !root_done)
#endif
         display_cut_info(T);
#if 1 /* 27/II-2016 by Chris */
      /* the first node will not be treated as root any more */
      if (!root_done) root_done = 1;
#endif
      /* update history information used on pseudocost branching */
      if (T->pcost != NULL) ios_pcost_update(T);
      /* it's time to perform branching */
      xassert(T->br_var == 0);
      xassert(T->br_sel == 0);
      /* let the application program choose variable to branch on */
      if (T->parm->cb_func != NULL)
      {  xassert(T->reason == 0);
         xassert(T->br_var == 0);
         xassert(T->br_sel == 0);
         T->reason = GLP_IBRANCH;
         T->parm->cb_func(T, T->parm->cb_info);
         T->reason = 0;
         if (T->stop)
         {  ret = GLP_ESTOP;
            goto done;
         }
      }
      /* if nothing has been chosen, choose some variable as specified
         by the branching technique option */
      if (T->br_var == 0)
         T->br_var = ios_choose_var(T, &T->br_sel);
      /* perform actual branching */
      curr_p = T->curr->p;
      ret = branch_on(T, T->br_var, T->br_sel);
      T->br_var = T->br_sel = 0;
      if (ret == 0)
      {  /* both branches have been created */
         pred_p = curr_p;
         goto loop;
      }
      else if (ret == 1)
      {  /* one branch is hopeless and has been pruned, so now the
            current subproblem is other branch */
         /* the current subproblem should be considered as a new one,
            since one bound of the branching variable was changed */
         T->curr->solved = T->curr->changed = 0;
#if 1 /* 18/VII-2013 */
         /* bad_cut = 0; */
#endif
         goto more;
      }
      else if (ret == 2)
      {  /* both branches are hopeless and have been pruned; new
            subproblem selection is needed to continue the search */
         goto fath;
      }
      else
         xassert(ret != ret);
fath: /* the current subproblem has been fathomed */
      if (T->parm->msg_lev >= GLP_MSG_DBG)
         xprintf("Node %d fathomed\n", p);
      /* freeze the current subproblem */
      ios_freeze_node(T);
      /* and prune the corresponding branch of the tree */
      ios_delete_node(T, p);
      /* if a new integer feasible solution has just been found, other
         branches may become hopeless and therefore must be pruned */
      if (T->mip->mip_stat == GLP_FEAS) cleanup_the_tree(T);
      /* new subproblem selection is needed due to backtracking */
      pred_p = 0;
      goto loop;
done: /* display progress of the search on exit from the solver */
      if (T->parm->msg_lev >= GLP_MSG_ON)
         show_progress1(T, 0);
      if (T->mir_gen != NULL)
#if 0 /* 06/III-2016 */
         ios_mir_term(T->mir_gen), T->mir_gen = NULL;
#else
         glp_mir_free(T->mir_gen), T->mir_gen = NULL;
#endif
      if (T->clq_gen != NULL)
#if 0 /* 08/III-2016 */
         ios_clq_term(T->clq_gen), T->clq_gen = NULL;
#else
         glp_cfg_free(T->clq_gen), T->clq_gen = NULL;
#endif
      /* return to the calling program */
      return ret;
}

/* eof */



/* spychuzc.c */

/***********************************************************************
*  This code is part of GLPK (GNU Linear Programming Kit).
*
*  Copyright (C) 2015-2016 Andrew Makhorin, Department for Applied
*  Informatics, Moscow Aviation Institute, Moscow, Russia. All rights
*  reserved. E-mail: <mao@gnu.org>.
*
*  GLPK is free software: you can redistribute it and/or modify it
*  under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  GLPK is distributed in the hope that it will be useful, but WITHOUT
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
*  License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/


/***********************************************************************
*  spy_chuzc_std - choose non-basic variable (dual textbook ratio test)
*
*  This routine implements an improved dual textbook ratio test to
*  choose non-basic variable xN[q].
*
*  Current reduced costs of non-basic variables should be placed in the
*  array locations d[1], ..., d[n-m]. Note that d[j] is a value of dual
*  basic variable lambdaN[j] in the current basis.
*
#if 0 (* 14/III-2016 *)
*  The parameter s specifies the sign of bound violation for basic
*  variable xB[p] chosen: s = +1.0 means that xB[p] violates its lower
*  bound, so dual non-basic variable lambdaB[p] = lambda^+B[p]
*  increases, and s = -1.0 means that xB[p] violates its upper bound,
*  so dual non-basic variable lambdaB[p] = lambda^-B[p] decreases.
*  (Thus, the dual ray parameter theta = s * lambdaB[p] >= 0.)
#else
*  The parameter r specifies the bound violation for basic variable
*  xB[p] chosen:
*
*  r = lB[p] - beta[p] > 0 means that xB[p] violates its lower bound,
*  so dual non-basic variable lambdaB[p] = lambda^+B[p] increases; and
*
*  r = uB[p] - beta[p] < 0 means that xB[p] violates its upper bound,
*  so dual non-basic variable lambdaB[p] = lambda^-B[p] decreases.
*
*  (Note that r is the dual reduced cost of lambdaB[p].)
#endif
*
*  Elements of p-th simplex table row t[p] = (t[p,j]) corresponding
*  to basic variable xB[p] should be placed in the array locations
*  trow[1], ..., trow[n-m].
*
*  The parameter tol_piv specifies a tolerance for elements of the
*  simplex table row t[p]. If |t[p,j]| < tol_piv, dual basic variable
*  lambdaN[j] is skipped, i.e. it is assumed that it does not depend on
*  the dual ray parameter theta.
*
*  The parameters tol and tol1 specify tolerances used to increase the
*  choice freedom by simulating an artificial degeneracy as follows.
*  If lambdaN[j] = lambda^+N[j] >= 0 and d[j] <= +delta[j], or if
*  lambdaN[j] = lambda^-N[j] <= 0 and d[j] >= -delta[j], where
*  delta[j] = tol + tol1 * |cN[j]|, cN[j] is objective coefficient at
*  xN[j], then it is assumed that reduced cost d[j] is equal to zero.
*
*  The routine determines the index 1 <= q <= n-m of non-basic variable
*  xN[q], for which corresponding dual basic variable lambda^+N[j] or
*  lambda^-N[j] reaches its zero bound first on increasing the dual ray
*  parameter theta, and returns p on exit. And if theta may increase
*  unlimitedly, the routine returns zero. */

int spy_chuzc_std(SPXLP *lp, const double d[/*1+n-m*/],
#if 0 /* 14/III-2016 */
      double s, const double trow[/*1+n-m*/], double tol_piv,
#else
      double r, const double trow[/*1+n-m*/], double tol_piv,
#endif
      double tol, double tol1)
{     int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int j, k, q;
      double alfa, biga, delta, teta, teta_min;
#if 0 /* 14/III-2016 */
      xassert(s == +1.0 || s == -1.0);
#else
      double s;
      xassert(r != 0.0);
      s = (r > 0.0 ? +1.0 : -1.0);
#endif
      /* nothing is chosen so far */
      q = 0, teta_min = DBL_MAX, biga = 0.0;
      /* walk thru the list of non-basic variables */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         /* if xN[j] is fixed variable, skip it */
         if (l[k] == u[k])
            continue;
         alfa = s * trow[j];
         if (alfa >= +tol_piv && !flag[j])
         {  /* xN[j] is either free or has its lower bound active, so
             * lambdaN[j] = d[j] >= 0 decreases down to zero */
            delta = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);
            /* determine theta on which lambdaN[j] reaches zero */
            teta = (d[j] < +delta ? 0.0 : d[j] / alfa);
         }
         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))
         {  /* xN[j] is either free or has its upper bound active, so
             * lambdaN[j] = d[j] <= 0 increases up to zero */
            delta = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);
            /* determine theta on which lambdaN[j] reaches zero */
            teta = (d[j] > -delta ? 0.0 : d[j] / alfa);
         }
         else
         {  /* lambdaN[j] cannot reach zero on increasing theta */
            continue;
         }
         /* choose non-basic variable xN[q] by corresponding dual basic
          * variable lambdaN[q] for which theta is minimal */
         xassert(teta >= 0.0);
         alfa = (alfa >= 0.0 ? +alfa : -alfa);
         if (teta_min > teta || (teta_min == teta && biga < alfa))
            q = j, teta_min = teta, biga = alfa;
      }
      return q;
}

/***********************************************************************
*  spy_chuzc_harris - choose non-basic var. (dual Harris' ratio test)
*
*  This routine implements dual Harris' ratio test to choose non-basic
*  variable xN[q].
*
*  All the parameters, except tol and tol1, as well as the returned
*  value have the same meaning as for the routine spx_chuzr_std (see
*  above).
*
*  The parameters tol and tol1 specify tolerances on zero bound
*  violations for reduced costs of non-basic variables. For reduced
*  cost d[j] the tolerance is delta[j] = tol + tol1 |cN[j]|, where
*  cN[j] is objective coefficient at non-basic variable xN[j]. */

int spy_chuzc_harris(SPXLP *lp, const double d[/*1+n-m*/],
#if 0 /* 14/III-2016 */
      double s, const double trow[/*1+n-m*/], double tol_piv,
#else
      double r, const double trow[/*1+n-m*/], double tol_piv,
#endif
      double tol, double tol1)
{     int m = lp->m;
      int n = lp->n;
      double *c = lp->c;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int j, k, q;
      double alfa, biga, delta, teta, teta_min;
#if 0 /* 14/III-2016 */
      xassert(s == +1.0 || s == -1.0);
#else
      double s;
      xassert(r != 0.0);
      s = (r > 0.0 ? +1.0 : -1.0);
#endif
      /*--------------------------------------------------------------*/
      /* first pass: determine teta_min for relaxed bounds            */
      /*--------------------------------------------------------------*/
      teta_min = DBL_MAX;
      /* walk thru the list of non-basic variables */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         /* if xN[j] is fixed variable, skip it */
         if (l[k] == u[k])
            continue;
         alfa = s * trow[j];
         if (alfa >= +tol_piv && !flag[j])
         {  /* xN[j] is either free or has its lower bound active, so
             * lambdaN[j] = d[j] >= 0 decreases down to zero */
            delta = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);
            /* determine theta on which lambdaN[j] reaches -delta */
            teta = ((d[j] < 0.0 ? 0.0 : d[j]) + delta) / alfa;
         }
         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))
         {  /* xN[j] is either free or has its upper bound active, so
             * lambdaN[j] = d[j] <= 0 increases up to zero */
            delta = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);
            /* determine theta on which lambdaN[j] reaches +delta */
            teta = ((d[j] > 0.0 ? 0.0 : d[j]) - delta) / alfa;
         }
         else
         {  /* lambdaN[j] cannot reach zero on increasing theta */
            continue;
         }
         xassert(teta >= 0.0);
         if (teta_min > teta)
            teta_min = teta;
      }
      /*--------------------------------------------------------------*/
      /* second pass: choose non-basic variable xN[q]                 */
      /*--------------------------------------------------------------*/
      if (teta_min == DBL_MAX)
      {  /* theta may increase unlimitedly */
         q = 0;
         goto done;
      }
      /* nothing is chosen so far */
      q = 0, biga = 0.0;
      /* walk thru the list of non-basic variables */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         /* if xN[j] is fixed variable, skip it */
         if (l[k] == u[k])
            continue;
         alfa = s * trow[j];
         if (alfa >= +tol_piv && !flag[j])
         {  /* xN[j] is either free or has its lower bound active, so
             * lambdaN[j] = d[j] >= 0 decreases down to zero */
            /* determine theta on which lambdaN[j] reaches zero */
            teta = d[j] / alfa;
         }
         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))
         {  /* xN[j] is either free or has its upper bound active, so
             * lambdaN[j] = d[j] <= 0 increases up to zero */
            /* determine theta on which lambdaN[j] reaches zero */
            teta = d[j] / alfa;
         }
         else
         {  /* lambdaN[j] cannot reach zero on increasing theta */
            continue;
         }
         /* choose non-basic variable for which theta is not greater
          * than theta_min determined for relaxed bounds and which has
          * best (largest in magnitude) pivot */
         alfa = (alfa >= 0.0 ? +alfa : -alfa);
         if (teta <= teta_min && biga < alfa)
            q = j, biga = alfa;
      }
      /* something must be chosen */
      xassert(1 <= q && q <= n-m);
done: return q;
}

#if 0 /* 23/III-2016 */
/***********************************************************************
*  spy_eval_bp - determine dual objective function break-points
*
*  This routine determines the dual objective function break-points.
*
*  The parameters lp, d, r, trow, and tol_piv have the same meaning as
*  for the routine spx_chuzc_std (see above).
*
*  On exit the routine stores the break-points determined to the array
*  elements bp[1], ..., bp[num], where 0 <= num <= n-m is the number of
*  break-points returned by the routine.
*
*  The break-points stored in the array bp are ordered by ascending
*  the ray parameter teta >= 0. The break-points numbered 1, ..., num-1
*  always correspond to non-basic non-fixed variables xN[j] of primal
*  LP having both lower and upper bounds while the last break-point
*  numbered num may correspond to a non-basic variable having only one
*  lower or upper bound, if such variable prevents further increasing
*  of the ray parameter teta. Besides, the routine includes in the
*  array bp only the break-points that correspond to positive increment
*  of the dual objective. */

static int fcmp(const void *v1, const void *v2)
{     const SPYBP *p1 = v1, *p2 = v2;
      if (p1->teta < p2->teta)
         return -1;
      else if (p1->teta > p2->teta)
         return +1;
      else
         return 0;
}

int spy_eval_bp(SPXLP *lp, const double d[/*1+n-m*/],
      double r, const double trow[/*1+n-m*/], double tol_piv,
      SPYBP bp[/*1+n-m*/])
{     int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int j, j_max, k, t, nnn, num;
      double s, alfa, teta, teta_max, dz, v;
      xassert(r != 0.0);
      s = (r > 0.0 ? +1.0 : -1.0);
      /* build the list of all dual basic variables lambdaN[j] that
       * can reach zero on increasing the ray parameter teta >= 0 */
      num = 0;
      /* walk thru the list of non-basic variables */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         /* if xN[j] is fixed variable, skip it */
         if (l[k] == u[k])
            continue;
         alfa = s * trow[j];
         if (alfa >= +tol_piv && !flag[j])
         {  /* xN[j] is either free or has its lower bound active, so
             * lambdaN[j] = d[j] >= 0 decreases down to zero */
            /* determine teta[j] on which lambdaN[j] reaches zero */
            teta = (d[j] < 0.0 ? 0.0 : d[j] / alfa);
         }
         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))
         {  /* xN[j] is either free or has its upper bound active, so
             * lambdaN[j] = d[j] <= 0 increases up to zero */
            /* determine teta[j] on which lambdaN[j] reaches zero */
            teta = (d[j] > 0.0 ? 0.0 : d[j] / alfa);
         }
         else
         {  /* lambdaN[j] cannot reach zero on increasing teta */
            continue;
         }
         /* add lambdaN[j] to the list */
         num++;
         bp[num].j = j;
         bp[num].teta = teta;
      }
      if (num == 0)
      {  /* dual unboundedness */
         goto done;
      }
      /* determine "blocking" dual basic variable lambdaN[j_max] that
       * prevents increasing teta more than teta_max */
      j_max = 0, teta_max = DBL_MAX;
      for (t = 1; t <= num; t++)
      {  j = bp[t].j;
         k = head[m+j]; /* x[k] = xN[j] */
         if (l[k] == -DBL_MAX || u[k] == +DBL_MAX)
         {  /* lambdaN[j] cannot intersect zero */
            if (j_max == 0
               || teta_max > bp[t].teta
               || (teta_max == bp[t].teta
                  && fabs(trow[j_max]) < fabs(trow[j])))
               j_max = j, teta_max = bp[t].teta;
         }
      }
      /* keep in the list only dual basic variables lambdaN[j] that
       * correspond to primal double-bounded variables xN[j] and whose
       * teta[j] is not greater than teta_max */
      nnn = 0;
      for (t = 1; t <= num; t++)
      {  j = bp[t].j;
         k = head[m+j]; /* x[k] = xN[j] */
         if (l[k] != -DBL_MAX && u[k] != +DBL_MAX
            && bp[t].teta <= teta_max)
         {  nnn++;
            bp[nnn].j = j;
            bp[nnn].teta = bp[t].teta;
         }
      }
      num = nnn;
      /* sort break-points by ascending teta[j] */
      qsort(&bp[1], num, sizeof(SPYBP), fcmp);
      /* add lambdaN[j_max] to the end of the list */
      if (j_max != 0)
      {  xassert(num < n-m);
         num++;
         bp[num].j = j_max;
         bp[num].teta = teta_max;
      }
      /* compute increments of the dual objective at all break-points
       * (relative to its value at teta = 0) */
      dz = 0.0;      /* dual objective increment */
      v = fabs(r);   /* dual objective slope d zeta / d teta */
      for (t = 1; t <= num; t++)
      {  /* compute increment at current break-point */
         dz += v * (bp[t].teta - (t == 1 ? 0.0 : bp[t-1].teta));
         if (dz < 0.001)
         {  /* break-point with non-positive increment reached */
            num = t - 1;
            break;
         }
         bp[t].dz = dz;
         /* compute next slope on the right to current break-point */
         if (t < num)
         {  j = bp[t].j;
            k = head[m+j]; /* x[k] = xN[j] */
            xassert(-DBL_MAX < l[k] && l[k] < u[k] && u[k] < +DBL_MAX);
            v -= fabs(trow[j]) * (u[k] - l[k]);
         }
      }
done: return num;
}
#endif

/***********************************************************************
*  spy_ls_eval_bp - determine dual objective function break-points
*
*  This routine determines the dual objective function break-points.
*
*  The parameters lp, d, r, trow, and tol_piv have the same meaning as
*  for the routine spx_chuzc_std (see above).
*
*  The routine stores the break-points determined to the array elements
*  bp[1], ..., bp[nbp] in *arbitrary* order, where 0 <= nbp <= n-m is
*  the number of break-points returned by the routine on exit. */

int spy_ls_eval_bp(SPXLP *lp, const double d[/*1+n-m*/],
      double r, const double trow[/*1+n-m*/], double tol_piv,
      SPYBP bp[/*1+n-m*/])
{     int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      char *flag = lp->flag;
      int j, k, t, nnn, nbp;
      double s, alfa, teta, teta_max;
      xassert(r != 0.0);
      s = (r > 0.0 ? +1.0 : -1.0);
      /* build the list of all dual basic variables lambdaN[j] that
       * can reach zero on increasing the ray parameter teta >= 0 */
      nnn = 0, teta_max = DBL_MAX;
      /* walk thru the list of non-basic variables */
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         /* if xN[j] is fixed variable, skip it */
         if (l[k] == u[k])
            continue;
         alfa = s * trow[j];
         if (alfa >= +tol_piv && !flag[j])
         {  /* xN[j] is either free or has its lower bound active, so
             * lambdaN[j] = d[j] >= 0 decreases down to zero */
            /* determine teta[j] on which lambdaN[j] reaches zero */
            teta = (d[j] < 0.0 ? 0.0 : d[j] / alfa);
            /* if xN[j] has no upper bound, lambdaN[j] cannot become
             * negative and thereby blocks further increasing teta */
            if (u[k] == +DBL_MAX && teta_max > teta)
               teta_max = teta;
         }
         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))
         {  /* xN[j] is either free or has its upper bound active, so
             * lambdaN[j] = d[j] <= 0 increases up to zero */
            /* determine teta[j] on which lambdaN[j] reaches zero */
            teta = (d[j] > 0.0 ? 0.0 : d[j] / alfa);
            /* if xN[j] has no lower bound, lambdaN[j] cannot become
             * positive and thereby blocks further increasing teta */
            if (l[k] == -DBL_MAX && teta_max > teta)
               teta_max = teta;
         }
         else
         {  /* lambdaN[j] cannot reach zero on increasing teta */
            continue;
         }
         /* add lambdaN[j] to the list */
         nnn++;
         bp[nnn].j = j;
         bp[nnn].teta = teta;
      }
      /* remove from the list all dual basic variables lambdaN[j], for
       * which teta[j] > teta_max */
      nbp = 0;
      for (t = 1; t <= nnn; t++)
      {  if (bp[t].teta <= teta_max + 1e-6)
         {  nbp++;
            bp[nbp].j = bp[t].j;
            bp[nbp].teta = bp[t].teta;
         }
      }
      return nbp;
}

/***********************************************************************
*  spy_ls_select_bp - select and process dual objective break-points
*
*  This routine selects a next portion of the dual objective function
*  break-points and processes them.
*
*  On entry to the routine it is assumed that break-points bp[1], ...,
*  bp[num] are already processed, and slope is the dual objective slope
*  to the right of the last processed break-point bp[num]. (Initially,
*  when num = 0, slope should be specified as fabs(r), where r has the
*  same meaning as above.)
*
*  The routine selects break-points among bp[num+1], ..., bp[nbp], for
*  which teta <= teta_lim, and moves these break-points to the array
*  elements bp[num+1], ..., bp[num1], where num <= num1 <= n-m is the
*  new number of processed break-points returned by the routine on
*  exit. Then the routine sorts these break-points by ascending teta
*  and computes the change of the dual objective function relative to
*  its value at teta = 0.
*
*  On exit the routine also replaces the parameter slope with a new
*  value that corresponds to the new last break-point bp[num1]. */

static int fcmp(const void *v1, const void *v2)
{     const SPYBP *p1 = v1, *p2 = v2;
      if (p1->teta < p2->teta)
         return -1;
      else if (p1->teta > p2->teta)
         return +1;
      else
         return 0;
}

int spy_ls_select_bp(SPXLP *lp, const double trow[/*1+n-m*/],
      int nbp, SPYBP bp[/*1+n-m*/], int num, double *slope, double
      teta_lim)
{     int m = lp->m;
      int n = lp->n;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      int j, k, t, num1;
      double teta, dz;
      xassert(0 <= num && num <= nbp && nbp <= n-m);
      /* select a new portion of break-points */
      num1 = num;
      for (t = num+1; t <= nbp; t++)
      {  if (bp[t].teta <= teta_lim)
         {  /* move break-point to the beginning of the new portion */
            num1++;
            j = bp[num1].j, teta = bp[num1].teta;
            bp[num1].j = bp[t].j, bp[num1].teta = bp[t].teta;
            bp[t].j = j, bp[t].teta = teta;
         }
      }
      /* sort new break-points bp[num+1], ..., bp[num1] by ascending
       * the ray parameter teta */
      if (num1 - num > 1)
         qsort(&bp[num+1], num1 - num, sizeof(SPYBP), fcmp);
      /* calculate the dual objective change at the new break-points */
      for (t = num+1; t <= num1; t++)
      {  /* calculate the dual objective change relative to its value
          * at break-point bp[t-1] */
         if (*slope == -DBL_MAX)
            dz = -DBL_MAX;
         else
            dz = (*slope) *
               (bp[t].teta - (t == 1 ? 0.0 : bp[t-1].teta));
         /* calculate the dual objective change relative to its value
          * at teta = 0 */
         if (dz == -DBL_MAX)
            bp[t].dz = -DBL_MAX;
         else
            bp[t].dz = (t == 1 ? 0.0 : bp[t-1].dz) + dz;
         /* calculate a new slope of the dual objective to the right of
          * the current break-point bp[t] */
         if (*slope != -DBL_MAX)
         {  j = bp[t].j;
            k = head[m+j]; /* x[k] = xN[j] */
            if (l[k] == -DBL_MAX || u[k] == +DBL_MAX)
               *slope = -DBL_MAX; /* blocking break-point reached */
            else
            {  xassert(l[k] < u[k]);
               *slope -= fabs(trow[j]) * (u[k] - l[k]);
            }
         }
      }
      return num1;
}

/* eof */





/* spychuzr.c */

/***********************************************************************
*  This code is part of GLPK (GNU Linear Programming Kit).
*
*  Copyright (C) 2015 Andrew Makhorin, Department for Applied
*  Informatics, Moscow Aviation Institute, Moscow, Russia. All rights
*  reserved. E-mail: <mao@gnu.org>.
*
*  GLPK is free software: you can redistribute it and/or modify it
*  under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  GLPK is distributed in the hope that it will be useful, but WITHOUT
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
*  License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/

/***********************************************************************
*  spy_chuzr_sel - select eligible basic variables
*
*  This routine selects eligible basic variables xB[i], whose value
*  beta[i] violates corresponding lower lB[i] or upper uB[i] bound.
*  Positive bound violation rp[i] = lb[i] - beta[i] > 0 is the reduced
*  cost of non-basic dual variable lambda^+B[i] >= 0, so increasing it
*  increases the dual objective. Similarly, negative bound violation
*  rn[i] = ub[i] - beta[i] < 0 is the reduced cost of non-basic dual
*  variable lambda^-B[i] <= 0, so decreasing it also increases the dual
*  objective.
*
*  Current values of basic variables should be placed in the array
*  locations beta[1], ..., beta[m].
*
*  Basic variable xB[i] is considered eligible, if:
*
*     beta[i] <= lB[i] - eps1[i], or
*
*     beta[i] >= uB[i] + eps2[i],
*
*  for
*
*     eps1[i] = tol + tol1 * |lB[i]|,
*
*     eps2[i] = tol + tol2 * |uB[i]|,
*
*  where lB[i] and uB[i] are, resp., lower and upper bounds of xB[i],
*  tol and tol1 are specified tolerances.
*
*  On exit the routine stores indices i of eligible basic variables
*  xB[i] to the array locations list[1], ..., list[num] and returns the
*  number of such variables 0 <= num <= m. (If the parameter list is
*  specified as NULL, no indices are stored.) */

int spy_chuzr_sel(SPXLP *lp, const double beta[/*1+m*/], double tol,
      double tol1, int list[/*1+m*/])
{     int m = lp->m;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      int i, k, num;
      double lk, uk, eps;
      num = 0;
      /* walk thru list of basic variables */
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         lk = l[k], uk = u[k];
         /* check if xB[i] is eligible */
         if (beta[i] < lk)
         {  /* determine absolute tolerance eps1[i] */
            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
            if (beta[i] < lk - eps)
            {  /* lower bound is violated */
               num++;
               if (list != NULL)
                  list[num] = i;
            }
         }
         else if (beta[i] > uk)
         {  /* determine absolute tolerance eps2[i] */
            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
            if (beta[i] > uk + eps)
            {  /* upper bound is violated */
               num++;
               if (list != NULL)
                  list[num] = i;
            }
         }
      }
      return num;
}

/***********************************************************************
*  spy_chuzr_std - choose basic variable (dual Dantzig's rule)
*
*  This routine chooses most eligible basic variable xB[p] according
*  to dual Dantzig's ("standard") rule:
*
*     r[p] =   max  |r[i]|,
*            i in I
*
*            ( lB[i] - beta[i], if beta[i] < lB[i]
*            (
*     r[i] = { 0,               if lB[i] <= beta[i] <= uB[i]
*            (
*            ( uB[i] - beta[i], if beta[i] > uB[i]
*
*  where I <= {1, ..., m} is the set of indices of eligible basic
*  variables, beta[i] is current value of xB[i], lB[i] and uB[i] are,
*  resp., lower and upper bounds of xB[i], r[i] is bound violation.
*
*  Current values of basic variables should be placed in the array
*  locations beta[1], ..., beta[m].
*
*  Indices of eligible basic variables i in I should be placed in the
*  array locations list[1], ..., list[num], where num = |J| > 0 is the
*  total number of such variables.
*
*  On exit the routine returns p, the index of the basic variable xB[p]
*  chosen. */

int spy_chuzr_std(SPXLP *lp, const double beta[/*1+m*/], int num,
      const int list[])
{     int m = lp->m;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      int i, k, p, t;
      double abs_ri, abs_rp;
      xassert(0 < num && num <= m);
      p = 0, abs_rp = -1.0;
      for (t = 1; t <= num; t++)
      {  i = list[t];
         k = head[i]; /* x[k] = xB[i] */
         if (beta[i] < l[k])
            abs_ri = l[k] - beta[i];
         else if (beta[i] > u[k])
            abs_ri = beta[i] - u[k];
         else
            xassert(t != t);
         if (abs_rp < abs_ri)
            p = i, abs_rp = abs_ri;
      }
      xassert(p != 0);
      return p;
}

/***********************************************************************
*  spy_alloc_se - allocate dual pricing data block
*
*  This routine allocates the memory for arrays used in the dual
*  pricing data block. */

void spy_alloc_se(SPXLP *lp, SPYSE *se)
{     int m = lp->m;
      int n = lp->n;
#if 1 /* 30/III-2016 */
      int i;
#endif
      se->valid = 0;
      se->refsp = talloc(1+n, char);
      se->gamma = talloc(1+m, double);
      se->work = talloc(1+m, double);
#if 1 /* 30/III-2016 */
      se->u.n = m;
      se->u.nnz = 0;
      se->u.ind = talloc(1+m, int);
      se->u.vec = talloc(1+m, double);
      for (i = 1; i <= m; i++)
         se->u.vec[i] = 0.0;
#endif
      return;
}

/***********************************************************************
*  spy_reset_refsp - reset dual reference space
*
*  This routine resets (re-initializes) the dual reference space
*  composing it from dual variables which are non-basic (corresponding
*  to basic primal variables) in the current basis, and sets all
*  weights gamma[i] to 1. */

void spy_reset_refsp(SPXLP *lp, SPYSE *se)
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *refsp = se->refsp;
      double *gamma = se->gamma;
      int i, k;
      se->valid = 1;
      memset(&refsp[1], 0, n * sizeof(char));
      for (i = 1; i <= m; i++)
      {  k = head[i]; /* x[k] = xB[i] */
         refsp[k] = 1;
         gamma[i] = 1.0;
      }
      return;
}

/***********************************************************************
*  spy_eval_gamma_i - compute dual proj. steepest edge weight directly
*
*  This routine computes dual projected steepest edge weight gamma[i],
*  1 <= i <= m, for the current basis directly with the formula:
*
*                           n-m
*     gamma[i] = delta[i] + sum eta[j] * T[i,j]**2,
*                           j=1
*
*  where T[i,j] is element of the current simplex table, and
*
*                ( 1, if lambdaN[j] is in the reference space
*     eta[j]   = {
*                ( 0, otherwise
*
*                ( 1, if lambdaB[i] is in the reference space
*     delta[i] = {
*                ( 0, otherwise
*
*  Dual basic variable lambdaN[j] corresponds to primal non-basic
*  variable xN[j], and dual non-basic variable lambdaB[j] corresponds
*  to primal basic variable xB[i].
*
*  NOTE: For testing/debugging only. */

double spy_eval_gamma_i(SPXLP *lp, SPYSE *se, int i)
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *refsp = se->refsp;
      double *rho = se->work;
      int j, k;
      double gamma_i, t_ij;
      xassert(se->valid);
      xassert(1 <= i && i <= m);
      k = head[i]; /* x[k] = xB[i] */
      gamma_i = (refsp[k] ? 1.0 : 0.0);
      spx_eval_rho(lp, i, rho);
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         if (refsp[k])
         {  t_ij = spx_eval_tij(lp, rho, j);
            gamma_i += t_ij * t_ij;
         }
      }
      return gamma_i;
}

/***********************************************************************
*  spy_chuzr_pse - choose basic variable (dual projected steepest edge)
*
*  This routine chooses most eligible basic variable xB[p] according
*  to the dual projected steepest edge method:
*
*      r[p]**2           r[i]**2
*     -------- =   max  -------- ,
*     gamma[p]   i in I gamma[i]
*
*            ( lB[i] - beta[i], if beta[i] < lB[i]
*            (
*     r[i] = { 0,               if lB[i] <= beta[i] <= uB[i]
*            (
*            ( uB[i] - beta[i], if beta[i] > uB[i]
*
*  where I <= {1, ..., m} is the set of indices of eligible basic
*  variables, beta[i] is current value of xB[i], lB[i] and uB[i] are,
*  resp., lower and upper bounds of xB[i], r[i] is bound violation.
*
*  Current values of basic variables should be placed in the array
*  locations beta[1], ..., beta[m].
*
*  Indices of eligible basic variables i in I should be placed in the
*  array locations list[1], ..., list[num], where num = |J| > 0 is the
*  total number of such variables.
*
*  On exit the routine returns p, the index of the basic variable xB[p]
*  chosen. */

int spy_chuzr_pse(SPXLP *lp, SPYSE *se, const double beta[/*1+m*/],
      int num, const int list[])
{     int m = lp->m;
      double *l = lp->l;
      double *u = lp->u;
      int *head = lp->head;
      double *gamma = se->gamma;
      int i, k, p, t;
      double best, ri, temp;
      xassert(0 < num && num <= m);
      p = 0, best = -1.0;
      for (t = 1; t <= num; t++)
      {  i = list[t];
         k = head[i]; /* x[k] = xB[i] */
         if (beta[i] < l[k])
            ri = l[k] - beta[i];
         else if (beta[i] > u[k])
            ri = u[k] - beta[i];
         else
            xassert(t != t);
         /* FIXME */
         if (gamma[i] < DBL_EPSILON)
            temp = 0.0;
         else
            temp = (ri * ri) / gamma[i];
         if (best < temp)
            p = i, best = temp;
      }
      xassert(p != 0);
      return p;
}

/***********************************************************************
*  spy_update_gamma - update dual proj. steepest edge weights exactly
*
*  This routine updates the vector gamma = (gamma[i]) of dual projected
*  steepest edge weights exactly, for the adjacent basis.
*
*  On entry to the routine the content of the se object should be valid
*  and should correspond to the current basis.
*
*  The parameter 1 <= p <= m specifies basic variable xB[p] which
*  becomes non-basic variable xN[q] in the adjacent basis.
*
*  The parameter 1 <= q <= n-m specified non-basic variable xN[q] which
*  becomes basic variable xB[p] in the adjacent basis.
*
*  It is assumed that the array trow contains elements of p-th (pivot)
*  row T'[p] of the simplex table in locations trow[1], ..., trow[n-m].
*  It is also assumed that the array tcol contains elements of q-th
*  (pivot) column T[q] of the simple table in locations tcol[1], ...,
*  tcol[m]. (These row and column should be computed for the current
*  basis.)
*
*  For details about the formulae used see the program documentation.
*
*  The routine also computes the relative error:
*
*     e = |gamma[p] - gamma'[p]| / (1 + |gamma[p]|),
*
*  where gamma'[p] is the weight for lambdaB[p] (which is dual
*  non-basic variable corresponding to xB[p]) on entry to the routine,
*  and returns e on exit. (If e happens to be large enough, the calling
*  program may reset the reference space, since other weights also may
*  be inaccurate.) */

double spy_update_gamma(SPXLP *lp, SPYSE *se, int p, int q,
      const double trow[/*1+n-m*/], const double tcol[/*1+m*/])
{     int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *refsp = se->refsp;
      double *gamma = se->gamma;
      double *u = se->work;
      int i, j, k, ptr, end;
      double gamma_p, delta_p, e, r, t1, t2;
      xassert(se->valid);
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n-m);
      /* compute gamma[p] in current basis more accurately; also
       * compute auxiliary vector u */
      k = head[p]; /* x[k] = xB[p] */
      gamma_p = delta_p = (refsp[k] ? 1.0 : 0.0);
      for (i = 1; i <= m; i++)
         u[i] = 0.0;
      for (j = 1; j <= n-m; j++)
      {  k = head[m+j]; /* x[k] = xN[j] */
         if (refsp[k] && trow[j] != 0.0)
         {  gamma_p += trow[j] * trow[j];
            /* u := u + T[p,j] * N[j], where N[j] = A[k] is constraint
             * matrix column corresponding to xN[j] */
            ptr = lp->A_ptr[k];
            end = lp->A_ptr[k+1];
            for (; ptr < end; ptr++)
               u[lp->A_ind[ptr]] += trow[j] * lp->A_val[ptr];
         }
      }
      bfd_ftran(lp->bfd, u);
      /* compute relative error in gamma[p] */
      e = fabs(gamma_p - gamma[p]) / (1.0 + gamma_p);
      /* compute new gamma[p] */
      gamma[p] = gamma_p / (tcol[p] * tcol[p]);
      /* compute new gamma[i] for all i != p */
      for (i = 1; i <= m; i++)
      {  if (i == p)
            continue;
         /* compute r[i] = T[i,q] / T[p,q] */
         r = tcol[i] / tcol[p];
         /* compute new gamma[i] */
         t1 = gamma[i] + r * (r * gamma_p + u[i] + u[i]);
         k = head[i]; /* x[k] = xB[i] */
         t2 = (refsp[k] ? 1.0 : 0.0) + delta_p * r * r;
         gamma[i] = (t1 >= t2 ? t1 : t2);
      }
      return e;
}

#if 1 /* 30/III-2016 */
double spy_update_gamma_s(SPXLP *lp, SPYSE *se, int p, int q,
      const FVS *trow, const FVS *tcol)
{     /* sparse version of spy_update_gamma */
      int m = lp->m;
      int n = lp->n;
      int *head = lp->head;
      char *refsp = se->refsp;
      double *gamma = se->gamma;
      double *u = se->work;
      int trow_nnz = trow->nnz;
      int *trow_ind = trow->ind;
      double *trow_vec = trow->vec;
      int tcol_nnz = tcol->nnz;
      int *tcol_ind = tcol->ind;
      double *tcol_vec = tcol->vec;
      int i, j, k, t, ptr, end;
      double gamma_p, delta_p, e, r, t1, t2;
      xassert(se->valid);
      xassert(1 <= p && p <= m);
      xassert(1 <= q && q <= n-m);
      /* compute gamma[p] in current basis more accurately; also
       * compute auxiliary vector u */
      k = head[p]; /* x[k] = xB[p] */
      gamma_p = delta_p = (refsp[k] ? 1.0 : 0.0);
      for (i = 1; i <= m; i++)
         u[i] = 0.0;
      for (t = 1; t <= trow_nnz; t++)
      {  j = trow_ind[t];
         k = head[m+j]; /* x[k] = xN[j] */
         if (refsp[k])
         {  gamma_p += trow_vec[j] * trow_vec[j];
            /* u := u + T[p,j] * N[j], where N[j] = A[k] is constraint
             * matrix column corresponding to xN[j] */
            ptr = lp->A_ptr[k];
            end = lp->A_ptr[k+1];
            for (; ptr < end; ptr++)
               u[lp->A_ind[ptr]] += trow_vec[j] * lp->A_val[ptr];
         }
      }
      bfd_ftran(lp->bfd, u);
      /* compute relative error in gamma[p] */
      e = fabs(gamma_p - gamma[p]) / (1.0 + gamma_p);
      /* compute new gamma[p] */
      gamma[p] = gamma_p / (tcol_vec[p] * tcol_vec[p]);
      /* compute new gamma[i] for all i != p */
      for (t = 1; t <= tcol_nnz; t++)
      {  i = tcol_ind[t];
         if (i == p)
            continue;
         /* compute r[i] = T[i,q] / T[p,q] */
         r = tcol_vec[i] / tcol_vec[p];
         /* compute new gamma[i] */
         t1 = gamma[i] + r * (r * gamma_p + u[i] + u[i]);
         k = head[i]; /* x[k] = xB[i] */
         t2 = (refsp[k] ? 1.0 : 0.0) + delta_p * r * r;
         gamma[i] = (t1 >= t2 ? t1 : t2);
      }
      return e;
}
#endif

/***********************************************************************
*  spy_free_se - deallocate dual pricing data block
*
*  This routine deallocates the memory used for arrays in the dual
*  pricing data block. */

void spy_free_se(SPXLP *lp, SPYSE *se)
{     xassert(lp == lp);
      tfree(se->refsp);
      tfree(se->gamma);
      tfree(se->work);
#if 1 /* 30/III-2016 */
      tfree(se->u.ind);
      tfree(se->u.vec);
#endif
      return;
}

/* eof */




#define qmdrch _glp_qmdrch
void qmdrch(int *root, int xadj[], int adjncy[], int deg[],
      int marker[], int *rchsze, int rchset[], int *nhdsze,
      int nbrhd[]);
/* Quotient MD ReaCHable set */

#define qmdqt _glp_qmdqt
void qmdqt(int *root, int xadj[], int adjncy[], int marker[],
      int *rchsze, int rchset[], int nbrhd[]);
/* Quotient MD Quotient graph Transformation */

#define qmdupd _glp_qmdupd
void qmdupd(int xadj[], int adjncy[], int *nlist, int list[],
      int deg[], int qsize[], int qlink[], int marker[], int rchset[],
      int nbrhd[]);
/* Quotient MD UPDate */

#define qmdmrg _glp_qmdmrg
void qmdmrg(int xadj[], int adjncy[], int deg[], int qsize[],
      int qlink[], int marker[], int *deg0, int *nhdsze, int nbrhd[],
      int rchset[], int ovrlp[]);
/* Quotient MD MeRGe */



/***********************************************************************
*  NAME
*
*  genqmd - GENeral Quotient Minimum Degree algorithm
*
*  SYNOPSIS
*
*  #include "qmd.h"
*  void genqmd(int *neqns, int xadj[], int adjncy[], int perm[],
*     int invp[], int deg[], int marker[], int rchset[], int nbrhd[],
*     int qsize[], int qlink[], int *nofsub);
*
*  PURPOSE
*
*  This routine implements the minimum degree algorithm. It makes use
*  of the implicit representation of the elimination graph by quotient
*  graphs, and the notion of indistinguishable nodes.
*
*  CAUTION
*
*  The adjancy vector adjncy will be destroyed.
*
*  INPUT PARAMETERS
*
*  neqns  - number of equations;
*  (xadj, adjncy) -
*           the adjancy structure.
*
*  OUTPUT PARAMETERS
*
*  perm   - the minimum degree ordering;
*  invp   - the inverse of perm.
*
*  WORKING PARAMETERS
*
*  deg    - the degree vector. deg[i] is negative means node i has been
*           numbered;
*  marker - a marker vector, where marker[i] is negative means node i
*           has been merged with another nodeand thus can be ignored;
*  rchset - vector used for the reachable set;
*  nbrhd  - vector used for neighborhood set;
*  qsize  - vector used to store the size of indistinguishable
*           supernodes;
*  qlink  - vector used to store indistinguishable nodes, i, qlink[i],
*           qlink[qlink[i]], ... are the members of the supernode
*           represented by i.
*
*  PROGRAM SUBROUTINES
*
*  qmdrch, qmdqt, qmdupd.
***********************************************************************/

void genqmd(int *_neqns, int xadj[], int adjncy[], int perm[],
      int invp[], int deg[], int marker[], int rchset[], int nbrhd[],
      int qsize[], int qlink[], int *_nofsub)
{     int inode, ip, irch, j, mindeg, ndeg, nhdsze, node, np, num,
         nump1, nxnode, rchsze, search, thresh;
#     define neqns  (*_neqns)
#     define nofsub (*_nofsub)
      /* Initialize degree vector and other working variables. */
      mindeg = neqns;
      nofsub = 0;
      for (node = 1; node <= neqns; node++)
      {  perm[node] = node;
         invp[node] = node;
         marker[node] = 0;
         qsize[node] = 1;
         qlink[node] = 0;
         ndeg = xadj[node+1] - xadj[node];
         deg[node] = ndeg;
         if (ndeg < mindeg) mindeg = ndeg;
      }
      num = 0;
      /* Perform threshold search to get a node of min degree.
       * Variable search point to where search should start. */
s200: search = 1;
      thresh = mindeg;
      mindeg = neqns;
s300: nump1 = num + 1;
      if (nump1 > search) search = nump1;
      for (j = search; j <= neqns; j++)
      {  node = perm[j];
         if (marker[node] >= 0)
         {  ndeg = deg[node];
            if (ndeg <= thresh) goto s500;
            if (ndeg < mindeg) mindeg = ndeg;
         }
      }
      goto s200;
      /* Node has minimum degree. Find its reachable sets by calling
       * qmdrch. */
s500: search = j;
      nofsub += deg[node];
      marker[node] = 1;
      qmdrch(&node, xadj, adjncy, deg, marker, &rchsze, rchset, &nhdsze,
         nbrhd);
      /* Eliminate all nodes indistinguishable from node. They are given
       * by node, qlink[node], ... . */
      nxnode = node;
s600: num++;
      np = invp[nxnode];
      ip = perm[num];
      perm[np] = ip;
      invp[ip] = np;
      perm[num] = nxnode;
      invp[nxnode] = num;
      deg[nxnode] = -1;
      nxnode = qlink[nxnode];
      if (nxnode > 0) goto s600;
      if (rchsze > 0)
      {  /* Update the degrees of the nodes in the reachable set and
          * identify indistinguishable nodes. */
         qmdupd(xadj, adjncy, &rchsze, rchset, deg, qsize, qlink,
            marker, &rchset[rchsze+1], &nbrhd[nhdsze+1]);
         /* Reset marker value of nodes in reach set. Update threshold
          * value for cyclic search. Also call qmdqt to form new
          * quotient graph. */
         marker[node] = 0;
         for (irch = 1; irch <= rchsze; irch++)
         {  inode = rchset[irch];
            if (marker[inode] >= 0)
            {  marker[inode] = 0;
               ndeg = deg[inode];
               if (ndeg < mindeg) mindeg = ndeg;
               if (ndeg <= thresh)
               {  mindeg = thresh;
                  thresh = ndeg;
                  search = invp[inode];
               }
            }
         }
         if (nhdsze > 0)
            qmdqt(&node, xadj, adjncy, marker, &rchsze, rchset, nbrhd);
      }
      if (num < neqns) goto s300;
      return;
#     undef neqns
#     undef nofsub
}

/***********************************************************************
*  NAME
*
*  qmdrch - Quotient MD ReaCHable set
*
*  SYNOPSIS
*
*  #include "qmd.h"
*  void qmdrch(int *root, int xadj[], int adjncy[], int deg[],
*     int marker[], int *rchsze, int rchset[], int *nhdsze,
*     int nbrhd[]);
*
*  PURPOSE
*
*  This subroutine determines the reachable set of a node through a
*  given subset. The adjancy structure is assumed to be stored in a
*  quotient graph format.
*
*  INPUT PARAMETERS
*
*  root   - the given node not in the subset;
*  (xadj, adjncy) -
*           the adjancy structure pair;
*  deg    - the degree vector. deg[i] < 0 means the node belongs to the
*           given subset.
*
*  OUTPUT PARAMETERS
*
*  (rchsze, rchset) -
*           the reachable set;
*  (nhdsze, nbrhd) -
*           the neighborhood set.
*
*  UPDATED PARAMETERS
*
*  marker - the marker vector for reach and nbrhd sets. > 0 means the
*           node is in reach set. < 0 means the node has been merged
*           with others in the quotient or it is in nbrhd set.
***********************************************************************/

void qmdrch(int *_root, int xadj[], int adjncy[], int deg[],
      int marker[], int *_rchsze, int rchset[], int *_nhdsze,
      int nbrhd[])
{     int i, istop, istrt, j, jstop, jstrt, nabor, node;
#     define root   (*_root)
#     define rchsze (*_rchsze)
#     define nhdsze (*_nhdsze)
      /* Loop through the neighbors of root in the quotient graph. */
      nhdsze = 0;
      rchsze = 0;
      istrt = xadj[root];
      istop = xadj[root+1] - 1;
      if (istop < istrt) return;
      for (i = istrt; i <= istop; i++)
      {  nabor = adjncy[i];
         if (nabor == 0) return;
         if (marker[nabor] == 0)
         {  if (deg[nabor] >= 0)
            {  /* Include nabor into the reachable set. */
               rchsze++;
               rchset[rchsze] = nabor;
               marker[nabor] = 1;
               goto s600;
            }
            /* nabor has been eliminated. Find nodes reachable from
             * it. */
            marker[nabor] = -1;
            nhdsze++;
            nbrhd[nhdsze] = nabor;
s300:       jstrt = xadj[nabor];
            jstop = xadj[nabor+1] - 1;
            for (j = jstrt; j <= jstop; j++)
            {  node = adjncy[j];
               nabor = - node;
               if (node < 0) goto s300;
               if (node == 0) goto s600;
               if (marker[node] == 0)
               {  rchsze++;
                  rchset[rchsze] = node;
                  marker[node] = 1;
               }
            }
         }
s600:    ;
      }
      return;
#     undef root
#     undef rchsze
#     undef nhdsze
}

/***********************************************************************
*  NAME
*
*  qmdqt - Quotient MD Quotient graph Transformation
*
*  SYNOPSIS
*
*  #include "qmd.h"
*  void qmdqt(int *root, int xadj[], int adjncy[], int marker[],
*     int *rchsze, int rchset[], int nbrhd[]);
*
*  PURPOSE
*
*  This subroutine performs the quotient graph transformation after a
*  node has been eliminated.
*
*  INPUT PARAMETERS
*
*  root   - the node just eliminated. It becomes the representative of
*           the new supernode;
*  (xadj, adjncy) -
*           the adjancy structure;
*  (rchsze, rchset) -
*           the reachable set of root in the old quotient graph;
*  nbrhd  - the neighborhood set which will be merged with root to form
*           the new supernode;
*  marker - the marker vector.
*
*  UPDATED PARAMETERS
*
*  adjncy - becomes the adjncy of the quotient graph.
***********************************************************************/

void qmdqt(int *_root, int xadj[], int adjncy[], int marker[],
      int *_rchsze, int rchset[], int nbrhd[])
{     int inhd, irch, j, jstop, jstrt, link, nabor, node;
#     define root   (*_root)
#     define rchsze (*_rchsze)
      irch = 0;
      inhd = 0;
      node = root;
s100: jstrt = xadj[node];
      jstop = xadj[node+1] - 2;
      if (jstop >= jstrt)
      {  /* Place reach nodes into the adjacent list of node. */
         for (j = jstrt; j <= jstop; j++)
         {  irch++;
            adjncy[j] = rchset[irch];
            if (irch >= rchsze) goto s400;
         }
      }
      /* Link to other space provided by the nbrhd set. */
      link = adjncy[jstop+1];
      node = - link;
      if (link >= 0)
      {  inhd++;
         node = nbrhd[inhd];
         adjncy[jstop+1] = - node;
      }
      goto s100;
      /* All reachable nodes have been saved. End the adjacent list.
       * Add root to the neighborhood list of each node in the reach
       * set. */
s400: adjncy[j+1] = 0;
      for (irch = 1; irch <= rchsze; irch++)
      {  node = rchset[irch];
         if (marker[node] >= 0)
         {  jstrt = xadj[node];
            jstop = xadj[node+1] - 1;
            for (j = jstrt; j <= jstop; j++)
            {  nabor = adjncy[j];
               if (marker[nabor] < 0)
               {  adjncy[j] = root;
                  goto s600;
               }
            }
         }
s600:    ;
      }
      return;
#     undef root
#     undef rchsze
}

/***********************************************************************
*  NAME
*
*  qmdupd - Quotient MD UPDate
*
*  SYNOPSIS
*
*  #include "qmd.h"
*  void qmdupd(int xadj[], int adjncy[], int *nlist, int list[],
*     int deg[], int qsize[], int qlink[], int marker[], int rchset[],
*     int nbrhd[]);
*
*  PURPOSE
*
*  This routine performs degree update for a set of nodes in the minimum
*  degree algorithm.
*
*  INPUT PARAMETERS
*
*  (xadj, adjncy) -
*           the adjancy structure;
*  (nlist, list) -
*           the list of nodes whose degree has to be updated.
*
*  UPDATED PARAMETERS
*
*  deg    - the degree vector;
*  qsize  - size of indistinguishable supernodes;
*  qlink  - linked list for indistinguishable nodes;
*  marker - used to mark those nodes in reach/nbrhd sets.
*
*  WORKING PARAMETERS
*
*  rchset - the reachable set;
*  nbrhd  - the neighborhood set.
*
*  PROGRAM SUBROUTINES
*
*  qmdmrg.
***********************************************************************/

void qmdupd(int xadj[], int adjncy[], int *_nlist, int list[],
      int deg[], int qsize[], int qlink[], int marker[], int rchset[],
      int nbrhd[])
{     int deg0, deg1, il, inhd, inode, irch, j, jstop, jstrt, mark,
         nabor, nhdsze, node, rchsze;
#     define nlist  (*_nlist)
      /* Find all eliminated supernodes that are adjacent to some nodes
       * in the given list. Put them into (nhdsze, nbrhd). deg0 contains
       * the number of nodes in the list. */
      if (nlist <= 0) return;
      deg0 = 0;
      nhdsze = 0;
      for (il = 1; il <= nlist; il++)
      {  node = list[il];
         deg0 += qsize[node];
         jstrt = xadj[node];
         jstop = xadj[node+1] - 1;
         for (j = jstrt; j <= jstop; j++)
         {  nabor = adjncy[j];
            if (marker[nabor] == 0 && deg[nabor] < 0)
            {  marker[nabor] = -1;
               nhdsze++;
               nbrhd[nhdsze] = nabor;
            }
         }
      }
      /* Merge indistinguishable nodes in the list by calling the
       * subroutine qmdmrg. */
      if (nhdsze > 0)
         qmdmrg(xadj, adjncy, deg, qsize, qlink, marker, &deg0, &nhdsze,
            nbrhd, rchset, &nbrhd[nhdsze+1]);
      /* Find the new degrees of the nodes that have not been merged. */
      for (il = 1; il <= nlist; il++)
      {  node = list[il];
         mark = marker[node];
         if (mark == 0 || mark == 1)
         {  marker[node] = 2;
            qmdrch(&node, xadj, adjncy, deg, marker, &rchsze, rchset,
               &nhdsze, nbrhd);
            deg1 = deg0;
            if (rchsze > 0)
            {  for (irch = 1; irch <= rchsze; irch++)
               {  inode = rchset[irch];
                  deg1 += qsize[inode];
                  marker[inode] = 0;
               }
            }
            deg[node] = deg1 - 1;
            if (nhdsze > 0)
            {  for (inhd = 1; inhd <= nhdsze; inhd++)
               {  inode = nbrhd[inhd];
                  marker[inode] = 0;
               }
            }
         }
      }
      return;
#     undef nlist
}

/***********************************************************************
*  NAME
*
*  qmdmrg - Quotient MD MeRGe
*
*  SYNOPSIS
*
*  #include "qmd.h"
*  void qmdmrg(int xadj[], int adjncy[], int deg[], int qsize[],
*     int qlink[], int marker[], int *deg0, int *nhdsze, int nbrhd[],
*     int rchset[], int ovrlp[]);
*
*  PURPOSE
*
*  This routine merges indistinguishable nodes in the minimum degree
*  ordering algorithm. It also computes the new degrees of these new
*  supernodes.
*
*  INPUT PARAMETERS
*
*  (xadj, adjncy) -
*           the adjancy structure;
*  deg0   - the number of nodes in the given set;
*  (nhdsze, nbrhd) -
*           the set of eliminated supernodes adjacent to some nodes in
*           the set.
*
*  UPDATED PARAMETERS
*
*  deg    - the degree vector;
*  qsize  - size of indistinguishable nodes;
*  qlink  - linked list for indistinguishable nodes;
*  marker - the given set is given by those nodes with marker value set
*           to 1. Those nodes with degree updated will have marker value
*           set to 2.
*
*  WORKING PARAMETERS
*
*  rchset - the reachable set;
*  ovrlp  - temp vector to store the intersection of two reachable sets.
***********************************************************************/

void qmdmrg(int xadj[], int adjncy[], int deg[], int qsize[],
      int qlink[], int marker[], int *_deg0, int *_nhdsze, int nbrhd[],
      int rchset[], int ovrlp[])
{     int deg1, head, inhd, iov, irch, j, jstop, jstrt, link, lnode,
         mark, mrgsze, nabor, node, novrlp, rchsze, root;
#     define deg0   (*_deg0)
#     define nhdsze (*_nhdsze)
      /* Initialization. */
      if (nhdsze <= 0) return;
      for (inhd = 1; inhd <= nhdsze; inhd++)
      {  root = nbrhd[inhd];
         marker[root] = 0;
      }
      /* Loop through each eliminated supernode in the set
       * (nhdsze, nbrhd). */
      for (inhd = 1; inhd <= nhdsze; inhd++)
      {  root = nbrhd[inhd];
         marker[root] = -1;
         rchsze = 0;
         novrlp = 0;
         deg1 = 0;
s200:    jstrt = xadj[root];
         jstop = xadj[root+1] - 1;
         /* Determine the reachable set and its intersection with the
          * input reachable set. */
         for (j = jstrt; j <= jstop; j++)
         {  nabor = adjncy[j];
            root = - nabor;
            if (nabor < 0) goto s200;
            if (nabor == 0) break;
            mark = marker[nabor];
            if (mark == 0)
            {  rchsze++;
               rchset[rchsze] = nabor;
               deg1 += qsize[nabor];
               marker[nabor] = 1;
            }
            else if (mark == 1)
            {  novrlp++;
               ovrlp[novrlp] = nabor;
               marker[nabor] = 2;
            }
         }
         /* From the overlapped set, determine the nodes that can be
          * merged together. */
         head = 0;
         mrgsze = 0;
         for (iov = 1; iov <= novrlp; iov++)
         {  node = ovrlp[iov];
            jstrt = xadj[node];
            jstop = xadj[node+1] - 1;
            for (j = jstrt; j <= jstop; j++)
            {  nabor = adjncy[j];
               if (marker[nabor] == 0)
               {  marker[node] = 1;
                  goto s1100;
               }
            }
            /* Node belongs to the new merged supernode. Update the
             * vectors qlink and qsize. */
            mrgsze += qsize[node];
            marker[node] = -1;
            lnode = node;
s900:       link = qlink[lnode];
            if (link > 0)
            {  lnode = link;
               goto s900;
            }
            qlink[lnode] = head;
            head = node;
s1100:      ;
         }
         if (head > 0)
         {  qsize[head] = mrgsze;
            deg[head] = deg0 + deg1 - 1;
            marker[head] = 2;
         }
         /* Reset marker values. */
         root = nbrhd[inhd];
         marker[root] = 0;
         if (rchsze > 0)
         {  for (irch = 1; irch <= rchsze; irch++)
            {  node = rchset[irch];
               marker[node] = 0;
            }
         }
      }
      return;
#     undef deg0
#     undef nhdsze
}






typedef struct RNG RNG;

struct RNG
{     /* Knuth's portable pseudo-random number generator */
      int A[56];
      /* pseudo-random values */
      int *fptr;
      /* the next A value to be exported */
};

#define rng_create_rand _glp_rng_create_rand
RNG *rng_create_rand(void);
/* create pseudo-random number generator */

#define rng_init_rand _glp_rng_init_rand
void rng_init_rand(RNG *rand, int seed);
/* initialize pseudo-random number generator */

#define rng_next_rand _glp_rng_next_rand
int rng_next_rand(RNG *rand);
/* obtain pseudo-random integer in the range [0, 2^31-1] */

#define rng_unif_rand _glp_rng_unif_rand
int rng_unif_rand(RNG *rand, int m);
/* obtain pseudo-random integer in the range [0, m-1] */

#define rng_delete_rand _glp_rng_delete_rand
void rng_delete_rand(RNG *rand);
/* delete pseudo-random number generator */

#define rng_unif_01 _glp_rng_unif_01
double rng_unif_01(RNG *rand);
/* obtain pseudo-random number in the range [0, 1] */

#define rng_uniform _glp_rng_uniform
double rng_uniform(RNG *rand, double a, double b);
/* obtain pseudo-random number in the range [a, b] */



#if 0
int A[56] = { -1 };
#else
#define A (rand->A)
#endif
/* pseudo-random values */

#if 0
int *fptr = A;
#else
#define fptr (rand->fptr)
#endif
/* the next A value to be exported */

#define mod_diff(x, y) (((x) - (y)) & 0x7FFFFFFF)
/* difference modulo 2^31 */

static int flip_cycle(RNG *rand)
{     /* this is an auxiliary routine to do 55 more steps of the basic
       * recurrence, at high speed, and to reset fptr */
      int *ii, *jj;
      for (ii = &A[1], jj = &A[32]; jj <= &A[55]; ii++, jj++)
         *ii = mod_diff(*ii, *jj);
      for (jj = &A[1]; ii <= &A[55]; ii++, jj++)
         *ii = mod_diff(*ii, *jj);
      fptr = &A[54];
      return A[55];
}

/***********************************************************************
*  NAME
*
*  rng_create_rand - create pseudo-random number generator
*
*  SYNOPSIS
*
*  #include "rng.h"
*  RNG *rng_create_rand(void);
*
*  DESCRIPTION
*
*  The routine rng_create_rand creates and initializes a pseudo-random
*  number generator.
*
*  RETURNS
*
*  The routine returns a pointer to the generator created. */

RNG *rng_create_rand(void)
{     RNG *rand;
      int i;
      rand = talloc(1, RNG);
      A[0] = -1;
      for (i = 1; i <= 55; i++) A[i] = 0;
      fptr = A;
      rng_init_rand(rand, 1);
      return rand;
}

/***********************************************************************
*  NAME
*
*  rng_init_rand - initialize pseudo-random number generator
*
*  SYNOPSIS
*
*  #include "rng.h"
*  void rng_init_rand(RNG *rand, int seed);
*
*  DESCRIPTION
*
*  The routine rng_init_rand initializes the pseudo-random number
*  generator. The parameter seed may be any integer number. Note that
*  on creating the generator this routine is called with the parameter
*  seed equal to 1. */

void rng_init_rand(RNG *rand, int seed)
{     int i;
      int prev = seed, next = 1;
      seed = prev = mod_diff(prev, 0);
      A[55] = prev;
      for (i = 21; i; i = (i + 21) % 55)
      {  A[i] = next;
         next = mod_diff(prev, next);
         if (seed & 1)
            seed = 0x40000000 + (seed >> 1);
         else
            seed >>= 1;
         next = mod_diff(next, seed);
         prev = A[i];
      }
      flip_cycle(rand);
      flip_cycle(rand);
      flip_cycle(rand);
      flip_cycle(rand);
      flip_cycle(rand);
      return;
}

/***********************************************************************
*  NAME
*
*  rng_next_rand - obtain pseudo-random integer in the range [0, 2^31-1]
*
*  SYNOPSIS
*
*  #include "rng.h"
*  int rng_next_rand(RNG *rand);
*
*  RETURNS
*
*  The routine rng_next_rand returns a next pseudo-random integer which
*  is uniformly distributed between 0 and 2^31-1, inclusive. The period
*  length of the generated numbers is 2^85 - 2^30. The low order bits of
*  the generated numbers are just as random as the high-order bits. */

int rng_next_rand(RNG *rand)
{     return
         *fptr >= 0 ? *fptr-- : flip_cycle(rand);
}

/***********************************************************************
*  NAME
*
*  rng_unif_rand - obtain pseudo-random integer in the range [0, m-1]
*
*  SYNOPSIS
*
*  #include "rng.h"
*  int rng_unif_rand(RNG *rand, int m);
*
*  RETURNS
*
*  The routine rng_unif_rand returns a next pseudo-random integer which
*  is uniformly distributed between 0 and m-1, inclusive, where m is any
*  positive integer less than 2^31. */

#define two_to_the_31 ((unsigned int)0x80000000)

int rng_unif_rand(RNG *rand, int m)
{     unsigned int t = two_to_the_31 - (two_to_the_31 % m);
      int r;
      xassert(m > 0);
      do { r = rng_next_rand(rand); } while (t <= (unsigned int)r);
      return r % m;
}

/***********************************************************************
*  NAME
*
*  rng_delete_rand - delete pseudo-random number generator
*
*  SYNOPSIS
*
*  #include "rng.h"
*  void rng_delete_rand(RNG *rand);
*
*  DESCRIPTION
*
*  The routine rng_delete_rand frees all the memory allocated to the
*  specified pseudo-random number generator. */

void rng_delete_rand(RNG *rand)
{     tfree(rand);
      return;
}

/**********************************************************************/

#ifdef GLP_TEST
/* To be sure that this modified version produces the same results as
 * the original version, run this validation program. */

int main(void)
{     RNG *rand;
      int j;
      rand = rng_create_rand();
      rng_init_rand(rand, -314159);
      if (rng_next_rand(rand) != 119318998)
      {  fprintf(stderr, "Failure on the first try!\n");
         return -1;
      }
      for (j = 1; j <= 133; j++) rng_next_rand(rand);
      if (rng_unif_rand(rand, 0x55555555) != 748103812)
      {  fprintf(stderr, "Failure on the second try!\n");
         return -2;
      }
      fprintf(stderr, "OK, the random-number generator routines seem to"
         " work!\n");
      rng_delete_rand(rand);
      return 0;
}
#endif









struct VAR
{     /* binary variable */
      int j;
      /* ordinal number */
      int x;
      /* value in the rounded solution (0 or 1) */
      double d;
      /* sorting key */
};

static int fcmp1(const void *x, const void *y)
{     /* comparison routine */
      const struct VAR *vx = x, *vy = y;
      if (vx->d > vy->d)
         return -1;
      else if (vx->d < vy->d)
         return +1;
      else
         return 0;
}

void ios_feas_pump(glp_tree *T)
{     glp_prob *P = T->mip;
      int n = P->n;
      glp_prob *lp = NULL;
      struct VAR *var = NULL;
      RNG *rand = NULL;
      GLPCOL *col;
      glp_smcp parm;
      int j, k, new_x, nfail, npass, nv, ret, stalling;
      double dist, tol;
      xassert(glp_get_status(P) == GLP_OPT);
      /* this heuristic is applied only once on the root level */
      if (!(T->curr->level == 0 && T->curr->solved == 1)) goto done;
      /* determine number of binary variables */
      nv = 0;
      for (j = 1; j <= n; j++)
      {  col = P->col[j];
         /* if x[j] is continuous, skip it */
         if (col->kind == GLP_CV) continue;
         /* if x[j] is fixed, skip it */
         if (col->type == GLP_FX) continue;
         /* x[j] is non-fixed integer */
         xassert(col->kind == GLP_IV);
         if (col->type == GLP_DB && col->lb == 0.0 && col->ub == 1.0)
         {  /* x[j] is binary */
            nv++;
         }
         else
         {  /* x[j] is general integer */
            if (T->parm->msg_lev >= GLP_MSG_ALL)
               xprintf("FPUMP heuristic cannot be applied due to genera"
                  "l integer variables\n");
            goto done;
         }
      }
      /* there must be at least one binary variable */
      if (nv == 0) goto done;
      if (T->parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Applying FPUMP heuristic...\n");
      /* build the list of binary variables */
      var = xcalloc(1+nv, sizeof(struct VAR));
      k = 0;
      for (j = 1; j <= n; j++)
      {  col = P->col[j];
         if (col->kind == GLP_IV && col->type == GLP_DB)
            var[++k].j = j;
      }
      xassert(k == nv);
      /* create working problem object */
      lp = glp_create_prob();
more: /* copy the original problem object to keep it intact */
      glp_copy_prob(lp, P, GLP_OFF);
      /* we are interested to find an integer feasible solution, which
         is better than the best known one */
      if (P->mip_stat == GLP_FEAS)
      {  int *ind;
         double *val, bnd;
         /* add a row and make it identical to the objective row */
         glp_add_rows(lp, 1);
         ind = xcalloc(1+n, sizeof(int));
         val = xcalloc(1+n, sizeof(double));
         for (j = 1; j <= n; j++)
         {  ind[j] = j;
            val[j] = P->col[j]->coef;
         }
         glp_set_mat_row(lp, lp->m, n, ind, val);
         xfree(ind);
         xfree(val);
         /* introduce upper (minimization) or lower (maximization)
            bound to the original objective function; note that this
            additional constraint is not violated at the optimal point
            to LP relaxation */
#if 0 /* modified by xypron <xypron.glpk@gmx.de> */
         if (P->dir == GLP_MIN)
         {  bnd = P->mip_obj - 0.10 * (1.0 + fabs(P->mip_obj));
            if (bnd < P->obj_val) bnd = P->obj_val;
            glp_set_row_bnds(lp, lp->m, GLP_UP, 0.0, bnd - P->c0);
         }
         else if (P->dir == GLP_MAX)
         {  bnd = P->mip_obj + 0.10 * (1.0 + fabs(P->mip_obj));
            if (bnd > P->obj_val) bnd = P->obj_val;
            glp_set_row_bnds(lp, lp->m, GLP_LO, bnd - P->c0, 0.0);
         }
         else
            xassert(P != P);
#else
         bnd = 0.1 * P->obj_val + 0.9 * P->mip_obj;
         /* xprintf("bnd = %f\n", bnd); */
         if (P->dir == GLP_MIN)
            glp_set_row_bnds(lp, lp->m, GLP_UP, 0.0, bnd - P->c0);
         else if (P->dir == GLP_MAX)
            glp_set_row_bnds(lp, lp->m, GLP_LO, bnd - P->c0, 0.0);
         else
            xassert(P != P);
#endif
      }
      /* reset pass count */
      npass = 0;
      /* invalidate the rounded point */
      for (k = 1; k <= nv; k++)
         var[k].x = -1;
pass: /* next pass starts here */
      npass++;
      if (T->parm->msg_lev >= GLP_MSG_ALL)
         xprintf("Pass %d\n", npass);
      /* initialize minimal distance between the basic point and the
         rounded one obtained during this pass */
      dist = DBL_MAX;
      /* reset failure count (the number of succeeded iterations failed
         to improve the distance) */
      nfail = 0;
      /* if it is not the first pass, perturb the last rounded point
         rather than construct it from the basic solution */
      if (npass > 1)
      {  double rho, temp;
         if (rand == NULL)
            rand = rng_create_rand();
         for (k = 1; k <= nv; k++)
         {  j = var[k].j;
            col = lp->col[j];
            rho = rng_uniform(rand, -0.3, 0.7);
            if (rho < 0.0) rho = 0.0;
            temp = fabs((double)var[k].x - col->prim);
            if (temp + rho > 0.5) var[k].x = 1 - var[k].x;
         }
         goto skip;
      }
loop: /* innermost loop begins here */
      /* round basic solution (which is assumed primal feasible) */
      stalling = 1;
      for (k = 1; k <= nv; k++)
      {  col = lp->col[var[k].j];
         if (col->prim < 0.5)
         {  /* rounded value is 0 */
            new_x = 0;
         }
         else
         {  /* rounded value is 1 */
            new_x = 1;
         }
         if (var[k].x != new_x)
         {  stalling = 0;
            var[k].x = new_x;
         }
      }
      /* if the rounded point has not changed (stalling), choose and
         flip some its entries heuristically */
      if (stalling)
      {  /* compute d[j] = |x[j] - round(x[j])| */
         for (k = 1; k <= nv; k++)
         {  col = lp->col[var[k].j];
            var[k].d = fabs(col->prim - (double)var[k].x);
         }
         /* sort the list of binary variables by descending d[j] */
         qsort(&var[1], nv, sizeof(struct VAR), fcmp1);
         /* choose and flip some rounded components */
         for (k = 1; k <= nv; k++)
         {  if (k >= 5 && var[k].d < 0.35 || k >= 10) break;
            var[k].x = 1 - var[k].x;
         }
      }
skip: /* check if the time limit has been exhausted */
      if (T->parm->tm_lim < INT_MAX &&
         (double)(T->parm->tm_lim - 1) <=
         1000.0 * xdifftime(xtime(), T->tm_beg)) goto done;
      /* build the objective, which is the distance between the current
         (basic) point and the rounded one */
      lp->dir = GLP_MIN;
      lp->c0 = 0.0;
      for (j = 1; j <= n; j++)
         lp->col[j]->coef = 0.0;
      for (k = 1; k <= nv; k++)
      {  j = var[k].j;
         if (var[k].x == 0)
            lp->col[j]->coef = +1.0;
         else
         {  lp->col[j]->coef = -1.0;
            lp->c0 += 1.0;
         }
      }
      /* minimize the distance with the simplex method */
      glp_init_smcp(&parm);
      if (T->parm->msg_lev <= GLP_MSG_ERR)
         parm.msg_lev = T->parm->msg_lev;
      else if (T->parm->msg_lev <= GLP_MSG_ALL)
      {  parm.msg_lev = GLP_MSG_ON;
         parm.out_dly = 10000;
      }
      ret = glp_simplex(lp, &parm);
      if (ret != 0)
      {  if (T->parm->msg_lev >= GLP_MSG_ERR)
            xprintf("Warning: glp_simplex returned %d\n", ret);
         goto done;
      }
      ret = glp_get_status(lp);
      if (ret != GLP_OPT)
      {  if (T->parm->msg_lev >= GLP_MSG_ERR)
            xprintf("Warning: glp_get_status returned %d\n", ret);
         goto done;
      }
      if (T->parm->msg_lev >= GLP_MSG_DBG)
         xprintf("delta = %g\n", lp->obj_val);
      /* check if the basic solution is integer feasible; note that it
         may be so even if the minimial distance is positive */
      tol = 0.3 * T->parm->tol_int;
      for (k = 1; k <= nv; k++)
      {  col = lp->col[var[k].j];
         if (tol < col->prim && col->prim < 1.0 - tol) break;
      }
      if (k > nv)
      {  /* okay; the basic solution seems to be integer feasible */
         double *x = xcalloc(1+n, sizeof(double));
         for (j = 1; j <= n; j++)
         {  x[j] = lp->col[j]->prim;
            if (P->col[j]->kind == GLP_IV) x[j] = floor(x[j] + 0.5);
         }
#if 1 /* modified by xypron <xypron.glpk@gmx.de> */
         /* reset direction and right-hand side of objective */
         lp->c0  = P->c0;
         lp->dir = P->dir;
         /* fix integer variables */
         for (k = 1; k <= nv; k++)
#if 0 /* 18/VI-2013; fixed by mao
       * this bug causes numerical instability, because column statuses
       * are not changed appropriately */
         {  lp->col[var[k].j]->lb   = x[var[k].j];
            lp->col[var[k].j]->ub   = x[var[k].j];
            lp->col[var[k].j]->type = GLP_FX;
         }
#else
            glp_set_col_bnds(lp, var[k].j, GLP_FX, x[var[k].j], 0.);
#endif
         /* copy original objective function */
         for (j = 1; j <= n; j++)
            lp->col[j]->coef = P->col[j]->coef;
         /* solve original LP and copy result */
         ret = glp_simplex(lp, &parm);
         if (ret != 0)
         {  if (T->parm->msg_lev >= GLP_MSG_ERR)
               xprintf("Warning: glp_simplex returned %d\n", ret);
#if 1 /* 17/III-2016: fix memory leak */
            xfree(x);
#endif
            goto done;
         }
         ret = glp_get_status(lp);
         if (ret != GLP_OPT)
         {  if (T->parm->msg_lev >= GLP_MSG_ERR)
               xprintf("Warning: glp_get_status returned %d\n", ret);
#if 1 /* 17/III-2016: fix memory leak */
            xfree(x);
#endif
            goto done;
         }
         for (j = 1; j <= n; j++)
            if (P->col[j]->kind != GLP_IV) x[j] = lp->col[j]->prim;
#endif
         ret = glp_ios_heur_sol(T, x);
         xfree(x);
         if (ret == 0)
         {  /* the integer solution is accepted */
            if (ios_is_hopeful(T, T->curr->bound))
            {  /* it is reasonable to apply the heuristic once again */
               goto more;
            }
            else
            {  /* the best known integer feasible solution just found
                  is close to optimal solution to LP relaxation */
               goto done;
            }
         }
      }
      /* the basic solution is fractional */
      if (dist == DBL_MAX ||
          lp->obj_val <= dist - 1e-6 * (1.0 + dist))
      {  /* the distance is reducing */
         nfail = 0, dist = lp->obj_val;
      }
      else
      {  /* improving the distance failed */
         nfail++;
      }
      if (nfail < 3) goto loop;
      if (npass < 5) goto pass;
done: /* delete working objects */
      if (lp != NULL) glp_delete_prob(lp);
      if (var != NULL) xfree(var);
      if (rand != NULL) rng_delete_rand(rand);
      return;
}

/* eof */








static int most_feas(glp_tree *T);
static int best_proj(glp_tree *T);
static int best_node(glp_tree *T);

int ios_choose_node(glp_tree *T)
{     int p;
      if (T->parm->bt_tech == GLP_BT_DFS)
      {  /* depth first search */
         xassert(T->tail != NULL);
         p = T->tail->p;
      }
      else if (T->parm->bt_tech == GLP_BT_BFS)
      {  /* breadth first search */
         xassert(T->head != NULL);
         p = T->head->p;
      }
      else if (T->parm->bt_tech == GLP_BT_BLB)
      {  /* select node with best local bound */
         p = best_node(T);
      }
      else if (T->parm->bt_tech == GLP_BT_BPH)
      {  if (T->mip->mip_stat == GLP_UNDEF)
         {  /* "most integer feasible" subproblem */
            p = most_feas(T);
         }
         else
         {  /* best projection heuristic */
            p = best_proj(T);
         }
      }
      else
         xassert(T != T);
      return p;
}

static int most_feas(glp_tree *T)
{     /* select subproblem whose parent has minimal sum of integer
         infeasibilities */
      IOSNPD *node;
      int p;
      double best;
      p = 0, best = DBL_MAX;
      for (node = T->head; node != NULL; node = node->next)
      {  xassert(node->up != NULL);
         if (best > node->up->ii_sum)
            p = node->p, best = node->up->ii_sum;
      }
      return p;
}

static int best_proj(glp_tree *T)
{     /* select subproblem using the best projection heuristic */
      IOSNPD *root, *node;
      int p;
      double best, deg, obj;
      /* the global bound must exist */
      xassert(T->mip->mip_stat == GLP_FEAS);
      /* obtain pointer to the root node, which must exist */
      root = T->slot[1].node;
      xassert(root != NULL);
      /* deg estimates degradation of the objective function per unit
         of the sum of integer infeasibilities */
      xassert(root->ii_sum > 0.0);
      deg = (T->mip->mip_obj - root->bound) / root->ii_sum;
      /* nothing has been selected so far */
      p = 0, best = DBL_MAX;
      /* walk through the list of active subproblems */
      for (node = T->head; node != NULL; node = node->next)
      {  xassert(node->up != NULL);
         /* obj estimates optimal objective value if the sum of integer
            infeasibilities were zero */
         obj = node->up->bound + deg * node->up->ii_sum;
         if (T->mip->dir == GLP_MAX) obj = - obj;
         /* select the subproblem which has the best estimated optimal
            objective value */
         if (best > obj) p = node->p, best = obj;
      }
      return p;
}

static int best_node(glp_tree *T)
{     /* select subproblem with best local bound */
      IOSNPD *node, *best = NULL;
      double bound, eps;
      switch (T->mip->dir)
      {  case GLP_MIN:
            bound = +DBL_MAX;
            for (node = T->head; node != NULL; node = node->next)
               if (bound > node->bound) bound = node->bound;
            xassert(bound != +DBL_MAX);
            eps = 1e-10 * (1.0 + fabs(bound));
            for (node = T->head; node != NULL; node = node->next)
            {  if (node->bound <= bound + eps)
               {  xassert(node->up != NULL);
                  if (best == NULL ||
#if 1
                  best->up->ii_sum > node->up->ii_sum) best = node;
#else
                  best->lp_obj > node->lp_obj) best = node;
#endif
               }
            }
            break;
         case GLP_MAX:
            bound = -DBL_MAX;
            for (node = T->head; node != NULL; node = node->next)
               if (bound < node->bound) bound = node->bound;
            xassert(bound != -DBL_MAX);
            eps = 1e-10 * (1.0 + fabs(bound));
            for (node = T->head; node != NULL; node = node->next)
            {  if (node->bound >= bound - eps)
               {  xassert(node->up != NULL);
                  if (best == NULL ||
#if 1
                  best->up->ii_sum > node->up->ii_sum) best = node;
#else
                  best->lp_obj < node->lp_obj) best = node;
#endif
               }
            }
            break;
         default:
            xassert(T != T);
      }
      xassert(best != NULL);
      return best->p;
}



#define proxy _glp_proxy
int proxy(glp_prob *lp, double *zstar, double *xstar,
          const double initsol[], double rel_impr, int tlim,
          int verbose);


/**********************************************************************/
/* 1. INCLUDE                                                         */
/**********************************************************************/
/* 2. PARAMETERS AND CONSTANTS                                        */
/**********************************************************************/

#define TDAY            86400.0
#undef TRUE
#define TRUE                1
#undef FALSE
#define FALSE               0
#define EPS              1e-6
#define RINF             1e38
#define MAXVAL           1e20
#define MINVAL          -1e20
#if 0 /* by gioker */
    #define PROXY_DEBUG
#endif

/**********************************************************************/
/* 3. GLOBAL VARIABLES                                                */
/**********************************************************************/

struct csa4 {

int integer_obj;        /* TRUE if each feasible solution has an
                           integral cost */
int b_vars_exist;       /* TRUE if there is at least one binary
                           variable in the problem */
int i_vars_exist;       /* TRUE if there is at least one general
                           integer variable in the problem */
const double *startsol; /* Pointer to the initial solution */

int *ckind;             /* Store the kind of the structural variables
                           of the problem */
double *clb;            /* Store the lower bound on the structural
                           variables of the problem */
double *cub;            /* Store the upper bound on the structural
                           variables of the problem */
double *true_obj;       /* Store the obj coefficients of the problem */

int dir;                /* Minimization or maximization problem */
int ncols;              /* Number of structural variables of the
                           problem */

time_t GLOtstart;       /* starting time of the algorithm */

glp_prob *lp_ref;       /* glp problem for refining only*/

};

/**********************************************************************/
/* 4. FUNCTIONS PROTOTYPES                                            */
/**********************************************************************/

static void callback(glp_tree *tree, void *info);
static void get_info(struct csa4 *csa, glp_prob *lp);
static int is_integer(struct csa4 *csa);
static void check_integrality4(struct csa4 *csa);
static int check_ref(struct csa4 *csa, glp_prob *lp, double *xref);
static double second(void);
static int add_cutoff(struct csa4 *csa, glp_prob *lp);
static void get_sol(struct csa4 *csa, glp_prob *lp, double *xstar);
static double elapsed_time(struct csa4 *csa);
static void redefine_obj(glp_prob *lp, double *xtilde, int ncols,
                         int *ckind, double *clb, double *cub);
static double update_cutoff(struct csa4 *csa, glp_prob *lp,
                            double zstar, int index, double rel_impr);
static double compute_delta(struct csa4 *csa, double z,
                            double rel_impr);
static double objval(int ncols, double *x, double *true_obj);
static void array_copy(int begin, int end, double *source,
                       double *destination);
static int do_refine(struct csa4 *csa, glp_prob *lp_ref, int ncols,
                     int *ckind, double *xref, int *tlim, int tref_lim,
                     int verbose);
static void deallocate(struct csa4 *csa, int refine);

/**********************************************************************/
/* 5. FUNCTIONS                                                       */
/**********************************************************************/

int proxy(glp_prob *lp, double *zfinal, double *xfinal,
          const double initsol[], double rel_impr, int tlim,
          int verbose)

{   struct csa4 csa_, *csa = &csa_;
    glp_iocp parm;
    glp_smcp parm_lp;
    size_t tpeak;
    int refine, tref_lim, err, cutoff_row, niter, status, i, tout;
    double *xref, *xstar, zstar, tela, cutoff, zz;

    memset(csa, 0, sizeof(struct csa4));


    /**********                         **********/
    /********** RETRIEVING PROBLEM INFO **********/
    /**********                         **********/

    /* getting problem direction (min or max) */
    csa->dir = glp_get_obj_dir(lp);

    /* getting number of variables */
    csa->ncols = glp_get_num_cols(lp);

    /* getting kind, bounds and obj coefficient of each variable
     information is stored in ckind, cub, clb, true_obj */
    get_info(csa, lp);

    /* checking if the objective function is always integral */
    check_integrality4(csa);

    /* Proximity search cannot be used if there are no binary
       variables */
    if (csa->b_vars_exist == FALSE) {
        if (verbose) {
            xprintf("The problem has not binary variables. Proximity se"
                    "arch cannot be used.\n");
        }
        tfree(csa->ckind);
        tfree(csa->clb);
        tfree(csa->cub);
        tfree(csa->true_obj);
        return -1;
    }

    /* checking if the problem needs refinement, i.e., not all
       variables are binary. If so, the routine creates a copy of the
       lp problem named lp_ref and initializes the solution xref to
       zero. */
    xref = talloc(csa->ncols+1, double);
#if 0 /* by mao */
    memset(xref, 0, sizeof(double)*(csa->ncols+1));
#endif
    refine = check_ref(csa, lp, xref);
#ifdef PROXY_DEBUG
    xprintf("REFINE = %d\n",refine);
#endif

    /* Initializing the solution */
    xstar = talloc(csa->ncols+1, double);
#if 0 /* by mao */
    memset(xstar, 0, sizeof(double)*(csa->ncols+1));
#endif

    /**********                         **********/
    /********** FINDING FIRST SOLUTION  **********/
    /**********                         **********/

    if (verbose) {
        xprintf("Applying PROXY heuristic...\n");
    }

    /* get the initial time */
    csa->GLOtstart = second();

    /* setting the optimization parameters */
    glp_init_iocp(&parm);
    glp_init_smcp(&parm_lp);
#if 0 /* by gioker */
    /* Preprocessing should be disabled because the mip passed
     to proxy is already preprocessed */
    parm.presolve = GLP_ON;
#endif
#if 1 /* by mao */
    /* best projection backtracking seems to be more efficient to find
       any integer feasible solution */
    parm.bt_tech = GLP_BT_BPH;
#endif

    /* Setting the default value of the minimum relative improvement
       to 1% */
    if ( rel_impr <= 0.0 ) {
        rel_impr = 0.01;
    }

    /* Setting the default value of time limit to 10 minutes */
    if (tlim <= 0) {
        tlim = INT_MAX;
    }
    if (verbose) {
        xprintf("Proxy's time limit set to %d seconds.\n",tlim/1000);
        xprintf("Proxy's relative improvement "
                "set to %2.2lf %c.\n",rel_impr*100,37);
    }

    parm_lp.tm_lim = tlim;

    parm.mip_gap = 9999999.9; /* to stop the optimization at the first
                                 feasible solution found */

    /* finding the first solution */
    if (verbose) {
        xprintf("Searching for a feasible solution...\n");
    }

    /* verifying the existence of an input starting solution */
    if (initsol != NULL) {
        csa->startsol = initsol;
        parm.cb_func = callback;
        parm.cb_info = csa;
        if (verbose) {
            xprintf("Input solution found.\n");
        }
    }

    tout = glp_term_out(GLP_OFF);
    err = glp_simplex(lp,&parm_lp);
    glp_term_out(tout);

    status = glp_get_status(lp);

    if (status != GLP_OPT) {
        if (verbose) {
            xprintf("Proxy heuristic terminated.\n");
        }
#ifdef  PROXY_DEBUG
        /* For debug only */
        xprintf("GLP_SIMPLEX status = %d\n",status);
        xprintf("GLP_SIMPLEX error code = %d\n",err);
#endif
        tfree(xref);
        tfree(xstar);
        deallocate(csa, refine);
        return -1;
    }

    tela = elapsed_time(csa);
    if (tlim-tela*1000 <= 0) {
        if (verbose) {
            xprintf("Time limit exceeded. Proxy could not "
                    "find optimal solution to LP relaxation.\n");
            xprintf("Proxy heuristic aborted.\n");
        }
        tfree(xref);
        tfree(xstar);
        deallocate(csa, refine);
        return -1;
    }

    parm.tm_lim = tlim - tela*1000;
    tref_lim = (tlim - tela *1000) / 20;

    tout = glp_term_out(GLP_OFF);
    err = glp_intopt(lp, &parm);
    glp_term_out(tout);

    status = glp_mip_status(lp);

    /***** If no solution was found *****/

    if (status == GLP_NOFEAS || status == GLP_UNDEF) {
        if (err == GLP_ETMLIM) {
            if (verbose) {
                xprintf("Time limit exceeded. Proxy could not "
                        "find an initial integer feasible solution.\n");
                xprintf("Proxy heuristic aborted.\n");
            }
        }
        else {
            if (verbose) {
                xprintf("Proxy could not "
                        "find an initial integer feasible solution.\n");
                xprintf("Proxy heuristic aborted.\n");
            }
        }
        tfree(xref);
        tfree(xstar);
        deallocate(csa, refine);
        return -1;
    }

    /* getting the first solution and its value */
    get_sol(csa, lp,xstar);
    zstar = glp_mip_obj_val(lp);

    if (verbose) {
        xprintf(">>>>> first solution = %e;\n", zstar);
    }

    /* If a feasible solution was found but the time limit is
       exceeded */
    if (err == GLP_ETMLIM) {
        if (verbose) {
          xprintf("Time limit exceeded. Proxy heuristic terminated.\n");
        }
        goto done;
    }

    tela = elapsed_time(csa);
    tpeak = 0;
    glp_mem_usage(NULL, NULL, NULL, &tpeak);
    if (verbose) {
        xprintf("Time used: %3.1lf secs.  Memory used: %2.1lf Mb\n",
                tela,(double)tpeak/1048576);
        xprintf("Starting proximity search...\n");
    }

    /**********                                 **********/
    /********** PREPARING THE PROBLEM FOR PROXY **********/
    /**********                                 **********/

    /* adding a dummy cutoff constraint */
    cutoff_row = add_cutoff(csa, lp);

    /* proximity search needs minimization direction
       even if the problem is a maximization one */
    if (csa->dir == GLP_MAX) {
        glp_set_obj_dir(lp, GLP_MIN);
    }

    /**********                           **********/
    /********** STARTING PROXIMITY SEARCH **********/
    /**********                           **********/


    niter = 0;

    while (TRUE) {
        niter++;

        /********** CHANGING THE OBJ FUNCTION **********/

        redefine_obj(lp,xstar, csa->ncols, csa->ckind, csa->clb,
                     csa->cub);

        /********** UPDATING THE CUTOFF CONSTRAINT **********/

        cutoff = update_cutoff(csa, lp,zstar, cutoff_row, rel_impr);

#ifdef PROXY_DEBUG
        xprintf("TRUE_OBJ[0] = %f\n",csa->true_obj[0]);
        xprintf("ZSTAR  = %f\n",zstar);
        xprintf("CUTOFF = %f\n",cutoff);
#endif

        /********** SEARCHING FOR A BETTER SOLUTION **********/

        tela = elapsed_time(csa);
        if (tlim-tela*1000 <= 0) {
            if (verbose) {
                xprintf("Time limit exceeded. Proxy heuristic "
                        "terminated.\n");
            }
            goto done;
        }
#ifdef PROXY_DEBUG
        xprintf("TELA = %3.1lf\n",tela*1000);
        xprintf("TLIM = %3.1lf\n",tlim - tela*1000);
#endif
        parm_lp.tm_lim = tlim -tela*1000;

        tout = glp_term_out(GLP_OFF);
        err = glp_simplex(lp,&parm_lp);
        glp_term_out(tout);

        status = glp_get_status(lp);

        if (status != GLP_OPT) {
            if (status == GLP_NOFEAS) {
                if (verbose) {
                    xprintf("Bound exceeded = %f. ",cutoff);
                }
            }
            if (verbose) {
                xprintf("Proxy heuristic terminated.\n");
            }
#ifdef PROXY_DEBUG
            xprintf("GLP_SIMPLEX status = %d\n",status);
            xprintf("GLP_SIMPLEX error code = %d\n",err);
#endif
            goto done;
        }

        tela = elapsed_time(csa);
        if (tlim-tela*1000 <= 0) {
            if (verbose) {
                xprintf("Time limit exceeded. Proxy heuristic "
                        "terminated.\n");
            }
            goto done;
        }
        parm.tm_lim = tlim - tela*1000;
        parm.cb_func = NULL;
#if 0 /* by gioker */
        /* Preprocessing should be disabled because the mip passed
         to proxy is already preprocessed */
        parm.presolve = GLP_ON;
#endif
        tout = glp_term_out(GLP_OFF);
        err = glp_intopt(lp, &parm);
        glp_term_out(tout);

        /********** MANAGEMENT OF THE SOLUTION **********/

        status = glp_mip_status(lp);

        /***** No feasible solutions *****/

        if (status == GLP_NOFEAS) {
            if (verbose) {
                xprintf("Bound exceeded = %f. Proxy heuristic "
                        "terminated.\n",cutoff);
            }
            goto done;
        }

        /***** Undefined solution *****/

        if (status == GLP_UNDEF) {
            if (err == GLP_ETMLIM) {
                if (verbose) {
                    xprintf("Time limit exceeded. Proxy heuristic "
                            "terminated.\n");
                }
            }
            else {
                if (verbose) {
                    xprintf("Proxy terminated unexpectedly.\n");
#ifdef PROXY_DEBUG
                    xprintf("GLP_INTOPT error code = %d\n",err);
#endif
                }
            }
            goto done;
        }

        /***** Feasible solution *****/

        if ((status == GLP_FEAS) || (status == GLP_OPT)) {

            /* getting the solution and computing its value */
            get_sol(csa, lp,xstar);
            zz = objval(csa->ncols, xstar, csa->true_obj);

            /* Comparing the incumbent solution with the current best
               one */
#ifdef PROXY_DEBUG
            xprintf("ZZ = %f\n",zz);
            xprintf("ZSTAR = %f\n",zstar);
            xprintf("REFINE = %d\n",refine);
#endif
            if (((zz<zstar) && (csa->dir == GLP_MIN)) ||
                ((zz>zstar) && (csa->dir == GLP_MAX))) {

                /* refining (possibly) the solution */
                if (refine) {

                    /* copying the incumbent solution in the refinement
                       one */
                    array_copy(1, csa->ncols +1, xstar, xref);
                    err = do_refine(csa, csa->lp_ref, csa->ncols,
                          csa->ckind, xref, &tlim, tref_lim, verbose);
                    if (!err) {
                        double zref = objval(csa->ncols, xref,
                                             csa->true_obj);
                        if (((zref<zz) && (csa->dir == GLP_MIN)) ||
                            ((zref>zz) && (csa->dir == GLP_MAX))) {
                            zz = zref;
                            /* copying the refinement solution in the
                               incumbent one */
                            array_copy(1, csa->ncols +1, xref, xstar);
                        }
                    }
                }
                zstar = zz;
                tela = elapsed_time(csa);
                if (verbose) {
                    xprintf(">>>>> it: %3d:   mip = %e;   elapsed time "
                            "%3.1lf sec.s\n", niter,zstar,tela);
                }
            }
        }
    }

done:
    tela = elapsed_time(csa);
    glp_mem_usage(NULL, NULL, NULL, &tpeak);
    if (verbose) {
        xprintf("Time used: %3.1lf.  Memory used: %2.1lf Mb\n",
                tela,(double)tpeak/1048576);
    }


    /* Exporting solution and obj val */
    *zfinal = zstar;

    for (i=1; i < (csa->ncols + 1); i++) {
        xfinal[i]=xstar[i];
    }

    /* Freeing allocated memory */
    tfree(xref);
    tfree(xstar);
    deallocate(csa, refine);

    return 0;
}

/**********************************************************************/
static void callback(glp_tree *tree, void *info){
/**********************************************************************/
    struct csa4 *csa = info;
    switch(glp_ios_reason(tree)) {
        case GLP_IHEUR:
            glp_ios_heur_sol(tree, csa->startsol);
            break;
        default: break;
    }
}

/**********************************************************************/
static void get_info(struct csa4 *csa, glp_prob *lp)
/**********************************************************************/
{
    int i;

    /*  Storing helpful info of the problem  */

    csa->ckind = talloc(csa->ncols+1, int);
#if 0 /* by mao */
    memset(csa->ckind, 0, sizeof(int)*(csa->ncols+1));
#endif
    csa->clb = talloc(csa->ncols+1, double);
#if 0 /* by mao */
    memset(csa->clb, 0, sizeof(double)*(csa->ncols+1));
#endif
    csa->cub = talloc(csa->ncols+1, double);
#if 0 /* by mao */
    memset(csa->cub, 0, sizeof(double)*(csa->ncols+1));
#endif
    csa->true_obj = talloc(csa->ncols+1, double);
#if 0 /* by mao */
    memset(csa->true_obj, 0, sizeof(double)*(csa->ncols+1));
#endif
        for( i = 1 ; i < (csa->ncols + 1); i++ ) {
            csa->ckind[i] = glp_get_col_kind(lp, i);
            csa->clb[i] = glp_get_col_lb(lp, i);
            csa->cub[i] = glp_get_col_ub(lp, i);
            csa->true_obj[i] = glp_get_obj_coef(lp, i);
        }
    csa->true_obj[0] = glp_get_obj_coef(lp, 0);
}

/**********************************************************************/
static int is_integer(struct csa4 *csa)
/**********************************************************************/
{
    int i;
    csa->integer_obj = TRUE;
    for ( i = 1; i < (csa->ncols + 1); i++ ) {
        if (fabs(csa->true_obj[i]) > INT_MAX ) {
            csa->integer_obj = FALSE;
        }
        if (fabs(csa->true_obj[i]) <= INT_MAX) {
            double tmp, rem;
            if (fabs(csa->true_obj[i]) - floor(fabs(csa->true_obj[i]))
                < 0.5) {
                tmp = floor(fabs(csa->true_obj[i]));
            }
            else {
                tmp = ceil(fabs(csa->true_obj[i]));
            }
            rem = fabs(csa->true_obj[i]) - tmp;
            rem = fabs(rem);
            if (rem > EPS) {
                csa->integer_obj = FALSE;
            }

        }
    }
    return csa->integer_obj;
}

/**********************************************************************/
static void check_integrality4(struct csa4 *csa)
/**********************************************************************/
{
    /*
     Checking if the problem has binary, integer or continuos variables.
     integer_obj is TRUE if the problem has no continuous variables
     and all the obj coefficients are integer (and < INT_MAX).
     */

    int i;
    csa->integer_obj = is_integer(csa);
    csa->b_vars_exist = FALSE;
    csa->i_vars_exist = FALSE;
    for ( i = 1; i < (csa->ncols + 1); i++ ) {
        if ( csa->ckind[i] == GLP_IV ){
            csa->i_vars_exist = TRUE;
            continue;
        }
        if ( csa->ckind[i] == GLP_BV ){
            csa->b_vars_exist =TRUE;
            continue;
        }
        csa->integer_obj = FALSE;
    }
}

/**********************************************************************/
static int check_ref(struct csa4 *csa, glp_prob *lp, double *xref)
/**********************************************************************/
{
    /*
     checking if the problem has continuos or integer variables. If so,
     refinement is prepared.
     */
    int refine = FALSE;
    int i;
    for ( i = 1; i < (csa->ncols + 1); i++ ) {
        if ( csa->ckind[i] != GLP_BV) {
            refine = TRUE;
            break;
        }
    }

    /* possibly creating a mip clone for refinement only */
    if ( refine ) {
        csa->lp_ref = glp_create_prob();
        glp_copy_prob(csa->lp_ref, lp, GLP_ON);
    }

    return refine;
}

/**********************************************************************/
static double second(void)
/**********************************************************************/
{
#if 0 /* by mao */
    return ((double)clock()/(double)CLOCKS_PER_SEC);
#else
    return xtime() / 1000.0;
#endif
}

/**********************************************************************/
static int add_cutoff(struct csa4 *csa, glp_prob *lp)
/**********************************************************************/
{
    /*
     Adding a cutoff constraint to set an upper bound (in case of
     minimaztion) on the obj value of the next solution, i.e., the next
     value of the true obj function that we would like to find
     */

    /* store non-zero coefficients in the objective function */
    int *obj_index = talloc(csa->ncols+1, int);
#if 0 /* by mao */
    memset(obj_index, 0, sizeof(int)*(csa->ncols+1));
#endif
    double *obj_value = talloc(csa->ncols+1, double);
#if 0 /* by mao */
    memset(obj_value, 0, sizeof(double)*(csa->ncols+1));
#endif
    int obj_nzcnt = 0;
    int i, irow;
    const char *rowname;
    for ( i = 1; i < (csa->ncols + 1); i++ ) {
        if ( fabs(csa->true_obj[i]) > EPS ) {
            obj_nzcnt++;
            obj_index[obj_nzcnt] = i;
            obj_value[obj_nzcnt] = csa->true_obj[i];
        }
    }

    irow = glp_add_rows(lp, 1);
    rowname = "Cutoff";
    glp_set_row_name(lp, irow, rowname);
    if (csa->dir == GLP_MIN) {
        /* minimization problem */
        glp_set_row_bnds(lp, irow, GLP_UP, MAXVAL, MAXVAL);
    }
    else {
        /* maximization problem */
        glp_set_row_bnds(lp, irow, GLP_LO, MINVAL, MINVAL);
    }

    glp_set_mat_row(lp, irow, obj_nzcnt, obj_index, obj_value);

    tfree(obj_index);
    tfree(obj_value);

    return irow;
}

/**********************************************************************/
static void get_sol(struct csa4 *csa, glp_prob *lp, double *xstar)
/**********************************************************************/
{
    /* Retrieving and storing the coefficients of the solution */

    int i;
    for (i = 1; i < (csa->ncols +1); i++) {
        xstar[i] = glp_mip_col_val(lp, i);
    }
}

/**********************************************************************/
static double elapsed_time(struct csa4 *csa)
/**********************************************************************/
{
    double tela = second() - csa->GLOtstart;
    if ( tela < 0 ) tela += TDAY;
    return(tela);
}

/**********************************************************************/
static void redefine_obj(glp_prob *lp, double *xtilde, int ncols,
                         int *ckind, double *clb, double *cub)
/**********************************************************************/

/*
 Redefine the lp objective function obj as the distance-to-integrality
 (Hamming distance) from xtilde (the incumbent feasible solution), wrt
 to binary vars only
 */

{
    int j;
    double *delta = talloc(ncols+1, double);
#if 0 /* by mao */
    memset(delta, 0, sizeof(double)*(ncols+1));
#endif

    for ( j = 1; j < (ncols +1); j++ ) {
        delta[j] = 0.0;
        /* skip continuous variables */
        if ( ckind[j] == GLP_CV ) continue;

        /* skip integer variables that have been fixed */
        if ( cub[j]-clb[j] < 0.5 ) continue;

        /* binary variable */
        if ( ckind[j] == GLP_BV ) {
            if ( xtilde[j] > 0.5 ) {
                delta[j] = -1.0;
            }
            else {
                delta[j] = 1.0;
            }
        }
    }

    /* changing the obj coeff. for all variables, including continuous
       ones */
    for ( j = 1; j < (ncols +1); j++ ) {
        glp_set_obj_coef(lp, j, delta[j]);
    }
    glp_set_obj_coef(lp, 0, 0.0);

    tfree(delta);
}

/**********************************************************************/
static double update_cutoff(struct csa4 *csa, glp_prob *lp,
                            double zstar, int cutoff_row,
                            double rel_impr)
/**********************************************************************/
{
    /*
     Updating the cutoff constraint with the value we would like to
     find during the next optimization
     */
    double cutoff;
    zstar -= csa->true_obj[0];
    if (csa->dir == GLP_MIN) {
        cutoff = zstar - compute_delta(csa, zstar, rel_impr);
        glp_set_row_bnds(lp, cutoff_row, GLP_UP, cutoff, cutoff);
    }
    else {
        cutoff = zstar + compute_delta(csa, zstar, rel_impr);
        glp_set_row_bnds(lp, cutoff_row, GLP_LO, cutoff, cutoff);
    }

    return cutoff;
}

/**********************************************************************/
static double compute_delta(struct csa4 *csa, double z, double rel_impr)
/**********************************************************************/
{
    /* Computing the offset for the next best solution */

    double delta = rel_impr * fabs(z);
    if ( csa->integer_obj ) delta = ceil(delta);

    return(delta);
}

/**********************************************************************/
static double objval(int ncols, double *x, double *true_obj)
/**********************************************************************/
{
    /* Computing the true cost of x (using the original obj coeff.s) */

    int j;
    double z = 0.0;
    for ( j = 1; j < (ncols +1); j++ ) {
        z += x[j] * true_obj[j];
    }
    return z + true_obj[0];
}

/**********************************************************************/
static void array_copy(int begin, int end, double *source,
                       double *destination)
/**********************************************************************/
{
    int i;
    for (i = begin; i < end; i++) {
        destination[i] = source[i];
    }
}
/**********************************************************************/
static int do_refine(struct csa4 *csa, glp_prob *lp_ref, int ncols,
                     int *ckind, double *xref, int *tlim, int tref_lim,
                     int verbose)
/**********************************************************************/
{
    /*
     Refinement is applied when the variables of the problem are not
     all binary. Binary variables are fixed to their value and
     remaining ones are optimized. If there are only continuos
     variables (in addition to those binary) the problem becomes just
     an LP. Otherwise, it remains a MIP but of smaller size.
     */

    int j, tout;
    double refineStart = second();
    double val, tela, tlimit;

    if ( glp_get_num_cols(lp_ref) != ncols ) {
        if (verbose) {
            xprintf("Error in Proxy refinement: ");
            xprintf("wrong number of columns (%d vs %d).\n",
                    ncols, glp_get_num_cols(lp_ref));
        }
        return 1;
    }

    val = -1.0;

    /* fixing all binary variables to their current value in xref */
    for ( j = 1; j < (ncols + 1); j++ ) {
        if ( ckind[j] == GLP_BV ) {
            val = 0.0;
            if ( xref[j] > 0.5 ) val = 1.0;
            glp_set_col_bnds(lp_ref, j, GLP_FX, val, val);
        }
    }

    /* re-optimizing (refining) if some bound has been changed */
    if ( val > -1.0 ) {
        glp_iocp parm_ref;
        glp_smcp parm_ref_lp;
        int err, status;

        glp_init_iocp(&parm_ref);
        parm_ref.presolve = GLP_ON;
        glp_init_smcp(&parm_ref_lp);
        /*
         If there are no general integer variable the problem becomes
         an LP (after fixing the binary variables) and can be solved
         quickly. Otherwise the problem is still a MIP problem and a
         timelimit has to be set.
         */
        parm_ref.tm_lim = tref_lim;
        if (parm_ref.tm_lim > *tlim) {
            parm_ref.tm_lim = *tlim;
        }
        parm_ref_lp.tm_lim = parm_ref.tm_lim;
#ifdef PROXY_DEBUG
        xprintf("***** REFINING *****\n");
#endif
        tout = glp_term_out(GLP_OFF);
        if (csa->i_vars_exist == TRUE) {
            err = glp_intopt(lp_ref, &parm_ref);
        }
        else {
            err = glp_simplex(lp_ref, &parm_ref_lp);
        }
        glp_term_out(tout);

        if (csa->i_vars_exist == TRUE) {
            status = glp_mip_status(lp_ref);
        }
        else {
            status = glp_get_status(lp_ref);
        }

#if 1 /* 29/II-2016 by mao as reported by Chris */
      switch (status)
      {  case GLP_OPT:
         case GLP_FEAS:
            break;
         default:
            status = GLP_UNDEF;
            break;
      }
#endif

#ifdef PROXY_DEBUG
        xprintf("STATUS REFINING = %d\n",status);
#endif
        if (status == GLP_UNDEF) {
            if (err == GLP_ETMLIM) {
#ifdef PROXY_DEBUG
                    xprintf("Time limit exceeded on Proxy refining.\n");
#endif
                return 1;
            }
        }
        for( j = 1 ; j < (ncols + 1); j++ ){
            if (ckind[j] != GLP_BV) {
                if (csa->i_vars_exist == TRUE) {
                    xref[j] = glp_mip_col_val(lp_ref, j);
                }
                else{
                    xref[j] = glp_get_col_prim(lp_ref, j);
                }
            }
        }
    }
    tela = second() - refineStart;
#ifdef PROXY_DEBUG
    xprintf("REFINE TELA = %3.1lf\n",tela*1000);
#endif
    return 0;
}
/**********************************************************************/
static void deallocate(struct csa4 *csa, int refine)
/**********************************************************************/
{
    /* Deallocating routine */

    if (refine) {
        glp_delete_prob(csa->lp_ref);
    }

    tfree(csa->ckind);
    tfree(csa->clb);
    tfree(csa->cub);
    tfree(csa->true_obj);

}

/* eof */

void ios_proxy_heur(glp_tree *T)
{     glp_prob *prob;
      int j, status;
      double *xstar, zstar;
      /* this heuristic is applied only once on the root level */
      if (!(T->curr->level == 0 && T->curr->solved == 1))
         goto done;
      prob = glp_create_prob();
      glp_copy_prob(prob, T->mip, 0);
      xstar = xcalloc(1+prob->n, sizeof(double));
      for (j = 1; j <= prob->n; j++)
         xstar[j] = 0.0;
      if (T->mip->mip_stat != GLP_FEAS)
         status = proxy(prob, &zstar, xstar, NULL, 0.0,
            T->parm->ps_tm_lim, 1);
      else
      {  double *xinit = xcalloc(1+prob->n, sizeof(double));
         for (j = 1; j <= prob->n; j++)
            xinit[j] = T->mip->col[j]->mipx;
         status = proxy(prob, &zstar, xstar, xinit, 0.0,
            T->parm->ps_tm_lim, 1);
         xfree(xinit);
      }
      if (status == 0)
#if 0 /* 17/III-2016 */
         glp_ios_heur_sol(T, xstar);
#else
      {  /* sometimes the proxy heuristic reports a wrong solution, so
          * make sure that the solution is really integer feasible */
         int i, feas1, feas2, ae_ind, re_ind;
         double ae_max, re_max;
         glp_copy_prob(prob, T->mip, 0);
         for (j = 1; j <= prob->n; j++)
            prob->col[j]->mipx = xstar[j];
         for (i = 1; i <= prob->m; i++)
         {  GLPROW *row;
            GLPAIJ *aij;
            row = prob->row[i];
            row->mipx = 0.0;
            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
               row->mipx += aij->val * aij->col->mipx;
         }
         glp_check_kkt(prob, GLP_MIP, GLP_KKT_PE, &ae_max, &ae_ind,
            &re_max, &re_ind);
         feas1 = (re_max <= 1e-6);
         glp_check_kkt(prob, GLP_MIP, GLP_KKT_PB, &ae_max, &ae_ind,
            &re_max, &re_ind);
         feas2 = (re_max <= 1e-6);
         if (feas1 && feas2)
            glp_ios_heur_sol(T, xstar);
         else
            xprintf("WARNING: PROXY HEURISTIC REPORTED WRONG SOLUTION; "
               "SOLUTION REJECTED\n");
      }
#endif
      xfree(xstar);
      glp_delete_prob(prob);
done: return;
}

/* eof */






// 
//
// gcc -o sample glpk-mip-sample.c -lglpk -lm
// ./sample

/*
Maximize
 obj: x1 + 2 x2 + 3 x3 + x4
Subject To
 c1: 0 <= - x1 + x2 + x3 + 10 x4 <= 20
 c2: 0 <= x1 - 3 x2 + x3 <= 30
 c3: x2 - 3.5 x4 = 0
Bounds
 0 <= x1 <= 40
 0 <= x2
 0 <= x3
 2 <= x4 <= 3
General # Integer Variables
 x3
 x4
End
*/

int main(void)
{
  glp_prob *mip = glp_create_prob();
  glp_set_prob_name(mip, "sample");
  glp_set_obj_dir(mip, GLP_MAX);

  // 
  // 
  glp_add_rows(mip, 3); // 
  glp_set_row_name(mip, 1, "c1"); glp_set_row_bnds(mip, 1, GLP_DB, 0.0, 20.0);
  glp_set_row_name(mip, 2, "c2"); glp_set_row_bnds(mip, 2, GLP_DB, 0.0, 30.0);
  glp_set_row_name(mip, 3, "c3"); glp_set_row_bnds(mip, 3, GLP_FX, 0.0, 0);

  // 
  // 
  glp_add_cols(mip, 4); // 
  glp_set_col_name(mip, 1, "x1");
  glp_set_col_bnds(mip, 1, GLP_DB, 0.0, 40.0); glp_set_obj_coef(mip, 1, 1.0);
  glp_set_col_name(mip, 2, "x2");
  glp_set_col_bnds(mip, 2, GLP_LO, 0.0, 0.0); glp_set_obj_coef(mip, 2, 2.0);
  glp_set_col_name(mip, 3, "x3");
  glp_set_col_bnds(mip, 3, GLP_LO, 0.0, 0.0); glp_set_obj_coef(mip, 3, 3.0);
  glp_set_col_kind(mip, 3, GLP_IV); // 
  glp_set_col_name(mip, 4, "x4");
  glp_set_col_bnds(mip, 4, GLP_DB, 2.0, 3.0); glp_set_obj_coef(mip, 4, 1.0);
  glp_set_col_kind(mip, 4, GLP_IV); // 

  int ia[1+9], ja[1+9];
  double ar[1+9];
  ia[1]=1,ja[1]=1,ar[1]=-1;   // a[1,1] = -1
  ia[2]=1,ja[2]=2,ar[2]=1;    // a[1,2] = 1
  ia[3]=1,ja[3]=3,ar[3]=1;    // a[1,3] = 1
  ia[4]=1,ja[4]=4,ar[4]=10;   // a[1,4] = 10
  ia[5]=2,ja[5]=1,ar[5]=1;    // a[2,1] = 1
  ia[6]=2,ja[6]=2,ar[6]=-3;   // a[2,2] = -3
  ia[7]=2,ja[7]=3,ar[7]=1;    // a[2,3] = 1
  ia[8]=3,ja[8]=2,ar[8]=1;    // a[3,2] = 1
  ia[9]=3,ja[9]=4,ar[9]=-3.5; // a[3,4] = -3.5
  glp_load_matrix(mip, 9, ia, ja, ar);

  glp_iocp parm;
  glp_init_iocp(&parm);
  parm.presolve = GLP_ON;
  int err = glp_intopt(mip, &parm);

  double z = glp_mip_obj_val(mip);
  double x1 = glp_mip_col_val(mip, 1);
  double x2 = glp_mip_col_val(mip, 2);
  double x3 = glp_mip_col_val(mip, 3);
  double x4 = glp_mip_col_val(mip, 4);
  printf("\nz = %g; x1 = %g; x2 = %g; x3 = %g, x4 = %g\n", z, x1, x2, x3, x4);
  // z = 122.5; x1 = 40; x2 = 10.5; x3 = 19.5, x4 = 3

  glp_delete_prob(mip);
  return 0;
}
